"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generatePathsAndNames = exports.buildKeplerBundle = void 0;
const path_1 = require("path");
const fs_1 = __importDefault(require("fs"));
const path_2 = __importDefault(require("path"));
const bundleId_1 = require("./bundleId");
const packageJsonUtils_1 = __importDefault(require("./packageJsonUtils"));
const common_1 = require("../common");
const kepler_compatibility_metro_config_1 = require("@amazon-devices/kepler-compatibility-metro-config");
const cli_tools_1 = require("@react-native-community/cli-tools");
const supportedEntryFileNames = ['index', 'service', 'task'];
const supportedHeadlessBundleEntryFileNames = ['service.js', 'task.js'];
const splitBundleEntryFileToConfigOptionMap = {
    'index.js': 'interactive',
    'service.js': 'service',
    'task.js': 'task',
};
async function buildKeplerBundle(ctx, args) {
    const buildType = args.buildType || 'Release';
    if (!ctx.reactNativeVersion) {
        if (!common_1.BundleUtils.validateRnCLIVersion(ctx.root)) {
            common_1.logger.warn('Assuming 0.72 react native version...');
            ctx.reactNativeVersion = '0.72';
        }
        else {
            // Should be unreachable...
            throw new cli_tools_1.CLIError('Unexpected Error: React native CLI command did not provide any react native version despite satisfying minimum ' +
                `CLI version. Try to reduce ${common_1.BundleUtils.rnCLIPackage} version to last confirmed tested version of "15.0.1".`);
        }
    }
    const buildBundleWithConfig = common_1.BundleUtils.getBundlerWithConfig(ctx.root, ctx.reactNativeVersion);
    // Generate the JS bundle file for each supported entry file at project root
    // Change from async to synchronous to avoid race condition in keplerscript-commonmodule package when building split bundle for multiple entrypoints
    const entryFiles = findEntryFiles(ctx.root);
    for (const entryFile of entryFiles) {
        common_1.logger.info(`Building bundle artifacts for ${entryFile}`);
        // First, define all the paths to be used for bundling
        const { bundleDir, srcMapDir, bundlePath, generatedSrcMapPath, hermesBundlePath, } = generatePathsAndNames(ctx.root, entryFile.split('.')[0], buildType);
        [bundleDir, srcMapDir].forEach(common_1.PathUtils.ensure);
        // Generate bundle config for split bundle and version compatibility
        const { bundleConfig, splitBundleApplied } = await getBundlingConfig(ctx, buildType, args, entryFile);
        const bundleArgs = {
            ...args,
            minify: false,
            platform: 'kepler',
            entryFile,
            bundleOutput: bundlePath,
            assetsDest: bundleDir,
            sourcemapOutput: generatedSrcMapPath,
            dev: buildType === 'Debug',
            unstableTransformProfile: 'default',
            verbose: args.verbose,
        };
        // Build the JS bundle
        common_1.logger.info(`Building ${splitBundleApplied ? 'split' : 'regular'} bundle for ${entryFile}`);
        await buildBundleWithConfig(bundleArgs, bundleConfig);
        common_1.logger.info(`Completed building JS bundle and sourcemap for ${entryFile}`);
        // Process debugging files (rename bundle and sourcemap with bundle ID)
        const { newBundlePath, newSourcemapPath } = await (0, bundleId_1.processDebuggingFiles)(bundlePath, generatedSrcMapPath);
        fs_1.default.copyFileSync(newSourcemapPath, (0, path_1.join)(bundleDir, path_2.default.basename(newSourcemapPath)));
        common_1.logger.info(`Completed processing debugging files for ${entryFile}`);
        // Build the Hermes bundle
        await common_1.Hermes.createBundle(ctx, {
            out: hermesBundlePath,
            bundlePath: newBundlePath,
            hermesFlags: args.hermesFlags,
        });
        common_1.logger.info(`Completed building Hermes bundle for ${entryFile}`);
        try {
            // Remove hash.bundle to save memory
            fs_1.default.rmSync(newBundlePath);
        }
        catch (error) {
            common_1.logger.debug(`Failed to delete bundle file at ${newBundlePath} due to error: ${error}`);
        }
    }
}
exports.buildKeplerBundle = buildKeplerBundle;
function generatePathsAndNames(root, entryFileName, buildType) {
    // Path for generated directory
    const generatedDir = (0, path_1.resolve)(common_1.PathUtils.getGeneratedDir(root));
    // Path where bundle files would be generated
    const bundleDir = (0, path_1.join)(generatedDir, 'lib', 'rn-bundles', buildType);
    // Path where sourcemap files would be generated
    const srcMapDir = (0, path_1.join)(generatedDir, 'debugging', buildType, 'srcmap');
    // Path where JS bundle file will be created
    const bundlePath = (0, path_1.join)(bundleDir, `${entryFileName}.bundle`);
    // Name of source map file
    const srcMapFileName = `${entryFileName}.bundle.map`;
    // Path to generated source map file
    const generatedSrcMapPath = (0, path_1.join)(srcMapDir, srcMapFileName);
    // Path to generated Hermes bundle file
    const hermesBundlePath = (0, path_1.join)(bundleDir, `${entryFileName}.hermes.bundle`);
    return {
        bundleDir,
        srcMapDir,
        bundlePath,
        generatedSrcMapPath,
        hermesBundlePath,
    };
}
exports.generatePathsAndNames = generatePathsAndNames;
function findEntryFiles(root) {
    const supportedEntryFiles = supportedEntryFileNames.map(name => `${name}.js`);
    const existingEntryFiles = supportedEntryFiles.filter(name => fs_1.default.existsSync((0, path_1.resolve)((0, path_1.join)(root, name))));
    if (existingEntryFiles.length) {
        return existingEntryFiles;
    }
    throw new Error(`No supported entry file found, please ensure one of these files in project root: ${supportedEntryFiles}`);
}
async function getBundlingConfig(ctx, buildType, args, entryFile) {
    var _a;
    const loadMetroConfig = common_1.BundleUtils.getMetroLoadConfig(ctx.root, ctx.reactNativeVersion);
    const mergeConfig = common_1.BundleUtils.getMetroMergeConfig(ctx.root);
    const loadedMetroConfig = await loadMetroConfig(ctx, {
        maxWorkers: args.maxWorkers,
        resetCache: args.resetCache,
        config: args.config,
    });
    let updatedMetroConfig = null;
    let splitBundleApplied = false;
    // Check if system bundles are enabled for entrypoint and apply config as required
    const useSystemBundles = shouldUseSystemBundles(args, ctx) &&
        areSystemBundlesSupported(buildType, ctx) &&
        areSystemBundlesForHeadlessSupported(entryFile, ctx);
    if (useSystemBundles) {
        try {
            const createAppBundleConfig = (_a = require(common_1.BundleUtils.splitBundleToolPackage)) === null || _a === void 0 ? void 0 : _a.createAppBundleConfig;
            if (createAppBundleConfig) {
                // Set output location of app system bundle metadata information from "createAppBundleConfig" to build/private/bundle/<buildType>/
                const sysBundleOutputDir = common_1.PathUtils.getGeneratedPrivateBundleConfigDir(ctx.root, buildType);
                if (process.env.SYS_BUNDLES_CONFIG_DIR) {
                    common_1.logger.debug(`Environment Variable "SYS_BUNDLES_CONFIG_DIR" is already defined. Kepler expects this value as ${sysBundleOutputDir}, overriding it`);
                }
                process.env.SYS_BUNDLES_CONFIG_DIR = sysBundleOutputDir;
                common_1.PathUtils.ensure(sysBundleOutputDir);
                // Compute config with system bundles enabled
                updatedMetroConfig = mergeConfig(loadedMetroConfig, createAppBundleConfig(ctx.root, splitBundleEntryFileToConfigOptionMap[entryFile]));
                splitBundleApplied = true;
            }
            else {
                common_1.logger.warn(`Dependency '${common_1.BundleUtils.splitBundleToolPackage}' required for generating split bundles not found. Declare it in your package.json to use the feature.`);
            }
        }
        catch (err) {
            // If error occurs, follow regular bundling
            common_1.logger.warn(`Failed to load configurations for using system bundles, will proceed with building regular bundle. Failure reason: ${err.message}`);
        }
    }
    return {
        bundleConfig: mergePolyfill(ctx.root, updatedMetroConfig !== null && updatedMetroConfig !== void 0 ? updatedMetroConfig : loadedMetroConfig),
        splitBundleApplied,
    };
}
function mergePolyfill(projectRoot, metroConfig) {
    // Get polyfill from KeplerCompatibilityMetroConfig
    const kcmcConfig = (0, kepler_compatibility_metro_config_1.getKeplerCompatibilityMetroConfig)(common_1.BundleUtils.getKeplerManifestBuilderBin(projectRoot), common_1.BundleUtils.computeModulesRoots(projectRoot));
    const originalGetPolyfills = metroConfig.serializer.getPolyfills;
    // Combine user-defined polyfills with KCMC polyfills
    metroConfig.serializer.getPolyfills = function () {
        try {
            const polyfills = originalGetPolyfills.call(this);
            const polyfillsKCMC = kcmcConfig.serializer.getPolyfills();
            return [...new Set([...polyfills, ...polyfillsKCMC])];
        }
        catch (e) {
            common_1.logger.error(`Failed to load Kepler Compatibility polyfills: ${e.message}`);
            throw e;
        }
    };
    return metroConfig;
}
function areSystemBundlesForHeadlessSupported(entryFile, ctx) {
    // when headless system bundle flag is disabled, only run split bundle for index.js
    const useSystemJsBundlesForHeadlessJs = new packageJsonUtils_1.default(ctx).getUseSystemJsBundlesForHeadlessJsConfig();
    return (useSystemJsBundlesForHeadlessJs ||
        !supportedHeadlessBundleEntryFileNames.includes(entryFile));
}
function areSystemBundlesSupported(buildType, ctx) {
    const unsupportedMsg = (msg) => {
        return `JS system bundle functionality unsupported for ${msg}. Using regular bundle...`;
    };
    if (buildType === 'Debug') {
        common_1.logger.info(unsupportedMsg('"Debug" build types'));
        return false;
    }
    if (ctx.reactNativeVersion === '0.76') {
        // Until PROJ****-240202
        common_1.logger.info(unsupportedMsg('0.76 react native projects. Support is pending'));
        return false;
    }
    return true;
}
function shouldUseSystemBundles(args, ctx) {
    // Command line args take highest priority
    if (typeof args.useSystemJsBundles !== 'undefined') {
        return args.useSystemJsBundles;
    }
    else if (typeof args.splitBundle !== 'undefined') {
        common_1.logger.warn(`
⚠️ Deprecation Warning:
The "--split-bundle" option is deprecated and will be removed in next release.
Please update your command to use "--use-system-js-bundles" instead.
    `);
        return args.splitBundle;
    }
    // Package.json config takes second priority
    const configLoader = new packageJsonUtils_1.default(ctx);
    return configLoader.getUseSystemJsBundlesConfig();
}

"use strict";
/*
 * Copyright (c) 2024 Amazon.com, Inc. or its affiliates.  All rights reserved.
 *
 * PROPRIETARY/CONFIDENTIAL.  USE IS SUBJECT TO LICENSE TERMS.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BundleUtils = void 0;
const path_1 = require("path");
const cli_tools_1 = require("@react-native-community/cli-tools");
const tools_node_1 = require("@rnx-kit/tools-node");
const log_1 = __importDefault(require("./log"));
const fs_1 = __importDefault(require("fs"));
const moduleUtils_1 = require("./moduleUtils");
const moduleErrors_1 = require("../errors/moduleErrors");
const semver_1 = require("semver");
const bundlePackages = new Map([
    [
        '0.72',
        {
            module: '@react-native-community/cli-plugin-metro',
            functions: {
                bundleWithConfig: {
                    relPathToFunc: (0, path_1.join)('build', 'commands', 'bundle', 'buildBundle'),
                    funcName: 'buildBundleWithConfig',
                },
                loadMetro: {
                    relPathToFunc: (0, path_1.join)('build', 'tools', 'loadMetroConfig'),
                    funcName: 'default',
                },
            },
        },
    ],
    [
        '0.76',
        {
            module: '@react-native/community-cli-plugin',
            functions: {
                bundleWithConfig: {
                    relPathToFunc: (0, path_1.join)('dist', 'commands', 'bundle', 'buildBundle'),
                    funcName: 'unstable_buildBundleWithConfig',
                },
                loadMetro: {
                    relPathToFunc: (0, path_1.join)('dist', 'utils', 'loadMetroConfig'),
                    funcName: 'default',
                },
            },
        },
    ],
]);
class BundleUtils {
    static getBundlerWithConfig(projectRoot, reactNativeVersion) {
        const { bundlerInfo, modulePath } = BundleUtils.getBundleModulePath(projectRoot, reactNativeVersion);
        return BundleUtils.getBundlerFunction(modulePath, bundlerInfo.functions.bundleWithConfig);
    }
    static getMetroLoadConfig(projectRoot, reactNativeVersion) {
        const { bundlerInfo, modulePath } = BundleUtils.getBundleModulePath(projectRoot, reactNativeVersion);
        return BundleUtils.getBundlerFunction(modulePath, bundlerInfo.functions.loadMetro);
    }
    static getMetroMergeConfig(projectRoot) {
        return require(BundleUtils.getModulePath(projectRoot, BundleUtils.metroConfigPackage, true)).mergeConfig;
    }
    static getKeplerManifestBuilderBin(projectRoot) {
        return BundleUtils.resolveBinaryFromPackage(projectRoot, BundleUtils.keplerManifestBuilderPackage, BundleUtils.keplerManifestBuilderBin);
    }
    static computeModulesRoots(projectRoot) {
        const nodeModulesRoots = [projectRoot];
        /*
         Projects may be standalone packages or part of a workspace/monorepo. In the latter case, common dependencies would
         be installed at the workspace root instead in addition to potentially the project root.
         */
        const workspaceRoot = require('find-workspaces').findWorkspacesRoot(projectRoot);
        if (workspaceRoot) {
            nodeModulesRoots.push(workspaceRoot.location);
        }
        return nodeModulesRoots.filter(fs_1.default.existsSync);
    }
    /**
     * Helper to resolve a binary from a package's bin entry in package.json
     */
    static resolveBinaryFromPackage(projectRoot, packageName, binName) {
        try {
            const packageJsonPath = BundleUtils.getModulePath(projectRoot, `${packageName}/package.json`, true);
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            const packageJson = require(packageJsonPath);
            if (!packageJson.bin || !packageJson.bin[binName]) {
                throw new Error(`Binary entry "${binName}" not found in ${packageName}'s package.json`);
            }
            const packageDir = (0, path_1.dirname)(packageJsonPath);
            const binPath = (0, path_1.join)(packageDir, packageJson.bin[binName]);
            if (!fs_1.default.existsSync(binPath)) {
                throw new Error(`Binary not found at ${binPath}`);
            }
            log_1.default.debug(`Found binary "${binName}" at ${binPath}`);
            return binPath;
        }
        catch (e) {
            throw new Error(`Could not find binary "${binName}" from package "${packageName}". ` +
                `Please ensure the package is installed correctly. Error: ${e.message}`);
        }
    }
    static getBundlerFunction(rootModulePath, funcInfo) {
        const modulePath = (0, path_1.join)(rootModulePath, funcInfo.relPathToFunc);
        log_1.default.debug('Using Bundler Function: ' + modulePath);
        const module = require(modulePath);
        if (!Object.keys(module).includes(funcInfo.funcName) ||
            typeof module[funcInfo.funcName] !== 'function') {
            throw new Error(`Error: Function '${funcInfo.funcName}' not found in module '${modulePath}'`);
        }
        return module[funcInfo.funcName];
    }
    /**
     * Helper function to validate that the RN CLI version that is seen (first seen, i.e. in "root/node_modules")
     * is of the minimum version. To avoid a empty RN version in "react-native config".
     * @param projectRoot Root of the project
     * @returns boolean if RN CLI package is of the minimum version. "True" being a valid CLI version.
     */
    static validateRnCLIVersion(projectRoot) {
        let rnClIVersion;
        try {
            const cliPackage = this.getModulePath(projectRoot, this.rnCLIPackage, false);
            rnClIVersion = require((0, path_1.join)(cliPackage, 'package.json')).version;
        }
        catch (e) {
            throw new cli_tools_1.CLIError('Could not find a required package: @react-native-community/cli.\n' +
                `Full Error: ${e.message}`, e);
        }
        if ((0, semver_1.lt)(rnClIVersion, this.minimumCLIVersion)) {
            log_1.default.warn(`\n⚠️ Used ${BundleUtils.rnCLIPackage} is of an unsupported range (less than ${BundleUtils.minimumCLIVersion}).` +
                ' This will result in errors if this is a 0.76 app.');
            return false;
        }
        return true;
    }
    /**
     * Resolves a bundler module based on the given react native version.
     * @param projectRoot
     * @param reactNativeVersion react native version
     * @returns {bundlerInfo, rootModulePath} returns rootModulePath to avoid finding module path again
     */
    static getBundleModulePath(projectRoot, reactNativeVersion) {
        let modulePath = '';
        log_1.default.debug('Grabbing bundle module mapped to react native version: ' +
            reactNativeVersion);
        const bundlerInfo = bundlePackages.get(reactNativeVersion);
        if (!bundlerInfo) {
            throw new cli_tools_1.CLIError(`Current version of @amazon-devices/kepler-cli-platform does not support react native version: ${reactNativeVersion}`);
        }
        log_1.default.debug('Attempting to use bundle module: ' + bundlerInfo.module);
        try {
            modulePath = this.getModulePath(projectRoot, bundlerInfo.module, false);
        }
        catch (e) {
            throw new cli_tools_1.CLIError(`Unable to find bundler module ${bundlerInfo.module} for react native version ${reactNativeVersion}.\n` +
                `Full Error: ${e.message}`, e);
        }
        return { bundlerInfo, modulePath };
    }
    // Does the normal module search algorithm in ModuleUtils but searches within React Native packages.
    static getModulePath(projectRoot, moduleName, useRequire = false) {
        try {
            return moduleUtils_1.ModuleUtils.getModulePath(projectRoot, moduleName, useRequire);
        }
        catch (e) {
            log_1.default.debug(`Could not find ${moduleName} from root modules, searching from React Native CLI. Reason: ${e.message}`);
        }
        // Secondly, search in the RN CLI modules in case RN CLI is a peer dependency itself
        try {
            const rnCliDir = BundleUtils.resolveFrom(BundleUtils.rnCLIPackage, projectRoot);
            return (0, cli_tools_1.resolveNodeModuleDir)(rnCliDir, moduleName);
        }
        catch (e) {
            log_1.default.debug(`Could not find ${moduleName} from React Native CLI dependency, searching from peer dependencies. Reason: ${e.message}`);
        }
        // Lastly, fall back to RN peer dependency as a last resort.
        // RN CLI is known to change the location of
        // this module across versions, so a static import is known to break. The
        // plugin would be installed by React Native peer dependency, so search
        // from that location.
        const rnDir = BundleUtils.resolveFrom('react-native', projectRoot);
        if (!rnDir) {
            throw new moduleErrors_1.ReactNativeNotFoundError('React Native dependency not installed. Please make sure to declare a dependency on the' +
                ' package and install it for the current project.');
        }
        const rnCliDir = BundleUtils.resolveFrom(BundleUtils.rnCLIPackage, rnDir);
        return (0, cli_tools_1.resolveNodeModuleDir)(rnCliDir, moduleName);
    }
    static resolveFrom(name, startDir) {
        return (0, tools_node_1.findPackageDependencyDir)(name, {
            startDir,
            resolveSymlinks: true,
        });
    }
}
exports.BundleUtils = BundleUtils;
BundleUtils.keplerManifestBuilderPackage = '@amazon-devices/kepler-module-manifest-builder';
BundleUtils.keplerManifestBuilderBin = 'kepler-module-manifest-builder';
BundleUtils.systemBundleModuleConfigFile = 'kepler-system-conf.toml';
BundleUtils.splitBundleToolPackage = '@amazon-devices/keplerscript-commonmodules';
BundleUtils.rnCLIPackage = '@react-native-community/cli';
// Requires used cli to be >= 11.3.2 as lower may not print reactNativeVersion
BundleUtils.minimumCLIVersion = '11.3.2';
BundleUtils.metroConfigPackage = '@react-native/metro-config';

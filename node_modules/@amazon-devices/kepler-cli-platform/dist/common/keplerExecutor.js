"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeplerExecutor = void 0;
/*
 * Copyright (c) 2023 Amazon.com, Inc. or its affiliates.  All rights reserved.
 *
 * PROPRIETARY/CONFIDENTIAL.  USE IS SUBJECT TO LICENSE TERMS.
 */
const shelljs_1 = __importDefault(require("shelljs"));
const log_1 = __importDefault(require("./log"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const cli_tools_1 = require("@react-native-community/cli-tools");
/**
 * Contains the various commands to be executed by KeplerNative build system.
 */
class KeplerExecutor {
    static build(options) {
        KeplerExecutor.exec(`build ${options}`);
    }
    static getBaseNpmCommand() {
        const envValue = process.env[KeplerExecutor.KEPLER_NPM_COMMAND];
        if (envValue) {
            log_1.default.debug(`Environment variable ${KeplerExecutor.KEPLER_NPM_COMMAND} found: ${envValue}`);
            return envValue;
        }
        return KeplerExecutor.defaultBuildToolEnvVarMap[KeplerExecutor.KEPLER_NPM_COMMAND];
    }
    static getHermesPath() {
        const cmdOutput = KeplerExecutor.exec('path hermes', { silent: true });
        return this.parseToolPathOutput(cmdOutput);
    }
    /**
     * Create the build options based on json input
     * @param args Json input received from resource
     */
    static createBuildOptions(args) {
        // the args may be undefined, filter out undefined args and append the relevant ones.
        let options = '';
        KeplerExecutor.buildArgsKeys.forEach((key) => {
            if (args[key] === undefined) {
                return;
            }
            let parsedArgs = args[key];
            if (key === 'additionalNativeOptions') {
                // Additional parsing needed for this arg to be passed as array to KCLI
                parsedArgs = `${args[key]
                    .split(',')
                    // Tested the additional escaping to be required for supporting quoted flags like KCLI expects
                    // eslint-disable-next-line no-useless-escape
                    .map((arg) => `\\\'\\\"${arg.trim()}\\\"\\\'`)
                    .join(' ')}`;
            }
            options += `--${KeplerExecutor.buildArgsMap[key]} ${parsedArgs} `;
        });
        return options;
    }
    /**
     * Trigger a build with Kepler Native
     * @param options cli args to pass to Kepler Native
     * @throws an error if build command executed by shell returns non-zero.
     */
    static exec(options, shellOptions) {
        const buildCmd = KeplerExecutor.getKeplerExecutable() + ' ' + options;
        const shellString = shellOptions
            ? shelljs_1.default.exec(buildCmd, shellOptions)
            : shelljs_1.default.exec(buildCmd);
        if (shellString.code !== 0) {
            const terminalOutputWithErr = shellString.stdout + '\n' + shellString.stderr;
            const errorMsg = `'${buildCmd}' exited with non-zero code '${shellString.code}' with the following message: ${terminalOutputWithErr}`;
            throw new cli_tools_1.CLIError(errorMsg);
        }
        return shellString.stdout;
    }
    static parseToolPathOutput(output) {
        // Filter out the output line that actually contains the tools path result
        const toolsPathOutStrs = output
            .split('\n')
            .map(line => line.trim())
            .filter(line => line.includes('hermesc'));
        if (toolsPathOutStrs.length === 0) {
            throw new Error('No tools path found in Kepler CLI output');
        }
        return toolsPathOutStrs[0];
    }
    static getKeplerExecutable() {
        // Check for Kepler CLI in SDK path
        const sdkPath = process.env[KeplerExecutor.KEPLER_ENV_NAME];
        if (sdkPath) {
            const cliPath = path_1.default.join(sdkPath, 'bin', 'kepler');
            if (fs_1.default.existsSync(cliPath)) {
                return cliPath;
            }
        }
        // Check if Kepler CLI exists in the environment
        log_1.default.debug(`Failed to find Kepler CLI using environment variable ${KeplerExecutor.KEPLER_ENV_NAME}, value '${sdkPath}'`);
        const shellString = shelljs_1.default.exec(`${KeplerExecutor.KEPLER_CLI_NAME} -v`, {
            silent: true,
        });
        if (shellString.code === 0) {
            return KeplerExecutor.KEPLER_CLI_NAME;
        }
        // Since CLI was not found in known locations, log reason and throw
        log_1.default.debug(`Failed to find Kepler CLI executable in the ambient environment. Shell check returned code ${shellString.code}, stderr: "${shellString.stderr}"`);
        const errMsg = `Kepler CLI was not found in ambient environment, nor could be found within $${KeplerExecutor.KEPLER_ENV_NAME} (value = '${sdkPath}').` +
            `\nPlease export a valid $${KeplerExecutor.KEPLER_ENV_NAME} or include Kepler CLI path in $PATH to run it.`;
        throw new cli_tools_1.CLIError(errMsg);
    }
}
exports.KeplerExecutor = KeplerExecutor;
KeplerExecutor.KEPLER_NPM_COMMAND = 'KEPLER_NPM_COMMAND';
// map environment variables to default build
KeplerExecutor.defaultBuildToolEnvVarMap = {
    [KeplerExecutor.KEPLER_NPM_COMMAND]: 'npm',
};
/**
 * Mapping of RN plugin args to Kepler Native args
 */
KeplerExecutor.buildArgsMap = {
    target: 'target',
    buildType: 'buildType',
    buildNumber: 'build-number',
    buildVersion: 'build-version',
    includeJsBundle: 'includeJsBundle',
    checkManifest: 'checkManifest',
    additionalNativeOptions: 'additionalNativeOptions',
};
KeplerExecutor.buildArgsKeys = Object.keys(KeplerExecutor.buildArgsMap);
KeplerExecutor.KEPLER_CLI_NAME = 'kepler';
KeplerExecutor.KEPLER_ENV_NAME = 'KEPLER_SDK_PATH';

"use strict";
/*
 * Copyright (c) 2023 Amazon.com, Inc. or its affiliates.  All rights reserved.
 *
 * PROPRIETARY/CONFIDENTIAL.  USE IS SUBJECT TO LICENSE TERMS.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.commandForResource = exports.getResourceValue = exports.resetStoredPromises = void 0;
const ora_1 = __importDefault(require("ora"));
const log_1 = __importDefault(require("./common/log"));
const util_1 = require("util");
log_1.default.setVerbose(process.argv.includes('--verbose'));
// TODO: Separate Resource concept from command line options further
// What we want is a way to describe a Resource's prerequisites including options from arguments
// and other commands - and way to turn configs and options into those prerequisites.
// TODO: We want to hook these into Health Check plugins at some point
// https://github.com/react-native-community/cli/blob/6.x/docs/healthChecks.md
// To do that, we'll need an additional layer for resources, where they can check dependencies
// _without_ generating or changing any files
const isOptionalResourceFunction = (x) => typeof x === 'function';
// This maps resources to a promise for the purposes of deduplication.
// eslint-disable-next-line @typescript-eslint/no-explicit-any
let storedPromises = {};
/**
 * This helper function is used for tests to reset the stored promises
 */
const resetStoredPromises = () => {
    storedPromises = {};
};
exports.resetStoredPromises = resetStoredPromises;
// getResourceValue is the means by which we get resources -
// This produces a spinner, and retrieves each dependency
// eslint-disable-next-line max-len
// eslint-disable-next-line @typescript-eslint/naming-convention, no-underscore-dangle, @typescript-eslint/ban-types
const _getResourceValue = async (resource, ctx, args) => {
    var _a, _b, _c, _d, _e, _f;
    const argsWithArch = args;
    const prefixText = argsWithArch.arch && typeof argsWithArch.arch === 'string'
        ? `${resource.name} (${argsWithArch.arch})`
        : resource.name;
    // Start our spinner with our starting text
    /* istanbul ignore next */
    const spinner = (0, ora_1.default)({
        text: `${(_b = (_a = resource.text.starting) !== null && _a !== void 0 ? _a : resource.text.awaiting) !== null && _b !== void 0 ? _b : resource.text.inProgress} `,
        isEnabled: false,
        stream: process.stdout,
        prefixText,
    });
    spinner.start();
    // first, get dependencies
    const entries = Object.entries(resource.dependencies);
    // No dependencies? Call the func immediately
    if (entries.length === 0) {
        spinner.text = `${resource.text.inProgress} `;
        try {
            return await resource.func(ctx, args, spinner, {}).then(value => {
                var _a;
                /* istanbul ignore next */
                if (spinner.isSpinning) {
                    spinner.succeed(`${(_a = resource.text.success) !== null && _a !== void 0 ? _a : resource.text.inProgress} `);
                }
                return value;
            });
        }
        catch (e) {
            /* istanbul ignore next */
            if (spinner.isSpinning) {
                spinner.fail(`${(_c = resource.text.failure) !== null && _c !== void 0 ? _c : e.toString()} `);
            }
            throw e;
        }
    }
    // Indicate we are not making progress and are instead awaiting resources
    /* istanbul ignore next */
    spinner.text = `${(_d = resource.text.awaiting) !== null && _d !== void 0 ? _d : spinner.text} `;
    spinner.color = 'yellow';
    // If a dependency is represented with an OptionalResourceFunction, call the function to
    // determine whether to retrieve the resource
    const dependencyResources = entries.map(entry => {
        if (isOptionalResourceFunction(entry[1])) {
            return [entry[0], entry[1](ctx, args)];
        }
        return entry;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    );
    // Get promises for all dependencies
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const promises = dependencyResources.map((entry) => {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        if (entry[1])
            return (0, exports.getResourceValue)(entry[1], ctx, args);
        // Absence of a resource value means it was optional. Immediately resolve with null
        return Promise.resolve(null);
    });
    // Await the results of all dependencies
    let resourceValues; // eslint-disable-line @typescript-eslint/no-explicit-any
    try {
        resourceValues = await Promise.all(promises);
    }
    catch (e) {
        /* istanbul ignore next */
        if (spinner.isSpinning) {
            spinner.fail(`${(_e = resource.text.failure) !== null && _e !== void 0 ? _e : e.toString()} `);
        }
        /* istanbul ignore next */
        throw e;
    }
    // Make the dependencies object from the results of resource promises
    const dependencies = Object.fromEntries(entries.map((entry, index) => [entry[0], resourceValues[index]]));
    // Start the spinner up again if it has stopped
    // Indicate we've started active execution
    spinner.color = 'cyan';
    spinner.start(`${resource.text.inProgress} `);
    // Call the resource's func with the dependency values
    try {
        return await resource.func(ctx, args, spinner, dependencies).then(value => {
            var _a;
            if (spinner.isSpinning) {
                /* istanbul ignore next */
                spinner.succeed(`${(_a = resource.text.success) !== null && _a !== void 0 ? _a : resource.text.inProgress} `);
            }
            return value;
        });
    }
    catch (e) {
        /* istanbul ignore next */
        if (spinner.isSpinning) {
            spinner.fail(`${(_f = resource.text.failure) !== null && _f !== void 0 ? _f : e.toString()} `);
        }
        /* istanbul ignore next */
        throw e;
    }
};
/**
 * Get the value of a resource. A command from a resource will rely on this as the primary means of
 * executing the command. Resources will automatically retrieve resources in their `dependencies`.
 * This is essentially a wrapper around a glorified promise - it provides some information to the
 * function as well as wraps the execution in some nice spinners and standard logging for
 * communication to users on the status of commands.
 *
 * @param resource - The resource to get the value of, which will require getting its dependencies
 *                   (if applicable)
 * @param ctx - Context, a React Native Config. This is usually unused, in favor of the arguments
 *              which have defaults populated from this configuration.
 * @param args - The arguments supplied from the command line arguments as processed through the RN
 *               CLI's standard argument processing system (this itself is a variation on the
 *               commands used by Commander.js)
 *
 * @returns a promise which will be fulfilled with the value of the resource or rejected if an
 *          error occurs either in its dependencies or its own execution
 */
// eslint-disable-next-line @typescript-eslint/ban-types
const getResourceValue = (resource, ctx, args) => {
    // The primary body of this function is in `_getResourceValue`. This function serves to
    // deduplicate the promises to avoid performing redundant work
    const dedupeObj = Object.fromEntries(Object.entries(args).filter(([key]) => { var _a; return ((_a = resource.dedupeArgs) !== null && _a !== void 0 ? _a : []).includes(key); }));
    const key = `${resource.name}-${JSON.stringify(dedupeObj)}`;
    if (!storedPromises[key]) {
        storedPromises[key] = _getResourceValue(resource, ctx, args);
    }
    return storedPromises[key];
};
exports.getResourceValue = getResourceValue;
/**
 * Creates an RN CLI Command for the given resource, wrapping the resource func in getResourceValue.
 *
 * @param resource - the resource to be made into a Command for the RN CLI
 * @returns an RN CLI command usable in the RN CLI plugin definition
 *
 * @remarks
 * This is a means of exposing a Resource to users of the CLI as a command.
 *
 * A resource's dependencies are often available as their own commands, but within a Resource no
 * Commands should be assumed to be available - instead use Resources directly. Keep the user
 * settings and interactions at the Command level, and keep Resources concerned only about finding,
 * using, and generating resources needed by users. @param resource - the resource to be made into
 * a Command
 *
 */
const commandForResource = (resource) => ({
    name: resource.name,
    description: resource.description,
    func: async (_, ctx, args) => {
        const result = await (0, exports.getResourceValue)(resource, ctx, args);
        if (result != null) {
            log_1.default.info(`${resource.name} completed with value [${(0, util_1.inspect)(result)}]`);
        }
        else {
            log_1.default.info(`${resource.name} completed`);
        }
    },
    options: resource.options,
    examples: resource.examples,
});
exports.commandForResource = commandForResource;

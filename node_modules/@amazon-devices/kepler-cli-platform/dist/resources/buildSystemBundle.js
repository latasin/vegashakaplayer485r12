"use strict";
/*
 * Copyright (c) 2023 Amazon.com, Inc. or its affiliates.  All rights reserved.
 *
 * PROPRIETARY/CONFIDENTIAL.  USE IS SUBJECT TO LICENSE TERMS.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs_1 = __importDefault(require("fs"));
const shelljs_1 = __importDefault(require("shelljs"));
const common_1 = require("../common");
const process = __importStar(require("node:process"));
const node_path_1 = __importDefault(require("node:path"));
const node_fs_1 = require("node:fs");
const options_1 = require("../options");
const verbose = process.argv.includes('--verbose');
common_1.logger.setVerbose(verbose);
/**
 * Creates a temporary dummy application for system bundle generation.
 * This app provides an isolated environment for bundling the TurboModule.
 *
 * @param workingDir - The root directory of the TurboModule package
 * @param libraryName - The name of the TurboModule package
 * @param tarballPath - Path to the packed TurboModule npm tarball
 * @returns Path to the created dummy app directory
 */
async function createDummyApp(workingDir, libraryName, tarballPath) {
    // Create dummy app directory
    const dummyAppDir = (0, path_1.join)(workingDir, 'build', 'private', 'bundle-split', libraryName.replace(/[@/]/g, '_'));
    common_1.PathUtils.ensure(dummyAppDir);
    // Read package-split.json first
    let packageSplit = {
        devDependencies: {},
    };
    const packageSplitPath = (0, path_1.join)(workingDir, 'package-split.json');
    if (fs_1.default.existsSync(packageSplitPath)) {
        packageSplit = {
            ...packageSplit,
            ...JSON.parse(fs_1.default.readFileSync(packageSplitPath, 'utf8')),
        };
    }
    // Define default preset dependencies. TODO Assumes 0.72 react native app since 0.76 does not support
    // split bundling.
    const presetDependencies = {
        '@amazon-devices/react-native-kepler': '^2.0.0',
        '@babel/traverse': '7.22.8',
        '@react-native/metro-config': '^0.72.6',
        '@react-native-community/cli-tools': '^11.3.2',
        '@amazon-devices/keplerscript-commonmodules': '^1.0.0',
    };
    // Merge preset dependencies with package-split dependencies
    const devDependencies = {
        ...presetDependencies,
        ...(packageSplit.devDependencies || {}), // Overwrite with package-split dependencies
    };
    // Create dummy package.json
    const dummyPackageJson = {
        name: '@amazon-devices/dummy-split-bundle-app',
        version: '1.0.0',
        ...packageSplit,
        devDependencies: devDependencies,
        kepler: {
            projectType: 'application', // Kepler Native requires this for fetching hermes
        },
    };
    fs_1.default.writeFileSync((0, path_1.join)(dummyAppDir, 'package.json'), JSON.stringify(dummyPackageJson, null, 2));
    // Install all dependencies at once
    shelljs_1.default.exec(`${common_1.KeplerExecutor.getBaseNpmCommand()} install`, {
        cwd: dummyAppDir,
    });
    // Install the library itself
    shelljs_1.default.exec([`${common_1.KeplerExecutor.getBaseNpmCommand()}`, 'install', tarballPath].join(' '), {
        cwd: dummyAppDir,
    });
    // Create metro config
    const metroConfig = `
        const libraryName = '${libraryName}';
        const { getDefaultConfig, mergeConfig } = require('@react-native/metro-config');
        const { createSystemBundlesConfig } = require('@amazon-devices/keplerscript-commonmodules');
        module.exports = mergeConfig(
        getDefaultConfig(__dirname),
        createSystemBundlesConfig(__dirname, libraryName)
        );
    `;
    fs_1.default.writeFileSync(node_path_1.default.join(dummyAppDir, 'metro.config.js'), metroConfig);
    // Remove SystemModules directory if it exists in node_modules
    const systemModulesPath = (0, path_1.join)(dummyAppDir, 'node_modules', libraryName, 'SystemModules');
    if (fs_1.default.existsSync(systemModulesPath)) {
        fs_1.default.rmSync(systemModulesPath, { recursive: true });
    }
    return dummyAppDir;
}
/**
 * Generates system bundles within the dummy app environment.
 * All paths and operations in this function are relative to the dummy app directory,
 * ensuring proper isolation from the parent project.
 *
 * @param dummyAppDir - Path to the dummy app directory
 * @param libraryName - Name of the TurboModule package
 * @param ctx - React Native CLI config context
 * @param args - Bundle generation arguments
 * @returns Object containing paths to generated bundles and modules
 */
async function buildInDummyApp(dummyAppDir, libraryName, ctx, args) {
    // change directory to dummy app root at the beginning of the function and change back at the end
    const originalCwd = process.cwd();
    process.chdir(dummyAppDir);
    try {
        // Setup paths within dummy app context
        const dummyAppPaths = {
            bundleDir: (0, path_1.join)(dummyAppDir, 'SystemBundles'),
            modulesDir: (0, path_1.join)(dummyAppDir, 'SystemModules'),
            bundlePath: (0, path_1.join)(dummyAppDir, 'SystemBundles', 'index.bundle'),
            srcMapPath: (0, path_1.join)(dummyAppDir, 'SystemBundles', 'index.bundle.map'),
            hermesBundlePath: '',
            metroConfigPath: (0, path_1.join)(dummyAppDir, 'metro.config.js'),
            entryFilePath: (0, path_1.join)(dummyAppDir, 'index.js'),
        };
        // Create necessary directories
        common_1.PathUtils.ensure(dummyAppPaths.bundleDir);
        // Create entry file
        const entryFile = `import * as lib from '${libraryName}';`;
        fs_1.default.writeFileSync(dummyAppPaths.entryFilePath, entryFile);
        // Generate bundle
        common_1.logger.info('Generating system JavaScript bundle');
        try {
            shelljs_1.default.exec(`npx react-native bundle \
        --platform kepler \
        --dev false \
        --minify false \
        --bundle-output ${dummyAppPaths.bundlePath} \
        --sourcemap-output ${dummyAppPaths.srcMapPath} \
        --sourcemap-sources-root ${process.cwd()} \
        --entry-file ${node_path_1.default.basename(dummyAppPaths.entryFilePath)}`, {
                cwd: dummyAppDir,
            });
        }
        catch (error) {
            throw new Error(`Failed to generate bundle in dummy app: ${error}`);
        }
        // Process debugging files
        const { newBundlePath, newSourcemapPath } = await (0, common_1.processDebuggingFiles)(dummyAppPaths.bundlePath, dummyAppPaths.srcMapPath);
        // Read bundle settings
        const settings = JSON.parse(fs_1.default.readFileSync((0, path_1.join)(dummyAppPaths.modulesDir, 'keplerscript-system-bundle-config.json'), 'utf8'));
        // Set Hermes bundle path
        const byteCodeBundleName = settings[libraryName].nameOnDevice;
        dummyAppPaths.hermesBundlePath = (0, path_1.join)(dummyAppPaths.bundleDir, byteCodeBundleName);
        // Generate Hermes bundle
        common_1.logger.info('Generating system Hermes bytecode bundle');
        const hermesFlags = [
            args.hermesFlags ? args.hermesFlags : '',
            `-source-map=${newSourcemapPath}`,
        ].join(' ');
        await common_1.Hermes.createBundle(ctx, {
            out: dummyAppPaths.hermesBundlePath,
            bundlePath: newBundlePath,
            hermesFlags: hermesFlags,
        });
        return {
            bundleDir: dummyAppPaths.bundleDir,
            sourcemapPath: newSourcemapPath,
            bundlePath: newBundlePath,
        };
    }
    finally {
        process.chdir(originalCwd);
    }
}
const buildSystemBundle = {
    name: 'build-system-bundle-kepler',
    description: 'Build metro and hermes bundle for system turbomodule',
    text: {
        awaiting: 'Preparing system bundle build',
        inProgress: 'Building system bundle',
        success: 'Built system bundle successfully',
        failure: 'Failed to build system bundle',
    },
    func: async (ctx, args) => {
        await runSystemBundleBuild(ctx, args);
    },
    dependencies: {},
    options: options_1.systemBundleOptionsArray,
};
/**
 * Main handler for system bundle generation.
 * Orchestrates the entire process of creating a dummy app,
 * generating bundles, and copying results back to the package.
 *
 * This command is designed to run in the prepublishOnly phase,
 * after the package is built but before it's published.
 */
async function runSystemBundleBuild(ctx, args) {
    const workingDir = ctx.root;
    // Read library name and version
    const packageJson = JSON.parse(fs_1.default.readFileSync((0, path_1.join)(workingDir, 'package.json'), 'utf8'));
    const libraryName = packageJson.name;
    const version = packageJson.version;
    // Setup package root paths
    const buildDir = (0, path_1.join)(workingDir, 'build');
    const bundleReleaseDir = (0, path_1.join)(buildDir, 'SystemBundles', libraryName);
    const bundlePackingDir = (0, path_1.join)(workingDir, 'SystemBundles');
    const moduleDir = (0, path_1.join)(workingDir, 'SystemModules');
    const srcmapDir = (0, path_1.join)(buildDir, 'debugging', 'Release', 'srcmap');
    const systemBundleConfig = (0, path_1.join)(workingDir, common_1.BundleUtils.systemBundleModuleConfigFile);
    const tarballName = `${libraryName
        .replace('@', '')
        .replace('/', '-')}-${version}.tgz`;
    const tarballDir = node_path_1.default.join(workingDir, 'build', 'private');
    const tarballPath = (0, path_1.join)(tarballDir, tarballName);
    // Create package root directories
    [bundleReleaseDir, bundlePackingDir, srcmapDir, tarballDir].forEach(common_1.PathUtils.ensure);
    // Pack the package first
    common_1.logger.info('Packing npm package...');
    shelljs_1.default.exec(`${common_1.KeplerExecutor.getBaseNpmCommand()} pack --pack-destination="${tarballDir}"`, {
        cwd: workingDir,
    }); // npm pack --pack-destination supported npm 7 and above
    // Verify the packed tarball exists
    if (!fs_1.default.existsSync(tarballPath)) {
        throw new Error(`Failed to find packed npm tarball at ${tarballPath}`);
    }
    // Create and setup dummy app
    const dummyAppDir = await createDummyApp(workingDir, libraryName, tarballPath);
    const dummyAppConfig = {
        ...ctx,
        root: dummyAppDir,
        reactNativeVersion: '0.72', // TODO specifies 0.72 specifically since 0.76 split bundle is not supported currently
    };
    if (fs_1.default.existsSync(moduleDir)) {
        fs_1.default.cpSync(moduleDir, (0, path_1.join)(dummyAppDir, 'SystemModules'), { recursive: true });
    }
    try {
        // Build everything in dummy app
        const { bundleDir, sourcemapPath, bundlePath } = await buildInDummyApp(dummyAppDir, libraryName, dummyAppConfig, args);
        // Copy results to package root
        fs_1.default.cpSync(bundleDir, bundleReleaseDir, { recursive: true });
        // Copy sourcemap and bundle into dist/SystemBundle for packing
        fs_1.default.copyFileSync(bundlePath, (0, path_1.join)(bundlePackingDir, node_path_1.default.basename(bundlePath)));
        fs_1.default.copyFileSync(sourcemapPath, (0, path_1.join)(bundlePackingDir, node_path_1.default.basename(sourcemapPath)));
        fs_1.default.copyFileSync(sourcemapPath, (0, path_1.join)(srcmapDir, node_path_1.default.basename(sourcemapPath)));
        // Copy required kepler-system-conf.toml file to system bundle directory
        fs_1.default.copyFileSync(systemBundleConfig, (0, path_1.join)(bundleReleaseDir, node_path_1.default.basename(systemBundleConfig)));
        common_1.logger.info('System bundle build completed successfully');
    }
    finally {
        // copy system module metadata generated to project root
        if ((0, node_fs_1.existsSync)((0, path_1.join)(dummyAppDir, 'SystemModules'))) {
            fs_1.default.cpSync((0, path_1.join)(dummyAppDir, 'SystemModules'), moduleDir, {
                recursive: true,
            });
        }
        // Clean up dummy app
        fs_1.default.rmSync(dummyAppDir, { recursive: true });
    }
}
exports.default = buildSystemBundle;

"use strict";
/*
 * Copyright 2024 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaControlClientAsync = void 0;
const KeplerMediaControlsClientTM_1 = __importDefault(require("./turbo-modules/KeplerMediaControlsClientTM"));
const KeplerMediaControlsTypes_1 = require("./turbo-modules/types/KeplerMediaControlsTypes");
if (KeplerMediaControlsClientTM_1.default === undefined || KeplerMediaControlsClientTM_1.default === null) {
    throw new Error('Media Controls Client TurboModule is null');
}
const EXCEPTION_MAP = {
    'com.amazon.kepler.media.control.InvalidStateError': KeplerMediaControlsTypes_1.InvalidStateError,
    'com.amazon.kepler.media.control.NotAllowedError': KeplerMediaControlsTypes_1.NotAllowedError,
    'com.amazon.kepler.media.control.SpeedOutOfRangeError': KeplerMediaControlsTypes_1.SpeedOutOfRangeError,
    'com.amazon.kepler.media.control.SeekOutOfRangeError': KeplerMediaControlsTypes_1.SeekOutOfRangeError,
    'com.amazon.kepler.media.control.NotAvailableError': KeplerMediaControlsTypes_1.NotAvailableError
};
const isPromiseResultSuccessful = (result) => {
    if (result.isSuccess === undefined || result.isSuccess === true) {
        return result;
    }
    const MappedError = EXCEPTION_MAP[result.errorTypes] ?? Error;
    throw new MappedError(result.errorMessage);
};
/**
 * Class representing a susbscription to changes in a media control endpoint's
 * session states. Used to remove a listener.
 */
class Subscription {
    token;
    constructor(token) {
        this.token = token;
    }
    /**
     * Called to remove the subscription
     */
    unsubscribe() {
        KeplerMediaControlsClientTM_1.default.removeListener(this.token);
    }
}
/**
 * Class representing a client for a media control endpoint. This class is used
 * to interact with the media control endpoint and perform various actions such
 * as play, pause, seek, and more.
 */
class MediaControlClientAsync {
    client;
    emptySession = { id: NaN };
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the package id of this endpoint if any
     * @returns @type {Promise} of @type {MediaControlTypes.IPackageId} the id
     * of the endpoint's package
     */
    getEndpointPackageId() {
        return KeplerMediaControlsClientTM_1.default.getEndpointPackageId(this.client.clientId);
    }
    /**
     * Send a play request to this media control endpoint
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to send the request for
     * @returns @type {Promise} of @type {void} which resolves on a successful
     * request, and rejects with an error otherwise
     */
    async play(session) {
        return await KeplerMediaControlsClientTM_1.default.play(this.client.clientId, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Send a pause request to this media control endpoint
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to send the request for
     * @returns @type {Promise} of @type {void} which resolves on a successful
     * request, and rejects with an error otherwise
     */
    async pause(session) {
        return await KeplerMediaControlsClientTM_1.default.pause(this.client.clientId, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Send a toggle play pause request to this media control endpoint
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to send the request for
     * @returns @type {Promise} of @type {void} which resolves on a successful
     * request, and rejects with an error otherwise
     */
    async togglePlayPause(session) {
        return await KeplerMediaControlsClientTM_1.default.togglePlayPause(this.client.clientId, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Send a stop request to this media control endpoint
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to send the request for
     * @returns @type {Promise} of @type {void} which resolves on a successful
     * request, and rejects with an error otherwise
     */
    async stop(session) {
        return await KeplerMediaControlsClientTM_1.default.stop(this.client.clientId, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Send a start over request to this media control endpoint
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to send the request for
     * @returns @type {Promise} of @type {void} which resolves on a successful
     * request, and rejects with an error otherwise
     */
    async startOver(session) {
        return await KeplerMediaControlsClientTM_1.default.startOver(this.client.clientId, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Send a fast forward request to this media control endpoint
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to send the request for
     * @returns @type {Promise} of @type {void} which resolves on a successful
     * request, and rejects with an error otherwise
     */
    async fastForward(session) {
        return await KeplerMediaControlsClientTM_1.default.fastForward(this.client.clientId, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Send a rewind request to this media control endpoint
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to send the request for
     * @returns @type {Promise} of @type {void} which resolves on a successful
     * request, and rejects with an error otherwise
     */
    async rewind(session) {
        return await KeplerMediaControlsClientTM_1.default.rewind(this.client.clientId, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Send a set playback speed request to this media control endpoint
     * @param speed @type {number} the speed to set the playback to
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to send the request for
     * @returns @type {Promise} of @type {void} which resolves on a successful
     * request, and rejects with an error otherwise
     */
    async setPlaybackSpeed(speed, session) {
        return await KeplerMediaControlsClientTM_1.default.setPlaybackSpeed(this.client.clientId, speed, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Send a skip forward request to this media control endpoint
     * @param delta @type {MediaControlTypes.ITimeValue} the delta to skip forward by
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to send the request for
     * @returns @type {Promise} of @type {void} which resolves on a successful
     * request, and rejects with an error otherwise
     */
    async skipForward(delta, session) {
        return await KeplerMediaControlsClientTM_1.default.skipForward(this.client.clientId, delta, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Send a skip backward request to this media control endpoint
     * @param delta @type {MediaControlTypes.ITimeValue} the delta to skip backward by
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to send the request for
     * @returns @type {Promise} of @type {void} which resolves on a successful
     * request, and rejects with an error otherwise
     */
    async skipBackward(delta, session) {
        return await KeplerMediaControlsClientTM_1.default.skipBackward(this.client.clientId, delta, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Send a seek request to this media control endpoint
     * @param position @type {MediaControlTypes.ITimeValue} the position to seek to
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to send the request for
     * @returns @type {Promise} of @type {void} which resolves on a successful
     * request, and rejects with an error otherwise
     */
    async seek(position, session) {
        return await KeplerMediaControlsClientTM_1.default.seek(this.client.clientId, position, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Send a set audio volume request to this media control endpoint
     * @param volume @type {number} the volume to set the audio to
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to send the request for
     * @returns @type {Promise} of @type {void} which resolves on a successful
     * request, and rejects with an error otherwise
     */
    async setAudioVolume(volume, session) {
        return await KeplerMediaControlsClientTM_1.default.setAudioVolume(this.client.clientId, volume, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Send a set audio track request to this media control endpoint
     * @param audioTrack @type {MediaControlTypes.ITrack} the audio track to set
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to send the request for
     * @returns @type {Promise} of @type {void} which resolves on a successful
     * request, and rejects with an error otherwise
     */
    async setAudioTrack(audioTrack, session) {
        return await KeplerMediaControlsClientTM_1.default.setAudioTrack(this.client.clientId, audioTrack, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Send an enable text track request to this media control endpoint
     * @param textTrack @type {MediaControlTypes.ITrack} the text track to enable
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to send the request for
     * @returns @type {Promise} of @type {void} which resolves on a successful
     * request, and rejects with an error otherwise
     */
    async enableTextTrack(textTrack, session) {
        return await KeplerMediaControlsClientTM_1.default.enableTextTrack(this.client.clientId, textTrack, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Send a disable text track request to this media control endpoint
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to send the request for
     * @returns @type {Promise} of @type {void} which resolves on a successful
     * request, and rejects with an error otherwise
     */
    async disableTextTrack(session) {
        return await KeplerMediaControlsClientTM_1.default.disableTextTrack(this.client.clientId, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Send a next request to this media control endpoint
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to send the request for
     * @returns @type {Promise} of @type {void} which resolves on a successful
     * request, and rejects with an error otherwise
     */
    async next(session) {
        return await KeplerMediaControlsClientTM_1.default.next(this.client.clientId, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Send a previous request to this media control endpoint
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to send the request for
     * @returns @type {Promise} of @type {void} which resolves on a successful
     * request, and rejects with an error otherwise
     */
    async previous(session) {
        return await KeplerMediaControlsClientTM_1.default.previous(this.client.clientId, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Send an enable shuffle request to this media control endpoint
     * @param enable @type {boolean} whether to enable or disable shuffle
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to send the request for
     * @returns @type {Promise} of @type {void} which resolves on a successful
     * request, and rejects with an error otherwise
     */
    async enableShuffle(enable, session) {
        return await KeplerMediaControlsClientTM_1.default.enableShuffle(this.client.clientId, enable, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Send a set repeat mode request to this media control endpoint
     * @param mode @type {MediaControlTypes.RepeatMode} the repeat mode to set
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to send the request for
     * @returns @type {Promise} of @type {void} which resolves on a successful
     * request, and rejects with an error otherwise
     */
    async setRepeatMode(mode, session) {
        return await KeplerMediaControlsClientTM_1.default.setRepeatMode(this.client.clientId, mode, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Send a set rating request to this media control endpoint
     * @param id @type {MediaId} the media id to set the rating for
     * @param rating @type {number} the rating to set
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to send the request for
     * @returns @type {Promise} of @type {void} which resolves on a successful
     * request, and rejects with an error otherwise
     */
    async setRating(id, rating, session) {
        return await KeplerMediaControlsClientTM_1.default.setRating(this.client.clientId, id, rating, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Send a get metadata request to this media control endpoint
     * @param id @type {MediaId} the media id to get the metadata for
     * @returns @type {Promise} of @type {MediaControlTypes.IMediaMetadat} which resolves with
     * the metadata on a successful request and rejects with an error otherwise
     */
    async getMetadata(id) {
        return await KeplerMediaControlsClientTM_1.default.getMetadata(this.client.clientId, id);
    }
    /**
     * Send a start over request to this media control endpoint
     * @param action @type {MediaControlTypes.Action} the action to send
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to send the request for
     * @returns @type {Promise} of @type {void} which resolves on a successful
     * request, and rejects with an error otherwise
     */
    async sendCustomAction(action, session) {
        return await KeplerMediaControlsClientTM_1.default.sendCustomAction(this.client.clientId, action, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Get the session state for this media control endpoint
     * @param session @type {MediaControlTypes.IMediaSessionId} the session id
     * to get the session state for. Leave null to retrieve states for all active sessions
     * @returns @type {Promise} of @type {MediaControlTypes.MediaSessionState[]} which resolves with
     * a list of session states on a successful request and rejects with an error otherwise
     */
    async getSessionState(session) {
        return await KeplerMediaControlsClientTM_1.default.getSessionState(this.client.clientId, session ?? this.emptySession)
            .then((result) => isPromiseResultSuccessful(result));
    }
    /**
     * Add a listener to this media control endpoint
     * @param listener @type {MediaControlTypes.IMediaControlListener} the listener to add
     * @returns @type {Promise} of @type {MediaControlTypes.ISubscription} which resolves with
     * a subscription object on a successful request and rejects with an error otherwise
     */
    async addListener(listener) {
        return await KeplerMediaControlsClientTM_1.default.addListener(this.client.clientId, listener.onStateChanged)
            .then((token) => new Subscription(token));
    }
    /**
     * Destroy this media control endpoint, releasing all assigned listeners.
     * Must be called if a listener was added.
     */
    destroy() {
        KeplerMediaControlsClientTM_1.default.destroy(this.client.clientId);
    }
}
exports.MediaControlClientAsync = MediaControlClientAsync;

#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.main = void 0;
const yargs_1 = __importDefault(require("yargs"));
const helpers_1 = require("yargs/helpers");
const index_1 = require("./index");
const manifest_builder_1 = require("./manifest-builder");
const logger_1 = require("./utils/logger");
async function main(args = process.argv) {
    await (0, yargs_1.default)((0, helpers_1.hideBin)(args))
        .command({
        command: 'build',
        describe: 'Build a manifest for a package directory',
        builder: (opts) => yargs_1.default
            .option('directory', {
            alias: 'd',
            describe: 'The directory or directories containing `node_modules/`',
            type: 'array',
            string: true,
            demandOption: true,
        })
            .option('package', {
            alias: 'p',
            type: 'string',
            describe: 'The package.json for the application',
        })
            .option('manifest', {
            alias: 'm',
            type: 'string',
            describe: 'The manifest.toml for the application',
        })
            .option('inject', {
            type: 'boolean',
            describe: 'Injects needs and wants modules into the manifest.toml',
            default: false,
        })
            .option('debug', {
            type: 'boolean',
            describe: 'Print the most-verbose logs. Useful for collecting data to report a bug.',
            default: false,
        })
            .option('silent', {
            alias: 's',
            type: 'boolean',
            describe: 'Do not log. Any output returned will be in JSON format.',
            default: false,
        }),
        handler: (argv) => {
            try {
                logger_1.logger.setSilent(argv.silent);
                logger_1.logger.enableDebugLogs(argv.debug);
                const manifestContents = (0, index_1.buildManifestForRootPaths)(argv.directory, argv.package, argv.manifest);
                console.log(JSON.stringify(manifestContents, null, 2));
                if (argv.inject) {
                    if (argv.manifest) {
                        (0, manifest_builder_1.injectManifest)(argv.manifest, manifestContents);
                    }
                    else {
                        console.error('Cannot inject manifest: no manifest file specified');
                    }
                }
            }
            catch (error) {
                logger_1.logger.fatal('Error:', error.message);
                process.exit(1);
            }
        },
    })
        .command({
        command: 'query <package>',
        describe: 'Query NPM package information',
        builder: (opts) => yargs_1.default
            .version(false)
            .positional('package', {
            describe: 'NPM package name',
            type: 'string',
            demandOption: true,
        })
            .option('version', {
            alias: 'v',
            type: 'string',
            describe: 'Specific version to query for backward-compatibility',
            default: undefined,
        })
            .option('pmjs', {
            type: 'string',
            describe: 'The tool will use this package manager for queries, pack, and view calls: (npm, yarn, ...)',
            default: 'npm',
        })
            .option('silent', {
            alias: 's',
            type: 'boolean',
            describe: 'Do not log. Any output returned will be in JSON format.',
            default: false,
        }),
        handler: (argv) => {
            try {
                logger_1.logger.setSilent(argv.silent);
                const result = (0, index_1.queryNpm)(argv.package, argv.version, argv.pmjs);
                if (argv.silent) {
                    console.log(JSON.stringify(result, null, 2));
                }
            }
            catch (error) {
                logger_1.logger.fatal('Error:', error.message);
                process.exit(1);
            }
        },
    })
        .example('$0 build -d ./my-project', 'Build manifest for a project')
        .example('$0 build -d ./my-project -p ./package.json', 'Build manifest with provided application package.json')
        .example('$0 build -d ./my-project -p ./package.json -m ./manifest.toml', 'Build manifest with provided application package.json and application manifest.toml')
        .example('$0 query @amazon-devices/react-native-gesture-handler', 'List all installable versions of a package.')
        .example('$0 query @amazon-devices/react-native-gesture-handler -v 2.4.0', 'Query specific version of a package to learn what backward-compatible versions are included.')
        .example('$0 query @amazon-devices/react-native-gesture-handler -v 2.4.0 --pmjs /path/to/custom/npm', 'Query specific version using a non-standard JS Package Manager')
        .demandCommand(1, 'You need to specify a command')
        .strict()
        .help()
        .alias('help', 'h')
        .parse();
}
exports.main = main;
// Only call main directly if this is the entry point
if (require.main === module) {
    main().catch((err) => {
        logger_1.logger.error('An error occurred setting up CLI:', err);
    });
}

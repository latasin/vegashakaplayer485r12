"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryNpm = exports.buildManifestForRootPaths = exports.buildManifest = void 0;
const lodash_1 = require("lodash");
const manifest_builder_1 = require("./manifest-builder");
const file_utils_1 = require("./utils/file-utils");
const logger_1 = require("./utils/logger");
const npm_utils_1 = require("./utils/npm-utils");
function buildManifest(jsRootPath, applicationPackageJson, applicationManifestToml) {
    return buildManifestForRootPaths([jsRootPath], applicationPackageJson, applicationManifestToml);
}
exports.buildManifest = buildManifest;
function buildManifestForRootPaths(jsRootPaths, applicationPackageJson, applicationManifestToml, allowListOverride) {
    if ((0, lodash_1.isEmpty)(jsRootPaths)) {
        throw new Error(`Required option directory was not provided.`);
    }
    const packageJsonContent = !(0, lodash_1.isNil)(applicationPackageJson)
        ? (0, file_utils_1.parseJsonFile)(applicationPackageJson)
        : {};
    return (0, manifest_builder_1.buildManifestForPackage)(jsRootPaths, packageJsonContent, applicationManifestToml, allowListOverride);
}
exports.buildManifestForRootPaths = buildManifestForRootPaths;
/**
 * Prints the results of processNpmLibrary in a formatted way
 * @param libraryName - The name of the NPM library
 * @param version - Optional version string
 * @returns void
 */
function queryNpm(libraryName, version, jsPackageManager = 'npm') {
    if (!version) {
        logger_1.logger.info(`Available versions to install for ${libraryName}:`);
        const versions = (0, npm_utils_1.getVersionsForLibrary)(libraryName, jsPackageManager);
        if (Array.isArray(versions)) {
            versions.forEach((ver) => logger_1.logger.info(`*  ${ver}`));
        }
        else {
            logger_1.logger.info(`*  ${versions}`);
        }
        return {
            versions,
        };
    }
    const includedVersions = (0, npm_utils_1.getVersionsIncludedFor)(libraryName, version, jsPackageManager);
    logger_1.logger.info(`Backward-compatible versions available when using ${libraryName}@${version}:`);
    Object.entries(includedVersions.versionMap).forEach(([ver, modulesDeclared]) => {
        if (includedVersions.includesModules.some((module) => Array.isArray(modulesDeclared)
            ? modulesDeclared.includes(module)
            : modulesDeclared === module)) {
            logger_1.logger.info(`*  ${ver}`);
        }
    });
    return {
        includedVersions,
    };
}
exports.queryNpm = queryNpm;

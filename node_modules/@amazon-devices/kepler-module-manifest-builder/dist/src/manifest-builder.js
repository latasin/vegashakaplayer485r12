"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectManifest = exports.verifyAndReturnResult = exports.applyKeplerBackwardCompatibility = exports.scanNodeModulesRecursively = exports.buildManifestForPackage = exports.loadAllowList = void 0;
const fs = __importStar(require("fs"));
const lodash_1 = require("lodash");
const path = __importStar(require("path"));
const semver = __importStar(require("semver"));
const compatibility_utils_1 = require("./utils/compatibility-utils");
const file_utils_1 = require("./utils/file-utils");
const logger_1 = require("./utils/logger");
const version_utils_1 = require("./utils/version-utils");
function loadAllowList() {
    try {
        const npmAllowList = require('@amazon-devices/js-bundle-system-allow-list');
        return {
            ...npmAllowList,
            // react native kepler 3.0.0 for RN 76 currently only vends
            // native artifacts and is thus not a JS bundle. Once it's
            // kepler module contains these artifacts we can push it to
            // the js-bundle-system-allow-list. This is needed so customers
            // do not explicitly need to put the module into their manifest.toml.
            '@amazon-devices/react-native-kepler': {
                ...(npmAllowList['@amazon-devices/react-native-kepler'] || {}),
                '3': true,
            },
        };
    }
    catch (error) {
        logger_1.logger.error('------------- WARNING: ----------------');
        logger_1.logger.error('@amazon-devices/js-system-bundle-allow-list was not found. All libraries will be included.');
        logger_1.logger.error('---------------------------------------');
        return {};
    }
}
exports.loadAllowList = loadAllowList;
/**
 * @param jsRootPaths A list of jsRootPath. node_modules/ should reside in this directory.
 * @param overridesPackageJson Tool will apply defined overrides from this file
 * @param applicationManifestToml Tool will validate the manifest.toml against any known privileges picked up along the way.
 * @returns
 */
function buildManifestForPackage(jsRootPaths, overridesPackageJson, applicationManifestToml, allowListOverride) {
    let finalCompatibilityMap = {};
    // Attempt to load the allow list if not provided
    const allowList = allowListOverride || loadAllowList();
    for (const jsRootPath of jsRootPaths) {
        if (!fs.existsSync(jsRootPath)) {
            throw new Error(`Provided directory does not exist: ${jsRootPath}`);
        }
        const npmLibraryManifestMap = scanNodeModulesRecursively(jsRootPath);
        finalCompatibilityMap = {
            ...finalCompatibilityMap,
            ...npmLibraryManifestMap,
        };
    }
    return applyKeplerBackwardCompatibility(overridesPackageJson, finalCompatibilityMap, applicationManifestToml, allowList);
}
exports.buildManifestForPackage = buildManifestForPackage;
function scanNodeModulesRecursively(directoryPath) {
    const libraryMap = {};
    const nodeModulesPath = path.join(directoryPath, 'node_modules');
    const validationErrors = [];
    if (!fs.existsSync(nodeModulesPath)) {
        logger_1.logger.error(`No node_modules directory found in ${directoryPath}`);
        return libraryMap;
    }
    function scanDirectoryEntries(currentPath, parentPackage) {
        const entries = fs.readdirSync(currentPath);
        // Handle scoped packages (directories starting with @)
        entries.forEach((entry) => {
            const entryPath = path.join(currentPath, entry);
            const stats = fs.statSync(entryPath);
            if (stats.isDirectory()) {
                if (entry.startsWith('@')) {
                    // This is a scope directory, process its contents
                    const scopedEntries = fs.readdirSync(entryPath);
                    scopedEntries.forEach((scopedEntry) => {
                        const scopedPath = path.join(entryPath, scopedEntry);
                        if (fs.statSync(scopedPath).isDirectory()) {
                            processPackage(scopedPath, `${entry}/${scopedEntry}`, parentPackage);
                        }
                    });
                }
                else {
                    // Regular package directory
                    processPackage(entryPath, entry, parentPackage);
                }
            }
        });
    }
    function processPackage(packagePath, packageName, parentPackage) {
        const keplerCompatibilityData = (0, compatibility_utils_1.getKeplerNodeModulesData)(packagePath);
        if (!keplerCompatibilityData) {
            logger_1.logger.log(`[SKIP] Library: ${packageName} did not contain valid compatibility information.`);
            return;
        }
        const libraryDependencies = [];
        let libraryPackageJson = {};
        try {
            libraryPackageJson = (0, file_utils_1.parseJsonFile)(path.join(packagePath, 'package.json'));
            if (libraryPackageJson?.kepler?.backwardCompatibility) {
                Object.entries(libraryPackageJson.kepler.backwardCompatibility).forEach(([depName, compatibility]) => {
                    libraryDependencies.push({
                        needsVersion: compatibility.needs,
                        wantsRange: compatibility.wants,
                        libraryName: depName,
                    });
                });
            }
        }
        catch (error) {
            logger_1.logger.log(`[SKIP] Library: ${packagePath} did not contain valid package.json information at root.`);
        }
        const packageVersion = (libraryPackageJson?.version || '').split('+')[0];
        const validationError = validatePackage(packageName, packageVersion, keplerCompatibilityData);
        if (validationError) {
            validationErrors.push(validationError);
        }
        if (keplerCompatibilityData) {
            const fullPackageName = parentPackage
                ? `${parentPackage}/node_modules/${packageName}`
                : packageName;
            let npmMajorVersion = '0';
            if (keplerCompatibilityData.versionMap &&
                Object.keys(keplerCompatibilityData.versionMap).length > 0) {
                // Get the first version from the versionMap and extract its major version
                const firstVersion = Object.keys(keplerCompatibilityData.versionMap)[0];
                const semverParsed = semver.parse(firstVersion);
                if (semverParsed) {
                    npmMajorVersion = String(semverParsed.major);
                }
            }
            libraryMap[fullPackageName] = {
                key: fullPackageName,
                npmLibraryName: packageName,
                npmMajorVersion: npmMajorVersion,
                needsModule: keplerCompatibilityData.needsModule,
                versionMap: keplerCompatibilityData.versionMap,
                privilegeMap: keplerCompatibilityData.privilegeMap,
                wantsModule: undefined,
                wantsRange: undefined,
                libraryDependencies: libraryDependencies,
            };
        }
        const nestedNodeModules = path.join(packagePath, 'node_modules');
        if (fs.existsSync(nestedNodeModules)) {
            scanDirectoryEntries(nestedNodeModules, packageName);
        }
    }
    function validatePackage(packageName, version, keplerCompatibilityData) {
        if (version && (0, lodash_1.isNil)(keplerCompatibilityData.versionMap[version])) {
            return `Library ${packageName} is not properly configured. The version is set to ${version} but that value is not part of it's 'kepler-compatibility.json' file. This library must be updated to correct the error!`;
        }
        return null;
    }
    // Start the recursive scan from the root node_modules
    scanDirectoryEntries(nodeModulesPath);
    // Check for validation errors at the end
    if (validationErrors.length > 0) {
        const YELLOW = '\x1b[33m';
        const RESET = '\x1b[0m';
        const preamble = YELLOW +
            '█████   ███   █████   █████████   ███████████   ██████   █████   \n' +
            '░░███   ░███  ░░███   ███░░░░░███ ░░███░░░░░███ ░░██████ ░░███   \n' +
            ' ░███   ░███   ░███  ░███    ░███  ░███    ░███  ░███░███ ░███   \n' +
            ' ░███   ░███   ░███  ░███████████  ░██████████   ░███░░███░███   \n' +
            ' ░░███  █████  ███   ░███░░░░░███  ░███░░░░░███  ░███ ░░██████   \n' +
            '  ░░░█████░█████░    ░███    ░███  ░███    ░███  ░███  ░░█████   \n' +
            '    ░░███ ░░███      █████   █████ █████   █████ █████  ░░█████  \n' +
            '     ░░░   ░░░      ░░░░░   ░░░░░ ░░░░░   ░░░░░ ░░░░░    ░░░░░   ' +
            RESET +
            '\n';
        console.warn(preamble);
        console.warn(`WARNING\nValidation errors found while scanning node_modules for this application:\n${validationErrors.join('\n\t- ')}`);
    }
    return libraryMap;
}
exports.scanNodeModulesRecursively = scanNodeModulesRecursively;
function applyKeplerBackwardCompatibility(packageJson, npmLibraryManifestMap, applicationManifestToml = '', allowList) {
    const backwardCompatibility = packageJson?.kepler?.backwardCompatibility || {};
    const result = [];
    if ((0, lodash_1.isEmpty)(backwardCompatibility)) {
        logger_1.logger.info('package.json file does not exist, does not contain a kepler object, or backwardCompatibility is not defined. No backward compatibility will be applied.');
    }
    const libraryDependencies = new Map();
    // First, we iterate through our libraries package (node_modules), each library may have defined their own backwardCompatibility spec.
    Object.entries(npmLibraryManifestMap).forEach(([libraryName, libInfo]) => {
        if (!(0, lodash_1.isEmpty)(libInfo.libraryDependencies)) {
            // @ts-ignore
            libInfo.libraryDependencies.forEach((req) => {
                if (!libraryDependencies.has(req.libraryName)) {
                    libraryDependencies.set(req.libraryName, {
                        needsVersion: req.needsVersion,
                        wantsRange: req.wantsRange,
                    });
                }
                const libraryDependencyOverride = libraryDependencies.get(req.libraryName);
                const mergedResult = {
                    needsVersion: (0, version_utils_1.isVersionLargerThan)(req.needsVersion, libraryDependencyOverride.needsVersion)
                        ? req.needsVersion
                        : libraryDependencyOverride.needsVersion,
                    wantsRange: (0, version_utils_1.getIntersectionRange)(req.wantsRange, libraryDependencyOverride.wantsRange),
                };
                logger_1.logger.info(`Library dependency has been set from: ${JSON.stringify(libraryDependencies.get(req.libraryName))} to ${JSON.stringify(mergedResult)}`);
                libraryDependencies.set(req.libraryName, mergedResult);
            });
        }
    });
    // Next, we iterate through definitions provided by the application and merge backwardCompatibility definitions with any library definitions above
    for (const [libraryName, mappedLib] of Object.entries(npmLibraryManifestMap)) {
        const keplerNodeModuleData = {
            ...mappedLib,
        };
        if (!mappedLib.versionMap) {
            throw new Error(`The module defined for ${libraryName} is missing a valid NPM mapping. Unable to continue.`);
        }
        const appCompatibility = backwardCompatibility[libraryName];
        // Application Definition Validation: Ensure the Application-provided backwardCompatibility is valid before evaluating the libraries
        if (appCompatibility) {
            if (!appCompatibility.wants || !appCompatibility.needs) {
                throw new Error(`Library ${libraryName} has invalid backwardCompatibility configuration: needs and wants must be specified.`);
            }
            if ((0, version_utils_1.isExactVersion)(appCompatibility.wants)) {
                // If wants is an exact version (not a range), verify it's not higher than needs
                if (!(0, version_utils_1.isVersionEqual)(appCompatibility.wants, appCompatibility.needs)) {
                    throw new Error(`Library ${libraryName} has invalid backwardCompatibility configuration: wants is specified as exact version ${appCompatibility.wants}. Wants should be equal or larger than the needs version (${appCompatibility.needs})`);
                }
            }
            else {
                // Wants is a range, but needs to be inclusive of needs
                if (!(0, version_utils_1.isVersionInRange)(appCompatibility.needs, appCompatibility.wants)) {
                    throw new Error(`Library ${libraryName} has invalid backwardCompatibility configuration: wants is specified as version range (${appCompatibility.wants}), but that range does not include the version defined in needs: ${appCompatibility.needs}. Wants version range must be inclusive of the value set in needs.`);
                }
            }
        }
        // If needs were defined for library, use that, otherwise always use the highest value defined
        // in kepler-compatibility.json
        const highestVersionDefinedInCompatibility = (0, version_utils_1.getHighestVersionInMap)(libraryName, mappedLib.versionMap);
        const appNeedsVersion = appCompatibility?.needs || highestVersionDefinedInCompatibility;
        const appWantsVersion = appCompatibility?.wants || highestVersionDefinedInCompatibility;
        // Apply needs version
        const needsModuleId = mappedLib.versionMap[appNeedsVersion];
        if (!needsModuleId) {
            throw new Error(`Library ${libraryName} needs version: ${appNeedsVersion} but no mapping exists for this version. Unable to continue.`);
        }
        keplerNodeModuleData.needsModule = needsModuleId;
        // VALIDATION CHECK 1: If library dependencies require a higher version for a library than app-specified
        //                     the developer's configuration is in error and must be resolved.
        const libraryDependencyOverride = libraryDependencies.get(libraryName);
        let wantsRange;
        if (libraryDependencyOverride) {
            if ((0, version_utils_1.isVersionLargerThan)(libraryDependencyOverride.needsVersion, appNeedsVersion)) {
                throw new Error(`One or more libraries require ${libraryName} version ${libraryDependencyOverride.needsVersion}, which is higher than the app-specified version ${appNeedsVersion}. Please modify your compatibility for this library in order to continue.`);
            }
            // First, we look for wants defined by the app
            // After that, if a library has defined `wants` for some _other_ library, we will limit
            // `wantsRange` to the most restrictive intersection of the two ranges.
            const libraryDefinedWants = libraryDependencyOverride?.wantsRange;
            const lastDefinedWants = appCompatibility?.wants || libraryDefinedWants;
            wantsRange = libraryDefinedWants
                ? (0, version_utils_1.getIntersectionRange)(libraryDefinedWants, lastDefinedWants)
                : lastDefinedWants;
        }
        else {
            wantsRange = appWantsVersion;
        }
        keplerNodeModuleData.wantsRange = wantsRange;
        const highestCompatibleVersion = Object.entries(mappedLib.versionMap).reduce((acc, [version, moduleId]) => {
            if ((0, version_utils_1.isVersionInRange)(version, wantsRange) &&
                (!acc.version || (0, version_utils_1.isVersionLargerThan)(version, acc.version))) {
                return {
                    version,
                    moduleId: returnFirstModule(moduleId),
                };
            }
            return acc;
        }, { version: '', moduleId: null });
        if (highestCompatibleVersion.moduleId) {
            keplerNodeModuleData.wantsModule =
                highestCompatibleVersion.moduleId;
            logger_1.logger.info(`A backward compatibility spec was found for lib ${libraryName}.. Values:`, keplerNodeModuleData);
        }
        result.push(keplerNodeModuleData);
    }
    return verifyAndReturnResult(result, applicationManifestToml, allowList);
}
exports.applyKeplerBackwardCompatibility = applyKeplerBackwardCompatibility;
function returnFirstModule(module) {
    if (Array.isArray(module)) {
        if (module.length < 1) {
            throw new Error('ModulesDeclared must not be an empty array');
        }
        return module[0];
    }
    return module;
}
function verifyAndReturnResult(selectedLibraries, applicationManifestToml, allowList) {
    // Only include non-shrink wrapped dependencies when calculating needs/wants/permissions...
    const directDependencyLibraries = selectedLibraries.filter((lib) => lib.key.indexOf('/node_modules/') === -1);
    // Support for Split Bundle AllowList
    const filteredLibraries = directDependencyLibraries.filter((lib) => {
        if ((0, lodash_1.isEmpty)(allowList)) {
            logger_1.logger.log(`AllowList was not supplied. Allow experimental system JS bundle for Library ${lib.key}.`);
            return true;
        }
        let npmLibName = lib.npmLibraryName;
        if (npmLibName.startsWith('@amazon-devices/')) {
            npmLibName = npmLibName.replace('@amazon-devices/', '@amazon-devices/');
        }
        const libMatch = allowList[npmLibName];
        if (!libMatch) {
            logger_1.logger.warn(`Ignoring experimental system JS bundle for Library ${lib.key}.`);
            return false;
        }
        const versionMatch = libMatch[lib.npmMajorVersion];
        if (versionMatch == null) {
            logger_1.logger.warn(`Ignoring experimental system JS bundle for Library ${lib.key}. Version ${lib.npmMajorVersion} not present.`);
            return false;
        }
        else if (!versionMatch) {
            logger_1.logger.warn(`Ignoring experimental system JS bundle for Library ${lib.key}. Version ${lib.npmMajorVersion} not enabled.`);
            return false;
        }
        return true;
    });
    const { needs, wants } = filteredLibraries.reduce((acc, selection) => {
        if (Array.isArray(selection.needsModule)) {
            selection.needsModule.forEach((module) => acc.needs.add(module));
        }
        else {
            acc.needs.add(selection.needsModule);
        }
        if (selection.wantsModule) {
            if (Array.isArray(selection.wantsModule)) {
                selection.wantsModule.forEach((module) => acc.wants.add(module));
            }
            else {
                acc.wants.add(selection.wantsModule);
            }
        }
        return acc;
    }, { needs: new Set(), wants: new Set() });
    const allPrivileges = new Set(filteredLibraries.flatMap((lib) => Object.values(lib.privilegeMap || {}).flat()));
    const appPrivileges = new Set((0, lodash_1.isEmpty)(applicationManifestToml)
        ? []
        : (0, compatibility_utils_1.getPrivilegesFromManifest)(applicationManifestToml));
    // Check if all library privileges are declared in the application manifest
    if (allPrivileges.size > 0 &&
        !Array.from(allPrivileges).every((priv) => appPrivileges.has(priv))) {
        const missingPrivileges = Array.from(allPrivileges).filter((priv) => !appPrivileges.has(priv));
        logger_1.logger.warn(`One or more libraries list required permissions that are not defined in the application manifest. Missing Permissions: ${missingPrivileges.join(', ')}`);
    }
    // Implementation Detail: KeplerModule `needs` are already
    // `wants`, so do not include them in the list.
    wants.forEach((wantedModule) => {
        if (needs.has(wantedModule)) {
            wants.delete(wantedModule);
        }
    });
    // Implementation Detail: Shrink-wrapped libraries may be NEWER
    // than what the app wants, and in that case we still need the libraryMap
    // to be valid. So we spread existing library data with the incoming data.
    const libraryMap = {};
    selectedLibraries.forEach((lib) => {
        const existingResult = libraryMap[lib.npmLibraryName];
        const keplerModuleMap = {};
        // Implementation Detail: This map only _needs_ to contain System-libraries for the Check API.
        // * System-libraries will have exactly one module defined -- the module they defined.
        // * Any additional modules required will be defined in that modules `.toml` file.
        // * Application-deployed libraries may have >1 module defined.
        // * A future solution from AppFramework will render this approach obsolete.
        //   * Refactor and remove this try/catch block after that feature has been released.
        try {
            Object.entries(lib.versionMap).forEach(([version, moduleId]) => {
                keplerModuleMap[version] = returnFirstModule(moduleId);
            });
        }
        catch (error) {
            if (error instanceof Error) {
                throw new Error(`Library ${lib.npmLibraryName} is not properly defined. Error: ${error.message}. Unable to continue.`);
            }
            throw error;
        }
        libraryMap[lib.npmLibraryName] = {
            ...existingResult,
            ...keplerModuleMap,
        };
    });
    return {
        needs: Array.from(needs),
        wants: Array.from(wants),
        privileges: Array.from(appPrivileges),
        keplerModuleMap: libraryMap,
    };
}
exports.verifyAndReturnResult = verifyAndReturnResult;
/**
 * Injects module needs/wants in to provided manifest.toml file
 * @param manifestTomlPath Path to the manifest.toml file
 * @param manifestContents Contains the ManifestDefinition that has defined needs, wants
 */
function injectManifest(manifestTomlPath, manifestContents) {
    // Check if the file exists
    if (!fs.existsSync(manifestTomlPath)) {
        throw new Error(`File not found: ${manifestTomlPath}`);
    }
    // Read existing manifest file
    let tomlContent = fs.readFileSync(manifestTomlPath, 'utf-8');
    let contentModified = false;
    // Add missing needs modules
    if (manifestContents.needs && manifestContents.needs.length > 0) {
        // Ensure needs section exists
        if (!tomlContent.includes('[needs]')) {
            tomlContent += '\n\n[needs]\n';
            contentModified = true;
        }
        // Add needs modules
        for (const moduleId of manifestContents.needs) {
            if (!isModuleDefinedInToml(tomlContent, moduleId, 'needs')) {
                tomlContent += `\n[[needs.module]]\nid = "${moduleId}"\n`;
                contentModified = true;
                logger_1.logger.info(`Added needs module: ${moduleId}`);
            }
            else {
                logger_1.logger.info(`Needs module already defined: ${moduleId}`);
            }
        }
    }
    // Add missing wants modules
    if (manifestContents.wants && manifestContents.wants.length > 0) {
        // Ensure wants section exists
        if (!tomlContent.includes('[wants]')) {
            tomlContent += '\n\n[wants]\n';
            contentModified = true;
        }
        // Add wants modules
        for (const moduleId of manifestContents.wants) {
            if (!isModuleDefinedInToml(tomlContent, moduleId, 'wants')) {
                tomlContent += `\n[[wants.module]]\nid = "${moduleId}"\n`;
                contentModified = true;
                logger_1.logger.info(`Added wants module: ${moduleId}`);
            }
            else {
                logger_1.logger.info(`Wants module already defined: ${moduleId}`);
            }
        }
    }
    // Only write if changes were made
    if (contentModified) {
        fs.writeFileSync(manifestTomlPath, tomlContent, 'utf-8');
        console.log(`Updated manifest file: ${manifestTomlPath}. If using this mechanism, you should commit these changes to your repository.`);
    }
    else {
        logger_1.logger.info(`No changes needed for manifest file: ${manifestTomlPath}`);
    }
}
exports.injectManifest = injectManifest;
/**
 * Check if a module is already defined in a TOML file content
 * @param tomlContent TOML file content as a string
 * @param moduleId Module ID to check
 * @param section Section to check ('needs' or 'wants')
 * @returns True if the module is already defined, false otherwise
 */
function isModuleDefinedInToml(tomlContent, moduleId, section) {
    // Escape special characters in moduleId for regex
    const escapedModuleId = moduleId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    // Create a regex pattern to match the module ID in the specified section
    const pattern = new RegExp(`\\[\\[${section}\\.module\\]\\][\\s\\S]*?id\\s*=\\s*["']${escapedModuleId}["']`, 'i');
    return pattern.test(tomlContent);
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// cli.test.ts
const cli_1 = require("../src/cli");
const index_1 = require("../src/index");
const logger_1 = require("../src/utils/logger");
// Mock the imported functions, these are tested elsewhere
jest.mock('../src/index', () => ({
    buildManifestForRootPaths: jest.fn(),
    queryNpm: jest.fn(),
}));
const mockLogger = {
    fatal: jest.spyOn(logger_1.logger, 'fatal').mockImplementation(),
    error: jest.spyOn(logger_1.logger, 'error').mockImplementation(),
    warn: jest.spyOn(logger_1.logger, 'warn').mockImplementation(),
    info: jest.spyOn(logger_1.logger, 'info').mockImplementation(),
    log: jest.spyOn(logger_1.logger, 'log').mockImplementation(),
    setSilent: jest.spyOn(logger_1.logger, 'setSilent').mockImplementation(),
};
describe('CLI', () => {
    let consoleLogSpy;
    let processExitSpy;
    const mockManifest = {
        needs: ['/com.amazon.kepler.svg_2@ISVG_1'],
        wants: ['/com.amazon.kepler.svg_2@ISVG_2'],
    };
    const mockQueryResult = {
        versions: ['1.0.0', '2.0.0', '3.0.0'],
    };
    beforeEach(() => {
        // Clear all mocks
        jest.clearAllMocks();
        // Setup spy
        consoleLogSpy = jest.spyOn(console, 'log').mockImplementation();
        // Without this line, yargs will force-exit
        processExitSpy = jest
            .spyOn(process, 'exit')
            .mockImplementation((code) => undefined);
        // Setup mock returns, these are tested elsewhere
        index_1.buildManifestForRootPaths.mockReturnValue(mockManifest);
        index_1.queryNpm.mockReturnValue(mockQueryResult);
    });
    afterEach(() => {
        jest.resetAllMocks();
        consoleLogSpy.mockRestore();
        processExitSpy.mockRestore();
    });
    describe('build command', () => {
        it('should execute build command successfully', async () => {
            await (0, cli_1.main)(['node', 'cli.js', 'build', '-d', './test-dir']);
            expect(index_1.buildManifestForRootPaths).toHaveBeenCalledWith(['./test-dir'], undefined, undefined);
            expect(consoleLogSpy).toHaveBeenCalledWith(JSON.stringify(mockManifest, null, 2));
        });
        it('should handle build command with package.json', async () => {
            await (0, cli_1.main)([
                'node',
                'cli.js',
                'build',
                '-d',
                './test-dir',
                '-p',
                './package.json',
            ]);
            expect(index_1.buildManifestForRootPaths).toHaveBeenCalledWith(['./test-dir'], './package.json', undefined);
            expect(consoleLogSpy).toHaveBeenCalledWith(JSON.stringify(mockManifest, null, 2));
        });
        it('should handle build command with package.json and manifest.toml', async () => {
            await (0, cli_1.main)([
                'node',
                'cli.js',
                'build',
                '-d',
                './test-dir',
                '-p',
                './package.json',
                '-m',
                './manifest.toml',
            ]);
            expect(index_1.buildManifestForRootPaths).toHaveBeenCalledWith(['./test-dir'], './package.json', './manifest.toml');
            expect(consoleLogSpy).toHaveBeenCalledWith(JSON.stringify(mockManifest, null, 2));
        });
        it('should handle build command with silent flag', async () => {
            await (0, cli_1.main)([
                'node',
                'cli.js',
                'build',
                '-d',
                './test-dir',
                '--silent',
            ]);
            expect(mockLogger.setSilent).toHaveBeenCalledWith(true);
            expect(index_1.buildManifestForRootPaths).toHaveBeenCalled();
            expect(consoleLogSpy).toHaveBeenCalledWith(JSON.stringify(mockManifest, null, 2));
        });
        it('should log when build command errors', async () => {
            index_1.buildManifestForRootPaths.mockImplementationOnce(() => {
                throw new Error('build failed');
            });
            await (0, cli_1.main)(['node', 'cli.js', 'build', '-d', './test-dir']);
            expect(mockLogger.fatal).toHaveBeenCalledWith('Error:', 'build failed');
            expect(processExitSpy).toHaveBeenCalledWith(1);
        });
    });
    describe('query command', () => {
        it('should execute query command successfully', async () => {
            await (0, cli_1.main)(['node', 'cli.js', 'query', '@amazon-devices/test-package']);
            expect(index_1.queryNpm).toHaveBeenCalledWith('@amazon-devices/test-package', undefined, 'npm');
        });
        it('should handle query command with version', async () => {
            await (0, cli_1.main)([
                'node',
                'cli.js',
                'query',
                '@amazon-devices/test-package',
                '-v',
                '1.0.0',
            ]);
            expect(index_1.queryNpm).toHaveBeenCalledWith('@amazon-devices/test-package', '1.0.0', 'npm');
        });
        it('should handle query command with silent flag', async () => {
            await (0, cli_1.main)([
                'node',
                'cli.js',
                'query',
                '@amazon-devices/test-package',
                '--silent',
            ]);
            expect(mockLogger.setSilent).toHaveBeenCalledWith(true);
            expect(index_1.queryNpm).toHaveBeenCalled();
            expect(consoleLogSpy).toHaveBeenCalledWith(JSON.stringify(mockQueryResult, null, 2));
        });
        it('should handle query command errors', async () => {
            index_1.queryNpm.mockImplementationOnce(() => {
                throw new Error('query failed');
            });
            await (0, cli_1.main)(['node', 'cli.js', 'query', '@amazon-devices/test-package']);
            expect(mockLogger.fatal).toHaveBeenCalledWith('Error:', 'query failed');
            expect(processExitSpy).toHaveBeenCalledWith(1);
        });
    });
    describe('general CLI behavior', () => {
        it('should show help when no arguments provided', async () => {
            await (0, cli_1.main)(['node', 'cli.js']);
            // Help output is handled by yargs
        });
        it('should handle invalid commands', async () => {
            await (0, cli_1.main)(['node', 'cli.js', 'invalid-command']);
            // Invalid command handling is done by yargs
        });
    });
});

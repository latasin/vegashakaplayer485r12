"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const realFs = jest.requireActual('fs');
const realPath = jest.requireActual('path');
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const src_1 = require("../src");
const manifest_builder_1 = require("../src/manifest-builder");
const compatibilityUtils = __importStar(require("../src/utils/compatibility-utils"));
const logger_1 = require("../src/utils/logger");
// Use a static allow_list for unit tests, to avoid NPM side effects
const getMockAllowList = (overrides) => {
    const allowListPath = realPath.join(__dirname, './assets/allow_list.json');
    const mockAllowList = JSON.parse(realFs.readFileSync(allowListPath, 'utf8'));
    return {
        ...mockAllowList,
        ...overrides,
    };
};
// Mock all external dependencies
jest.mock('fs', () => ({
    existsSync: jest.fn(),
    mkdtempSync: jest.fn(),
    readdirSync: jest.fn(),
    readFileSync: jest.fn(),
    writeFileSync: jest.fn(),
    rmSync: jest.fn(),
    mkdirSync: jest.fn(),
    statSync: jest.fn(),
}));
jest.mock('path', () => ({
    join: jest.fn((...args) => args.join('/')),
}));
// Use a static allow_list for unit tests, to avoid NPM side effects
jest.mock('@amazon-devices/js-bundle-system-allow-list/allow-list.json', () => {
    const allowListPath = realPath.join(__dirname, './assets/allow_list.json');
    return JSON.parse(realFs.readFileSync(allowListPath, 'utf8'));
});
jest.mock('../src/utils/compatibility-utils', () => ({
    getKeplerNodeModulesData: jest.fn(),
    getKeplerCompatibilityJson: jest.fn(),
    getPrivilegesFromManifest: jest.fn(),
}));
describe('End-to-End and Scenario Testing', () => {
    const mockLogger = {
        error: jest.spyOn(logger_1.logger, 'error').mockImplementation(),
        warn: jest.spyOn(logger_1.logger, 'warn').mockImplementation(),
        info: jest.spyOn(logger_1.logger, 'info').mockImplementation(),
        log: jest.spyOn(logger_1.logger, 'log').mockImplementation(),
    };
    const mockProjectDir = '/test/project';
    const mockAmznScope = ['@amzn'];
    let depth = 0;
    beforeEach(() => {
        jest.clearAllMocks();
        depth = 0;
        setupBasicMocks();
    });
    // Helper function to setup basic mocks that are common across tests
    function setupBasicMocks() {
        // Validate that package.json does exist for a given directory
        fs.existsSync.mockReturnValue(true);
        // Treat all packageJson as valid but non-useful, to be re-defined in specific test cases
        // as needed.
        fs.readFileSync.mockReturnValue(JSON.stringify({}));
        fs.mkdtempSync.mockReturnValue(mockProjectDir);
        path.join.mockImplementation((...args) => args.join('/'));
        fs.statSync.mockImplementation((...args) => {
            const fPath = args[0];
            const nmIndex = fPath.indexOf('node_modules');
            if (nmIndex === -1) {
                throw new Error('Mock for statSync expects the path to be .../node_modules');
            }
            depth = fPath.substring(nmIndex).split('/').length - 1;
            return {
                isDirectory: () => {
                    // Allow recursing to `node_modules/@amazon-devices/<library_name>.
                    // Depth of 5 is required to test `node_modules/@amazon-devices/<library_name>/node_modules/@amazon-devices/<transitive_lib_dependency>`
                    if (depth > 2) {
                        depth = 0;
                        return false;
                    }
                    // Anything that isn't package.json or kepler-compatibility.json is
                    // a directory, from the perspective of unit test
                    return !fPath.endsWith('.json');
                },
            };
        });
    }
    // Helper function to mock a library's compatibility info
    function mockLibraryCompatibility(versions, privileges, modulePrefix, revisionTagPrefix) {
        const versionMap = {};
        const privilegeMap = {};
        versions.forEach((version, index) => {
            const [majorVersion, minorVersion, _] = version.split('.');
            versionMap[version] =
                `${modulePrefix}_${majorVersion}@${revisionTagPrefix}_${minorVersion}`;
            privilegeMap[version] = privileges;
        });
        return {
            needsModule: versionMap[versions[versions.length - 1]],
            versionMap,
            privilegeMap,
        };
    }
    describe('Basic Manifest Generation', () => {
        it('should generate manifest for single library without overrides', () => {
            // Given
            const mockLibraries = ['react-native-gesture-handler'];
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValue(mockLibraries);
            // Mock compatibility info for each library
            const libraryMocks = {
                'react-native-gesture-handler': mockLibraryCompatibility(['2.0.0', '2.1.0', '2.2.0'], [], '/com.amazon.kepler.gesture_handler', 'IGestureHandler'),
            };
            compatibilityUtils.getKeplerNodeModulesData.mockImplementation((libraryPath) => {
                const libName = libraryPath.split('/').pop();
                return libName ? libraryMocks[libName] : null;
            });
            // When
            const result = (0, src_1.buildManifestForRootPaths)([mockProjectDir]);
            // Then
            expect(result.needs).toEqual([
                '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
            ]);
            expect(result.wants).toEqual([]);
        });
        it('should generate manifest for multiple libraries without overrides', () => {
            // Given
            const mockLibraries = [
                'react-native-gesture-handler',
                'react-native-svg',
                'react-native-qrcode-svg',
            ];
            const mockGestureHandlerFiles = ['package.json'];
            const mockSVGFiles = ['package.json'];
            const mockQRCodeFiles = ['package.json'];
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValueOnce(mockLibraries)
                .mockReturnValueOnce(mockGestureHandlerFiles)
                .mockReturnValueOnce(mockSVGFiles)
                .mockReturnValueOnce(mockQRCodeFiles);
            // Mock compatibility info for each library
            const libraryMocks = {
                'react-native-gesture-handler': mockLibraryCompatibility(['2.0.0', '2.1.0', '2.2.0'], [], '/com.amazon.kepler.gesture_handler', 'IGestureHandler'),
                'react-native-svg': mockLibraryCompatibility(['2.0.0', '2.1.0', '2.2.0'], [], '/com.amazon.kepler.svg', 'ISVG'),
                'react-native-qrcode-svg': mockLibraryCompatibility(['2.0.0', '2.1.0', '2.2.0'], [], '/com.amazon.kepler.qrcode', 'IQRCode'),
            };
            compatibilityUtils.getKeplerNodeModulesData.mockImplementation((libraryPath) => {
                const libName = libraryPath.split('/').pop();
                return libraryMocks[libName];
            });
            // When
            const result = (0, src_1.buildManifestForRootPaths)([mockProjectDir], undefined, undefined, getMockAllowList({
                '@amazon-devices/react-native-svg': { '2': true },
                '@amazon-devices/react-native-qrcode-svg': { '2': true },
            }));
            // Then
            expect(result.needs).toHaveLength(3);
            expect(result.needs).toEqual([
                '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                '/com.amazon.kepler.svg_2@ISVG_2',
                '/com.amazon.kepler.qrcode_2@IQRCode_2',
            ]);
            expect(result.wants).toEqual([]);
        });
    });
    describe('Manifest Generation with Overrides', () => {
        it('should apply overrides correctly for single library', () => {
            // Given
            const mockLibraries = ['react-native-gesture-handler'];
            const mockOverrides = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-gesture-handler': {
                            needs: '2.0.0',
                            wants: '^2.0.0',
                        },
                    },
                },
            };
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValue(mockLibraries);
            compatibilityUtils.getKeplerNodeModulesData.mockReturnValue(mockLibraryCompatibility(['2.0.0', '2.1.0', '2.2.0'], [], '/com.amazon.kepler.gesture_handler', 'IGestureHandler'));
            const overridesPath = '/test/overrides.json';
            fs.readFileSync.mockReturnValue(JSON.stringify(mockOverrides));
            // When
            const result = (0, src_1.buildManifestForRootPaths)([mockProjectDir], overridesPath);
            // Then
            expect(result.needs).toEqual([
                '/com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
            ]);
            expect(result.wants).toHaveLength(1);
            expect(result.wants).toContain('/com.amazon.kepler.gesture_handler_2@IGestureHandler_2');
        });
        it('should apply overrides correctly for multiple libraries', () => {
            // Given
            const mockLibraries = [
                'react-native-gesture-handler',
                'react-native-svg',
            ];
            const mockOverrides = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-gesture-handler': {
                            needs: '2.0.0',
                            wants: '^2.0.0',
                        },
                        '@amazon-devices/react-native-svg': {
                            needs: '2.0.0',
                            wants: '~2.0.0',
                        },
                    },
                },
            };
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValue(mockLibraries);
            const libraryMocks = {
                'react-native-gesture-handler': mockLibraryCompatibility(['2.0.0', '2.1.0', '2.2.0'], [], '/com.amazon.kepler.gesture_handler', 'IGestureHandler'),
                'react-native-svg': mockLibraryCompatibility(['2.0.0', '2.1.0', '2.2.0'], [], '/com.amazon.kepler.svg', 'ISVG'),
            };
            compatibilityUtils.getKeplerNodeModulesData.mockImplementation((libraryPath) => {
                const libName = libraryPath.split('/').pop();
                return libraryMocks[libName];
            });
            const overridesPath = '/test/overrides.json';
            fs.readFileSync.mockReturnValue(JSON.stringify(mockOverrides));
            // When
            const result = (0, src_1.buildManifestForRootPaths)([mockProjectDir], overridesPath, undefined, getMockAllowList({
                '@amazon-devices/react-native-svg': { '2': true },
            }));
            // Then
            expect(result.needs).toHaveLength(2);
            expect(result.needs).toEqual([
                '/com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                '/com.amazon.kepler.svg_2@ISVG_0',
            ]);
            // Gesture handler should want all versions due to ^2.0.0
            expect(result.wants).toContain('/com.amazon.kepler.gesture_handler_2@IGestureHandler_2');
            // SVG should only want 2.0.0 due to ~2.0.0
            // Which is NOT in wants, because it exists in `needs`.
            expect(result.wants).not.toContain('/com.amazon.kepler.svg_2@ISVG_0');
        });
        it('Should consider transitive library that does declare `needs`, but still use latest if app does not set overrides of its own.', () => {
            // Given
            const mockLibraries = [
                'react-native-screens',
                'react-navigation__stack',
            ];
            const mockScreensCompatibilityInfo = {
                needsModule: '/com.amazon.kepler.screens_2@IScreens_4',
                versionMap: {
                    '2.0.0': '/com.amazon.kepler.screens_2@IScreens_0',
                    '2.2.0': '/com.amazon.kepler.screens_2@IScreens_2',
                    '2.4.0': '/com.amazon.kepler.screens_2@IScreens_4',
                },
            };
            const mockStackCompatibilityInfo = {
                needsModule: '/com.amazon.kepler.navigation__stack_2@IStack_0',
                versionMap: {
                    '2.0.0': '/com.amazon.kepler.navigation__stack_2@IStack_0',
                },
            };
            const mockScreensPackageJson = {
                kepler: {
                    extraKey: 'extraValue',
                },
            };
            const mockStackPackageJson = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-screens': {
                            needs: '2.2.0',
                            wants: '^2.0.0',
                        },
                    },
                },
            };
            // Mocks for manifest-builder.ts to the point before getKeplerNodeModulesData
            fs.existsSync.mockReturnValue(true);
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValue(mockLibraries);
            // Also conditionally mock getKeplerNodeModulesData
            compatibilityUtils.getKeplerNodeModulesData.mockImplementation((libraryPath) => {
                if (libraryPath.includes('react-native-screens')) {
                    return mockScreensCompatibilityInfo;
                }
                else if (libraryPath.includes('react-navigation__stack')) {
                    return mockStackCompatibilityInfo;
                }
                // Return empty info block
                return null;
            });
            // Also conditionally mock parseJsonFile
            fs.readFileSync.mockImplementation((packageJsonPath) => {
                if (packageJsonPath.includes('react-native-screens/package.json')) {
                    return JSON.stringify(mockScreensPackageJson);
                }
                else if (packageJsonPath.includes('react-navigation__stack/package.json')) {
                    return JSON.stringify(mockStackPackageJson);
                }
                return null;
            });
            // Given: Application did NOT define a backwardCompatibility block.
            const mockAppPackageJson = {
                kepler: {},
            };
            const result = (0, manifest_builder_1.buildManifestForPackage)(['/test/project'], mockAppPackageJson);
            // Then
            expect(result.needs).toHaveLength(2);
            expect(result.needs).toContain('/com.amazon.kepler.screens_2@IScreens_4');
            expect(result.needs).toContain('/com.amazon.kepler.navigation__stack_2@IStack_0');
            // Should not have any wants defined
            expect(result.wants).toEqual([]);
        });
    });
    describe('Manifest Generation with Privileges', () => {
        it('should apply backward compatibility and check for app-developer defined needs privileges', () => {
            const mockLibraries = ['react-native-gesture-handler'];
            const applicationPackageJson = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-gesture-handler': {
                            needs: '2.0.0',
                            wants: '^2.0.0',
                        },
                    },
                },
            };
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValue(mockLibraries);
            const libraryMocks = {
                'react-native-gesture-handler': {
                    needsModule: '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                    versionMap: {
                        '2.0.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                        '2.1.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                        '2.2.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                    },
                    privilegeMap: {
                        '2.0.0': ['com.amazon.camera.privilege.access'],
                        '2.1.0': ['com.amazon.camera.privilege.access'],
                        '2.2.0': ['com.amazon.camera.privilege.access'],
                    },
                },
            };
            compatibilityUtils.getKeplerNodeModulesData.mockImplementation((libraryPath) => {
                const libName = libraryPath.split('/').pop();
                return libName ? libraryMocks[libName] : null;
            });
            const applicationManifestTomlContent = `
            [needs]
            [[needs.privilege]]
            id = "com.amazon.camera.privilege.access"
        `;
            const applicationPackageJsonPath = '/application/package.json';
            const applicationManifestToml = '/application/manifest.toml';
            fs.readFileSync.mockImplementation((aPath) => {
                if (aPath === applicationManifestToml) {
                    return applicationManifestTomlContent;
                }
                if (aPath === applicationPackageJsonPath) {
                    return JSON.stringify(applicationPackageJson);
                }
                return null;
            });
            const appDefinedPrivileges = ['com.amazon.camera.privilege.access'];
            compatibilityUtils.getPrivilegesFromManifest.mockReturnValueOnce(appDefinedPrivileges);
            const result = (0, src_1.buildManifestForRootPaths)([mockProjectDir], applicationPackageJsonPath, applicationManifestToml);
            expect(result.needs).toEqual([
                '/com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
            ]);
            expect(result.wants).toContain('/com.amazon.kepler.gesture_handler_2@IGestureHandler_2');
        });
        it('should apply backward compatibility and check for app-developer defined wants-privileges', () => {
            const mockLibraries = ['react-native-gesture-handler'];
            const applicationPackageJson = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-gesture-handler': {
                            needs: '2.0.0',
                            wants: '^2.0.0',
                        },
                    },
                },
            };
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValue(mockLibraries);
            const libraryMocks = {
                'react-native-gesture-handler': {
                    needsModule: '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                    versionMap: {
                        '2.0.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                        '2.1.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                        '2.2.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                    },
                    privilegeMap: {
                        '2.0.0': ['com.amazon.camera.privilege.access'],
                        '2.1.0': ['com.amazon.camera.privilege.access'],
                        '2.2.0': ['com.amazon.camera.privilege.access'],
                    },
                },
            };
            compatibilityUtils.getKeplerNodeModulesData.mockImplementation((libraryPath) => {
                const libName = libraryPath.split('/').pop();
                return libName ? libraryMocks[libName] : null;
            });
            const applicationManifestTomlContent = `
            [wants]
            [[wants.privilege]]
            id = "com.amazon.camera.privilege.access"
        `;
            const applicationPackageJsonPath = '/application/package.json';
            const applicationManifestToml = '/application/manifest.toml';
            fs.readFileSync.mockImplementation((aPath) => {
                if (aPath === applicationManifestToml) {
                    return applicationManifestTomlContent;
                }
                if (aPath === applicationPackageJsonPath) {
                    return JSON.stringify(applicationPackageJson);
                }
                return null;
            });
            const appDefinedPrivileges = ['com.amazon.camera.privilege.access'];
            compatibilityUtils.getPrivilegesFromManifest.mockReturnValueOnce(appDefinedPrivileges);
            const result = (0, src_1.buildManifestForRootPaths)([mockProjectDir], applicationPackageJsonPath, applicationManifestToml);
            expect(result.needs).toEqual([
                '/com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
            ]);
            expect(result.wants).toContain('/com.amazon.kepler.gesture_handler_2@IGestureHandler_2');
        });
        it('should log warning if found library privileges are missing', () => {
            const mockLibraries = ['react-native-gesture-handler'];
            const mockOverrides = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-gesture-handler': {
                            needs: '2.0.0',
                            wants: '^2.0.0',
                        },
                    },
                },
            };
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValue(mockLibraries);
            const requiredPrivilege = 'com.amazon.camera.privilege.access';
            const libraryMocks = {
                'react-native-gesture-handler': {
                    needsModule: '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                    versionMap: {
                        '2.0.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                        '2.1.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                        '2.2.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                    },
                    privilegeMap: {
                        '2.0.0': ['com.amazon.camera.privilege.access'],
                        '2.1.0': ['com.amazon.camera.privilege.access'],
                        '2.2.0': ['com.amazon.camera.privilege.access'],
                    },
                },
            };
            compatibilityUtils.getKeplerNodeModulesData.mockImplementation((libraryPath) => {
                const libName = libraryPath.split('/').pop();
                return libName ? libraryMocks[libName] : null;
            });
            const applicationManifestToml = '/application/manifest.toml';
            compatibilityUtils.getPrivilegesFromManifest.mockReturnValueOnce([]);
            const result = (0, src_1.buildManifestForRootPaths)([mockProjectDir], undefined, applicationManifestToml);
            expect(result.needs).toEqual([
                '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
            ]);
            expect(result.wants).toEqual([]);
            expect(result.privileges).toEqual([]);
            // User presented with warnings:
            expect(mockLogger.info).toHaveBeenCalledTimes(2);
            expect(mockLogger.info).toHaveBeenNthCalledWith(1, expect.stringContaining(`package.json file does not exist, does not contain a kepler object, or backwardCompatibility is not defined. No backward compatibility will be applied.`));
            expect(mockLogger.info).toHaveBeenNthCalledWith(2, expect.stringContaining(`A backward compatibility spec was found for lib @amazon-devices/react-native-gesture-handler.. Values:`), expect.anything());
            expect(mockLogger.warn).toHaveBeenNthCalledWith(1, expect.stringContaining(`One or more libraries list required permissions that are not defined in the application manifest. Missing Permissions: ${requiredPrivilege}`));
        });
    });
    describe('Application and Transitive Library both define backwardCompatibility in package.json ', () => {
        it('Should apply both and return the most restrictive `wants` between app and library', () => {
            // Given two libraries, Screens and Navigation/stack
            const mockLibraries = [
                'react-native-screens',
                'react-navigation__stack',
            ];
            // Both libraries have defined a `kepler-compatibility.json`
            const mockScreensCompatibilityInfo = {
                needsModule: '/com.amazon.kepler.screens_2@IScreens_4',
                versionMap: {
                    '2.0.0': '/com.amazon.kepler.screens_2@IScreens_0',
                    '2.2.0': '/com.amazon.kepler.screens_2@IScreens_2',
                    '2.3.0': '/com.amazon.kepler.screens_2@IScreens_3',
                    '2.4.0': '/com.amazon.kepler.screens_2@IScreens_4',
                    '2.5.0': '/com.amazon.kepler.screens_2@IScreens_5',
                },
            };
            const mockStackCompatibilityInfo = {
                needsModule: '/com.amazon.kepler.navigation__stack_2@IStack_0',
                versionMap: {
                    '2.0.0': '/com.amazon.kepler.navigation__stack_2@IStack_0',
                    '2.1.0': '/com.amazon.kepler.navigation__stack_2@IStack_1',
                    '2.2.0': '/com.amazon.kepler.navigation__stack_2@IStack_2',
                    '2.3.0': '/com.amazon.kepler.navigation__stack_2@IStack_3',
                    '2.4.0': '/com.amazon.kepler.navigation__stack_2@IStack_4',
                    '2.5.0': '/com.amazon.kepler.navigation__stack_2@IStack_5',
                },
            };
            // The application package.json defines backwardCompatibility for screens, to support 2.2.0 up to ~2.2.0.
            const mockAppPackageJson = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-screens': {
                            needs: '2.2.0',
                            wants: '~2.2.0',
                        },
                    },
                },
            };
            // The screens library has a package.json, but does not define compatibility.
            const mockScreensPackageJson = {
                kepler: {
                    extraKey: 'extraValue',
                },
            };
            // The library (react-navigation__stack) has a package.json that
            // also defines backwardCompatibility for screens, to support 2.2.0 up to ^2.2.0.
            const mockStackPackageJson = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-screens': {
                            needs: '2.2.0',
                            wants: '^2.2.0',
                        },
                    },
                },
            };
            // Most restrictive range between == ~2.2.0
            // Mocks for manifest-builder.ts to the point before getKeplerNodeModulesData
            fs.existsSync.mockReturnValue(true);
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValue(mockLibraries);
            // Also conditionally mock getKeplerNodeModulesData
            compatibilityUtils.getKeplerNodeModulesData.mockImplementation((libraryPath) => {
                if (libraryPath.includes('react-native-screens')) {
                    return mockScreensCompatibilityInfo;
                }
                else if (libraryPath.includes('react-navigation__stack')) {
                    return mockStackCompatibilityInfo;
                }
                // Return empty info block
                return null;
            });
            // Also conditionally mock parseJsonFile
            fs.readFileSync.mockImplementation((packageJsonPath) => {
                if (packageJsonPath.includes('react-native-screens/package.json')) {
                    return JSON.stringify(mockScreensPackageJson);
                }
                else if (packageJsonPath.includes('react-navigation__stack/package.json')) {
                    return JSON.stringify(mockStackPackageJson);
                }
                return null;
            });
            // When
            const result = (0, manifest_builder_1.buildManifestForPackage)(['/test/project'], mockAppPackageJson);
            // Then
            expect(result.needs).toContain('/com.amazon.kepler.screens_2@IScreens_2');
            expect(result.wants).toEqual([]);
        });
    });
    describe('Edge Cases', () => {
        it('Should apply both and return the most restrictive `wants` between app and library, handling missed mapping', () => {
            // Given two libraries, Screens and Navigation/stack
            const mockLibraries = [
                'react-native-screens',
                'react-navigation__stack',
            ];
            // Both libraries have defined a `kepler-compatibility.json`
            const mockScreensCompatibilityInfo = {
                needsModule: '/com.amazon.kepler.screens_2@IScreens_4',
                versionMap: {
                    '2.0.0': '/com.amazon.kepler.screens_2@IScreens_0',
                    '2.2.0': '/com.amazon.kepler.screens_2@IScreens_2',
                    '2.4.0': '/com.amazon.kepler.screens_2@IScreens_4',
                    '2.5.0': '/com.amazon.kepler.screens_2@IScreens_5',
                },
            };
            const mockStackCompatibilityInfo = {
                needsModule: '/com.amazon.kepler.navigation__stack_2@IStack_0',
                versionMap: {
                    '2.0.0': '/com.amazon.kepler.navigation__stack_2@IStack_0',
                    '2.1.0': '/com.amazon.kepler.navigation__stack_2@IStack_1',
                    '2.2.0': '/com.amazon.kepler.navigation__stack_2@IStack_2',
                    '2.3.0': '/com.amazon.kepler.navigation__stack_2@IStack_3',
                    '2.4.0': '/com.amazon.kepler.navigation__stack_2@IStack_4',
                    '2.5.0': '/com.amazon.kepler.navigation__stack_2@IStack_5',
                },
            };
            // The application package.json defines backwardCompatibility for screens, to support 2.2.0 up to and including 2.3.0.
            const mockAppPackageJson = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-screens': {
                            needs: '2.2.0',
                            wants: '<=2.3.0',
                        },
                    },
                },
            };
            // The screens library has a package.json, but does not define compatibility.
            const mockScreensPackageJson = {
                kepler: {
                    extraKey: 'extraValue',
                },
            };
            // The library (react-navigation__stack) has a package.json that
            // also defines backwardCompatibility for screens, to support 2.2.0 up to ^2.2.0.
            const mockStackPackageJson = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-screens': {
                            needs: '2.2.0',
                            wants: '^2.2.0',
                        },
                    },
                },
            };
            // Mocks for manifest-builder.ts to the point before getKeplerNodeModulesData
            fs.existsSync.mockReturnValue(true);
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValue(mockLibraries);
            // Also conditionally mock getKeplerNodeModulesData
            compatibilityUtils.getKeplerNodeModulesData.mockImplementation((libraryPath) => {
                if (libraryPath.includes('react-native-screens')) {
                    return mockScreensCompatibilityInfo;
                }
                else if (libraryPath.includes('react-navigation__stack')) {
                    return mockStackCompatibilityInfo;
                }
                // Return empty info block
                return null;
            });
            // Also conditionally mock parseJsonFile
            fs.readFileSync.mockImplementation((packageJsonPath) => {
                if (packageJsonPath.includes('react-native-screens/package.json')) {
                    return JSON.stringify(mockScreensPackageJson);
                }
                else if (packageJsonPath.includes('react-navigation__stack/package.json')) {
                    return JSON.stringify(mockStackPackageJson);
                }
                return null;
            });
            // When
            const result = (0, manifest_builder_1.buildManifestForPackage)(['/test/project'], mockAppPackageJson);
            // Then
            expect(result.needs).toContain('/com.amazon.kepler.screens_2@IScreens_2');
            expect(result.wants).toEqual([]);
        });
    });
    describe('Error Handling', () => {
        it('Throw an error if App has defined a `needs` in overrides  < `needs` defined by a transitive library.', () => {
            // Given
            const mockLibraries = [
                'react-native-screens',
                'react-navigation__stack',
            ];
            const mockAppPackageJson = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-screens': {
                            needs: '2.0.0',
                            wants: '^2.0.0',
                        },
                    },
                },
            };
            const mockScreensCompatibilityInfo = {
                needsModule: '/com.amazon.kepler.screens_2@IScreens_4',
                versionMap: {
                    '2.0.0': '/com.amazon.kepler.screens_2@IScreens_0',
                    '2.2.0': '/com.amazon.kepler.screens_2@IScreens_2',
                    '2.4.0': '/com.amazon.kepler.screens_2@IScreens_4',
                },
            };
            const mockStackCompatibilityInfo = {
                needsModule: '/com.amazon.kepler.navigation__stack_2@IStack_0',
                versionMap: {
                    '2.0.0': '/com.amazon.kepler.navigation__stack_2@IStack_0',
                },
            };
            const mockScreensPackageJson = {
                kepler: {
                    extraKey: 'extraValue',
                },
            };
            const mockStackPackageJson = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-screens': {
                            needs: '2.2.0',
                            wants: '^2.0.0',
                        },
                    },
                },
            };
            // Mocks for manifest-builder.ts to the point before getKeplerNodeModulesData
            fs.existsSync.mockReturnValue(true);
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValue(mockLibraries);
            // Also conditionally mock getKeplerNodeModulesData
            compatibilityUtils.getKeplerNodeModulesData.mockImplementation((libraryPath) => {
                if (libraryPath.includes('react-native-screens')) {
                    return mockScreensCompatibilityInfo;
                }
                else if (libraryPath.includes('react-navigation__stack')) {
                    return mockStackCompatibilityInfo;
                }
                // Return empty info block
                return null;
            });
            // Also conditionally mock parseJsonFile
            fs.readFileSync.mockImplementation((packageJsonPath) => {
                if (packageJsonPath.includes('react-native-screens/package.json')) {
                    return JSON.stringify(mockScreensPackageJson);
                }
                else if (packageJsonPath.includes('react-navigation__stack/package.json')) {
                    return JSON.stringify(mockStackPackageJson);
                }
                return null;
            });
            expect(() => {
                (0, manifest_builder_1.buildManifestForPackage)(['/test/project'], mockAppPackageJson);
            }).toThrow('One or more libraries require @amazon-devices/react-native-screens version 2.2.0, which is higher than the app-specified version 2.0.0. Please modify your compatibility for this library in order to continue.');
        });
        it('should handle missing libraries gracefully', () => {
            // Given
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValue([]);
            // When
            const result = (0, src_1.buildManifestForRootPaths)([mockProjectDir]);
            // Then
            expect(result.needs).toEqual([]);
            expect(result.wants).toEqual([]);
        });
        it('should handle invalid version ranges in overrides', () => {
            // Given
            const mockLibraries = ['react-native-gesture-handler'];
            const mockOverrides = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-gesture-handler': {
                            needs: '2.0.0',
                            wants: 'invalid-range',
                        },
                    },
                },
            };
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValue(mockLibraries);
            compatibilityUtils.getKeplerNodeModulesData.mockReturnValue(mockLibraryCompatibility(['2.0.0', '2.1.0', '2.2.0'], [], '/com.amazon.kepler.gesture_handler', 'IGestureHandler'));
            const overridesPath = '/test/overrides.json';
            fs.readFileSync.mockReturnValue(JSON.stringify(mockOverrides));
            // When
            expect(() => (0, src_1.buildManifestForRootPaths)([mockProjectDir], overridesPath)).toThrow(/invalid-range is invalid/);
        });
        it('should throw error for non-existent versions in overrides', () => {
            // Given
            const mockLibraries = ['react-native-gesture-handler'];
            const mockOverrides = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-gesture-handler': {
                            needs: '999.0.0',
                            wants: '^999.0.0',
                        },
                    },
                },
            };
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValue(mockLibraries);
            compatibilityUtils.getKeplerNodeModulesData.mockReturnValue(mockLibraryCompatibility(['2.0.0', '2.1.0', '2.2.0'], [], '/com.amazon.kepler.gesture_handler', 'IGestureHandler'));
            const overridesPath = '/test/overrides.json';
            fs.readFileSync.mockReturnValue(JSON.stringify(mockOverrides));
            // Then
            expect(() => (0, src_1.buildManifestForRootPaths)([mockProjectDir], overridesPath)).toThrow(/no mapping exists for this version/);
        });
    });
});

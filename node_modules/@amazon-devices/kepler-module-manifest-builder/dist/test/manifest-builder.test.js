"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2025 Amazon.com, Inc. or its affiliates.  All rights reserved.
 *
 * PROPRIETARY/CONFIDENTIAL.  USE IS SUBJECT TO LICENSE TERMS.
 */
const realFs = jest.requireActual('fs');
const realPath = jest.requireActual('path');
const fs = __importStar(require("fs"));
const manifest_builder_1 = require("../src/manifest-builder");
const compatibilityUtils = __importStar(require("../src/utils/compatibility-utils"));
const logger_1 = require("../src/utils/logger");
// Mock all external dependencies
jest.mock('fs', () => ({
    existsSync: jest.fn(),
    readdirSync: jest.fn(),
    readFileSync: jest.fn(),
    statSync: jest.fn(),
    writeFileSync: jest.fn(), // Used by injectManifest
}));
jest.mock('path', () => ({
    join: jest.fn((...args) => args.join('/')),
}));
// Use a static allow_list for unit tests, to avoid NPM side effects
const getMockAllowList = (overrides) => {
    const allowListPath = realPath.join(__dirname, './assets/allow_list.json');
    const mockAllowList = JSON.parse(realFs.readFileSync(allowListPath, 'utf8'));
    return {
        ...mockAllowList,
        ...overrides,
    };
};
jest.mock('../src/utils/compatibility-utils', () => ({
    getKeplerNodeModulesData: jest.fn(),
    getPrivilegesFromManifest: jest.fn(),
    getKeplerCompatibilityJson: jest.fn(),
}));
describe('manifest-builder', () => {
    const mockLogger = {
        error: jest.spyOn(logger_1.logger, 'error').mockImplementation(),
        warn: jest.spyOn(logger_1.logger, 'warn').mockImplementation(),
        info: jest.spyOn(logger_1.logger, 'info').mockImplementation(),
        log: jest.spyOn(logger_1.logger, 'log').mockImplementation(),
    };
    const mockAmznScope = ['@amzn'];
    let depth = 0;
    let consoleWarnSpy;
    beforeEach(() => {
        jest.clearAllMocks();
        consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation();
        depth = 0;
        fs.statSync.mockImplementation((...args) => {
            const fPath = args[0];
            depth = depth + 1;
            return {
                isDirectory: () => {
                    // Allow recursing to `node_modules/@amazon-devices/<library_name>.
                    // Depth of 5 is required to test `node_modules/@amazon-devices/<library_name>/node_modules/@amazon-devices/<transitive_lib_dependency>`
                    if (depth > 2) {
                        depth = 0;
                        return false;
                    }
                    // Anything that isn't package.json or kepler-compatibility.json is
                    // a directory, from the perspective of unit test
                    return !fPath.endsWith('.json');
                },
            };
        });
    });
    describe('verifyAndReturnResult', () => {
        it('should return a keplerModuleMap that contains all libraries and versions with kepler-compatibility definitions', () => {
            const selectedLibraries = [
                {
                    key: '@amazon-devices/react-native-gesture-handler',
                    npmLibraryName: '@amazon-devices/react-native-gesture-handler',
                    npmMajorVersion: '2',
                    needsModule: '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                    versionMap: {
                        '2.0.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                        '2.1.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                        '2.2.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                    },
                    privilegeMap: {},
                    wantsModule: undefined,
                    wantsRange: undefined,
                },
                {
                    key: '@amazon-devices/react-native-reanimated',
                    npmLibraryName: '@amazon-devices/react-native-reanimated',
                    npmMajorVersion: '2',
                    needsModule: '/com.amazon.kepler.reanimated_2@IReanimated_2',
                    versionMap: {
                        '2.0.0': '/com.amazon.kepler.reanimated_2@IReanimated_0',
                        '2.1.0': '/com.amazon.kepler.reanimated_2@IReanimated_1',
                        '2.2.0': '/com.amazon.kepler.reanimated_2@IReanimated_2',
                    },
                    privilegeMap: {},
                    wantsModule: undefined,
                    wantsRange: undefined,
                },
            ];
            const applicationManifestToml = '/application/manifest.toml';
            const applicationManifestTomlContent = `
            [needs]
            [[needs.privilege]]
            id = "com.amazon.camera.privilege.access"
            `;
            fs.readFileSync.mockReturnValueOnce(applicationManifestTomlContent);
            const result = (0, manifest_builder_1.verifyAndReturnResult)(selectedLibraries, applicationManifestToml, getMockAllowList());
            expect(result.needs).toEqual([
                '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                '/com.amazon.kepler.reanimated_2@IReanimated_2',
            ]);
            expect(result.wants).toEqual([]);
            expect(result.privileges).toEqual([]);
            expect(result.keplerModuleMap).toEqual({
                '@amazon-devices/react-native-gesture-handler': {
                    '2.0.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                    '2.1.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                    '2.2.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                },
                '@amazon-devices/react-native-reanimated': {
                    '2.0.0': '/com.amazon.kepler.reanimated_2@IReanimated_0',
                    '2.1.0': '/com.amazon.kepler.reanimated_2@IReanimated_1',
                    '2.2.0': '/com.amazon.kepler.reanimated_2@IReanimated_2',
                },
            });
        });
        it('should handle array values in kepler-compatibility input, returning all needs and wants defined', () => {
            const selectedLibraries = [
                {
                    key: '@amazon-devices/kepler-compatibility',
                    npmLibraryName: '@amazon-devices/kepler-compatibility',
                    npmMajorVersion: '2',
                    needsModule: [
                        '/com.amazon.kepler.experimental.features_2025_02@IFeature',
                        '/com.amazon.kepler.security@ISecurityModule',
                    ],
                    wantsModule: [
                        '/com.amazon.kepler.experimental.features_2025_03@IFeature',
                        '/com.amazon.kepler.security@ISecurityModule_2',
                    ],
                    versionMap: {
                        '2.1.0': [
                            '/com.amazon.kepler.experimental.features_2025_02@IFeature',
                            '/com.amazon.kepler.security@ISecurityModule',
                        ],
                        '2.2.0': [
                            '/com.amazon.kepler.experimental.features_2025_03@IFeature',
                            '/com.amazon.kepler.security@ISecurityModule_2',
                        ],
                    },
                    privilegeMap: {},
                },
            ];
            const result = (0, manifest_builder_1.verifyAndReturnResult)(selectedLibraries, '', getMockAllowList());
            expect(result.needs).toEqual([
                '/com.amazon.kepler.experimental.features_2025_02@IFeature',
                '/com.amazon.kepler.security@ISecurityModule',
            ]);
            expect(result.wants).toEqual([
                '/com.amazon.kepler.experimental.features_2025_03@IFeature',
                '/com.amazon.kepler.security@ISecurityModule_2',
            ]);
        });
        it('should throw error when empty array values are found in input', () => {
            const selectedLibraries = [
                {
                    key: '@amazon-devices/kepler-compatibility',
                    npmLibraryName: '@amazon-devices/kepler-compatibility',
                    npmMajorVersion: '2',
                    needsModule: [
                        '/com.amazon.kepler.experimental.features_2025_02@IFeature',
                        '/com.amazon.kepler.security@ISecurityModule',
                    ],
                    wantsModule: [],
                    versionMap: {
                        '2.1.0': [
                            '/com.amazon.kepler.experimental.features_2025_02@IFeature',
                            '/com.amazon.kepler.security@ISecurityModule',
                        ],
                        '2.2.0': [],
                    },
                    privilegeMap: {},
                },
            ];
            const underlyingException = 'ModulesDeclared must not be an empty array';
            expect(() => (0, manifest_builder_1.verifyAndReturnResult)(selectedLibraries, '', getMockAllowList())).toThrow(`Library ${selectedLibraries[0].npmLibraryName} is not properly defined. Error: ${underlyingException}. Unable to continue.`);
        });
    });
    describe('scanNodeModulesRecursively', () => {
        const mockProjectDir = '/test/project';
        it('should return empty map when @amzn directory does not exist', () => {
            // Given
            fs.existsSync.mockReturnValue(false);
            // When
            const result = (0, manifest_builder_1.scanNodeModulesRecursively)(mockProjectDir);
            // Then
            expect(result).toEqual({});
            expect(mockLogger.error).toHaveBeenCalledWith('No node_modules directory found in ' + mockProjectDir);
        });
        it('should scan and process a single @amzn module correctly', () => {
            // Given
            const mockModules = ['react-native-gesture-handler'];
            const mockFiles = ['package.json'];
            const mockCompatibilityInfo = {
                needsModule: 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                versionMap: {
                    '2.0.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                    '2.1.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                    '2.2.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                },
                privilegeMap: {},
            };
            fs.existsSync.mockReturnValue(true);
            // Represents a projectDir containing:
            // node_modules/@amazon-devices/react-native-gesture-handler/package.json
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValueOnce(mockModules)
                .mockReturnValueOnce(mockFiles);
            compatibilityUtils.getKeplerNodeModulesData.mockReturnValue(mockCompatibilityInfo);
            // When
            const result = (0, manifest_builder_1.scanNodeModulesRecursively)(mockProjectDir);
            // Then
            expect(Object.keys(result)).toHaveLength(1);
            expect(result['@amazon-devices/react-native-gesture-handler']).toEqual({
                key: '@amazon-devices/react-native-gesture-handler',
                npmLibraryName: '@amazon-devices/react-native-gesture-handler',
                npmMajorVersion: '2',
                libraryDependencies: [],
                needsModule: mockCompatibilityInfo.needsModule,
                versionMap: mockCompatibilityInfo.versionMap,
                privilegeMap: mockCompatibilityInfo.privilegeMap,
                wantsModule: undefined,
                wantsRange: undefined,
            });
        });
        it('should scan and process a single @amazon-devices module correctly', () => {
            // Given
            const mockModules = ['react-native-gesture-handler'];
            const mockFiles = ['package.json'];
            const mockCompatibilityInfo = {
                needsModule: 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                versionMap: {
                    '2.0.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                    '2.1.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                    '2.2.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                },
                privilegeMap: {},
            };
            fs.existsSync.mockReturnValue(true);
            // Represents a projectDir containing:
            // node_modules/@amazon-devices/react-native-gesture-handler/package.json
            const mockAmzndScope = ['@amazon-devices'];
            fs.readdirSync
                .mockReturnValueOnce(mockAmzndScope)
                .mockReturnValueOnce(mockModules)
                .mockReturnValueOnce(mockFiles);
            compatibilityUtils.getKeplerNodeModulesData.mockReturnValue(mockCompatibilityInfo);
            // When
            const result = (0, manifest_builder_1.scanNodeModulesRecursively)(mockProjectDir);
            // Then
            expect(Object.keys(result)).toHaveLength(1);
            expect(result['@amazon-devices/react-native-gesture-handler']).toEqual({
                key: '@amazon-devices/react-native-gesture-handler',
                npmLibraryName: '@amazon-devices/react-native-gesture-handler',
                npmMajorVersion: '2',
                libraryDependencies: [],
                needsModule: mockCompatibilityInfo.needsModule,
                versionMap: mockCompatibilityInfo.versionMap,
                privilegeMap: mockCompatibilityInfo.privilegeMap,
                wantsModule: undefined,
                wantsRange: undefined,
            });
        });
        it('should scan and process @amzn modules with their own kepler.backwardCompatibility, correctly', () => {
            // Given 2 libraries, RNGH and SVG ...
            const mockModules = [
                'react-native-gesture-handler',
                'react-native-svg',
            ];
            const mockFiles = ['package.json'];
            const mockCompatibilityInfo = {
                needsModule: 'com.amazon.kepler.gesture_handler_2@IGestureHandler_4',
                versionMap: {
                    '2.0.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                    '2.1.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                    '2.2.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                    '2.3.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_3',
                    '2.4.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_4',
                },
                privilegeMap: {},
            };
            const mockSVGCompatibilityInfo = {
                needsModule: 'com.amazon.kepler.svg_2@ISVG_4',
                versionMap: {
                    '2.0.0': 'com.amazon.kepler.svg_2@ISVG_0',
                    '2.1.0': 'com.amazon.kepler.svg_2@ISVG_1',
                    '2.2.0': 'com.amazon.kepler.svg_2@ISVG_2',
                    '2.3.0': 'com.amazon.kepler.svg_2@ISVG_3',
                    '2.4.0': 'com.amazon.kepler.svg_2@ISVG_4',
                },
                privilegeMap: {},
            };
            fs.existsSync.mockReturnValue(true);
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValueOnce(mockModules)
                .mockReturnValue(mockFiles);
            fs.readFileSync
                // Nothing of interest is defined in RNGH,
                .mockReturnValueOnce(JSON.stringify({}))
                // however BackwardCompatibility is defined for SVG
                .mockReturnValueOnce(JSON.stringify({
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-gesture-handler': {
                            needs: '2.2.0',
                            wants: '^2.2.0',
                        },
                    },
                },
            }));
            compatibilityUtils.getKeplerNodeModulesData
                .mockReturnValueOnce(mockCompatibilityInfo)
                .mockReturnValueOnce(mockSVGCompatibilityInfo);
            // When
            const result = (0, manifest_builder_1.scanNodeModulesRecursively)(mockProjectDir);
            // Then
            expect(Object.keys(result)).toHaveLength(2);
            expect(result['@amazon-devices/react-native-gesture-handler']).toEqual({
                key: '@amazon-devices/react-native-gesture-handler',
                npmLibraryName: '@amazon-devices/react-native-gesture-handler',
                npmMajorVersion: '2',
                libraryDependencies: [],
                needsModule: mockCompatibilityInfo.needsModule,
                versionMap: mockCompatibilityInfo.versionMap,
                privilegeMap: mockCompatibilityInfo.privilegeMap,
                wantsModule: undefined,
                wantsRange: undefined,
            });
            expect(result['@amazon-devices/react-native-svg']).toEqual({
                key: '@amazon-devices/react-native-svg',
                npmLibraryName: '@amazon-devices/react-native-svg',
                npmMajorVersion: '2',
                libraryDependencies: [
                    {
                        libraryName: '@amazon-devices/react-native-gesture-handler',
                        needsVersion: '2.2.0',
                        wantsRange: '^2.2.0',
                    },
                ],
                needsModule: mockSVGCompatibilityInfo.needsModule,
                versionMap: mockSVGCompatibilityInfo.versionMap,
                privilegeMap: mockCompatibilityInfo.privilegeMap,
                wantsModule: undefined,
                wantsRange: undefined,
            });
        });
        it('should scan and process nested @amzn modules that are transitive dependencies', () => {
            // Given a modified mock implementation for isDirectory
            depth = 0;
            fs.statSync.mockImplementation((...args) => {
                const fPath = args[0];
                depth = depth + 1;
                return {
                    isDirectory: () => {
                        // Depth of 2 allows recursing to `node_modules/@amazon-devices/<library_name>.
                        // Depth of 6 is required to test `node_modules/@amazon-devices/<library_name>/node_modules/@amazon-devices/<transitive_lib_dependency>`
                        if (depth > 6) {
                            depth = 0;
                            return false;
                        }
                        // Anything that isn't package.json or kepler-compatibility.json is
                        // a directory, from the perspective of unit test
                        return !fPath.endsWith('.json');
                    },
                };
            });
            // Given 2 libraries, RNGH and SVG ...
            const mockModules = ['react-native-gesture-handler'];
            const mockRNGHnodeModules = ['react-native-svg'];
            const mockFiles = ['package.json'];
            const mockCompatibilityInfo = {
                needsModule: 'com.amazon.kepler.gesture_handler_2@IGestureHandler_4',
                versionMap: {
                    '2.0.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                    '2.1.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                    '2.2.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                    '2.3.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_3',
                    '2.4.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_4',
                },
                privilegeMap: {},
            };
            const mockSVGCompatibilityInfo = {
                needsModule: 'com.amazon.kepler.svg_2@ISVG_4',
                versionMap: {
                    '2.0.0': 'com.amazon.kepler.svg_2@ISVG_0',
                    '2.1.0': 'com.amazon.kepler.svg_2@ISVG_1',
                    '2.2.0': 'com.amazon.kepler.svg_2@ISVG_2',
                    '2.3.0': 'com.amazon.kepler.svg_2@ISVG_3',
                    '2.4.0': 'com.amazon.kepler.svg_2@ISVG_4',
                },
                privilegeMap: {},
            };
            fs.existsSync.mockReturnValue(true);
            fs.readdirSync // node_modules
                .mockReturnValueOnce(mockAmznScope) // node_modules/@amzn
                .mockReturnValueOnce(mockModules) // node_modules/@amazon-devices/[react-native-gesture-handler]
                .mockReturnValueOnce(mockAmznScope) // node_modules/@amazon-devices/[react-native-gesture-handler]/@amzn
                .mockReturnValueOnce(mockRNGHnodeModules); // node_modules/@amazon-devices/[react-native-gesture-handler]/@amazon-devices/[react-native-svg]
            fs.readFileSync
                // Nothing of interest is defined in RNGH,
                .mockReturnValueOnce(JSON.stringify({}))
                // however BackwardCompatibility is defined for SVG
                .mockReturnValueOnce(JSON.stringify({
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-gesture-handler': {
                            needs: '2.2.0',
                            wants: '^2.2.0',
                        },
                    },
                },
            }));
            compatibilityUtils.getKeplerNodeModulesData
                .mockReturnValueOnce(mockCompatibilityInfo)
                .mockReturnValueOnce(mockSVGCompatibilityInfo);
            // When
            const result = (0, manifest_builder_1.scanNodeModulesRecursively)(mockProjectDir);
            // Then
            expect(Object.keys(result)).toEqual([
                '@amazon-devices/react-native-gesture-handler',
                '@amazon-devices/react-native-gesture-handler/node_modules/@amazon-devices/react-native-svg',
            ]);
            expect(result['@amazon-devices/react-native-gesture-handler']).toEqual({
                key: '@amazon-devices/react-native-gesture-handler',
                npmLibraryName: '@amazon-devices/react-native-gesture-handler',
                npmMajorVersion: '2',
                libraryDependencies: [],
                needsModule: mockCompatibilityInfo.needsModule,
                versionMap: mockCompatibilityInfo.versionMap,
                privilegeMap: mockCompatibilityInfo.privilegeMap,
                wantsModule: undefined,
                wantsRange: undefined,
            });
            // DEV NOTE: Still unclear what the real-world scenario is,
            //           but the point is that the values can be extracted
            //           if we end up needing to parse to this level.
            expect(result['@amazon-devices/react-native-gesture-handler/node_modules/@amazon-devices/react-native-svg']).toEqual({
                libraryDependencies: [
                    {
                        libraryName: '@amazon-devices/react-native-gesture-handler',
                        needsVersion: '2.2.0',
                        wantsRange: '^2.2.0',
                    },
                ],
                key: '@amazon-devices/react-native-gesture-handler/node_modules/@amazon-devices/react-native-svg',
                npmLibraryName: '@amazon-devices/react-native-svg',
                npmMajorVersion: '2',
                needsModule: mockSVGCompatibilityInfo.needsModule,
                versionMap: mockSVGCompatibilityInfo.versionMap,
                privilegeMap: mockCompatibilityInfo.privilegeMap,
                wantsModule: undefined,
                wantsRange: undefined,
            });
        });
        it('should skip libraries without valid compatibility information', () => {
            // Given
            fs.existsSync.mockReturnValue(true);
            fs.readdirSync
                .mockReturnValueOnce(['@amzn'])
                .mockReturnValue(['invalid-library']);
            compatibilityUtils.getKeplerNodeModulesData.mockReturnValue(null);
            // When
            const result = (0, manifest_builder_1.scanNodeModulesRecursively)(mockProjectDir);
            // Then
            expect(Object.keys(result)).toHaveLength(0);
            expect(mockLogger.log).toHaveBeenCalledWith(expect.stringContaining('did not contain valid compatibility information'));
        });
    });
    describe('applyKeplerBackwardCompatibility', () => {
        const mockLibraryManifestMap = {
            '@amazon-devices/react-native-gesture-handler': {
                key: '@amazon-devices/react-native-gesture-handler',
                npmLibraryName: '@amazon-devices/react-native-gesture-handler',
                npmMajorVersion: '2',
                needsModule: 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                versionMap: {
                    '2.0.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                    '2.1.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                    '2.2.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                },
                privilegeMap: {},
                wantsModule: undefined,
                wantsRange: undefined,
                libraryDependencies: [],
            },
        };
        it('returns NO wants and HIGHEST needs if Application does not define a kepler.backwardCompatibility in package.json', () => {
            // When
            const result = (0, manifest_builder_1.applyKeplerBackwardCompatibility)({}, mockLibraryManifestMap, undefined, getMockAllowList());
            // Then
            expect(result).toEqual({
                needs: [
                    'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                ],
                wants: [],
                privileges: [],
                keplerModuleMap: {
                    '@amazon-devices/react-native-gesture-handler': {
                        '2.0.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                        '2.1.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                        '2.2.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                    },
                },
            });
            expect(mockLogger.info).toHaveBeenCalledWith(expect.stringContaining('package.json file does not exist'));
        });
        it('should apply backward compatibility from package.json', () => {
            // Given
            const mockPackageJson = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-gesture-handler': {
                            needs: '2.0.0',
                            wants: '^2.0.0',
                        },
                    },
                },
            };
            // When
            const result = (0, manifest_builder_1.applyKeplerBackwardCompatibility)(mockPackageJson, mockLibraryManifestMap, undefined, getMockAllowList());
            // Then
            expect(result.needs).toEqual([
                'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
            ]);
            expect(result.wants).toContain('com.amazon.kepler.gesture_handler_2@IGestureHandler_2');
        });
        it('Error Case: should apply backward compatibility from package.json, log an error when wants and needs produce invalid', () => {
            // Given
            const mockPackageJson = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-gesture-handler': {
                            needs: '2.0.0',
                            wants: '2.2.0',
                        },
                    },
                },
            };
            // Then
            expect(() => (0, manifest_builder_1.applyKeplerBackwardCompatibility)(mockPackageJson, mockLibraryManifestMap, undefined, getMockAllowList())).toThrow('Library @amazon-devices/react-native-gesture-handler has invalid backwardCompatibility configuration: wants is specified as exact version 2.2.0. Wants should be equal or larger than the needs version (2.0.0)');
        });
        it('Error Case: should throw error when wants range does not include needs version', () => {
            // Given
            const mockPackageJson = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-gesture-handler': {
                            needs: '2.0.0',
                            wants: '>2.5.0', // Range that excludes needs version
                        },
                    },
                },
            };
            // Then
            expect(() => (0, manifest_builder_1.applyKeplerBackwardCompatibility)(mockPackageJson, mockLibraryManifestMap, undefined, getMockAllowList())).toThrow('Library @amazon-devices/react-native-gesture-handler has invalid backwardCompatibility configuration: wants is specified as version range (>2.5.0), but that range does not include the version defined in needs: 2.0.0. Wants version range must be inclusive of the value set in needs.');
        });
        it('should apply backward compatibility from package.json, log an error when needs are defined but wants are not', () => {
            // Given
            const mockPackageJson = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-gesture-handler': {
                            needs: '2.2.0',
                        },
                    },
                },
            };
            // When
            // Then
            expect(() => (0, manifest_builder_1.applyKeplerBackwardCompatibility)(mockPackageJson, mockLibraryManifestMap, undefined, getMockAllowList())).toThrow('Library @amazon-devices/react-native-gesture-handler has invalid backwardCompatibility configuration: needs and wants must be specified.');
        });
        it('should apply backward compatibility from package.json, log an error when wants are defined but needs are not', () => {
            // Given
            const mockPackageJson = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-gesture-handler': {
                            wants: '2.2.0',
                        },
                    },
                },
            };
            // When
            // Then
            expect(() => (0, manifest_builder_1.applyKeplerBackwardCompatibility)(mockPackageJson, mockLibraryManifestMap, undefined, getMockAllowList())).toThrow('Library @amazon-devices/react-native-gesture-handler has invalid backwardCompatibility configuration: needs and wants must be specified.');
        });
        describe('privileges', () => {
            const cameraPrivilege = 'com.amazon.camera.privilege.access';
            const mockLibraryManifestMapPrivileges = {
                '@amazon-devices/react-native-gesture-handler': {
                    key: '@amazon-devices/react-native-gesture-handler',
                    npmLibraryName: '@amazon-devices/react-native-gesture-handler',
                    npmMajorVersion: '2',
                    needsModule: 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                    versionMap: {
                        '2.0.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                        '2.1.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                        '2.2.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                    },
                    privilegeMap: {
                        '2.0.0': [cameraPrivilege],
                        '2.1.0': [cameraPrivilege],
                        '2.2.0': [cameraPrivilege],
                    },
                },
            };
            it('should apply backward compatibility and check for required privileges', () => {
                const mockPackageJson = {
                    kepler: {
                        backwardCompatibility: {
                            '@amazon-devices/react-native-gesture-handler': {
                                needs: '2.0.0',
                                wants: '^2.0.0',
                            },
                        },
                    },
                };
                const applicationManifestToml = '/application/manifest.toml';
                const appDefinedPrivileges = [cameraPrivilege];
                compatibilityUtils.getPrivilegesFromManifest.mockReturnValueOnce(appDefinedPrivileges);
                const result = (0, manifest_builder_1.applyKeplerBackwardCompatibility)(mockPackageJson, mockLibraryManifestMapPrivileges, applicationManifestToml, getMockAllowList());
                expect(result.needs).toEqual([
                    'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                ]);
                expect(result.wants).toEqual([
                    'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                ]);
                expect(result.privileges).toEqual([cameraPrivilege]);
            });
            it('should log warning if privileges are missing, returning only app-defined privileges', () => {
                const mockPackageJson = {
                    kepler: {
                        backwardCompatibility: {
                            '@amazon-devices/react-native-gesture-handler': {
                                needs: '2.0.0',
                                wants: '^2.0.0',
                            },
                        },
                    },
                };
                const applicationManifestToml = 'my_application/manifest.toml';
                const appDefinedPrivileges = [];
                compatibilityUtils.getPrivilegesFromManifest.mockReturnValueOnce(appDefinedPrivileges);
                const result = (0, manifest_builder_1.applyKeplerBackwardCompatibility)(mockPackageJson, mockLibraryManifestMapPrivileges, applicationManifestToml, getMockAllowList());
                expect(mockLogger.warn).toHaveBeenNthCalledWith(1, expect.stringContaining(`One or more libraries list required permissions that are not defined in the application manifest. Missing Permissions: ${cameraPrivilege}`));
                expect(result.needs).toEqual([
                    'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                ]);
                expect(result.wants).toEqual([
                    'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                ]);
                expect(result.privileges).toEqual([]);
            });
        });
        it('should throw an error if a library defined in Compatibility has no definitions', () => {
            // Given
            const mockPackageJson = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/nonexistent-library': {
                            needs: '2.0.0',
                            wants: '^2.0.0',
                        },
                    },
                },
            };
            // When
            try {
                (0, manifest_builder_1.applyKeplerBackwardCompatibility)(mockPackageJson, mockLibraryManifestMap, undefined, getMockAllowList());
            }
            catch (error) {
                expect(error instanceof Error).toBeTruthy();
                expect(error.message).toEqual(expect.stringContaining('@amazon-devices/nonexistent-library is missing a valid NPM mapping. Unable to continue.'));
            }
        });
        it('should throw error for invalid needs version', () => {
            // Given
            const mockPackageJson = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-gesture-handler': {
                            needs: '2.999.0',
                            wants: '^2.0.0',
                        },
                    },
                },
            };
            // Then
            expect(() => (0, manifest_builder_1.applyKeplerBackwardCompatibility)(mockPackageJson, mockLibraryManifestMap, '', getMockAllowList())).toThrow('no mapping exists for this version');
        });
    });
    describe('buildManifestForPackage', () => {
        const mockProjectDir = '/test/project';
        it('should throw error when directory does not exist', () => {
            // Given
            fs.existsSync.mockReturnValueOnce(false);
            // Then
            expect(() => (0, manifest_builder_1.buildManifestForPackage)([mockProjectDir])).toThrow(`Provided directory does not exist: ${mockProjectDir}`);
        });
        it('should build manifest with overrides and skip shrink-wrapped libraries', () => {
            // Given
            const mockModules = [
                'react-native-gesture-handler',
                'react-native-svg',
                'react-native-qrcode-svg',
            ];
            const mockCompatibilityInfoRNGH = {
                needsModule: 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                versionMap: {
                    '2.0.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                    '2.1.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                    '2.2.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                },
                privilegeMap: {},
            };
            const mockCompatibilityInfoQRCode = {
                needsModule: 'com.amazon.kepler.qrcode_2@IQRCode_2',
                versionMap: {
                    '2.0.0': 'com.amazon.kepler.qrcode_2@IQRCode_0',
                    '2.1.0': 'com.amazon.kepler.qrcode_2@IQRCode_1',
                    '2.2.0': 'com.amazon.kepler.qrcode_2@IQRCode_2',
                },
                privilegeMap: {},
            };
            const mockCompatibilityInfoSVG = {
                needsModule: 'com.amazon.kepler.svg_2@ISVG_2',
                versionMap: {
                    '2.0.0': 'com.amazon.kepler.svg_2@ISVG_0',
                    '2.1.0': 'com.amazon.kepler.svg_2@ISVG_1',
                    '2.2.0': 'com.amazon.kepler.svg_2@ISVG_2',
                },
                privilegeMap: {},
            };
            fs.existsSync.mockReturnValue(true);
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValueOnce(mockModules);
            compatibilityUtils.getKeplerNodeModulesData.mockReturnValueOnce(mockCompatibilityInfoRNGH);
            compatibilityUtils.getKeplerNodeModulesData.mockReturnValueOnce(mockCompatibilityInfoSVG);
            compatibilityUtils.getKeplerNodeModulesData.mockReturnValueOnce(undefined);
            const mockOverrides = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-gesture-handler': {
                            needs: '2.0.0',
                            wants: '^2.0.0',
                        },
                    },
                },
            };
            // When
            const result = (0, manifest_builder_1.buildManifestForPackage)([mockProjectDir], mockOverrides, '', getMockAllowList({
                '@amazon-devices/react-native-svg': { '2': true },
            }));
            // Then
            expect(result.needs).toEqual([
                'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                'com.amazon.kepler.svg_2@ISVG_2',
            ]);
            expect(result.wants).toEqual([
                'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
            ]);
        });
        it('should build manifest without overrides', () => {
            // Given
            const mockCompatibilityInfo = {
                needsModule: 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                versionMap: {
                    '2.0.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                    '2.1.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                    '2.2.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                },
                privilegeMap: {},
            };
            fs.existsSync.mockReturnValue(true);
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValue(['react-native-gesture-handler']);
            compatibilityUtils.getKeplerNodeModulesData.mockReturnValue(mockCompatibilityInfo);
            // When
            const result = (0, manifest_builder_1.buildManifestForPackage)([mockProjectDir], undefined, '', getMockAllowList());
            // Then
            expect(result.needs).toEqual([
                'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
            ]);
            expect(result.wants).toEqual([]);
        });
        it('should build manifest without overrides and two sets of node_modules to scan', () => {
            // Given
            const mockMonorepoRootDir = '/test/monorepo';
            const mockMonorepoAppDir = '/test/monorepo/app';
            const mockRNGHCompatibilityInfo = {
                needsModule: 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                versionMap: {
                    '2.0.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                    '2.1.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                    '2.2.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                },
                privilegeMap: {},
            };
            const mockReanimatedCompatibilityInfo = {
                needsModule: 'com.amazon.kepler.reanimated_2@IReanimated_2',
                versionMap: {
                    '2.0.0': 'com.amazon.kepler.reanimated_2@IReanimated_0',
                    '2.1.0': 'com.amazon.kepler.reanimated_2@IReanimated_1',
                    '2.2.0': 'com.amazon.kepler.reanimated_2@IReanimated_2',
                },
                privilegeMap: {},
            };
            let depthCounter = 0;
            fs.statSync.mockImplementation((...args) => {
                const fPath = args[0];
                depthCounter = depthCounter + 1;
                return {
                    isDirectory: () => {
                        // Allow recursing to `node_modules/@amazon-devices/<library_name>.
                        // Depth of 5 is required to test `node_modules/@amazon-devices/<library_name>/node_modules/@amazon-devices/<transitive_lib_dependency>`
                        if (depthCounter > 2) {
                            depthCounter = 0;
                            return false;
                        }
                        // Anything that isn't package.json or kepler-compatibility.json is
                        // a directory, from the perspective of unit test
                        return !fPath.endsWith('.json');
                    },
                };
            });
            fs.existsSync.mockImplementation((filepath) => {
                if (filepath.endsWith('package.json')) {
                    return true;
                }
                else if (filepath.endsWith('/test/monorepo')) {
                    return true;
                }
                else if (filepath.endsWith('/test/monorepo/node_modules')) {
                    return true;
                }
                else if (filepath.endsWith('/test/monorepo/node_modules/@amzn')) {
                    return true;
                }
                else if (filepath.endsWith('/test/monorepo/app')) {
                    depthCounter = 0;
                    return true;
                }
                else if (filepath.endsWith('/test/monorepo/app/node_modules')) {
                    return true;
                }
                else if (filepath.endsWith('/test/monorepo/app/node_modules/@amzn')) {
                    return true;
                }
                return false;
            });
            // Simulated: When scanning `/test/monorepo`, the node_modules/ directory contains:
            // - @amazon-devices/react-native-gesture-handler
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValueOnce(['react-native-gesture-handler'])
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValueOnce(['react-native-reanimated']);
            compatibilityUtils.getKeplerNodeModulesData.mockReturnValueOnce(mockRNGHCompatibilityInfo);
            // Simulated: When scanning `/test/monorepo/app`, the node_modules/ directory contains:
            // - @amazon-devices/react-native-reanimated
            compatibilityUtils.getKeplerNodeModulesData.mockReturnValueOnce(mockReanimatedCompatibilityInfo);
            // When
            const result = (0, manifest_builder_1.buildManifestForPackage)([mockMonorepoRootDir, mockMonorepoAppDir], undefined, '', getMockAllowList({
                '@amazon-devices/react-native-reanimated': { '2': true },
            }));
            // Then
            expect(result.needs).toEqual([
                'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                'com.amazon.kepler.reanimated_2@IReanimated_2',
            ]);
            expect(result.wants).toEqual([]);
        });
        it('should build manifest with overrides', () => {
            // Given
            const mockOverrides = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-gesture-handler': {
                            needs: '2.0.0',
                            wants: '^2.0.0',
                        },
                    },
                },
            };
            const mockCompatibilityInfo = {
                needsModule: 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                versionMap: {
                    '2.0.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                    '2.1.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                    '2.2.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                },
                privilegeMap: {},
            };
            fs.existsSync.mockImplementation((filepath) => {
                if (filepath.endsWith('package.json')) {
                    return true;
                }
                else if (filepath.endsWith('project')) {
                    return true;
                }
                else if (filepath.endsWith('project/node_modules')) {
                    return true;
                }
                else if (filepath.endsWith('project/node_modules/@amzn')) {
                    return true;
                }
                return false;
            });
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValue(['react-native-gesture-handler']);
            compatibilityUtils.getKeplerNodeModulesData.mockReturnValue(mockCompatibilityInfo);
            // When
            const result = (0, manifest_builder_1.buildManifestForPackage)([mockProjectDir], mockOverrides);
            // Then
            expect(result.needs).toEqual([
                'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
            ]);
            expect(result.wants).toContain('com.amazon.kepler.gesture_handler_2@IGestureHandler_2');
        });
        it('should build manifest with overrides and exact needs and wants', () => {
            // Given
            const mockOverrides = {
                kepler: {
                    backwardCompatibility: {
                        '@amazon-devices/react-native-gesture-handler': {
                            needs: '2.0.0',
                            wants: '2.0.0',
                        },
                    },
                },
            };
            const mockCompatibilityInfo = {
                needsModule: 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                versionMap: {
                    '2.0.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                    '2.1.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                    '2.2.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                },
                privilegeMap: {},
            };
            fs.existsSync.mockReturnValue(true);
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValue(['react-native-gesture-handler']);
            compatibilityUtils.getKeplerNodeModulesData.mockReturnValue(mockCompatibilityInfo);
            // When
            const result = (0, manifest_builder_1.buildManifestForPackage)([mockProjectDir], mockOverrides, getMockAllowList());
            // Then
            expect(result.needs).toEqual([
                'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
            ]);
            expect(result.wants).toEqual([]);
        });
    });
    describe('verifyAndReturnResult with allowList', () => {
        it('should NOT filter out libraries if an allowList is not provided', () => {
            const selectedLibraries = [
                {
                    key: '@amazon-devices/react-native-gesture-handler',
                    npmLibraryName: '@amazon-devices/react-native-gesture-handler',
                    npmMajorVersion: '2',
                    needsModule: '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                    versionMap: {
                        '2.0.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                        '2.1.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                        '2.2.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                    },
                    privilegeMap: {},
                    wantsModule: undefined,
                    wantsRange: undefined,
                    libraryDependencies: [],
                },
                {
                    key: '@amazon-devices/not-allowed-library',
                    npmLibraryName: '@amazon-devices/not-allowed-library',
                    npmMajorVersion: '1',
                    needsModule: '/com.amazon.kepler.not_allowed_1@INotAllowed_1',
                    versionMap: {
                        '1.0.0': '/com.amazon.kepler.not_allowed_1@INotAllowed_0',
                        '1.1.0': '/com.amazon.kepler.not_allowed_1@INotAllowed_1',
                    },
                    privilegeMap: {},
                    wantsModule: undefined,
                    wantsRange: undefined,
                    libraryDependencies: [],
                },
                {
                    key: '@amazon-devices/disabled-library',
                    npmLibraryName: '@amazon-devices/disabled-library',
                    npmMajorVersion: '1',
                    needsModule: '/com.amazon.kepler.disabled_3@IDisabled_1',
                    versionMap: {
                        '1.0.0': '/com.amazon.kepler.disabled_3@IDisabled_0',
                        '1.1.0': '/com.amazon.kepler.disabled_3@IDisabled_1',
                    },
                    privilegeMap: {},
                    wantsModule: undefined,
                    wantsRange: undefined,
                    libraryDependencies: [],
                },
            ];
            const allowList = {};
            const result = (0, manifest_builder_1.verifyAndReturnResult)(selectedLibraries, '', allowList);
            expect(result.needs).toEqual([
                '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                '/com.amazon.kepler.not_allowed_1@INotAllowed_1',
                '/com.amazon.kepler.disabled_3@IDisabled_1',
            ]);
            expect(result.wants).toEqual([]);
            expect(mockLogger.log).toHaveBeenNthCalledWith(1, 'AllowList was not supplied. Allow experimental system JS bundle for Library @amazon-devices/react-native-gesture-handler.');
            expect(mockLogger.log).toHaveBeenNthCalledWith(2, 'AllowList was not supplied. Allow experimental system JS bundle for Library @amazon-devices/not-allowed-library.');
            expect(mockLogger.log).toHaveBeenNthCalledWith(3, 'AllowList was not supplied. Allow experimental system JS bundle for Library @amazon-devices/disabled-library.');
        });
        it('should filter out libraries not in the allowList', () => {
            const selectedLibraries = [
                {
                    key: '@amazon-devices/react-native-gesture-handler',
                    npmLibraryName: '@amazon-devices/react-native-gesture-handler',
                    npmMajorVersion: '2',
                    needsModule: '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                    versionMap: {
                        '2.0.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                        '2.1.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                        '2.2.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                    },
                    privilegeMap: {},
                    wantsModule: undefined,
                    wantsRange: undefined,
                    libraryDependencies: [],
                },
                {
                    key: '@amazon-devices/not-allowed-library',
                    npmLibraryName: '@amazon-devices/not-allowed-library',
                    npmMajorVersion: '1',
                    needsModule: '/com.amazon.kepler.not_allowed_1@INotAllowed_1',
                    versionMap: {
                        '1.0.0': '/com.amazon.kepler.not_allowed_1@INotAllowed_0',
                        '1.1.0': '/com.amazon.kepler.not_allowed_1@INotAllowed_1',
                    },
                    privilegeMap: {},
                    wantsModule: undefined,
                    wantsRange: undefined,
                    libraryDependencies: [],
                },
                {
                    key: '@amazon-devices/disabled-library',
                    npmLibraryName: '@amazon-devices/disabled-library',
                    npmMajorVersion: '1',
                    needsModule: '/com.amazon.kepler.disabled_3@IDisabled_1',
                    versionMap: {
                        '1.0.0': '/com.amazon.kepler.disabled_3@IDisabled_0',
                        '1.1.0': '/com.amazon.kepler.disabled_3@IDisabled_1',
                    },
                    privilegeMap: {},
                    wantsModule: undefined,
                    wantsRange: undefined,
                    libraryDependencies: [],
                },
            ];
            const allowList = {
                '@amazon-devices/react-native-gesture-handler': {
                    '2': true,
                    '4': true,
                },
                '@amazon-devices/not-allowed-library': {
                    '3': true,
                    '4': true,
                },
                '@amazon-devices/disabled-library': {
                    '1': false,
                },
            };
            const result = (0, manifest_builder_1.verifyAndReturnResult)(selectedLibraries, '', allowList);
            expect(result.needs).toEqual([
                '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
            ]);
            expect(result.wants).toEqual([]);
            expect(mockLogger.warn).toHaveBeenNthCalledWith(1, 'Ignoring experimental system JS bundle for Library @amazon-devices/not-allowed-library. Version 1 not present.');
            expect(mockLogger.warn).toHaveBeenNthCalledWith(2, 'Ignoring experimental system JS bundle for Library @amazon-devices/disabled-library. Version 1 not enabled.');
        });
        it('should NOT filter out libraries with @amazon-devices if @amzn library exists in allow-list', () => {
            const selectedLibraries = [
                {
                    key: '@amazon-devices/react-native-gesture-handler',
                    npmLibraryName: '@amazon-devices/react-native-gesture-handler',
                    npmMajorVersion: '2',
                    needsModule: '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                    versionMap: {
                        '2.0.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                        '2.1.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                        '2.2.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                    },
                    privilegeMap: {},
                    wantsModule: undefined,
                    wantsRange: undefined,
                    libraryDependencies: [],
                },
            ];
            const allowList = {
                '@amazon-devices/react-native-gesture-handler': {
                    '2': true,
                    '4': true,
                },
            };
            const result = (0, manifest_builder_1.verifyAndReturnResult)(selectedLibraries, '', allowList);
            expect(result.needs).toEqual([
                '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
            ]);
            expect(result.wants).toEqual([]);
        });
        it('should filter out @amazon-devices libraries if no matching @amzn library exists in allow-list', () => {
            const selectedLibraries = [
                {
                    key: '@amazon-devices/not-allowed-library',
                    npmLibraryName: '@amazon-devices/not-allowed-library',
                    npmMajorVersion: '1',
                    needsModule: '/com.amazon.kepler.not_allowed_1@INotAllowed_1',
                    versionMap: {
                        '1.0.0': '/com.amazon.kepler.not_allowed_1@INotAllowed_0',
                        '1.1.0': '/com.amazon.kepler.not_allowed_1@INotAllowed_1',
                    },
                    privilegeMap: {},
                    wantsModule: undefined,
                    wantsRange: undefined,
                    libraryDependencies: [],
                },
            ];
            const allowList = {
                '@amazon-devices/react-native-gesture-handler': {
                    '2': true,
                    '4': true,
                },
            };
            const result = (0, manifest_builder_1.verifyAndReturnResult)(selectedLibraries, '', allowList);
            expect(result.needs).toEqual([]);
            expect(result.wants).toEqual([]);
            expect(mockLogger.warn).toHaveBeenNthCalledWith(1, 'Ignoring experimental system JS bundle for Library @amazon-devices/not-allowed-library.');
        });
        it('should filter out @amazon-devices libraries if matching @amzn package exists with different version', () => {
            const selectedLibraries = [
                {
                    key: '@amazon-devices/react-native-gesture-handler',
                    npmLibraryName: '@amazon-devices/react-native-gesture-handler',
                    npmMajorVersion: '1',
                    needsModule: '/com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                    versionMap: {
                        '1.0.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                        '1.1.0': '/com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                    },
                    privilegeMap: {},
                    wantsModule: undefined,
                    wantsRange: undefined,
                    libraryDependencies: [],
                },
            ];
            const allowList = {
                '@amazon-devices/react-native-gesture-handler': {
                    '2': true,
                    '4': true,
                },
            };
            const result = (0, manifest_builder_1.verifyAndReturnResult)(selectedLibraries, '', allowList);
            expect(result.needs).toEqual([]);
            expect(result.wants).toEqual([]);
            expect(mockLogger.warn).toHaveBeenNthCalledWith(1, 'Ignoring experimental system JS bundle for Library @amazon-devices/react-native-gesture-handler. Version 1 not present.');
        });
    });
    describe('injectManifest', () => {
        beforeEach(() => {
            jest.clearAllMocks();
            jest.spyOn(fs, 'existsSync').mockImplementation();
            jest.spyOn(fs, 'readFileSync').mockImplementation();
            jest.spyOn(fs, 'writeFileSync').mockImplementation();
        });
        afterEach(() => {
            jest.restoreAllMocks();
        });
        it('should add missing needs and wants modules matching our Schema/Names', () => {
            // Given
            const manifestPath = '/path/to/manifest.toml';
            const existingManifest = `
    [package]
    id = "com.test.app"

    [needs]

    [[needs.privilege]]
    id = "com.test.privilege"
    [[needs.privilege]]
    id = "com.amazon.media.secureplayback"
    [[needs.privilege]]
    id = "com.amazon.devconf.privilege.configuration.day-night-mode.write"
    [[needs.privilege]]
    id = "com.amazon.devconf.privilege.accessibility"
    [[needs.privilege]]
    id = "com.amazon.input.device.id.access"
            `;
            const manifestContents = {
                needs: [
                    '/com.amazon.kepler.experimental.features_2025_02@IFeature',
                    '/com.amazon.kepler.security@ISecurityModule',
                    '/com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                    '/com.amazon.kepler.keplerscript_2@IKeplerScript_0',
                    '/com.amazon.kepler.safe_area_context_2@ISafeAreaContext_0',
                    '/com.amazon.kepler.screens_2@IScreens_0',
                    '/com.amazon.kepler.navigation__core_2@INavigation__Core_0',
                    '/com.amazon.kepler.navigation__drawer_2@INavigation__Drawer_0',
                    '/com.amazon.kepler.navigation__elements_2@INavigation__Elements_0',
                    '/com.amazon.kepler.navigation__native_2@INavigation__Native_0',
                    '/com.amazon.kepler.navigation__native_stack_2@INavigation__NativeStack_0',
                    '/com.amazon.kepler.navigation__routers_2@INavigation__Routers_0',
                    '/com.amazon.kepler.navigation__stack_2@INavigation__Stack_0',
                ],
                wants: [
                    '/com.amazon.kepler.gesture_handler_2@IGestureHandler_4',
                    '/com.amazon.kepler.keplerscript_2@IKeplerScript_4',
                    '/com.amazon.kepler.safe_area_context_2@ISafeAreaContext_4',
                    '/com.amazon.kepler.screens_2@IScreens_4',
                    '/com.amazon.kepler.navigation__core_2@INavigation__Core_4',
                    '/com.amazon.kepler.navigation__drawer_2@INavigation__Drawer_4',
                    '/com.amazon.kepler.navigation__elements_2@INavigation__Elements_4',
                    '/com.amazon.kepler.navigation__native_2@INavigation__Native_4',
                    '/com.amazon.kepler.navigation__native_stack_2@INavigation__NativeStack_4',
                    '/com.amazon.kepler.navigation__routers_2@INavigation__Routers_4',
                    '/com.amazon.kepler.navigation__stack_2@INavigation__Stack_4',
                ],
                privileges: [
                    'com.amazon.media.secureplayback',
                    'com.amazon.devconf.privilege.configuration.day-night-mode.write',
                    'com.amazon.devconf.privilege.accessibility',
                    'com.amazon.input.device.id.access',
                ],
                keplerModuleMap: {},
            };
            fs.existsSync.mockReturnValue(true);
            fs.readFileSync.mockReturnValue(existingManifest);
            // When
            (0, manifest_builder_1.injectManifest)(manifestPath, manifestContents);
            // Then
            expect(fs.writeFileSync).toHaveBeenCalledTimes(1);
            const writtenContent = fs.writeFileSync.mock
                .calls[0][1];
            // All needs.module from above must be there
            manifestContents.needs.forEach((moduleId) => {
                const expectedPattern = `[[needs.module]]\nid = "${moduleId}"`;
                expect(writtenContent).toContain(expectedPattern);
            });
            // All wants.module from above must be there
            manifestContents.wants.forEach((moduleId) => {
                const expectedPattern = `[[wants.module]]\nid = "${moduleId}"`;
                expect(writtenContent).toContain(expectedPattern);
            });
            // Previously defined privileges are preserved in the file
            const expectedPrivileges = [
                'com.test.privilege',
                'com.amazon.media.secureplayback',
                'com.amazon.devconf.privilege.configuration.day-night-mode.write',
                'com.amazon.devconf.privilege.accessibility',
                'com.amazon.input.device.id.access',
            ];
            expectedPrivileges.forEach((privilege) => {
                const expectedPattern = `[[needs.privilege]]\n    id = "${privilege}"`;
                expect(writtenContent).toContain(expectedPattern);
            });
            // Sanity: Manifest still conatins a [needs] section and [wants] section
            expect(writtenContent).toMatch(/\[needs\]/);
            expect(writtenContent).toMatch(/\[wants\]/);
            // Make sure we have the expected number of needs/wants module entries
            const needsModuleMatches = writtenContent.match(/\[\[needs\.module\]\]/g);
            expect(needsModuleMatches).toHaveLength(manifestContents.needs.length);
            const wantsModuleMatches = writtenContent.match(/\[\[wants\.module\]\]/g);
            expect(wantsModuleMatches).toHaveLength(manifestContents.wants.length);
        });
        it('should add missing needs modules to an existing manifest file', () => {
            // Given
            const manifestPath = '/path/to/manifest.toml';
            const existingManifest = `
    [package]
    id = "com.test.app"

    [needs]

    [[needs.privilege]]
    id = "com.test.privilege"
            `;
            const manifestContents = {
                needs: [
                    '/com.test.module_0@ITest_1',
                    '/com.test.other_module_0@ITest_2',
                ],
                wants: [],
                privileges: [],
                keplerModuleMap: {},
            };
            fs.existsSync.mockReturnValue(true);
            fs.readFileSync.mockReturnValue(existingManifest);
            // When
            (0, manifest_builder_1.injectManifest)(manifestPath, manifestContents);
            // Then
            expect(fs.writeFileSync).toHaveBeenCalledWith(manifestPath, expect.stringContaining('[[needs.module]]\nid = "/com.test.module_0@ITest_1"'), 'utf-8');
            expect(fs.writeFileSync).toHaveBeenCalledWith(manifestPath, expect.stringContaining('[[needs.module]]\nid = "/com.test.other_module_0@ITest_2"'), 'utf-8');
        });
        it('should add missing wants modules to an existing manifest file', () => {
            // Given
            const manifestPath = '/path/to/manifest.toml';
            const existingManifest = `
    [package]
    id = "com.test.app"

    [wants]

    [[wants.service]]
    id = "com.test.service"
            `;
            const manifestContents = {
                needs: [],
                wants: [
                    '/com.test.module_0@ITest_1',
                    '/com.test.other_module_0@ITest_2',
                ],
                privileges: [],
                keplerModuleMap: {},
            };
            fs.existsSync.mockReturnValue(true);
            fs.readFileSync.mockReturnValue(existingManifest);
            // When
            (0, manifest_builder_1.injectManifest)(manifestPath, manifestContents);
            // Then
            expect(fs.writeFileSync).toHaveBeenCalledWith(manifestPath, expect.stringContaining('[[wants.module]]\nid = "/com.test.module_0@ITest_1"'), 'utf-8');
            expect(fs.writeFileSync).toHaveBeenCalledWith(manifestPath, expect.stringContaining('[[wants.module]]\nid = "/com.test.other_module_0@ITest_2"'), 'utf-8');
        });
        it('should not add modules that are already defined', () => {
            // Given
            const manifestPath = '/path/to/manifest.toml';
            const existingManifest = `
    [package]
    id = "com.test.app"

    [needs]

    [[needs.module]]
    id = "/com.test.module_0@ITest_1"

    [wants]

    [[wants.module]]
    id = "/com.test.other_module_0@ITest_2"
            `;
            const manifestContents = {
                needs: ['/com.test.module_0@ITest_1'],
                wants: ['/com.test.other_module_0@ITest_2'],
                privileges: [],
                keplerModuleMap: {},
            };
            fs.existsSync.mockReturnValue(true);
            fs.readFileSync.mockReturnValue(existingManifest);
            // When
            (0, manifest_builder_1.injectManifest)(manifestPath, manifestContents);
            // Then
            expect(fs.writeFileSync).not.toHaveBeenCalled();
        });
        it('should create sections if they do not exist', () => {
            // Given
            const manifestPath = '/path/to/manifest.toml';
            const existingManifest = `
    [package]
    id = "com.test.app"
            `;
            const manifestContents = {
                needs: ['/com.test.module_0@ITest_1'],
                wants: ['/com.test.other_module_0@ITest_2'],
                privileges: [],
                keplerModuleMap: {},
            };
            fs.existsSync.mockReturnValue(true);
            fs.readFileSync.mockReturnValue(existingManifest);
            // When
            (0, manifest_builder_1.injectManifest)(manifestPath, manifestContents);
            // Then
            expect(fs.writeFileSync).toHaveBeenCalledWith(manifestPath, expect.stringContaining('[needs]'), 'utf-8');
            expect(fs.writeFileSync).toHaveBeenCalledWith(manifestPath, expect.stringContaining('[wants]'), 'utf-8');
        });
        it('should throw error if manifest file does not exist', () => {
            // Given
            const manifestPath = '/path/to/nonexistent/manifest.toml';
            const manifestContents = {
                needs: ['/com.test.module_0@ITest_1'],
                wants: [],
                privileges: [],
                keplerModuleMap: {},
            };
            fs.existsSync.mockReturnValue(false);
            // When/Then
            expect(() => (0, manifest_builder_1.injectManifest)(manifestPath, manifestContents)).toThrow(`File not found: ${manifestPath}`);
        });
    });
    describe('validatePackage', () => {
        const mockProjectDir = '/test/project';
        afterEach(() => {
            // Restore console.warn
            consoleWarnSpy.mockRestore();
        });
        it('should process a library with a version that is in the versionMap', () => {
            // Given
            const mockModules = ['react-native-gesture-handler'];
            const mockFiles = ['package.json'];
            const version = '2.2.0';
            const mockCompatibilityInfo = {
                needsModule: 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                versionMap: {
                    '2.0.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                    '2.1.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                    '2.2.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                },
                privilegeMap: {},
            };
            fs.existsSync.mockReturnValue(true);
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValueOnce(mockModules)
                .mockReturnValueOnce(mockFiles);
            // When
            fs.readFileSync.mockReturnValueOnce(JSON.stringify({
                version: version, // Version in versionMap
            }));
            compatibilityUtils.getKeplerNodeModulesData.mockReturnValue(mockCompatibilityInfo);
            const result = (0, manifest_builder_1.scanNodeModulesRecursively)(mockProjectDir);
            // Then
            expect(Object.keys(result)).toHaveLength(1);
            expect(result['@amazon-devices/react-native-gesture-handler']).toBeDefined();
        });
        it('should process a library with a version and build metadata that is in the versionMap', () => {
            // Given
            const mockModules = ['react-native-gesture-handler'];
            const mockFiles = ['package.json'];
            const version = '2.2.0+1alpha5';
            const mockCompatibilityInfo = {
                needsModule: 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                versionMap: {
                    '2.0.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                    '2.1.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                    '2.2.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                },
                privilegeMap: {},
            };
            fs.existsSync.mockReturnValue(true);
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValueOnce(mockModules)
                .mockReturnValueOnce(mockFiles);
            // When
            fs.readFileSync.mockReturnValueOnce(JSON.stringify({
                version: version, // Version in versionMap
            }));
            compatibilityUtils.getKeplerNodeModulesData.mockReturnValue(mockCompatibilityInfo);
            const result = (0, manifest_builder_1.scanNodeModulesRecursively)(mockProjectDir);
            // Then
            expect(Object.keys(result)).toHaveLength(1);
            expect(result['@amazon-devices/react-native-gesture-handler']).toBeDefined();
        });
        it('should warn when a single library contains a version that is not in the versionMap', () => {
            // Given
            const version = '2.2.1';
            const mockModules = ['react-native-gesture-handler'];
            const mockFiles = ['package.json'];
            const mockCompatibilityInfo = {
                needsModule: 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                versionMap: {
                    '2.0.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                    '2.1.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                    '2.2.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                },
                privilegeMap: {},
            };
            fs.existsSync.mockReturnValue(true);
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValueOnce(mockModules)
                .mockReturnValueOnce(mockFiles);
            // When
            fs.readFileSync.mockReturnValueOnce(JSON.stringify({
                version: version,
            }));
            compatibilityUtils.getKeplerNodeModulesData.mockReturnValue(mockCompatibilityInfo);
            // Then
            (0, manifest_builder_1.scanNodeModulesRecursively)(mockProjectDir);
            // Verify console.warn was called twice (preamble + warning message)
            expect(consoleWarnSpy).toHaveBeenCalledTimes(2);
            // Verify the (First line of) ASCII art preamble was displayed properly
            expect(consoleWarnSpy).toHaveBeenNthCalledWith(1, expect.stringContaining('                     '));
            // Verify the warning message contains the expected error
            const warningMessage = consoleWarnSpy.mock.calls[1][0];
            expect(warningMessage).toContain('WARNING');
            expect(warningMessage).toContain('Validation errors found while scanning node_modules');
            expect(warningMessage).toContain('Library @amazon-devices/react-native-gesture-handler is not properly configured. The version is set to ' +
                version +
                " but that value is not part of it's 'kepler-compatibility.json' file. " +
                'This library must be updated to correct the error!');
        });
        it('should collect and report all validation errors across libraries', () => {
            // Given
            const mockModules = [
                'react-native-gesture-handler',
                'react-native-reanimated',
            ];
            const mockFiles = ['package.json'];
            const mockRNGHCompatibilityInfo = {
                needsModule: 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                versionMap: {
                    '2.0.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_0',
                    '2.1.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_1',
                    '2.2.0': 'com.amazon.kepler.gesture_handler_2@IGestureHandler_2',
                },
                privilegeMap: {},
            };
            const mockReanimatedCompatibilityInfo = {
                needsModule: 'com.amazon.kepler.reanimated_2@IReanimated_2',
                versionMap: {
                    '2.0.0': 'com.amazon.kepler.reanimated_2@IReanimated_0',
                    '2.1.0': 'com.amazon.kepler.reanimated_2@IReanimated_1',
                    '2.2.0': 'com.amazon.kepler.reanimated_2@IReanimated_2',
                },
                privilegeMap: {},
            };
            fs.existsSync.mockReturnValue(true);
            fs.readdirSync
                .mockReturnValueOnce(mockAmznScope)
                .mockReturnValueOnce(mockModules)
                .mockReturnValueOnce(mockFiles) // for first library
                .mockReturnValueOnce(mockFiles); // for second library
            // Both libraries have versions not in their versionMaps
            fs.readFileSync
                .mockReturnValueOnce(JSON.stringify({ version: '3.0.0' })) // RNGH
                .mockReturnValueOnce(JSON.stringify({ version: '2.5.0' })); // Reanimated
            compatibilityUtils.getKeplerNodeModulesData
                .mockReturnValueOnce(mockRNGHCompatibilityInfo)
                .mockReturnValueOnce(mockReanimatedCompatibilityInfo);
            // When
            (0, manifest_builder_1.scanNodeModulesRecursively)(mockProjectDir);
            // Then
            expect(consoleWarnSpy).toHaveBeenCalledTimes(2);
            // Verify the (First line of) ASCII art preamble was displayed properly
            expect(consoleWarnSpy).toHaveBeenNthCalledWith(1, expect.stringContaining('                     '));
            // Verify the warning message contains both errors
            const warningMessage = consoleWarnSpy.mock.calls[1][0];
            expect(warningMessage).toContain('WARNING');
            expect(warningMessage).toContain('Validation errors found while scanning node_modules');
            expect(warningMessage).toContain('@amazon-devices/react-native-gesture-handler is not properly configured');
            expect(warningMessage).toContain('@amazon-devices/react-native-reanimated is not properly configured');
        });
    });
});

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const compatibilityUtils = __importStar(require("../../src/utils/compatibility-utils"));
const fileUtils = __importStar(require("../../src/utils/file-utils"));
const logger_1 = require("../../src/utils/logger");
const npm_utils_1 = require("../../src/utils/npm-utils");
// Mock all external dependencies
jest.mock('child_process', () => ({
    execSync: jest.fn(),
}));
jest.mock('fs', () => ({
    mkdtempSync: jest.fn(),
    rmSync: jest.fn(),
    existsSync: jest.fn(),
    readFileSync: jest.fn(),
}));
jest.mock('path', () => ({
    join: jest.fn((...args) => args.join('/')),
}));
jest.mock('../../src/utils/file-utils', () => ({
    extractTarball: jest.fn(),
}));
jest.mock('../../src/utils/compatibility-utils', () => ({
    parseCompatibilityInfo: jest.fn(),
}));
describe('npm-utils', () => {
    const mockLogger = {
        error: jest.spyOn(logger_1.logger, 'error').mockImplementation(),
        warn: jest.spyOn(logger_1.logger, 'warn').mockImplementation(),
        info: jest.spyOn(logger_1.logger, 'info').mockImplementation(),
    };
    beforeEach(() => {
        jest.clearAllMocks();
    });
    describe('getVersionsForLibrary', () => {
        const mockLibraryName = '@amazon-devices/react-native-gesture-handler';
        it('should return parsed versions from npm view command', () => {
            // Given
            const mockVersions = ['1.0.0', '1.1.0', '2.0.0'];
            child_process_1.execSync.mockReturnValue(JSON.stringify(mockVersions));
            // When
            const result = (0, npm_utils_1.getVersionsForLibrary)(mockLibraryName);
            // Then
            expect(result).toEqual(mockVersions);
            expect(child_process_1.execSync).toHaveBeenCalledWith('npm view @amazon-devices/react-native-gesture-handler versions --json', { encoding: 'utf8' });
        });
        it('should support custom package managers', () => {
            // Given
            const mockVersions = ['1.0.0'];
            child_process_1.execSync.mockReturnValue(JSON.stringify(mockVersions));
            // When
            const result = (0, npm_utils_1.getVersionsForLibrary)(mockLibraryName, 'yarn');
            // Then
            expect(child_process_1.execSync).toHaveBeenCalledWith('yarn view @amazon-devices/react-native-gesture-handler versions --json', { encoding: 'utf8' });
        });
        it('should throw error when npm command fails', () => {
            // Given
            child_process_1.execSync.mockImplementation(() => {
                throw new Error('npm command failed');
            });
            // Then
            expect(() => (0, npm_utils_1.getVersionsForLibrary)(mockLibraryName)).toThrow('Failed to retrieve versions for @amazon-devices/react-native-gesture-handler');
        });
        it('should throw error on invalid JSON response', () => {
            // Given
            child_process_1.execSync.mockReturnValue('invalid json');
            // Then
            expect(() => (0, npm_utils_1.getVersionsForLibrary)(mockLibraryName)).toThrow('Failed to retrieve versions for @amazon-devices/react-native-gesture-handler');
        });
    });
    describe('getVersionsIncludedFor', () => {
        const mockConfig = {
            libraryName: '@amazon-devices/react-native-gesture-handler',
            version: '1.0.0',
            npmManager: 'npm',
        };
        const mockTempDir = '/tmp/mock-temp-dir';
        const mockCompatibilityContent = JSON.stringify({
            '1.0.0': 'com.amazon.kepler.gesture_handler@IGesture_Handler_0',
            '1.1.0': 'com.amazon.kepler.gesture_handler@IGesture_Handler_1',
        });
        beforeEach(() => {
            fs.mkdtempSync.mockReturnValue(mockTempDir);
            // Mock reading the compatibility file
            fs.readFileSync.mockReturnValue(mockCompatibilityContent);
        });
        it('should successfully process library and return module info', () => {
            // Given
            const expectedResult = {
                includesModules: [
                    'com.amazon.kepler.gesture_handler@IGesture_Handler_0',
                    'com.amazon.kepler.gesture_handler@IGesture_Handler_1',
                ],
                versionMap: {
                    '1.0.0': 'com.amazon.kepler.gesture_handler@IGesture_Handler_0',
                    '1.1.0': 'com.amazon.kepler.gesture_handler@IGesture_Handler_1',
                },
            };
            compatibilityUtils.parseCompatibilityInfo.mockReturnValue(expectedResult);
            // When
            const result = (0, npm_utils_1.getVersionsIncludedFor)(mockConfig.libraryName, mockConfig.version, mockConfig.npmManager);
            // Then
            expect(result).toEqual(expectedResult);
            expect(fileUtils.extractTarball).toHaveBeenCalledWith(mockConfig.npmManager, mockConfig.libraryName, mockConfig.version, mockTempDir);
            expect(fs.rmSync).toHaveBeenCalledWith(mockTempDir, {
                recursive: true,
                force: true,
            });
        });
        it('should throw error when compatibility info parsing fails', () => {
            // Given
            compatibilityUtils.parseCompatibilityInfo.mockReturnValue(null);
            // Then
            expect(() => (0, npm_utils_1.getVersionsIncludedFor)(mockConfig.libraryName, mockConfig.version, mockConfig.npmManager)).toThrow(`Failed to process ${mockConfig.libraryName}@${mockConfig.version}`);
        });
        it('should clean up temp directory even when processing fails', () => {
            // Given
            fileUtils.extractTarball.mockImplementation(() => {
                throw new Error('Extract failed');
            });
            // Then
            expect(() => (0, npm_utils_1.getVersionsIncludedFor)(mockConfig.libraryName, mockConfig.version, mockConfig.npmManager)).toThrow(`Failed to process ${mockConfig.libraryName}@${mockConfig.version}`);
            expect(fs.rmSync).toHaveBeenCalledWith(mockTempDir, {
                recursive: true,
                force: true,
            });
        });
        it('should throw error when compatibility file cannot be read', () => {
            // Given
            fs.readFileSync.mockImplementation(() => {
                throw new Error('File read error');
            });
            // Then
            expect(() => (0, npm_utils_1.getVersionsIncludedFor)(mockConfig.libraryName, mockConfig.version, mockConfig.npmManager)).toThrow(`Failed to process ${mockConfig.libraryName}@${mockConfig.version}`);
        });
    });
});

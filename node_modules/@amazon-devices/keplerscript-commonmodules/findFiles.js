#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const SYSTEM_BUNDLE_EXCLUSION_LIST = 'system-bundle-exclusion-list';

// Error codes enum with numeric values
const Errors = {
  LIBRARY_NAME_MISSING: 101,
  PACKAGE_JSON_NOT_FOUND: 102,
  LIBRARY_NOT_FOUND: 103,
  EXCLUSION_LIST_PATH_ERROR: 104,
  GENERAL_ERROR: 105
};

/**
 * Converts numeric error code to human-readable message
 * 
 * @param {number} code - Error code from Errors enum
 * @returns {string} Human-readable error message
 */
function getErrorMessage(code) {
  switch (code) {
    case Errors.LIBRARY_NAME_MISSING:
      return 'find-files command is expected to be called with libraryName parameter passed as an argument';
    case Errors.PACKAGE_JSON_NOT_FOUND:
      return 'package.json not found at specified path';
    case Errors.LIBRARY_NOT_FOUND:
      return 'Library not found in node_modules';
    case Errors.EXCLUSION_LIST_PATH_ERROR:
      return 'The system has detected that files specified in your package.json system-bundle-exclusion-list cannot be located. The files are missing from the expected node_modules directory location. This error typically occurs when file paths are not properly specified relative to the node_modules directory of your library package. Please review the file paths and ensure they are correct. To resolve this issue, you will need to verify and correct the file paths in your package.json configuration. Each path should be a valid relative path that points to an existing file within your node_modules directory structure.';
    case Errors.GENERAL_ERROR:
      return 'Error finding files from node_modules';
    default:
      return 'Unknown error occurred';
  }
}

/**
 * Checks if libraryName argument is passed with find_files command call
 * If argument is provided then call findAllFilesFromNodeModules command with libraryName
 *
 * @throws {Error} If libraryName argument not passed with find_files command call
 */
function findFiles() {
    // process.argv[2] is expected to be a parameter passed with the find-files command containing the package libraryName
    const libraryName = process.argv[2];
    if (libraryName) {
      findAllFilesFromNodeModules(libraryName);
    } else {
      console.error(`Error ${Errors.LIBRARY_NAME_MISSING}: ${getErrorMessage(Errors.LIBRARY_NAME_MISSING)}`);
      process.exit(Errors.LIBRARY_NAME_MISSING);
    }
}

/**
 * Extracts the contents of the `system-bundle-exclusion-list` from the `kepler` block 
 * of the given library's package.json file.
 *
 * @param {string} packageJsonPath - Full path to the library's package.json file.
 * @returns {Map<string, boolean>} A Map where keys are file paths to be excluded in index.bundle.js and values are `true`.
 *
 * @throws {Error} If the `packageJsonPath` does not exist
 */
function getSystemBundleExclusionMap(packageJsonPath) {
  if (!fs.existsSync(packageJsonPath)) {
    console.error(`Error ${Errors.PACKAGE_JSON_NOT_FOUND}: ${getErrorMessage(Errors.PACKAGE_JSON_NOT_FOUND)} - ${packageJsonPath}`);
    process.exit(Errors.PACKAGE_JSON_NOT_FOUND);
  }
  const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
  const exclusionList = packageJson?.kepler?.[SYSTEM_BUNDLE_EXCLUSION_LIST] || [];
  const exclusionMap = new Map();
  exclusionList.forEach((filePath) => {
    exclusionMap.set(filePath, true);
  });
  return exclusionMap;
}

/**
 * Generates an index.bundle.js file in the build directory which contains paths to library files
 *
 * This function performs the following steps:
 * 1. Scans node_modules directory for all relevant source files and paths within the library package
 * 2. Extracts all file paths listed in package.json kepler block system-bundle-exclusion-list of the library package 
 * 3. Creates index.bundle.js with imports for all files excludinding files listed in system-bundle-exclusion-list within a specific library in node_modules
 *
 * @param libraryName - the name of the system bundled library package within which the find-files command has been called
 * @throws {Error} If the above steps are unable to be carried out. Also throws error if there is a change between generated index.bundle.js file and source checked in index.bundle.js file.
 */
function findAllFilesFromNodeModules(libraryName) {
  try {
    // Path to the project root, package.json and node_modules
    const projectRootPath = process.cwd();
    const nodeModulesPath = path.join(projectRootPath, 'node_modules');

    // Path to the libraryName folder within the node_modules directory
    const targetLibraryPath = path.join(nodeModulesPath, libraryName);
    // Path to thelibrary's package.json file
    const packageJsonPath = path.join(targetLibraryPath, 'package.json');

    // Make sure the target library path exists
    if (!fs.existsSync(targetLibraryPath)) {
      console.error(`Error ${Errors.LIBRARY_NOT_FOUND}: ${getErrorMessage(Errors.LIBRARY_NOT_FOUND)} - ${libraryName}`);
      process.exit(Errors.LIBRARY_NOT_FOUND);
    }
    // Make sure the packageJson path exists
    if (!fs.existsSync(packageJsonPath)) {
      console.error(`Error ${Errors.PACKAGE_JSON_NOT_FOUND}: ${getErrorMessage(Errors.PACKAGE_JSON_NOT_FOUND)} - ${packageJsonPath}`);
      process.exit(Errors.PACKAGE_JSON_NOT_FOUND);
    }

    // Path to index.bundle.js (entry file)
    const indexFilePath = path.join(projectRootPath, 'index.bundle.js');
    // Always create a new index.bundle.js file
    fs.writeFileSync(indexFilePath, '', 'utf8');
    // Get the list of files to be excluded during index.bundle.js creation
    const exclusionMap = getSystemBundleExclusionMap(packageJsonPath);
    let id = 0; 
    // Recursively walk through the node_modules directory and generate index.bundle.js
    function walkDir(dir) {
      const files = fs.readdirSync(dir);
      files.forEach(file => {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);

        if (stat.isDirectory()) {
          // Skip unwanted directories like scripts, __tests__, and node_modules
          if (file === 'scripts' || file === 'node_modules' || file === '__tests__' || file === 'jest') {
            return;
          }
          walkDir(filePath); // Recursively scan the directory
        } else if (
          /\.(js|jsx|ts|tsx|cts|mts)$/.test(file) && // Collect JavaScript and TypeScript files
          !file.endsWith('.d.ts') &&  // Ignore TypeScript definition files
          !file.endsWith('.ios.js') &&
          !file.endsWith('.android.js') &&
          !file.endsWith('.web.ts') &&
          !file.endsWith('.web.js')
        ) {
          // Check if the file needs to be excluded from index.bundle.js
          // If the file does not need to be excluded then add it as an import to index.bundle.js
          const relativeNodeModulesPath = path.relative(path.join(projectRootPath, 'node_modules'), filePath);
          if (!exclusionMap.has(relativeNodeModulesPath)) {
            const newLine = `import * as lib${id} from '${relativeNodeModulesPath}';`
            id++;
            fs.appendFileSync(indexFilePath, newLine + '\n', 'utf8');
          } else {
            exclusionMap.delete(relativeNodeModulesPath);
          }
        }
      });
    }

    // Start the recursive directory walk from the target library path
    walkDir(targetLibraryPath);
    // If there are any files left in exclusionMap that means that the wrong file path was provided in system-bundle-exclusion-list
    if (exclusionMap.size > 0) {
      const remainingFiles = Array.from(exclusionMap.keys()).join('\n');
      console.error(
        `Error ${Errors.EXCLUSION_LIST_PATH_ERROR}: ${getErrorMessage(Errors.EXCLUSION_LIST_PATH_ERROR)}\nProblematic files:\n${remainingFiles}`
      );
      process.exit(Errors.EXCLUSION_LIST_PATH_ERROR);
    }
    console.log('Successfully completed running find-files command');
  } catch (error) {
    console.error(`Error ${Errors.GENERAL_ERROR}: ${getErrorMessage(Errors.GENERAL_ERROR)}:`, error);
    process.exit(Errors.GENERAL_ERROR);
  }
}

/**
 * Updates the index.bundle.js file by commenting out problematic import lines
 * 
 * This function:
 * 1. Reads the index.bundle.js file
 * 2. Searches for lines containing the specified module name (shortName)
 * 3. Comments out matching lines that aren't already commented
 * 4. Adds an error message comment to the end of commented lines
 * 5. Writes the updated contents back to the file
 *
 * @param {string} shortName - Module name/path to search for in import statements
 * @param {string} messageInComment - Error message to append to commented lines
 * @returns {boolean} True if the module was found and commented out, false otherwise
 */
function updateFile(shortName, messageInComment) {
  const rootPath = process.cwd();
  const entryFileSample = path.join(rootPath, 'index.bundle.js');
  let moduleNotPresentInFile = false;
  const fileContents = fs.readFileSync(entryFileSample, 'utf8');
  const lines = fileContents.split('\n');
  const updatedLines = lines.map(line => {
    if (line.includes(shortName)){
      moduleNotPresentInFile = line.includes(shortName);
      if(!line.startsWith('//')) {
        console.error('commenting out line', line);
        return `// ${line} ${messageInComment}`;
      }
    }
    return line;
  });
  fs.writeFileSync(entryFileSample, updatedLines.join('\n'));
  return moduleNotPresentInFile
}


/**
 * Handles different types of errors that occur during module processing
 * 
 * This function handles three main types of errors:
 * 1. UnableToResolveError/PackageResolutionError - When a module cannot be resolved
 * 2. TransformError - When there is an error transforming the module
 * 3. Other errors - Any other unhandled error types
 *
 * For each error type, it:
 * - Logs appropriate error messages
 * - Updates the index.bundle.js file to comment out problematic imports
 * - Adds error details in the comments
 *
 * @param {Error} error - The error object to handle
 * @param {string} shortName - Short name/path of the module that caused the error
 */
function handleError(error, shortName) {
  const {
    UnableToResolveError,
  } = require('metro/src/node-haste/DependencyGraph/ModuleResolution.js');
  const {
    PackageResolutionError,
  } = require("metro-core");

  if (error instanceof UnableToResolveError || error instanceof PackageResolutionError) {
    console.error('error is of type UnableToResolveError', shortName, error.targetModuleName);
    const moduleNotPresentInFile = updateFile(shortName, `// missing module: ${error.targetModuleName}`)
    if (!moduleNotPresentInFile) {
      console.error('file was not updated for', shortName, error.targetModuleName);
      console.error(error);
    }
  } else if (error.type === 'TransformError') {
    console.error('error is of type TransformError', shortName);
    const moduleNotPresentInFile = updateFile(shortName, `// TransformError`)
    if (!moduleNotPresentInFile) {
      console.error('file was not updated for', shortName, error.targetModuleName);
      console.error(error);
    }
  } else {
    console.error('Different error for ', shortName, error.targetModuleName);
    console.error(error);
  }
}


/**
 * Updates index.bundle.js by checking each imported module for build errors
 * 
 * This function:
 * 1. Sets up and initializes a Metro bundler server with Kepler platform config
 * 2. Reads the index.bundle.js file and processes each import line
 * 3. Attempts to build each imported module individually
 * 4. If build errors occur, comments out problematic imports with error details
 * 5. Handles UnableToResolveError, PackageResolutionError and TransformError cases
 *
 * @returns {Promise<void>} Resolves when all imports have been processed
 * @throws {Error} If Metro server setup or file operations fail
 */
async function updateIndexBundleWithExceptions() {
  
  const Server = require('metro/src/Server');
  
  const { getDefaultConfig, mergeConfig } = require('@react-native/metro-config');
  var _metroPlatformResolver = require("@react-native-community/cli-plugin-metro/build/tools/metroPlatformResolver");
  const outOfTreePlatforms = [ 'kepler' ]
  const config = mergeConfig(
      getDefaultConfig(__dirname),
      {
        projectRoot: process.cwd(),
        watchFolders: [process.cwd()],
        resolver: {
          platforms: [ 'ios', 'android', 'kepler', 'native' ],
          resolveRequest : (0, _metroPlatformResolver.reactNativePlatformResolver)(outOfTreePlatforms.reduce((result, platform) => {
            result[platform] = '@amazon-devices/react-native-kepler';
            return result;
          }, {}))
        }
      }
  );
  // Initialize server with options
  const server = new Server(config);

  // Wait for server to be ready
  await server.ready();
  const rootPath = process.cwd();
  const entryFileSample = path.join(rootPath, 'index.bundle.js');
  console.debug('Starting the process of ', entryFileSample, ' to find exceptions')

  const fileContents = fs.readFileSync(entryFileSample, 'utf8');
  const lines = fileContents.split('\n');

  const filePromises = lines.map(async line => {
    // Extract path from import statement
    const match = line.match(/from '([^']+)'/);
    if (match) {
      const importPath = match[1];
      const fullPath = path.join(rootPath, 'node_modules', importPath);

      const bundleOptions = {
        entryFile: fullPath, 
        dev: false,
        hot:false,
        minify: false,
        platform: 'kepler', // or 'android'
        sourceMapUrl: null,
        unstable_transformProfile: 'default'
      };

      const nodeModulesIndex = fullPath.indexOf('node_modules')
      const shortName = fullPath.slice(nodeModulesIndex + 'node_modules/'.length)
      try {
        const {code, map} = await server.build({
          ...Server.DEFAULT_BUNDLE_OPTIONS,
          ...bundleOptions,
          bundleType: "bundle",
        });
        return 'Success: ' + shortName
      } catch (error) {
        handleError(error, shortName);
      }
    }
    return null;
  });

  await Promise.all(filePromises.filter(p => p !== null));
  
  console.debug('Finished processing of ', entryFileSample)
  // Close server
  await server.end();
    
}

// Run the function
findFiles();
updateIndexBundleWithExceptions()

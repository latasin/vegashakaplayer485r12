const { env } = require('node:process');
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

// Stores a list of libraries with their major versions
// System bundle enabled apps will only use system library dependencies that are present in allow list
let ALLOW_LIST = require('./allow-list.json');
try {
  ALLOW_LIST = require('@amazon-devices/js-bundle-system-allow-list');
} catch (e) {
  console.debug('@amazon-devices/js-system-bundle-allow-list is not available. Using default list');
}

/**
 * Environment Variables:
 *
 *   env.SYS_BUNDLES_CONFIG_DIR
 *   Optional path to where to output <INTERATIVE_APP/SERVICE/TASK>_SYSTEM_BUNDLES_CONFIG_JSON
 *
 *   env.DISABLE_APP_BUNDLE_SPLITTING
 *   Optional - If set to 'true' application bundle splitting will not be applied
 */

// DO NOT CHECK IN CHANGES TO VERBOSE_DEBUGGING THAT IMPACT RELEASE
const VERBOSE_DEBUGGING = env.NODE_ENV === 'test' && 1; // Set it 0 to disable logs in tests
// Flag used to create modules for app. It is automatically set to true if VERBOSE_DEBUGGING is true.
const ENABLE_APP_BUNDLE_MODULE_CREATION = env.ENABLE_APP_BUNDLE_MODULE_CREATION === 'true' || VERBOSE_DEBUGGING;
const APP_BUNDLE_MODULE_FILE = 'system-bundle-app-modules.txt';

const NODE_MODULES = 'node_modules/';
const SYSTEM_MODULES_DIR = 'SystemModules';

// This is the name of the file in the SystemModules directory
// that provides metadata for a specific library's bundle
const SYSTEM_LIBRARY_JSON = 'keplerscript-system-bundle-config.json';

// This is the name of the file in the library root that provides relevant
// package transformation information for the library (eg. original name
// of the library prior to renaming)
const TRANSFORMED_PKG_JSON = 'kepler-transformed-package-info.json';

// This is the name of a metadata file generated at build time for an application
// that provides all the metadata settings required to identify the system bundles
// used by the interactive application's dependencies.
const INTERACTIVE_APP_SYSTEM_BUNDLES_CONFIG_JSON = 'keplerscript-app-system-bundles-config.json';
const SERVICE_SYSTEM_BUNDLES_CONFIG_JSON = 'keplerscript-service-system-bundles-config.json';
const TASK_SYSTEM_BUNDLES_CONFIG_JSON = 'keplerscript-task-system-bundles-config.json';

const POLYFILL_REQUIRE_JS = 'metro-runtime/src/polyfills/require.js';
const REACT_PATH = 'node_modules/react/';

const dependencySystemModulesFileToId = new Map();
const previousDependencySystemModulesFileToId = new Map();

const cache = new Map();

/**
 * @module BundleSplitter
 */

/**
 * Creates a dummy keplerscript-system-bundle-config.json file with library configuration
 * @param {string} projectRootDir - Root directory of the project
 * @param {string} libraryName - Name of the library
 * @throws {Error} If file cannot be created
 */
function createTemplateLibrariesJson(projectRootDir, libraryName) {
  const convertedName = libraryName.replace(/^@/, '').replace(/\//g, '__');
  const content = {
    [libraryName]: {
      nameOnDevice: `${convertedName}.hermes.bundle`,
      modulesPath: `${convertedName}.modules.txt`,
      privateModulesPath: `${convertedName}.private.modules.txt`,
    },
  };

  const fileName = path.join(projectRootDir, SYSTEM_MODULES_DIR, SYSTEM_LIBRARY_JSON);
  try {
    fs.writeFileSync(fileName, JSON.stringify(content, null, 2));
  } catch (error) {
    throw new Error(`System could not create a required file ${fileName}:`, error);
  }
}

/**
 * Creates system modules folder if it doesn't exist
 */
function createSystemModulesFolder() {
  if (!fs.existsSync(SYSTEM_MODULES_DIR)) {
    fs.mkdirSync(SYSTEM_MODULES_DIR);
  }
}

/**
 * Gets the system module directory path
 * @param {string} projectRootPath - Root path of the project
 * @param {string} libraryName - Name of the library
 * @param {boolean} isDependencyFromNodeModules - Whether to get path for self or dependency
 * @returns {string} System module directory path
 */
function getDependencySystemModulePathDir(projectRootPath, libraryName, isDependencyFromNodeModules) {
  if (!isDependencyFromNodeModules) {
    createSystemModulesFolder();
    return path.join(projectRootPath, SYSTEM_MODULES_DIR);
  } else {
    if (VERBOSE_DEBUGGING) {
      console.debug('[GET_SYSTEM_MODULE_PATH_DIR]', projectRootPath, NODE_MODULES, libraryName, SYSTEM_MODULES_DIR);
    }
    return path.join(projectRootPath, NODE_MODULES, libraryName, SYSTEM_MODULES_DIR);
  }
}

/**
 * Gets the keplerscript-system-bundle-config.json contents
 * @param {string} projectRootPath - Root path of the project
 * @param {string} libraryName - Name of the library
 * @param {boolean} isDependencyFromNodeModules - Whether to get for self or dependency
 * @returns {Object|undefined} Parsed JSON contents or undefined if not found
 */
function getSystemLibrariesJson(projectRootPath, libraryName, isDependencyFromNodeModules) {
  try {
    const systemModulesPathDir = getDependencySystemModulePathDir(projectRootPath, libraryName, isDependencyFromNodeModules);
    const systemLibraryPath = path.join(systemModulesPathDir, SYSTEM_LIBRARY_JSON);
    const systemLibrariesData = fs.readFileSync(systemLibraryPath, 'utf8');
    const systemLibrariesJson = JSON.parse(systemLibrariesData);
    return systemLibrariesJson;
  } catch (err) {
    return undefined;
  }
}

/**
 * Gets the system modules file path
 * @param {string} projectRootPath - Root path of the project
 * @param {string} libraryName - Name of the library
 * @param {boolean} isDependencyFromNodeModules - Whether to get for self or dependency
 * @param {string} originalLibraryName - the original name if library is aliased
 * @returns {string|undefined} System modules file path or undefined
 */
function getSystemModulesPath(projectRootPath, libraryName, isDependencyFromNodeModules, originalLibraryName = undefined) {
  const systemLibrariesJson = getSystemLibrariesJson(projectRootPath, libraryName, isDependencyFromNodeModules);
  if (systemLibrariesJson) {
    const systemModulesPathDir = getDependencySystemModulePathDir(projectRootPath, libraryName, isDependencyFromNodeModules);
    const systemModulesPath = path.join(systemModulesPathDir, systemLibrariesJson[originalLibraryName ?? libraryName].modulesPath);
    return systemModulesPath;
  } else {
    return undefined;
  }
}

/**
 * Gets the path to the private system modules file for a specific library.
 * The private system modules file contains mappings between module paths and numeric IDs
 * for modules that are private dependencies of the library and not exposed publicly.
 * These private modules are still part of the library's bundle but are not accessible
 * to other libraries or applications consuming this library.
 *
 * @param {string} projectRootPath - Root path of the project
 * @param {string} libraryName - Name of the library
 * @param {boolean} [isDependencyFromNodeModules=true] - Whether to get path for a node_modules dependency
 * @returns {string|undefined} Path to private system modules file, or undefined if not found
 *
 * @example
 * // Get private modules path for library in project root
 * const path = getSystemPrivateModulesPath('/project/root', 'my-lib');
 *
 * // Get private modules path for dependency
 * const depPath = getSystemPrivateModulesPath('/project/root', 'dep-lib', true);
 */
function getSystemPrivateModulesPath(projectRootPath, libraryName, isDependencyFromNodeModules = true) {
  const systemLibrariesJson = getSystemLibrariesJson(projectRootPath, libraryName, isDependencyFromNodeModules);
  if (systemLibrariesJson) {
    const systemModulesPathDir = getDependencySystemModulePathDir(projectRootPath, libraryName, isDependencyFromNodeModules);
    const systemPrivateModulesPath = path.join(systemModulesPathDir, systemLibrariesJson[libraryName].privateModulesPath);
    return systemPrivateModulesPath;
  } else {
    return undefined;
  }
}

/**
 * Reads system module mappings from a file and updates the provided map.
 *
 * The file should contain lines in the format:
 * modulePath:numericId
 *
 * For example:
 * node_modules/my-lib/index.js:123456789
 * node_modules/my-lib/utils.js:987654321
 *
 * @param {string} systemModulesPath - Path to the system modules mapping file
 * @param {Map} mapToUpdate - Map to store the module path to ID mappings
 * @throws {Error} If a line in the file does not match the expected format
 *
 * @example
 * const moduleMap = new Map();
 * readSystemModules('/path/to/modules.txt', moduleMap);
 *
 * // moduleMap will contain entries like:
 * // "node_modules/my-lib/index.js" => { id: 123456789 }
 */
function readSystemModules(systemModulesPath, mapToUpdate) {
  const contents = fs.readFileSync(systemModulesPath, 'utf8');
  const lines = contents.split('\n');
  lines.forEach(line => {
    if (line.length > 2) {
      const elements = line.split(':');
      if (elements.length !== 2) {
        throw new Error('Format of SystemModule is not correct');
      }
      mapToUpdate.set(elements[0], {
        id: elements[1],
      });
    }
  });
}

/**
 * Loads dependency system modules into memory and maps their file paths to IDs
 *
 * @param {string} projectRootPath - Root directory path of the project
 * @param {string} libraryName - Name of the library to load modules for
 * @param {Map} mapToUpdate - Map to store the file path to ID mappings
 * @param {boolean} [isDependencyFromNodeModules=true] - Whether the library is a node_modules dependency
 * @param {string} originalLibraryName - the name of the library if aliased
 * @returns {string|undefined} Library name if successful, undefined if system modules path not found
 * @throws {Error} If system module file format is incorrect
 *
 * @example
 * // Load system modules for a library
 * const moduleMap = new Map();
 * getDependencySystemModules('/project/root', 'my-lib', moduleMap);
 *
 * // moduleMap will contain entries like:
 * // "node_modules/my-lib/index.js" => { id: 123456789 }
 */
function getDependencySystemModules(projectRootPath, libraryName, majorVersion, mapToUpdate, isDependencyFromNodeModules = true, originalLibraryName = undefined) {
  if (cache.get(`getDependencySystemModules(${libraryName}, ${majorVersion})`)) {
    return libraryName;
  }
  const dependencySystemModulePath = getSystemModulesPath(projectRootPath, libraryName, isDependencyFromNodeModules, originalLibraryName);
  if (dependencySystemModulePath === undefined) {
    cache.set(`getDependencySystemModules(${libraryName}, ${majorVersion})`, false);
    return undefined;
  }

  console.log('Getting Dependencies from System Modules: ' + dependencySystemModulePath);
  readSystemModules(dependencySystemModulePath, mapToUpdate);
  cache.set(`getDependencySystemModules(${libraryName}, ${majorVersion})`, true);
  return libraryName;
}

/**
 * Checks if path is a known prelude or source map
 * @param {string} modulePath - Path to check
 * @returns {boolean} True if known prelude/source map
 */
function isKnownPreludeOrSourceMap(modulePath) {
  return modulePath === '__prelude__' || modulePath === 'source-map';
}

/**
 * Checks if path is inside node_modules
 * @param {string} modulePath - Path to check
 * @returns {boolean} True if inside node_modules
 */
function isInsideNodeModule(modulePath) {
  return modulePath.lastIndexOf(NODE_MODULES) !== -1;
}

/**
 * Creates unique numeric ID from File Path
 * @param {string} filePath - Path to create ID from
 * @returns {number} Unique numeric ID
 */
function createUniqueIdFromFilePath(filePath) {
  // Generate SHA-256 hash
  const hash = crypto
    .createHash('sha256')
    .update(filePath)
    .digest('hex');
  // take 20 chars from sha256
  const uniqueId = hash.slice(0, 20);
  if (VERBOSE_DEBUGGING) {
    console.debug('[CREATE_UNIQUE_ID_FROM_FILE_PATH]', filePath, 'uniqueId:', uniqueId);
  }
  return uniqueId;
}

/**
 * Remove previous system modules.
 */
function removePreviousSystemModules(systemModulesPath) {
  if (fs.existsSync(systemModulesPath)) {
    // delete file if exists
    console.log(`Deleting ${systemModulesPath}`);
    fs.unlinkSync(systemModulesPath);
  }
}

/**
 * Returns whether library is present in allow list
 *
 * @param {string} modulePath - Path to file
 * @param {string} aliasModulePath - Path to alias module if an alias for the library exists.
 * @returns {boolean} -  true if library and major version present in allow list
 */
function isLibraryInAllowList(modulePath, aliasModulePath = '') {
  const libraryName = findLibraryName(modulePath);
  const libraryMajorVersion = findLibraryMajorVersionWithModulePath(
    aliasModulePath ? aliasModulePath : modulePath
  );
  const isLibraryInAllowListBool = (ALLOW_LIST[libraryName] !== undefined) && (ALLOW_LIST[libraryName][libraryMajorVersion] !== undefined) && ALLOW_LIST[libraryName][libraryMajorVersion];
  return isLibraryInAllowListBool;
}

/**
 * Find the name of the library from module path
 *
 * @param {string} modulePath - Path to file
 * @returns {string} -  name of the library that this path belongs to
 */
function findLibraryName(modulePath) {
  const nodeModulesIndex = modulePath.lastIndexOf(NODE_MODULES);
  if (nodeModulesIndex !== -1) {
    const afterNodeModules = modulePath.slice(nodeModulesIndex + NODE_MODULES.length);
    const parts = afterNodeModules.split('/');

    // Handle scoped packages
    if (parts[0].startsWith('@')) {
      return parts.length > 1 ? `${parts[0]}/${parts[1]}`.trim() : '';
    }
    // Handle regular packages
    return parts[0].trim();
  }
  return '';
}

/**
 * Finds the version of a library by reading its package.json file
 *
 * @param {string} libraryPath - Path to the library's root directory containing package.json
 * @returns {string} The version string from package.json, or empty string if not found/error
 */
function findLibraryVersion(libraryPath) {
  try {
    const packageJsonPath = path.join(libraryPath, 'package.json');
    const packageJsonData = fs.readFileSync(packageJsonPath, 'utf8');
    const packageJson = JSON.parse(packageJsonData);
    return packageJson.version;
  } catch (error) {
    console.error(`Error reading package.json for library ${libraryPath}:`, error);
  }
  return '';
}

/**
 * Computes the path to package.json file for the dependency given its module path
 *
 * @param modulePath - Module path for the given dependency
 * @returns {string} - Path to package.json file for the given dependency
 */
function findPackageJsonFromModulePath(modulePath) {
  const libraryName = findLibraryName(modulePath);
  const nodeModulesIndex = modulePath.lastIndexOf(NODE_MODULES);
  const libraryPath = modulePath.slice(0, nodeModulesIndex + NODE_MODULES.length + libraryName.length);
  return path.join(libraryPath, 'package.json');
}

/**
 * Finds the version of a library by reading its package.json file, given a module path
 *
 * Takes a module path that includes node_modules and extracts the library name and path,
 * then reads the version from that library's package.json file.
 *
 * @param {string} modulePath - Full path to a module file, must include node_modules
 * @returns {string} The version string from package.json, or empty string if not found/error
 *
 * @example
 * // Returns "1.2.3" for a module path like:
 * findLibraryVersionWithModulePath("path/to/node_modules/my-lib/src/index.js")
 * // Reads version from path/to/node_modules/my-lib/package.json
 */
function findLibraryMajorVersionWithModulePath(modulePath) {
  const packageJsonPath = findPackageJsonFromModulePath(modulePath);
  try {
    const packageJsonData = fs.readFileSync(packageJsonPath, 'utf8');
    const packageJson = JSON.parse(packageJsonData);
    return packageJson.version.split('.')[0];
  } catch (error) {
    console.error(`Error reading package.json at ${packageJsonPath}:`, error);
  }
  return '';
}

/**
 * Computes the alias for a given package or the lack thereof. Returns valid alias by
 * comparing name in package.json or transformation info file with requested dependency name.
 * If name is not different, then it is returned as-is.
 *
 * @param {string} aliasModulePath - Module path that has been requested and is potentially aliased
 * @param {string} dependencyLibraryName - Name of the dependency library for the module
 * @param {string} projectRootPath - Path to the project root
 * @returns {string} - Alias name for the library, or the requested name itself if not aliased
 */
function lazyComputeAliasName(aliasModulePath, dependencyLibraryName, projectRootPath) {
  let mappedLibraryName = dependencyLibraryName;
  const dependencyPackageJson = findPackageJsonFromModulePath(aliasModulePath);

  if (!fs.existsSync(dependencyPackageJson)) {
    return dependencyLibraryName;
  }

  // package.json for dependency was found. Check if the name of dependency in it is the same as the
  // requested name
  const dependencyNameInPackageJson = JSON.parse(fs.readFileSync(dependencyPackageJson, 'utf8')).name;
  if (dependencyNameInPackageJson !== dependencyLibraryName) {
    mappedLibraryName = dependencyNameInPackageJson;
  }

  // If the names do match, check if package contains explicit info for a rename/transformation
  const inferredDependencyLibraryPath = path.dirname(dependencyPackageJson);
  const pkgTransformationInfoPath = path.join(inferredDependencyLibraryPath, TRANSFORMED_PKG_JSON);
  mappedLibraryName = getRefNameForTransformedPackage(pkgTransformationInfoPath) ?? mappedLibraryName;

  // If the final resolution is not the same as the dependency name, it is an alias
  if (mappedLibraryName !== dependencyLibraryName) {
    return mappedLibraryName;
  }

  return dependencyLibraryName;
}

/**
 * Computes library alias if it has been renamed/transformed for Kepler
 *
 * @param pkgTransformationInfoPath - Path to transformation info file within the library
 * @returns {undefined|*} - Name of the original library
 */
function getRefNameForTransformedPackage(pkgTransformationInfoPath) {
  if (fs.existsSync(pkgTransformationInfoPath)) {
    const transformedPkgInfo = JSON.parse(fs.readFileSync(pkgTransformationInfoPath, 'utf8'));
    return transformedPkgInfo.sourcePackageRef;
  }

  return undefined;
}

/**
 * Gets the library path with version number appended to library name
 *
 * Takes a module path and extracts the library name and version, then constructs
 * a new path with the version appended to the library name.
 *
 * For example:
 * Input: "node_modules/my-lib/src/index.js"
 * Output: "node_modules/my-lib_1.0.0/src/index.js"
 *
 * @param {string} modulePath - Full path to the module file
 * @returns {string} Modified path with version appended to library name
 * @throws {Error} If nodeModulesIndex is undefined or library version cannot be determined
 */
function getLibraryPathWithVersion(modulePath, libraryName, libraryVersion) {
  const nodeModulesIndex = modulePath.lastIndexOf(NODE_MODULES);
  if (nodeModulesIndex !== -1) {
    const moduleFilePath = modulePath.slice(nodeModulesIndex + NODE_MODULES.length + libraryName.length);
    return path.join(NODE_MODULES, `${libraryName}_${libraryVersion}`, moduleFilePath);
  }
  return modulePath;
}

/**
 * Generates a module path to use for creating a unique hash.
 * For non-system libraries, appends the library version to the path.
 * For system libraries, uses the path with major version to the path.
 *
 * @param {string} modulePath - Full path to the module file
 * @param {string} libraryName - Name of the library being processed
 * @param {string} libraryPresentInAllowList - Optional string indicating if the library and major version is present in the allow list.
 * @param {string} aliasModulePath - Path to alias module if alias exists
 * @returns {string} Module path to use for hash generation
 * @throws {Error} If modulePath does not contain node_modules
 *
 * @example
 * // For non-system library:
 * // Input: "/workspace/node_modules/my-lib/index.js"
 * // Output: "node_modules/my-lib_1.0.0/index.js"
 *
 * // For system library:
 * // Input: "/workspace/node_modules/system-lib/index.js"
 * // Output: "node_modules/system-lib_2/index.js"
 */
function generateModulePathForHash(modulePath, libraryName, libraryPresentInAllowList = true, aliasModulePath = '') {
  const dependencyLibraryName = findLibraryName(modulePath);
  const nodeModulesIndex = modulePath.lastIndexOf(NODE_MODULES);
  if (nodeModulesIndex === -1) {
    throw new Error(`Function should be called with node_modules path`);
  }
  const repoPath = modulePath.slice(0, nodeModulesIndex);
  // Special case for metro-runtime/src/polyfills/require.js. Having 2 copies results in a failure related to id could not be found.
  // keep the path as is and do not add version metro-runtime/src/polyfills/require.js or react path
  if (modulePath.includes(POLYFILL_REQUIRE_JS) || modulePath.includes(REACT_PATH)) {
    return modulePath.slice(nodeModulesIndex);
  }
  let dependencyLibraryPath = modulePath.slice(0, nodeModulesIndex + NODE_MODULES.length + dependencyLibraryName.length);
  let dependencySystemModulePath = (libraryPresentInAllowList) ? getSystemModulesPath(repoPath, dependencyLibraryName, dependencyLibraryName !== libraryName) : undefined;
  if (aliasModulePath) {
    const aliasDependencyLibraryName = findLibraryName(aliasModulePath);
    const aliasNodeModulesIndex = aliasModulePath.lastIndexOf(NODE_MODULES);
    dependencyLibraryPath = aliasModulePath.slice(0, aliasNodeModulesIndex + NODE_MODULES.length + aliasDependencyLibraryName.length);
    dependencySystemModulePath = (libraryPresentInAllowList) ? getSystemModulesPath(repoPath, aliasDependencyLibraryName, dependencyLibraryName !== libraryName, dependencyLibraryName) : undefined;
  }
  // Libraries with major version that are present in allow list will behave as system bundled library dependencies
  // Libraries with major version that are not present in allow list will behave as regular non system bundled libraries
  const libraryVersion = dependencySystemModulePath ? findLibraryVersion(dependencyLibraryPath).split('.')[0] : findLibraryVersion(dependencyLibraryPath);
  return getLibraryPathWithVersion(modulePath, dependencyLibraryName, libraryVersion);
}

/**
 *
 * @param {string} projectRootPath - Root directory path of the project
 * @param {string} appBundleType - The type of the app bundle ('interactive', 'task', or 'service').
 * @returns (string} The path to the <INTERATIVE_APP/SERVICE/TASK>_SYSTEM_BUNDLES_CONFIG_JSON
 */
function getSystemBundlesConfigPath(projectRootPath, appBundleType) {
    let configPath = "";
    let fileName = INTERACTIVE_APP_SYSTEM_BUNDLES_CONFIG_JSON;

    if (appBundleType === 'task') {
        fileName = TASK_SYSTEM_BUNDLES_CONFIG_JSON;
    } else if (appBundleType === 'service') {
        fileName = SERVICE_SYSTEM_BUNDLES_CONFIG_JSON;
    }

    // If the environment variable SYS_BUNDLES_CONFIG_DIR is defined
    // we will use it, otherwise we will use a default location.
    if (env.SYS_BUNDLES_CONFIG_DIR) {
        if (!fs.existsSync(env.SYS_BUNDLES_CONFIG_DIR)) {
            throw new Error("[SYSTEM_BUNDLES_CONFIG_PATH] Error: SYS_BUNDLES_CONFIG_DIR does not point to an existing directory! Path: " + env.SYS_BUNDLES_CONFIG_DIR);
        }
        configPath = path.join(env.SYS_BUNDLES_CONFIG_DIR, fileName);
    } else {
        configPath = path.join(projectRootPath, 'node_modules', fileName);
    }

    if (VERBOSE_DEBUGGING) {
      console.debug('[SYSTEM_BUNDLES_CONFIG_PATH] path:', configPath);
    }

    return configPath;
}

/**
 * Get the key to use for common system modules in the <INTERATIVE_APP/SERVICE/TASK>_SYSTEM_BUNDLES_CONFIG_JSON
 * according to the app component type
 * @param {string} appBundleType - The type of the app bundle ('interactive', 'task', or 'service').
 * @returns {string}
 */
function getBundleCommonKeyForAppComponent(appBundleType) {
  const appComponentType =  appBundleType ? appBundleType : "interactive";
  let commonKey="common"
  if (appComponentType === 'task') {
    commonKey="common-task"
  } else if (appComponentType === 'service') {
    commonKey="common-service"
  }
  return commonKey;
}

/**
 * Checks if the system bundle JSON contains the correct major version for the library.
 *
 * @param {Object} systemLibrariesJson - The parsed contents of the system library JSON file
 * @param {string} libraryMajorVersion - The major version of the library
 * @param {string} libraryName - The name of the library to check
 * @throws {Error} Throws an error if the major version in system bundle JSON doesn't match the library version
 */
function checkSystemBundleJsonMajorVersion(systemLibrariesJson, libraryMajorVersion, libraryName) {
  const { nameOnDevice, modulesPath, privateModulesPath } = systemLibrariesJson[libraryName];
  const hasCorrectVersion =
    nameOnDevice.includes(libraryMajorVersion) &&
    modulesPath.includes(libraryMajorVersion) &&
    privateModulesPath.includes(libraryMajorVersion);
  if (!hasCorrectVersion) {
    throw new Error(
      `${libraryName} does not have the expected major version ${libraryMajorVersion} in the ${SYSTEM_LIBRARY_JSON} file. ` +
      `If this is intended due to a major version update of the library, please delete the SystemModules folder in the package and rebuild the package`
    );
  }
}

/**
 * Resolves a module path and dependency name using an alias map.
 *
 * If the dependency name exists as a key in the alias map, this function:
 * - Replaces the alias in the module path with the original package name
 * - Updates the dependency name to the original name
 *
 * @param {string} aliasModulePath - Aliased module file path (e.g. "/node_modules/my-lib/index.js")
 * @param {string} dependencyLibraryName - The dependency name to resolve (e.g. "my-lib")
 * @param {Map<string, string>} dependencyAliasMap - A map of alias => real package name
 * @param {string} projectRootPath - Path to the project root
 * @returns {{ modulePath: string, dependencyLibraryName: string }} - The resolved values
 */
function resolveModuleAlias(aliasModulePath, dependencyLibraryName, dependencyAliasMap, projectRootPath) {
  // Populate cache if alias hasn't been computed yet
  if (!dependencyAliasMap.has(dependencyLibraryName)) {
    const dependencyAliasName = lazyComputeAliasName(aliasModulePath, dependencyLibraryName, projectRootPath);
    dependencyAliasMap.set(dependencyLibraryName, dependencyAliasName);
  }

  // Check if the alias map contains a replacement for the dependency
  const originalLibraryName = dependencyAliasMap.get(dependencyLibraryName);
  if (originalLibraryName === dependencyLibraryName) {
    return false;
  }

  // Replace the alias with the real package name in the module path
  const originalModulePath = aliasModulePath.replace(dependencyLibraryName, originalLibraryName);

  return {
    modulePath: originalModulePath,
    dependencyLibraryName: originalLibraryName
  };
}

/**
 * Configures bundle splitter for an application type project.
 *
 * @param {string} basePath - The base path of the project.
 * @param {string} appBundleType - The type of the app bundle ('interactive', 'task', or 'service').
 * @returns {Array} An array containing two functions: moduleIDCreator and moduleFilter.
 */
let bundleSplitterConfigurator = function(basePath, appBundleType) {
  const projectRootPath = basePath + '/';
  // File path to app bundle modules if ENABLE_APP_BUNDLE_MODULE_CREATION flag set to true
  const appBundleModuleFilePath = path.join(basePath, 'node_modules', APP_BUNDLE_MODULE_FILE);
  const systemBundledLibraries = new Map();
  const dependencyAliasMap = new Map();
  /**
   * Updates the <INTERATIVE_APP/SERVICE/TASK>_SYSTEM_BUNDLES_CONFIG_JSON file with system bundles.
   * This file is read by the build tool when it creates the app's
   * keplerscript.app.config.json file. It will copy this data
   * to that file.
   *
   * @param {string} libraryName - The name of the library to add to system bundles.
   */
  function updateSystemBundlesConfig(libraryRootPath, libraryName, majorVersion, originalLibraryName) {
    if (cache.get(`updateSystemBundlesConfig(${libraryName}, ${majorVersion})`)) {
      return;
    }
    /* File contents illustration: (systemBundles object is copied by build tool)

            {
              "systemBundles": {
                "common": [
                  <names of common bundles required on all devices>
                ],
                "kepler": [
                     <names of bundles required only on kepler>
                ],
                "fireos": [
                     <names of common bundles required only on fireos>
                ],
                "mac": [
                     <names of common bundles required only on mac>
                ]
              }
            }

        */

    const systemLibraries = getSystemLibrariesJson(libraryRootPath, libraryName, true);
    if (systemLibraries) {
      const systemBundlesConfigPath = getSystemBundlesConfigPath(projectRootPath, appBundleType);
      const configData = fs.readFileSync(systemBundlesConfigPath, 'utf8');
      const configJson = JSON.parse(configData);
      if (!configJson.systemBundles) {
        configJson.systemBundles = {};
      }
      // Presently, only common bundles are supported
      // In the future, platform specific bundles for 'kepler', 'fireos',
      // and 'mac' may be supported for libraries that are only used
      // on a particular platform.
      // Bundles for interactive, service, and task components are separate from
      // each other and may have different lists of system bundles to load.
      // We separate these into "common", "common-service" and "common-task" respectively.
      // TODO: Issue-239655 - Replace direct bundle names/paths usage with lookup
      // in the system by module ID or other means.
      const commonKey = getBundleCommonKeyForAppComponent(appBundleType);
      if (!configJson.systemBundles[commonKey]) {
        configJson.systemBundles[commonKey] = [];
      }
      const nameOnDevice = systemLibraries[originalLibraryName].nameOnDevice;
      // if the nameOnDevice is not already in the systemBundles array add it
      if (!configJson.systemBundles[commonKey].includes(nameOnDevice)) {
        configJson.systemBundles[commonKey].push(nameOnDevice);
        const configJsonStr = JSON.stringify(configJson, null, 2);
        fs.writeFileSync(systemBundlesConfigPath, configJsonStr);
      }
    }
    cache.set(`updateSystemBundlesConfig(${libraryName}, ${majorVersion})`, true); // memoization
  }

  /**
   * Creates a unique module ID based on the module path.
   *
   * @param {string} path - The path of the module.
   * @returns {number} A unique numeric ID for the module.
   */
  let moduleIDCreator = function(path) {
    let modulePath = path;
    if (cache.has(`moduleIDCreator(${modulePath})`)) {
      return cache.get(`moduleIDCreator(${modulePath})`);
    }

    if (VERBOSE_DEBUGGING) {
      console.debug('[APP_MODULE_ID_CREATOR] path:', modulePath);
    }

    // paths from node_modules
    const nodeModulesIndex = modulePath.lastIndexOf(NODE_MODULES);
    if (nodeModulesIndex !== -1 && !modulePath.startsWith('require-')) {
      const repoPath = modulePath.slice(0, nodeModulesIndex);
      const dependencyLibraryMajorVersion = findLibraryMajorVersionWithModulePath(modulePath);
      let dependencyLibraryName = findLibraryName(modulePath);
      const libraryNameInRequestedModule = dependencyLibraryName; // This is the name of the lib in dependency cache
      let libraryInAllowList = isLibraryInAllowList(modulePath);
      let modulePathForHash;
      const moduleAlias = resolveModuleAlias(modulePath, dependencyLibraryName, dependencyAliasMap, basePath);
      // If library is aliased in the app then we use the library name and library module path from the original module
      if (moduleAlias) {
        const originalModulePath = moduleAlias.modulePath;
        const originalLibraryName = moduleAlias.dependencyLibraryName;
        libraryInAllowList = isLibraryInAllowList(originalModulePath, modulePath);
        // Only modify variables when alias is used on a system bundled library
        if (libraryInAllowList) {
          dependencyLibraryName = originalLibraryName;
          modulePathForHash = generateModulePathForHash(originalModulePath, '', libraryInAllowList, modulePath);
          modulePath = originalModulePath;
        }
      }
      // Set the modulePathForHash for library dependencies that do not have an alias
      if (!modulePathForHash) {
        modulePathForHash = generateModulePathForHash(modulePath, '', libraryInAllowList);
      }
      if (libraryInAllowList && getDependencySystemModules(repoPath, libraryNameInRequestedModule, dependencyLibraryMajorVersion, dependencySystemModulesFileToId, true, dependencyLibraryName)) {
        updateSystemBundlesConfig(repoPath, libraryNameInRequestedModule, dependencyLibraryMajorVersion, dependencyLibraryName);
        systemBundledLibraries.set(libraryNameInRequestedModule, dependencyLibraryMajorVersion);
      }
      const idFromMap = dependencySystemModulesFileToId.get(modulePathForHash);
      if (idFromMap !== undefined) {
        cache.set(`moduleIDCreator(${modulePath})`, idFromMap.id);
        return idFromMap.id;
      }
      const id = createUniqueIdFromFilePath(modulePathForHash);
      cache.set(`moduleIDCreator(${modulePath})`, id);
      return id;
    }
    // e.g. apps sources
    // prelude, --require, source-map,
    const id = createUniqueIdFromFilePath(modulePath);
    cache.set(`moduleIDCreator(${modulePath})`, id);
    return id;
  };

  /**
   * Filters modules based on certain criteria.
   *
   * @param {Object} module - The module object to filter.
   * @param {string} module.path - The path of the module.
   * @param {string} module.output - The output of the module.
   * @returns {boolean} True if the module should be included, false otherwise.
   * @throws {Error} If the format of the module is not supported.
   */
  let moduleFilter = function(module) {
    if (module.path === undefined || module.output === undefined) {
      throw new Error('Format of module is not supported');
    }
    let modulePath = module.path;
    if (VERBOSE_DEBUGGING) {
      console.debug('[APP_MODULE_ID_FILTER] path:', modulePath);
    }
    if (cache.has(`moduleFilter(${modulePath})`)) {
      return cache.get(`moduleFilter(${modulePath})`);
    }

    if (modulePath.startsWith('require-')) {
      cache.set(`moduleFilter(${modulePath})`, true);
      return true;
    }

    if (!isInsideNodeModule(modulePath)) {
      // This path is for the sources of the app.
      cache.set(`moduleFilter(${modulePath})`, true);
      if (ENABLE_APP_BUNDLE_MODULE_CREATION) {
        const id = createUniqueIdFromFilePath(modulePath);
        fs.appendFileSync(appBundleModuleFilePath, `${modulePath}:${id}\n`);
      }
      return true;
    }
    // All paths here are with node_modules
    // Library with major version present in allow list will have a module path that contains only the major version
    // All other libraries not present in allow list will have a module path that contains the full library version
    const dependencyLibraryMajorVersion = findLibraryMajorVersionWithModulePath(modulePath);
    let modulePathForHash;
    let dependencyLibraryName = findLibraryName(modulePath);
    const moduleAlias = resolveModuleAlias(modulePath, dependencyLibraryName, dependencyAliasMap, basePath);
    if (moduleAlias) {
      const originalModulePath = moduleAlias.modulePath;
      const originalLibraryName = moduleAlias.dependencyLibraryName;
      const libraryInAllowList = isLibraryInAllowList(originalModulePath, modulePath);
      // Only modify variables when alias is used on a system bundled library
      if (libraryInAllowList) {
        dependencyLibraryName = originalLibraryName;
        modulePathForHash = generateModulePathForHash(originalModulePath, '', libraryInAllowList, modulePath);
        modulePath = originalModulePath;
      }
    }
    // Set the modulePathForHash for library dependencies that do not have an alias
    if (!modulePathForHash) {
      modulePathForHash = generateModulePathForHash(modulePath, '', isLibraryInAllowList(modulePath));
    }
    const result = dependencySystemModulesFileToId.get(modulePathForHash) === undefined;
    cache.set(`moduleFilter(${modulePath})`, result);
    // All of the modules used by the app are added to the appBundleModuleFilePath with their modulePathHash
    // result will return true when the module is not a system bundled library
    if (ENABLE_APP_BUNDLE_MODULE_CREATION && result === true) {
      const id = createUniqueIdFromFilePath(modulePathForHash);
      fs.appendFileSync(appBundleModuleFilePath, `${modulePathForHash}:${id}\n`);
    }
    if (result === true) {
      if (systemBundledLibraries.has(dependencyLibraryName) && systemBundledLibraries.get(dependencyLibraryName) === dependencyLibraryMajorVersion) {
        console.warn(
          `________________________________________________________________________________\n` +
          `__DEPENDENCY SYSTEM BUNDLED LIBRARY PRESENT IN APP BUNDLE MODULES WARNING__\n` +
          `The app bundle contains a system bundled library: "${dependencyLibraryName}" at module path: "${modulePathForHash}". ` +
          `System bundled libraries should not be present in the app bundle as apps should read system bundled libraries from the OS. Please confirm that "${dependencyLibraryName}" system bundle contains file in "${modulePathForHash}".\n` +
          `________________________________________________________________________________`
        );
      }
    }
    return result;
  };

  return [moduleIDCreator, moduleFilter];
};

/**
 * Configures the bundle splitter for system modules.
 *
 * @param {string} basePath - The base path of the project.
 * @param {string} libraryName - The name of the library being processed.
 * @returns {Array} An array containing two functions: systemModuleIDCreator and systemModuleUpdater.
 */
let bundleSplitterConfiguratorSystem = function(basePath, libraryName) {
  const projectRootPath = basePath + '/';
  const isDependencyFromNodeModules = false;
  // Check if this library has the SystemModules folder. If not then generate a template.
  const systemModulesPath = getSystemModulesPath(projectRootPath, libraryName, isDependencyFromNodeModules);
  if (systemModulesPath === undefined) {
    createTemplateLibrariesJson(projectRootPath, libraryName);
    throw new Error(
      `${libraryName} is not configured for systemModuleUpdater. This tool has created a placeholder SystemModules/${SYSTEM_LIBRARY_JSON} file for you. Please update it for your library`
    );
  }
  const systemPrivateModulesPath = getSystemPrivateModulesPath(projectRootPath, libraryName, isDependencyFromNodeModules);
  if (fs.existsSync(systemModulesPath)) {
    // Store modules from previous release to be used to check for breaking changes.
    getDependencySystemModules(projectRootPath, libraryName, "", previousDependencySystemModulesFileToId, isDependencyFromNodeModules);
  }
  // Clearing the file of system modules for new update
  removePreviousSystemModules(systemModulesPath);
  removePreviousSystemModules(systemPrivateModulesPath);
  // List of libraries that do not follow the existing naming convention in SYSTEM_LIBRARY_JSON
  const systemBundleVersionCheckExceptions = new Set([
    '@amazon-devices/kepler-media-controls',
    '@amazon-devices/react-native-screens'
  ]);
  const isExemptFromVersionCheck = systemBundleVersionCheckExceptions.has(libraryName);
  if (!isExemptFromVersionCheck) {
    const systemLibrariesJson = getSystemLibrariesJson(projectRootPath, libraryName, isDependencyFromNodeModules);
    if (systemLibrariesJson) {
      const jsRootDirectory = path.join(projectRootPath, NODE_MODULES, libraryName);
      const libraryMajorVersion = findLibraryVersion(jsRootDirectory).split('.')[0];
      checkSystemBundleJsonMajorVersion(systemLibrariesJson, libraryMajorVersion, libraryName);
    }
  }

  /**
   * Creates a unique ID for system modules.
   *
   * @param {string} pathOfModule - The path of the module.
   * @returns {number} A unique numeric ID for the module.
   */
  let systemModuleIDCreator = function(pathOfModule) {
    const modulePath = pathOfModule;
    if (cache.has(`systemModuleIDCreator(${modulePath})`)) {
      return cache.get(`systemModuleIDCreator(${modulePath})`);
    }
    if (VERBOSE_DEBUGGING) {
      console.debug('[SYSTEM_MODULE_ID_CREATOR] modulePath: ', modulePath);
    }
    // Case 1: path === '__prelude__', 'source-map'
    if (isKnownPreludeOrSourceMap(modulePath)) {
      const id = createUniqueIdFromFilePath(modulePath);
      cache.set(`systemModuleIDCreator(${modulePath})`, id);
      previousDependencySystemModulesFileToId.delete(modulePath);
      return id;
    }

    // Case 2: path contains node_modules (monorepo or multirepo)
    const nodeModulesIndex = modulePath.lastIndexOf(NODE_MODULES);
    if (nodeModulesIndex !== -1) {
      const repoPath = modulePath.slice(0, nodeModulesIndex);
      const dependencyLibraryName = findLibraryName(modulePath);
      const dependencyLibraryMajorVersion = findLibraryMajorVersionWithModulePath(modulePath);
      getDependencySystemModules(repoPath, dependencyLibraryName, dependencyLibraryMajorVersion, dependencySystemModulesFileToId);
      const modulePathForHash = generateModulePathForHash(modulePath, libraryName);
      const id = createUniqueIdFromFilePath(modulePathForHash);
      cache.set(`systemModuleIDCreator(${modulePath})`, id);
      previousDependencySystemModulesFileToId.delete(modulePathForHash);
      return id;
    }

    // Case 3: Other paths , mostly dummy app path
    const id = createUniqueIdFromFilePath(modulePath);
    // Log added to get data on if there are any files that get added which are not from node_modules for a library bundle creation.
    // Based on the build of 6 common libs only index.bundle.js was present in this category.
    // Log should be kept during initial trials to determine any miss.
    // TODO: Issue-253585: Log can be deleted or added under a flag after 2nd release
    console.debug('[SYSTEM_MODULE_ID_CREATOR] files not from node_modules :', modulePath);
    cache.set(`systemModuleIDCreator(${modulePath})`, id);
    return id;
  };

  /**
   * Updates system modules and manages their processing.
   *
   * @param {Object} module - The module object to process.
   * @param {string} module.path - The path of the module.
   * @param {string} module.output - The output of the module.
   * @returns {boolean} True if the module should be processed, false otherwise.
   * @throws {Error} If the format of the module is not supported or if the library is not configured.
   */
  let systemModuleUpdater = function(module) {
    if (module.path === undefined || module.output === undefined) {
      throw new Error('Format of module is not supported');
    }
    const modulePath = module.path;
    if (VERBOSE_DEBUGGING) {
      console.debug('[SYSTEM_MODULE_ID_UPDATER] modulePath: ', modulePath);
    }
    if (cache.has(`systemModuleUpdater(${modulePath})`)) {
      return cache.get(`systemModuleUpdater(${modulePath})`);
    }
    // Logic to detect a breaking change. Breaking change can be deleting, renaming or moving a file from previously released system module.
    // Special handling for @react-native/js-polyfills as these show up only in systemModuleUpdater and not in moduleIDCreator
    // node_modules/@react-native/js-polyfills_0.72.1/console.js:3386615686152208
    // node_modules/@react-native/js-polyfills_0.72.1/error-guard.js:96427056494579
    // node_modules/@react-native/js-polyfills_0.72.1/Object.es8.js:2986238474155223
    if (modulePath.includes('js-polyfills') || modulePath.includes('metro-runtime') || modulePath === '__prelude__') {
      const modulePathForHash = modulePath === '__prelude__' ? modulePath : generateModulePathForHash(modulePath, libraryName);
      previousDependencySystemModulesFileToId.delete(modulePathForHash);
    } else if (previousDependencySystemModulesFileToId.size !== 0) {
      const mismatchingPaths = Array.from(previousDependencySystemModulesFileToId.keys()).join('\n');
      console.error('The following files were removed from the new module. Please re-add them to the SystemModules file. Please ignore this message if this change is part of a mojor version update.');
      console.error('Files from previous release which are not present currently: ', mismatchingPaths);
      previousDependencySystemModulesFileToId.clear();
      throw new Error('Breaking change detected: Previously released modules are not present in the new release. Please re-add the files to SystemModules file');
    }

    // require is not needed for system bundle as we only need definitions.
    if (modulePath === 'source-map' || modulePath.startsWith('require-')) {
      cache.set(`systemModuleUpdater(${modulePath})`, false);
      return false;
    }

    // Special case to add __prelude__ only in react-native-kepler.
    if (modulePath === '__prelude__') {
      cache.set(`systemModuleUpdater(${modulePath})`, true);
      return true;
    }

    // Special case to add metro-runtime/src/polyfills/require.js only in react-native-kepler.
    // This is a must have as duplicate copies of this module causes issues on app launch where app does not find the required id even if its loaded.
    if (modulePath.includes(POLYFILL_REQUIRE_JS)) {
      if (libraryName === '@amazon-devices/react-native-kepler') {
        const modulePathForHash = path.join(NODE_MODULES, POLYFILL_REQUIRE_JS);
        const id = createUniqueIdFromFilePath(modulePathForHash);
        fs.appendFileSync(systemModulesPath, `${modulePathForHash}:${id}\n`);
        cache.set(`systemModuleUpdater(${modulePath})`, true);
        return true;
      } else {
        cache.set(`systemModuleUpdater(${modulePath})`, false);
        return false;
      }
    }

    // TODO: fix logic to make incompatible react versions working PROJ*-266473
    if (modulePath.includes(REACT_PATH)) {
      if (libraryName === '@amazon-devices/react-native-kepler') {
        const nodeModulesIndex = modulePath.lastIndexOf(NODE_MODULES);
        const modulePathForHash = modulePath.slice(nodeModulesIndex);
        const id = createUniqueIdFromFilePath(modulePathForHash);
        fs.appendFileSync(systemModulesPath, `${modulePathForHash}:${id}\n`);
        cache.set(`systemModuleUpdater(${modulePath})`, true);
        return true;
      } else {
        cache.set(`systemModuleUpdater(${modulePath})`, false);
        return false;
      }
    }

    if (isInsideNodeModule(modulePath)) {
      const modulePathForHash = generateModulePathForHash(modulePath, libraryName);
      if (dependencySystemModulesFileToId.get(modulePathForHash) !== undefined) {
        cache.set(`systemModuleUpdater(${modulePath})`, false);
        return false;
      }
      const id = createUniqueIdFromFilePath(modulePathForHash);
      if (modulePathForHash.includes(libraryName)) {
        // TODO: add a test for this Issue - 258422
        // Modules.txt should only have modules from the same library.
        // The index.bundle will still include modules from both the library and its dependencies.
        fs.appendFileSync(systemModulesPath, `${modulePathForHash}:${id}\n`);
      } else {
        // This is a private dependency. Add it to SystemPrivateModules
        if (isLibraryInAllowList(modulePath)) {
          const dependencyLibraryName = findLibraryName(modulePath);
          console.warn(
            `________________________________________________________________________________\n` +
            `__DEPENDENCY SYSTEM BUNDLED LIBRARY PRESENT IN SYSTEM BUNDLE MODULES WARNING__\n` +
            `The system bundle "${libraryName}" contains a system bundled library at module path: "${modulePathForHash}". ` +
            `Dependency system bundled libraries should not be present in the private modules as system bundled libraries should read dependency system bundled libraries from the OS. Please confirm that "${modulePathForHash}" file is present in "${dependencyLibraryName}" system bundle.\n` +
            `________________________________________________________________________________`
          );
        }
        fs.appendFileSync(systemPrivateModulesPath, `${modulePathForHash}:${id}\n`);
      }
      cache.set(`systemModuleUpdater(${modulePath})`, true);
      return true;
    } else {
      // Discard any files that are not in node_modules for library. As the library bundle is
      // created in app setting all the files should come from node_modules. All other files
      // are mostly from the dummy app used to create the library bundle.
      // Based on the build of 6 common libs only index.bundle.js was present in this category.
      // Log should be kept during initial trials to determine any miss.
      // TODO: Issue-253585: Log can be deleted or added under a flag after 2nd release
      console.debug('[SYSTEM_MODULE_UPDATER] discarding : ', modulePath);
      cache.set(`systemModuleUpdater(${modulePath})`, false);
      return false;
    }
  };
  return [systemModuleIDCreator, systemModuleUpdater];
};

/**
 * Creates a configuration object for system bundle creation.
 *
 * @param {string} projectRoot - The root path of the project.
 * @param {string} libraryName - The name of the library for which the system bundle is being created.
 * @returns {Object} A configuration object with serializer functions for system bundle creation.
 */
function createSystemBundlesConfig(projectRoot, libraryName) {
  // Clear global cache to support multiple calls to createSystemBundlesConfig in same process.
  cache.clear();
  dependencySystemModulesFileToId.clear();
  previousDependencySystemModulesFileToId.clear();
  const [systemModuleIDCreator, systemModuleUpdater] = bundleSplitterConfiguratorSystem(projectRoot, libraryName);
  return {
    serializer: {
      createModuleIdFactory: function() {
        return systemModuleIDCreator;
      },
      processModuleFilter: systemModuleUpdater,
    },
  };
}

/**
 * Creates a configuration object for app bundle creation.
 *
 * @param {string} projectRoot - The root path of the project.
 * @param {string} appBundleType - The type of the app bundle ('interactive', 'task', or 'service').
 * @returns {Object} A configuration object with serializer functions for app bundle creation.
 */
function createAppBundleConfig(projectRoot, appBundleType) {
  // Clear global cache to support headless use case of multiple calls to createAppBundleConfig in same process.
  cache.clear();
  dependencySystemModulesFileToId.clear();
  previousDependencySystemModulesFileToId.clear();
  // If the environment variable DISABLE_BUNDLE_SPLITTING is true we won't create a split bundle,
  if (env.DISABLE_APP_BUNDLE_SPLITTING === 'true') {
    return {};
  }

  // Create a new empty system bundle config file
  const systemBundlesConfigPath = getSystemBundlesConfigPath(projectRoot, appBundleType);
  fs.writeFileSync(systemBundlesConfigPath, '{}', {
    encoding: 'utf8',
    flag: 'w',
  });

  const [moduleIDCreator, moduleFilter] = bundleSplitterConfigurator(projectRoot, appBundleType);
  return {
    serializer: {
      createModuleIdFactory: function() {
        return moduleIDCreator;
      },
      processModuleFilter: moduleFilter,
    },
  };
}

// export all functions for test
if (env.NODE_ENV === 'test') {
  module.exports = {
    cache,
    SYSTEM_MODULES_DIR,
    SYSTEM_LIBRARY_JSON,
    INTERACTIVE_APP_SYSTEM_BUNDLES_CONFIG_JSON,
    SERVICE_SYSTEM_BUNDLES_CONFIG_JSON,
    TRANSFORMED_PKG_JSON,
    TASK_SYSTEM_BUNDLES_CONFIG_JSON,
    NODE_MODULES,
    createTemplateLibrariesJson,
    getSystemBundlesConfigPath,
    getSystemLibrariesJson,
    isInsideNodeModule,
    createSystemBundlesConfig,
    createAppBundleConfig,
    findLibraryName,
    dependencySystemModulesFileToId,
    getDependencySystemModules,
    removePreviousSystemModules,
    getBundleCommonKeyForAppComponent,
    findLibraryMajorVersionWithModulePath,
    getSystemPrivateModulesPath,
    checkSystemBundleJsonMajorVersion,
    resolveModuleAlias,
    lazyComputeAliasName,
  };
} else {
  module.exports = {
    SYSTEM_MODULES_DIR,
    SYSTEM_LIBRARY_JSON,
    getSystemLibrariesJson,
    createSystemBundlesConfig,
    createAppBundleConfig,
  };
}

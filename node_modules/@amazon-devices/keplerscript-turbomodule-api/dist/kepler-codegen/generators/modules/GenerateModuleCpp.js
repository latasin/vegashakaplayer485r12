"use strict";
/**
 * Copyright (c) 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * PROPRIETARY/CONFIDENTIAL
 *
 * Use is subject to license terms.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
const RNCodegenUtils_1 = require("../../RNCodegenUtils");
const GenerateModuleSpecH_1 = require("./GenerateModuleSpecH");
const KeplerCxxUtils_1 = require("./KeplerCxxUtils");
/**
 * Creates a module implementation file.
 * One file can contain multiple modules.
 *
 * @param libraryName {string} The library name used for spec file naming.
 * @param modules {string[]} Array of module contents as strings.
 * @returns file spec code as string.
 */
const FileTemplate = (libraryName, cxxnamespace, nativeModule) => {
    return `/**
 * This code was generated by the Kepler Codegen tool.
 * 
 * It is provided as a starting template and can be modified.
 * 
 * @generated by GenerateModuleCpp.js
 */

#include "${libraryName}.h"

using namespace ${KeplerCxxUtils_1.TMAPINamespace};

namespace ${cxxnamespace} {

${nativeModule}

} // namespace ${cxxnamespace}
`;
};
/**
 * Creates an implementation template for an individual module.
 *
 * @param className {string} C++ class name of the module.
 * @param moduleProperties {string[]} Array of module properties (methods) as strings.
 * @returns module spec code as string.
 */
const ModuleImplTemplate = (className, moduleProperties) => {
    return `${className}::${className}() {}
${className}::~${className}() noexcept {};

${moduleProperties.join('\n\n')}`;
};
const CppImplTemplate = (className, resolveAlias, prop) => {
    return `${(0, GenerateModuleSpecH_1.translatePropertyToCpp)(className, prop, resolveAlias, false, false)} {
  // Your implementation here
  throw std::logic_error("Function not yet implemented");
}`;
};
/**
 * Transforms a Codegen Schema into a C++ Kepler Turbo Module .cpp template.
 *
 * @param libraryName {string} Used for the generated file name.
 * @param schema {SchemaType} The Kepler-annotated Codegen Schema for the library/modules.
 * @returns
 */
const generate = (metadata, moduleName, schema) => {
    const { aliasMap, spec: { properties }, } = schema;
    const { filePrefix, cxxnamespace, classname } = metadata;
    const resolveAlias = (0, RNCodegenUtils_1.createAliasResolver)(aliasMap);
    const filename = `${filePrefix}.cpp`;
    return {
        filename,
        contents: FileTemplate(filePrefix, cxxnamespace, ModuleImplTemplate(classname, properties.map((prop) => CppImplTemplate(classname, resolveAlias, prop)))),
        alwaysWrite: false,
    };
};
exports.default = generate;

"use strict";
/**
 * Copyright (c) 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * PROPRIETARY/CONFIDENTIAL
 *
 * Use is subject to license terms.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.translatePropertyToMethodAggregator = void 0;
const RNCodegenUtils_1 = require("../../RNCodegenUtils");
const KeplerCxxUtils_1 = require("./KeplerCxxUtils");
/**
 * Creates file-level SpecCpp.
 * One file can contain multiple modules.
 *
 * @param libraryName {string} The library name used for spec file naming.
 * @param modules {string[]} Array of module contents as strings.
 * @returns file spec code as string.
 */
const FileTemplate = (libraryName, cxxnamespace, nativeModule) => {
    return `/**
 * This code was generated by the Kepler Codegen tool.
 * 
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * when the code is regenerated.
 * 
 * @generated by GenerateModuleSpecCpp.js
 */

#include "${libraryName}Spec.h"

using namespace ${KeplerCxxUtils_1.TMAPINamespace};

namespace ${cxxnamespace} {

${nativeModule}

} // namespace ${cxxnamespace}
`;
};
/**
 * Creates spec implementation (ctor, aggregateMethods) for an individual module.
 *
 * @param className {string} C++ class name of the module.
 * @param moduleName {string} Name under which the module is registered.
 * @param moduleProperties {string[]} Array of module properties (methods) as strings.
 * @returns module spec code as string.
 */
const ModuleSpecImplTemplate = (className, moduleName, moduleProperties) => {
    return `${className}Spec::${className}Spec() : KeplerTurboModule("${moduleName}") {}

${className}Spec::~${className}Spec() = default;

void ${className}Spec::aggregateMethods(MethodAggregator<KeplerTurboModule>& methodAggregator) const noexcept {
  ${(0, RNCodegenUtils_1.indent)(moduleProperties.join('\n'), 2)}
}`;
};
/**
 * Translates a module property (method) from NativeModulePropertyShape to C++.
 *
 * @param className {string} C++ class name of the module.
 * @param prop {NativeModulePropertyShape} The property to be translated.
 * @returns A C++ signature for the property.
 */
const translatePropertyToMethodAggregator = (className, prop) => {
    return `methodAggregator.addMethod("${prop.name}", &${className}Spec::${prop.name});`;
};
exports.translatePropertyToMethodAggregator = translatePropertyToMethodAggregator;
/**
 * Transforms a Codegen Schema into a C++ Kepler Turbo Module Spec.cpp file.
 *
 * @param libraryName {string} Used for the generated file name.
 * @param schema {SchemaType} The Kepler-annotated Codegen Schema for the library/modules.
 * @returns
 */
const generate = (metadata, moduleName, schema) => {
    const { spec: { properties }, } = schema;
    const { filePrefix, cxxnamespace, classname } = metadata;
    const filename = `${filePrefix}Spec.cpp`;
    return {
        filename,
        contents: FileTemplate(filePrefix, cxxnamespace, ModuleSpecImplTemplate(classname, moduleName, properties.map((prop) => (0, exports.translatePropertyToMethodAggregator)(classname, prop)))),
        alwaysWrite: true,
    };
};
exports.default = generate;

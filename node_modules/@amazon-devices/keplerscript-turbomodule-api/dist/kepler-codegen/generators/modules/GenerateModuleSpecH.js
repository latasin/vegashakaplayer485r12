"use strict";
/**
 * Copyright (c) 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * PROPRIETARY/CONFIDENTIAL
 *
 * Use is subject to license terms.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.translatePropertyToCpp = void 0;
const RNCodegenUtils_1 = require("../../RNCodegenUtils");
const KeplerCxxUtils_1 = require("./KeplerCxxUtils");
const invariant_1 = require("../../../invariant/invariant");
/**
 * Creates file-level SpecH.
 * One file can contain multiple modules.
 *
 * @param modules {string[]} Array of module contents as strings.
 * @returns file spec code as string.
 */
const FileTemplate = (cxxnamespace, nativeModule) => {
    return `/**
 * This code was generated by the Kepler Codegen tool.
 * 
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * when the code is regenerated.
 * 
 * @generated by GenerateModuleSpecH.js
 */

#pragma once

#include <Kepler/turbomodule/ArrayBuffer.h>
#include <Kepler/turbomodule/Callback.h>
#include <Kepler/turbomodule/Error.h>
#include <Kepler/turbomodule/HostCallback.h>
#include <Kepler/turbomodule/JSValue.h>
#include <Kepler/turbomodule/KeplerTurboModule.h>
#include <Kepler/turbomodule/NativeObject.h>
#include <Kepler/turbomodule/Promise.h>
#include <Kepler/turbomodule/TMLog.h>

#include <string>
#include <vector>

namespace ${cxxnamespace} {

${nativeModule}

} // namespace ${cxxnamespace}
`;
};
/**
 * Creates spec for an individual module.
 *
 * @param className {string} C++ class name of the module.
 * @param moduleProperties {string[]} Array of module properties (methods) as strings.
 * @returns module spec code as string.
 */
const ModuleSpecTemplate = (className, moduleProperties) => {
    return `class ${className}Spec : public com::amazon::kepler::turbomodule::KeplerTurboModule {
protected:
  ${className}Spec();
  virtual ~${className}Spec() = 0;

public:
  void aggregateMethods(com::amazon::kepler::turbomodule::MethodAggregator<KeplerTurboModule>& methodAggregator) const noexcept override;

  ${(0, RNCodegenUtils_1.indent)(moduleProperties.join('\n'), 2)}
};`;
};
/**
 * Translates a module property (method) from NativeModulePropertyShape to C++ signature.
 *
 * @param className {string} The name of the C++ class.
 * @param prop {NativeModulePropertyShape} The property to be translated.
 * @param virtual {boolean} Whether to generate a pure virtual declaration. Defaults to true.
 * @param declaration {boolean} Whether to generate for declaration or implementation. Defaults to false.
 * @returns A C++ signature for the property.
 */
const translatePropertyToCpp = (className, prop, resolveAlias, virtual = true, declaration = true) => {
    const [propTypeAnnotation] = (0, RNCodegenUtils_1.unwrapNullable)(prop.typeAnnotation);
    const paramTypes = propTypeAnnotation.params.map((param) => {
        const translatedParam = (0, KeplerCxxUtils_1.translatePrimitiveJSTypeToCpp)(param.typeAnnotation, param.optional, true, (typeName) => `Unsupported type for param "${param.name}" in ${prop.name}. Found: ${typeName}`, resolveAlias);
        (0, KeplerCxxUtils_1.checkReservedNames)(param.name, (name) => `Invalid name for param "${param.name}" in ${prop.name}. "${param.name}" is reserved.`);
        return `${translatedParam} ${param.name}`;
    });
    const returnType = (0, KeplerCxxUtils_1.translatePrimitiveJSTypeToCpp)(propTypeAnnotation.returnTypeAnnotation, false, false, (typeName) => `Unsupported return type for ${prop.name}. Found: ${typeName}`, resolveAlias);
    (0, invariant_1.default)(!virtual || declaration, "Cannot have a pure virtual implementation");
    if (declaration) {
        const method = `${returnType} ${prop.name}(${paramTypes.join(', ')})`;
        if (virtual) {
            return `virtual ${method} = 0;`;
        }
        return `${method} override;`;
    }
    return `${returnType} ${className}::${prop.name}(${paramTypes.join(', ')})`;
};
exports.translatePropertyToCpp = translatePropertyToCpp;
/**
 * Transforms a Codegen Schema into a C++ Kepler Turbo Module Spec.h file.
 *
 * @param libraryName {string} Used for the generated file name.
 * @param schema {SchemaType} The Kepler-annotated Codegen Schema for the library/modules.
 * @returns
 */
const generate = (metadata, moduleName, schema) => {
    const { aliasMap, spec: { properties }, } = schema;
    const { filePrefix, cxxnamespace, classname } = metadata;
    const resolveAlias = (0, RNCodegenUtils_1.createAliasResolver)(aliasMap);
    const filename = `${filePrefix}Spec.h`;
    return {
        filename,
        contents: FileTemplate(cxxnamespace, ModuleSpecTemplate(classname, properties.map((prop) => (0, exports.translatePropertyToCpp)(classname, prop, resolveAlias)))),
        alwaysWrite: true,
    };
};
exports.default = generate;

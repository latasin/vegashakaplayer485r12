"use strict";
/*
 * Copyright 2021 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlexaManager = exports.AlexaManagerImpl = void 0;
const AlexaManagerTypes_1 = require("./AlexaManagerTypes");
const AlexaManagerSpec_1 = __importDefault(require("./spec/AlexaManagerSpec"));
class AlexaManagerImpl {
    start() {
        return this.getAlexaManagerStatus(AlexaManagerSpec_1.default.start());
    }
    stop() {
        return this.getAlexaManagerStatus(AlexaManagerSpec_1.default.stop());
    }
    registerDirectiveListener(callbacks) {
        return this.getAlexaManagerStatus(AlexaManagerSpec_1.default.registerDirectiveListener(callbacks.onPreHandleDirective, callbacks.onHandleDirective, callbacks.onCancelDirective));
    }
    registerStateProvider(avsNamespace, name) {
        return this.getAlexaManagerStatus(AlexaManagerSpec_1.default.registerStateProvider(avsNamespace, name));
    }
    unregisterStateProvider(avsNamespace, name) {
        return this.getAlexaManagerStatus(AlexaManagerSpec_1.default.unregisterStateProvider(avsNamespace, name));
    }
    sendResponse(directive, payload) {
        return this.getAlexaManagerStatus(AlexaManagerSpec_1.default.sendResponse(directive, payload));
    }
    sendDeferredResponse(directive, expectedDeferredInSeconds) {
        return this.getAlexaManagerStatus(AlexaManagerSpec_1.default.sendDeferredResponse(directive, expectedDeferredInSeconds));
    }
    sendErrorResponse(directive, errorType, errorMessage) {
        return this.getAlexaManagerStatus(AlexaManagerSpec_1.default.sendErrorResponse(directive, this.getAlexaErrorResponseType(errorType), errorMessage));
    }
    getAlexaErrorResponseType(errorType) {
        switch (errorType) {
            case AlexaManagerTypes_1.AlexaErrorResponseType.ALREADY_IN_OPERATION:
                return "ALREADY_IN_OPERATION";
            case AlexaManagerTypes_1.AlexaErrorResponseType.BRIDGE_UNREACHABLE:
                return "BRIDGE_UNREACHABLE";
            case AlexaManagerTypes_1.AlexaErrorResponseType.ENDPOINT_BUSY:
                return "ENDPOINT_BUSY";
            case AlexaManagerTypes_1.AlexaErrorResponseType.ENDPOINT_LOW_POWER:
                return "ENDPOINT_LOW_POWER";
            case AlexaManagerTypes_1.AlexaErrorResponseType.ENDPOINT_UNREACHABLE:
                return "ENDPOINT_UNREACHABLE";
            case AlexaManagerTypes_1.AlexaErrorResponseType.EXPIRED_AUTHORIZATION_CREDENTIAL:
                return "EXPIRED_AUTHORIZATION_CREDENTIAL";
            case AlexaManagerTypes_1.AlexaErrorResponseType.FIRMWARE_OUT_OF_DATE:
                return "FIRMWARE_OUT_OF_DATE";
            case AlexaManagerTypes_1.AlexaErrorResponseType.HARDWARE_MALFUNCTION:
                return "FIRMWARE_OUT_OF_DATE";
            case AlexaManagerTypes_1.AlexaErrorResponseType.INSUFFICIENT_PERMISSIONS:
                return "FIRMWARE_OUT_OF_DATE";
            case AlexaManagerTypes_1.AlexaErrorResponseType.INTERNAL_ERROR:
                return "INTERNAL_ERROR";
            case AlexaManagerTypes_1.AlexaErrorResponseType.INVALID_AUTHORIZATION_CREDENTIAL:
                return "INVALID_AUTHORIZATION_CREDENTIAL";
            case AlexaManagerTypes_1.AlexaErrorResponseType.INVALID_DIRECTIVE:
                return "INVALID_DIRECTIVE";
            case AlexaManagerTypes_1.AlexaErrorResponseType.INVALID_VALUE:
                return "INVALID_VALUE";
            case AlexaManagerTypes_1.AlexaErrorResponseType.NO_SUCH_ENDPOINT:
                return "NO_SUCH_ENDPOINT";
            case AlexaManagerTypes_1.AlexaErrorResponseType.NOT_CALIBRATED:
                return "NOT_CALIBRATED";
            case AlexaManagerTypes_1.AlexaErrorResponseType.NOT_SUPPORTED_IN_CURRENT_MODE:
                return "NOT_SUPPORTED_IN_CURRENT_MODE";
            case AlexaManagerTypes_1.AlexaErrorResponseType.NOT_IN_OPERATION:
                return "NOT_IN_OPERATION";
            case AlexaManagerTypes_1.AlexaErrorResponseType.POWER_LEVEL_NOT_SUPPORTED:
                return "POWER_LEVEL_NOT_SUPPORTED";
            case AlexaManagerTypes_1.AlexaErrorResponseType.RATE_LIMIT_EXCEEDED:
                return "RATE_LIMIT_EXCEEDED";
            case AlexaManagerTypes_1.AlexaErrorResponseType.TEMPERATURE_VALUE_OUT_OF_RANGE:
                return "TEMPERATURE_VALUE_OUT_OF_RANGE";
            default:
                return "VALUE_OUT_OF_RANGE";
        }
    }
    reportStateChange(avsNamespace, name, state, cause) {
        return this.getAlexaManagerStatus(AlexaManagerSpec_1.default.reportStateChange(avsNamespace, name, state, this.getAlexaStateChangeCauseType(cause)));
    }
    getAlexaStateChangeCauseType(cause) {
        switch (cause) {
            case AlexaManagerTypes_1.AlexaStateChangeCauseType.ALEXA_INTERACTION:
                return "ALEXA_INTERACTION";
            case AlexaManagerTypes_1.AlexaStateChangeCauseType.APP_INTERACTION:
                return "APP_INTERACTION";
            case AlexaManagerTypes_1.AlexaStateChangeCauseType.PHYSICAL_INTERACTION:
                return "PHYSICAL_INTERACTION";
            case AlexaManagerTypes_1.AlexaStateChangeCauseType.PERIODIC_POLL:
                return "PERIODIC_POLL";
            case AlexaManagerTypes_1.AlexaStateChangeCauseType.RULE_TRIGGER:
                return "RULE_TRIGGER";
            default:
                return "VOICE_INTERACTION";
        }
    }
    setCapabilities(capabilities) {
        for (let capability of capabilities) {
            if (!capability.configurations) {
                capability.configurations = "";
            }
        }
        return this.getAlexaManagerStatus(AlexaManagerSpec_1.default.setCapabilities(capabilities));
    }
    sendAvsEvent(avsNamespace, name, payload, dialogRequestId, interactionId) {
        const requestId = dialogRequestId ? dialogRequestId : "";
        const interactionIdTmp = interactionId ? interactionId : "";
        return this.getAlexaManagerStatus(AlexaManagerSpec_1.default.sendAvsEvent(avsNamespace, name, requestId, interactionIdTmp, payload));
    }
    getAlexaManagerStatus(alexaManagerStatus) {
        switch (alexaManagerStatus) {
            case "SUCCESS":
                return AlexaManagerTypes_1.AlexaManagerStatus.SUCCESS;
            case "BAD_PARAM_ERROR":
                return AlexaManagerTypes_1.AlexaManagerStatus.BAD_PARAM_ERROR;
            default:
                return AlexaManagerTypes_1.AlexaManagerStatus.GENERAL_ERROR;
        }
    }
}
exports.AlexaManagerImpl = AlexaManagerImpl;
exports.AlexaManager = new AlexaManagerImpl();

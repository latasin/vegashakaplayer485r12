"use strict";
/*
 * Copyright 2021-22 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useAddGamepadEventListenerCallback = exports.useAddHWEventListenerCallback = exports.useAddUserInputListenerCallback = exports.UserInputManager = exports.UserInputEventName = void 0;
const react_1 = require("react");
const UserInputManagerTurboModuleSpec_1 = __importDefault(require("./UserInputManagerTurboModuleSpec"));
const RootTag_1 = require("../ReactNative/RootTag");
var UserInputEventName;
(function (UserInputEventName) {
    UserInputEventName["Up"] = "UP";
    UserInputEventName["Down"] = "DOWN";
    UserInputEventName["Left"] = "LEFT";
    UserInputEventName["Right"] = "RIGHT";
    UserInputEventName["Select"] = "SELECT";
    UserInputEventName["PlayPause"] = "PLAYPAUSE";
    UserInputEventName["SkipForward"] = "SKIP_FORWARD";
    UserInputEventName["SkipBackward"] = "SKIP_BACKWARD";
    UserInputEventName["Back"] = "BACK";
    UserInputEventName["Menu"] = "MENU";
    UserInputEventName["PageUp"] = "PAGE_UP";
    UserInputEventName["PageDown"] = "PAGE_DOWN";
    UserInputEventName["PageLeft"] = "PAGE_LEFT";
    UserInputEventName["PageRight"] = "PAGE_RIGHT";
    UserInputEventName["More"] = "MORE";
    UserInputEventName["Info"] = "INFO";
})(UserInputEventName = exports.UserInputEventName || (exports.UserInputEventName = {}));
;
/**
 * @deprecated
 * An interface to subscribe for user input events of type `UserInputEventName`.
 */
class UserInputManager {
    /**
     * Register a listener for a given `UserInputEvent`.
     * @param {UserInputEventName} eventName - The event name to subscribe to.
     * @param {OnUserInputEventCallback} callback - Callback to be invoked when an event arrives. Return true from this
     * callback to indicate the consumer will handle the event. Return false from this callback to release control of
     * the event.
     * @return {EventSubscription} - A handle to the subscription. Call `remove()` to remove the subscription.
     */
    static addListener(eventName, callback) {
        // Callback to be invoked by native. This invokes the JS callback `callback`, and posts a response to the
        // turbo module indicating if this app will handle the event.
        const callbackInternal = (event) => {
            let handled = false;
            try {
                handled = callback(event) === true; // Coerce to boolean
            }
            catch (error) {
                console.error("UserInputManager - error in callback: ", error);
            }
            UserInputManagerTurboModuleSpec_1.default.postResponse(eventName, handled);
        };
        return UserInputManagerTurboModuleSpec_1.default.addUserInputListener(eventName, callbackInternal);
    }
    ;
    /**
     * Remove all listeners for all events.
     * @return {void}
     */
    static removeListeners() {
        UserInputManagerTurboModuleSpec_1.default.removeUserInputListeners();
    }
    ;
}
exports.UserInputManager = UserInputManager;
;
/**
 * @brief A custom hook that returns a callback that, when invoked, registers a listener for a given `UserInputEvent`.
 *
 *
 * @returns UserInputListenerCallback: a callback function to invoke to register a listener.
 *     @param {UserInputEventName} eventName - The event name to subscribe to.
 *     @param {OnUserInputEventCallback} callback - Callback to be invoked when an event arrives. Return true from this
 *     callback to indicate the consumer will handle the event. Return false from this callback to release control of
 *     the event.
 *     @returns {EventSubscription} - A handle to the subscription. Call `remove()` to remove the subscription.
 */
const useAddUserInputListenerCallback = () => {
    const rootTag = react_1.useContext(RootTag_1.RootTagContext);
    const createCallbackInternal = react_1.useCallback((callback) => {
        return (event) => {
            let handled = false;
            try {
                handled = callback(event) === true; // Coerce to boolean
            }
            catch (error) {
                console.error("UserInputManager - error in callback: ", error);
            }
            return handled;
        };
    }, []);
    return react_1.useMemo(() => {
        return (eventName, callback) => {
            const callbackInternal = createCallbackInternal(callback);
            const subscription = UserInputManagerTurboModuleSpec_1.default.addUserInputListenerV2(rootTag, eventName, (event) => {
                const handled = callbackInternal(event);
                UserInputManagerTurboModuleSpec_1.default.postResponse(eventName, handled);
            });
            return subscription;
        };
    }, [rootTag, createCallbackInternal]);
};
exports.useAddUserInputListenerCallback = useAddUserInputListenerCallback;
/**
 * @brief A custom hook that returns a callback that, when invoked, registers a listener for HWEvents.
 *
 * @returns HwEventListenerCallback: a callback function to invoke to register a listener.
 *     @param {OnHWEventCallback} callback - Callback to be invoked when an event arrives.
 *     @returns {EventSubscription} - A handle to the subscription. Call `remove()` to remove the subscription.
 */
const useAddHWEventListenerCallback = () => {
    const rootTag = react_1.useContext(RootTag_1.RootTagContext);
    return react_1.useCallback((callback) => {
        const callbackInternal = (event) => {
            try {
                callback(event);
            }
            catch (error) {
                console.error("TVEventHandler - error in callback: ", error);
            }
        };
        return UserInputManagerTurboModuleSpec_1.default.addTvEventListener(rootTag, callbackInternal);
    }, [rootTag]);
};
exports.useAddHWEventListenerCallback = useAddHWEventListenerCallback;
/**
 * @brief A custom hook that returns a callback that, when invoked, registers a listener for GamepadEvents.
 *
 * @returns GamepadEventListenerCallback: returna a callback function when invoked registers a listener.
 *     @param {OnGamepadEventCallback} callback - This callback will be invoked when an event arrives.
 *     @returns {EventSubscription} - A handle to the subscription. Call `remove()` to remove the subscription.
 */
const useAddGamepadEventListenerCallback = () => {
    const rootTag = react_1.useContext(RootTag_1.RootTagContext);
    return react_1.useCallback((callback) => {
        const callbackInternal = (event) => {
            try {
                callback(event);
            }
            catch (error) {
                console.error("GamepadEventHandler - error in callback: ", error);
            }
        };
        return UserInputManagerTurboModuleSpec_1.default.addGamepadEventListener(rootTag, callbackInternal);
    }, [rootTag]);
};
exports.useAddGamepadEventListenerCallback = useAddGamepadEventListenerCallback;

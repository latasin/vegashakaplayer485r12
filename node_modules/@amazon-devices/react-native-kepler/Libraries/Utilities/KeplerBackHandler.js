/*
* Copyright 2024 Amazon.com, Inc. or its affiliates. All rights reserved.
*
* AMAZON PROPRIETARY/CONFIDENTIAL
*
* You may not use this file except in compliance with the terms and
* conditions set forth in the accompanying LICENSE.TXT file.
*
* THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
* DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
* IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
*/
'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useKeplerBackHandler = void 0;
const react_1 = require("react");
const RootTag_1 = require("../ReactNative/RootTag");
const NativeDeviceEventManager_1 = __importDefault(require("../NativeModules/specs/NativeDeviceEventManager"));
const UserInputManager_1 = require("../UserInputManager/UserInputManager");
/**
 * rootTagToInstance is a Map that prevents
 * creation of multiple KeplerBackHandler instances for the same rootTag.
 * It stores the instance, subscriptions, instance count, and UserInputManager
 * listener subscription for each rootTag.
 */
const rootTagToInstance = new Map();
class KeplerBackHandlerImpl {
    constructor(rootTag, backPressSubscriptions) {
        this.#rootTag = rootTag;
        this._backPressSubscriptions = backPressSubscriptions;
    }
    #rootTag;
    exitApp() {
        if (!NativeDeviceEventManager_1.default) {
            return;
        }
        NativeDeviceEventManager_1.default.invokeDefaultBackPressHandlerByRootTag(this.#rootTag);
    }
    ;
    addEventListener(eventName, handler) {
        if (handler && typeof handler === 'function') {
            // Check if the handler already exists
            if (this._backPressSubscriptions.indexOf(handler) === -1) {
                this._backPressSubscriptions.push(handler);
            }
            else {
                console.warn('Existing listener could not be added more than once');
            }
        }
        return {
            remove: () => this.removeEventListener(eventName, handler),
        };
    }
    ;
    removeEventListener(eventName, handler) {
        if (this._backPressSubscriptions.indexOf(handler) !== -1) {
            this._backPressSubscriptions.splice(this._backPressSubscriptions.indexOf(handler), 1);
        }
    }
    ;
}
/**
 * Hook to return the KeplerBackHandler instance
 * Usage:
 * import { KeplerBackHandler, useKeplerBackHandler } from '@amazon-devices/react-native-kepler';
 * ...
 * const keplerBackHandler: KeplerBackHandler = useKeplerBackHandler();
 *  keplerBackHandler.exitApp();
 */
const useKeplerBackHandler = () => {
    const rootTag = react_1.useContext(RootTag_1.RootTagContext);
    const addUserInputListener = UserInputManager_1.useAddUserInputListenerCallback();
    const rootTagInstanceCallback = react_1.useCallback(() => {
        if (!rootTagToInstance.has(rootTag)) {
            const subscriptions = [];
            const instance = new KeplerBackHandlerImpl(rootTag, subscriptions);
            const listenerSubscription = addUserInputListener(UserInputManager_1.UserInputEventName.Back, function ({ phase }) {
                if (phase !== 'RELEASED') {
                    return false;
                }
                for (let i = subscriptions.length - 1; i >= 0; i--) {
                    if (subscriptions[i]()) {
                        return true;
                    }
                }
                console.log(`KeplerBackHandler triggering default behavior as no handler was added`);
                instance.exitApp();
                return false; // unreached
            });
            rootTagToInstance.set(rootTag, {
                instance,
                subscriptions,
                instanceCount: 1,
                listenerSubscription
            });
            console.debug(`KeplerBackHandler: Created new instance for rootTag ${rootTag}`);
        }
        else {
            const info = rootTagToInstance.get(rootTag);
            info.instanceCount++;
            console.debug(`KeplerBackHandler: increment instanceCount - ${info.instanceCount}`);
        }
        return rootTagToInstance.get(rootTag).instance;
    }, [rootTag, addUserInputListener]);
    const backHandlerInstance = rootTagInstanceCallback();
    react_1.useEffect(() => {
        return () => {
            const info = rootTagToInstance.get(rootTag);
            if (info) {
                info.instanceCount--;
                console.debug(`KeplerBackHandler: decrement instanceCount -  ${info.instanceCount}`);
                if (info.instanceCount === 0) {
                    // Removes the EventSubscription to UserInputManager when the last component
                    // from current rootTag unmounts 
                    info.listenerSubscription.remove();
                    rootTagToInstance.delete(rootTag);
                    console.debug(`KeplerBackHandler: Cleaned up EventSubscription listener for rootTag ${rootTag}`);
                }
            }
        };
    }, [rootTag]);
    return backHandlerInstance;
};
exports.useKeplerBackHandler = useKeplerBackHandler;

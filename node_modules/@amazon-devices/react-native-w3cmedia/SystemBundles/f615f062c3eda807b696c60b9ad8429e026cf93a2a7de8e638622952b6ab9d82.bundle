var __BUNDLE_START_TIME__=this.nativePerformanceNow?nativePerformanceNow():Date.now(),__DEV__=false,process=this.process||{},__METRO_GLOBAL_PREFIX__='';process.env=process.env||{};process.env.NODE_ENV=process.env.NODE_ENV||"production";
(function (global) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @polyfill
   * @nolint
   * @format
   */

  /* eslint-disable no-shadow, eqeqeq, curly, no-unused-vars, no-void, no-control-regex  */

  /**
   * This pipes all of our console logging functions to native logging so that
   * JavaScript errors in required modules show up in Xcode via NSLog.
   */
  var inspect = function () {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    //
    // https://github.com/joyent/node/blob/master/lib/util.js

    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        formatValueCalls: 0,
        stylize: stylizeNoColor
      };
      return formatValue(ctx, obj, opts.depth);
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function (val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      ctx.formatValueCalls++;
      if (ctx.formatValueCalls > 200) {
        return `[TOO BIG formatValueCalls ${ctx.formatValueCalls} exceeded limit of 200]`;
      }

      // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }

      // Look up the keys of the object.
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      // IE doesn't make error fields non-enumerable
      // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }

      // Some type of object without properties can be shortcutted.
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = '',
        array = false,
        braces = ['{', '}'];

      // Make Array say that they are Array
      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }

      // Make functions say that they are functions
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }

      // Make RegExps say that they are RegExps
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }

      // Make dates with properties first say the date
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }

      // Make error with message first say the error
      if (isError(value)) {
        base = ' ' + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function (key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value)) return ctx.stylize('' + value, 'number');
      if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
      // For some reason typeof null is "object", so special case here.
      if (isNull(value)) return ctx.stylize('null', 'null');
    }
    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
      };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function (line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function (line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }
      return name + ': ' + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function (prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }
      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.
    function isArray(ar) {
      return Array.isArray(ar);
    }
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    function isNull(arg) {
      return arg === null;
    }
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    function isString(arg) {
      return typeof arg === 'string';
    }
    function isUndefined(arg) {
      return arg === undefined;
    }
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    return inspect;
  }();
  var OBJECT_COLUMN_NAME = '(index)';
  var LOG_LEVELS = {
    trace: 0,
    info: 1,
    warn: 2,
    error: 3
  };
  var INSPECTOR_LEVELS = [];
  INSPECTOR_LEVELS[LOG_LEVELS.trace] = 'debug';
  INSPECTOR_LEVELS[LOG_LEVELS.info] = 'log';
  INSPECTOR_LEVELS[LOG_LEVELS.warn] = 'warning';
  INSPECTOR_LEVELS[LOG_LEVELS.error] = 'error';

  // Strip the inner function in getNativeLogFunction(), if in dev also
  // strip method printing to originalConsole.
  var INSPECTOR_FRAMES_TO_SKIP = 1;
  function getNativeLogFunction(level) {
    return function () {
      var str;
      if (arguments.length === 1 && typeof arguments[0] === 'string') {
        str = arguments[0];
      } else {
        str = Array.prototype.map.call(arguments, function (arg) {
          return inspect(arg, {
            depth: 10
          });
        }).join(', ');
      }

      // TRICKY
      // If more than one argument is provided, the code above collapses them all
      // into a single formatted string. This transform wraps string arguments in
      // single quotes (e.g. "foo" -> "'foo'") which then breaks the "Warning:"
      // check below. So it's important that we look at the first argument, rather
      // than the formatted argument string.
      var firstArg = arguments[0];
      var logLevel = level;
      if (typeof firstArg === 'string' && firstArg.slice(0, 9) === 'Warning: ' && logLevel >= LOG_LEVELS.error) {
        // React warnings use console.error so that a stack trace is shown,
        // but we don't (currently) want these to show a redbox
        // (Note: Logic duplicated in ExceptionsManager.js.)
        logLevel = LOG_LEVELS.warn;
      }
      if (global.__inspectorLog) {
        global.__inspectorLog(INSPECTOR_LEVELS[logLevel], str, [].slice.call(arguments), INSPECTOR_FRAMES_TO_SKIP);
      }
      if (groupStack.length) {
        str = groupFormat('', str);
      }
      global.nativeLoggingHook(str, logLevel);
    };
  }
  function repeat(element, n) {
    return Array.apply(null, Array(n)).map(function () {
      return element;
    });
  }
  function consoleTablePolyfill(rows) {
    // convert object -> array
    if (!Array.isArray(rows)) {
      var data = rows;
      rows = [];
      for (var key in data) {
        if (data.hasOwnProperty(key)) {
          var row = data[key];
          row[OBJECT_COLUMN_NAME] = key;
          rows.push(row);
        }
      }
    }
    if (rows.length === 0) {
      global.nativeLoggingHook('', LOG_LEVELS.info);
      return;
    }
    var columns = Object.keys(rows[0]).sort();
    var stringRows = [];
    var columnWidths = [];

    // Convert each cell to a string. Also
    // figure out max cell width for each column
    columns.forEach(function (k, i) {
      columnWidths[i] = k.length;
      for (var j = 0; j < rows.length; j++) {
        var cellStr = (rows[j][k] || '?').toString();
        stringRows[j] = stringRows[j] || [];
        stringRows[j][i] = cellStr;
        columnWidths[i] = Math.max(columnWidths[i], cellStr.length);
      }
    });

    // Join all elements in the row into a single string with | separators
    // (appends extra spaces to each cell to make separators  | aligned)
    function joinRow(row, space) {
      var cells = row.map(function (cell, i) {
        var extraSpaces = repeat(' ', columnWidths[i] - cell.length).join('');
        return cell + extraSpaces;
      });
      space = space || ' ';
      return cells.join(space + '|' + space);
    }
    var separators = columnWidths.map(function (columnWidth) {
      return repeat('-', columnWidth).join('');
    });
    var separatorRow = joinRow(separators, '-');
    var header = joinRow(columns);
    var table = [header, separatorRow];
    for (var i = 0; i < rows.length; i++) {
      table.push(joinRow(stringRows[i]));
    }

    // Notice extra empty line at the beginning.
    // Native logging hook adds "RCTLog >" at the front of every
    // logged string, which would shift the header and screw up
    // the table
    global.nativeLoggingHook('\n' + table.join('\n'), LOG_LEVELS.info);
  }
  var GROUP_PAD = "\u2502"; // Box light vertical
  var GROUP_OPEN = "\u2510"; // Box light down+left
  var GROUP_CLOSE = "\u2518"; // Box light up+left

  var groupStack = [];
  function groupFormat(prefix, msg) {
    // Insert group formatting before the console message
    return groupStack.join('') + prefix + ' ' + (msg || '');
  }
  function consoleGroupPolyfill(label) {
    global.nativeLoggingHook(groupFormat(GROUP_OPEN, label), LOG_LEVELS.info);
    groupStack.push(GROUP_PAD);
  }
  function consoleGroupCollapsedPolyfill(label) {
    global.nativeLoggingHook(groupFormat(GROUP_CLOSE, label), LOG_LEVELS.info);
    groupStack.push(GROUP_PAD);
  }
  function consoleGroupEndPolyfill() {
    groupStack.pop();
    global.nativeLoggingHook(groupFormat(GROUP_CLOSE), LOG_LEVELS.info);
  }
  function consoleAssertPolyfill(expression, label) {
    if (!expression) {
      global.nativeLoggingHook('Assertion failed: ' + label, LOG_LEVELS.error);
    }
  }
  if (global.nativeLoggingHook) {
    var originalConsole = global.console;
    // Preserve the original `console` as `originalConsole`

    global.console = {
      error: getNativeLogFunction(LOG_LEVELS.error),
      info: getNativeLogFunction(LOG_LEVELS.info),
      log: getNativeLogFunction(LOG_LEVELS.info),
      warn: getNativeLogFunction(LOG_LEVELS.warn),
      trace: getNativeLogFunction(LOG_LEVELS.trace),
      debug: getNativeLogFunction(LOG_LEVELS.trace),
      table: consoleTablePolyfill,
      group: consoleGroupPolyfill,
      groupEnd: consoleGroupEndPolyfill,
      groupCollapsed: consoleGroupCollapsedPolyfill,
      assert: consoleAssertPolyfill
    };
    Object.defineProperty(console, '_isPolyfilled', {
      value: true,
      enumerable: false
    });

    // If available, also call the original `console` method since that is
    // sometimes useful. Ex: on OS X, this will let you see rich output in
    // the Safari Web Inspector console.
  } else if (!global.console) {
    var stub = function stub() {};
    var log = global.print || stub;
    global.console = {
      debug: log,
      error: log,
      info: log,
      log: log,
      trace: log,
      warn: log,
      assert: function assert(expression, label) {
        if (!expression) {
          log('Assertion failed: ' + label);
        }
      },
      clear: stub,
      dir: stub,
      dirxml: stub,
      group: stub,
      groupCollapsed: stub,
      groupEnd: stub,
      profile: stub,
      profileEnd: stub,
      table: stub
    };
    Object.defineProperty(console, '_isPolyfilled', {
      value: true,
      enumerable: false
    });
  }
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   * @polyfill
   */

  var _inGuard = 0;
  /**
   * This is the error handler that is called when we encounter an exception
   * when loading a module. This will report any errors encountered before
   * ExceptionsManager is configured.
   */
  var _globalHandler = function onError(e, isFatal) {
    throw e;
  };

  /**
   * The particular require runtime that we are using looks for a global
   * `ErrorUtils` object and if it exists, then it requires modules with the
   * error handler specified via ErrorUtils.setGlobalHandler by calling the
   * require function with applyWithGuard. Since the require module is loaded
   * before any of the modules, this ErrorUtils must be defined (and the handler
   * set) globally before requiring anything.
   */
  var ErrorUtils = {
    setGlobalHandler: function setGlobalHandler(fun) {
      _globalHandler = fun;
    },
    getGlobalHandler: function getGlobalHandler() {
      return _globalHandler;
    },
    reportError: function reportError(error) {
      _globalHandler && _globalHandler(error, false);
    },
    reportFatalError: function reportFatalError(error) {
      // NOTE: This has an untyped call site in Metro.
      _globalHandler && _globalHandler(error, true);
    },
    applyWithGuard: function applyWithGuard(fun, context, args,
    // Unused, but some code synced from www sets it to null.
    unused_onError,
    // Some callers pass a name here, which we ignore.
    unused_name) {
      try {
        _inGuard++;
        /* $FlowFixMe[incompatible-call] : TODO T48204745 (1) apply(context,
         * null) is fine. (2) array -> rest array should work */
        /* $FlowFixMe[incompatible-type] : TODO T48204745 (1) apply(context,
         * null) is fine. (2) array -> rest array should work */
        return fun.apply(context, args);
      } catch (e) {
        ErrorUtils.reportError(e);
      } finally {
        _inGuard--;
      }
      return null;
    },
    applyWithGuardIfNeeded: function applyWithGuardIfNeeded(fun, context, args) {
      if (ErrorUtils.inGuard()) {
        /* $FlowFixMe[incompatible-call] : TODO T48204745 (1) apply(context,
         * null) is fine. (2) array -> rest array should work */
        /* $FlowFixMe[incompatible-type] : TODO T48204745 (1) apply(context,
         * null) is fine. (2) array -> rest array should work */
        return fun.apply(context, args);
      } else {
        ErrorUtils.applyWithGuard(fun, context, args);
      }
      return null;
    },
    inGuard: function inGuard() {
      return !!_inGuard;
    },
    guard: function guard(fun, name, context) {
      var _ref;
      // TODO: (moti) T48204753 Make sure this warning is never hit and remove it - types
      // should be sufficient.
      if (typeof fun !== 'function') {
        console.warn('A function must be passed to ErrorUtils.guard, got ', fun);
        return null;
      }
      var guardName = (_ref = name != null ? name : fun.name) != null ? _ref : '<generated guard>';
      /* $FlowFixMe[missing-this-annot] The 'this' type annotation(s) required by
       * Flow's LTI update could not be added via codemod */
      function guarded() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return ErrorUtils.applyWithGuard(fun, context != null ? context : this, args, null, guardName);
      }
      return guarded;
    }
  };
  global.ErrorUtils = ErrorUtils;
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * @polyfill
   * @nolint
   */

  (function () {
    'use strict';

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    /**
     * Returns an array of the given object's own enumerable entries.
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries
     */
    if (typeof Object.entries !== 'function') {
      Object.entries = function (object) {
        // `null` and `undefined` values are not allowed.
        if (object == null) {
          throw new TypeError('Object.entries called on non-object');
        }
        var entries = [];
        for (var key in object) {
          if (hasOwnProperty.call(object, key)) {
            entries.push([key, object[key]]);
          }
        }
        return entries;
      };
    }

    /**
     * Returns an array of the given object's own enumerable entries.
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values
     */
    if (typeof Object.values !== 'function') {
      Object.values = function (object) {
        // `null` and `undefined` values are not allowed.
        if (object == null) {
          throw new TypeError('Object.values called on non-object');
        }
        var values = [];
        for (var key in object) {
          if (hasOwnProperty.call(object, key)) {
            values.push(object[key]);
          }
        }
        return values;
      };
    }
  })();
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2022-2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KeplerMediaControlHandler = exports.VTTCue = exports.decodingInfo = exports.TextDecoder = exports.AudioContentType = exports.AudioUsageType = exports.KeplerVideoView = exports.KeplerShareableSurfaceView = exports.KeplerVideoSurfaceView = exports.KeplerCaptionsView = exports.WebCrypto = exports.W3CMediaTurboModule = exports.QuotaExceededError = exports.InvalidStateError = exports.NotSupportedError = exports.W3CLibPolyfill = exports.requestMediaKeysSystemAccess = exports.requestMediaKeySystemAccess = exports.TrackEvent = exports.Event = exports.HTMLAudioElement = exports.HTMLVideoElement = exports.HTMLMediaElement = exports.EndOfStreamError = exports.ReadyState = exports.AppendMode = exports.SourceBufferImpl = exports.MediaSource = exports.VideoPlayer = exports.AudioPlayer = exports.Video = exports.Audio = exports.Media = undefined;
  Object.defineProperty(exports, "KeplerCaptionsView", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[0]).KeplerCaptionsView;
    }
  });
  Object.defineProperty(exports, "KeplerVideoSurfaceView", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1]).KeplerVideoSurfaceView;
    }
  });
  Object.defineProperty(exports, "KeplerShareableSurfaceView", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[2]).KeplerShareableSurfaceView;
    }
  });
  Object.defineProperty(exports, "KeplerVideoView", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[3]).KeplerVideoView;
    }
  });
  Object.defineProperty(exports, "requestMediaKeysSystemAccess", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[4]).requestMediaKeysSystemAccess;
    }
  });
  Object.defineProperty(exports, "requestMediaKeySystemAccess", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[4]).requestMediaKeySystemAccess;
    }
  });
  Object.defineProperty(exports, "Audio", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[5]).Audio;
    }
  });
  Object.defineProperty(exports, "AudioPlayer", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[6]).AudioPlayer;
    }
  });
  Object.defineProperty(exports, "SourceBufferImpl", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[7]).SourceBufferImpl;
    }
  });
  Object.defineProperty(exports, "InvalidStateError", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[8]).InvalidStateError;
    }
  });
  Object.defineProperty(exports, "NotSupportedError", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[8]).NotSupportedError;
    }
  });
  Object.defineProperty(exports, "QuotaExceededError", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[9]).QuotaExceededError;
    }
  });
  Object.defineProperty(exports, "Event", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[10]).Event;
    }
  });
  Object.defineProperty(exports, "TrackEvent", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[10]).TrackEvent;
    }
  });
  Object.defineProperty(exports, "HTMLAudioElement", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[11]).HTMLAudioElement;
    }
  });
  Object.defineProperty(exports, "HTMLMediaElement", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[11]).HTMLMediaElement;
    }
  });
  Object.defineProperty(exports, "HTMLVideoElement", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[11]).HTMLVideoElement;
    }
  });
  Object.defineProperty(exports, "MediaSource", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[12]).MediaSource;
    }
  });
  Object.defineProperty(exports, "AppendMode", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[13]).AppendMode;
    }
  });
  Object.defineProperty(exports, "EndOfStreamError", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[13]).EndOfStreamError;
    }
  });
  Object.defineProperty(exports, "ReadyState", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[13]).ReadyState;
    }
  });
  // temporary till we import from audio turbo module

  Object.defineProperty(exports, "AudioContentType", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[14]).AudioContentType;
    }
  });
  Object.defineProperty(exports, "AudioUsageType", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[14]).AudioUsageType;
    }
  });
  Object.defineProperty(exports, "Video", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[15]).Video;
    }
  });
  Object.defineProperty(exports, "VideoPlayer", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[16]).VideoPlayer;
    }
  });
  Object.defineProperty(exports, "Media", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[17]).Media;
    }
  });
  Object.defineProperty(exports, "W3CLibPolyfill", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[18]).W3CLibPolyfill;
    }
  });
  var W3CMediaTurboModule_1 = __importDefault(_$$_REQUIRE(_dependencyMap[19]));
  exports.W3CMediaTurboModule = W3CMediaTurboModule_1.default;
  Object.defineProperty(exports, "WebCrypto", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[20]).WebCrypto;
    }
  });
  Object.defineProperty(exports, "TextDecoder", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[21]).TextDecoder;
    }
  });
  Object.defineProperty(exports, "KeplerMediaControlHandler", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[22]).KeplerMediaControlHandler;
    }
  });
  Object.defineProperty(exports, "decodingInfo", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[23]).decodingInfo;
    }
  });
  Object.defineProperty(exports, "VTTCue", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[24]).VTTCue;
    }
  });
},"4f0744bbc30ce876f435",["0d9a17d8c6f7cb480e97","d280120de7a05ead75ef","0d7ab8d53799eecfef8c","9d5e7fd998ee3b3e6c71","7d1995a852866a3b5fa6","a5190f43c80aab78cbe5","866b49a5fba376b39fa2","d2e0db98724a97dd6b88","7f2298a3ae35e640412a","28b38b2de31c42119bdb","9e1e5e085598ef3ad539","27520dc71d42ce3c8e40","559b56212f65a51c1441","8ee67effabd3f8c12ca2","4bdd62aa245a27756882","9b23a320fef664e25c6c","a87dff82c61137f9b60f","372fa0c50373b8a1a1df","34a672321d3ccd75ade3","0814a269c2fb50034991","afece82566356eb3a892","3b51620f399f61cbe14a","0b93a73a8c0720588336","1c87679747a7f044c554","a13467c443d8b8a7e966"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2023 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  function _callSuper(t, o, e) { return o = _$$_REQUIRE(_dependencyMap[0])(o), _$$_REQUIRE(_dependencyMap[1])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _$$_REQUIRE(_dependencyMap[0])(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KeplerCaptionsView = undefined;
  var React = __importStar(_$$_REQUIRE(_dependencyMap[2]));
  var react_native_1 = _$$_REQUIRE(_dependencyMap[3]);
  var KeplerCaptionsViewSpec_1 = __importDefault(_$$_REQUIRE(_dependencyMap[4]));
  var styles = react_native_1.StyleSheet.create({
    base: {
      flexGrow: 1,
      flexShrink: 1
    }
  });
  ;
  /**
   * @brief This is a react native component that closed captions and subtitles on the
   * screen. Use the component only when operating in pre-buffering mode using `VideoPlayer`
   * and `AudioPlayer` components.
  
   * Apps attach the captions handle passed by `onCaptionViewCreated` event callback to
   * the `VideoPlayer` & `AudioPlayer` by calling the `setCaptionViewHandle` function so that
   * the player is able to render captions or subtitles on screen.
   */
  var KeplerCaptionsView = /*#__PURE__*/function (_React$Component) {
    function KeplerCaptionsView(props) {
      _$$_REQUIRE(_dependencyMap[5])(this, KeplerCaptionsView);
      return _callSuper(this, KeplerCaptionsView, [props]);
    }
    /**
     * @hidden
     */
    _$$_REQUIRE(_dependencyMap[6])(KeplerCaptionsView, _React$Component);
    return _$$_REQUIRE(_dependencyMap[7])(KeplerCaptionsView, [{
      key: "render",
      value: function render() {
        var _this$props$show;
        var _this$props = this.props,
          style = _this$props.style,
          _onCaptionViewCreated = _this$props.onCaptionViewCreated;
        _$$_REQUIRE(_dependencyMap[8]).LogUtil.info('render KeplerCaptionsView');
        return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[9]).jsx(KeplerCaptionsViewSpec_1.default, {
          onCaptionViewCreated: function onCaptionViewCreated(ev) {
            _$$_REQUIRE(_dependencyMap[8]).LogUtil.info('got the caption consumer in CaptionWindow');
            _onCaptionViewCreated == null ? undefined : _onCaptionViewCreated(ev.nativeEvent.value);
          },
          show: (_this$props$show = this.props.show) != null ? _this$props$show : true,
          style: [styles.base, style]
        });
      }
    }]);
  }(React.Component);
  exports.KeplerCaptionsView = KeplerCaptionsView;
  ;
},"0d9a17d8c6f7cb480e97",["f391b9d534c3a6bc8659","4534eb96ece5e83c089a","6ed0e34da2b23bd3554f","26ef620f86acf7f6932a","03a3f998e1368ca874e1","3508abd8c6b891008c0d","73afcd34a88a750f6d69","5533cec96f6a88041c69","1f12e7e43345228dfcad","048fed5a64a04bdb7fed"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _getPrototypeOf(t) {
    return module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _getPrototypeOf(t);
  }
  module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"f391b9d534c3a6bc8659",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _possibleConstructorReturn(t, e) {
    if (e && ("object" == _$$_REQUIRE(_dependencyMap[0])["default"](e) || "function" == typeof e)) return e;
    if (undefined !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return _$$_REQUIRE(_dependencyMap[1])(t);
  }
  module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"4534eb96ece5e83c089a",["d8362e1f4a4e80eaa9d4","3711e54376de5c9b9466"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _typeof(o) {
    "@babel/helpers - typeof";

    return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
  }
  module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"d8362e1f4a4e80eaa9d4",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _assertThisInitialized(e) {
    if (undefined === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"3711e54376de5c9b9466",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
      "default": e
    };
  }
  module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"f9cae617a85336004da4",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _toConsumableArray(r) {
    return _$$_REQUIRE(_dependencyMap[0])(r) || _$$_REQUIRE(_dependencyMap[1])(r) || _$$_REQUIRE(_dependencyMap[2])(r) || _$$_REQUIRE(_dependencyMap[3])();
  }
  module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"45888e56a711ad3d0182",["039d69e301d834fc57a3","87859f449f82e5321677","6c4e399b76abfb11b5e1","ad214602743714c9688f"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return _$$_REQUIRE(_dependencyMap[0])(r);
  }
  module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"039d69e301d834fc57a3",["63d01cf8405575b80957"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"63d01cf8405575b80957",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
  }
  module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"87859f449f82e5321677",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) return _$$_REQUIRE(_dependencyMap[0])(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _$$_REQUIRE(_dependencyMap[0])(r, a) : undefined;
    }
  }
  module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"6c4e399b76abfb11b5e1",["63d01cf8405575b80957"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"ad214602743714c9688f",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
  }
  module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"3508abd8c6b891008c0d",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _defineProperties(e, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _$$_REQUIRE(_dependencyMap[0])(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
      writable: false
    }), e;
  }
  module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"5533cec96f6a88041c69",["a8c8780df4560174ada7"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function toPropertyKey(t) {
    var i = _$$_REQUIRE(_dependencyMap[0])(t, "string");
    return "symbol" == _$$_REQUIRE(_dependencyMap[1])["default"](i) ? i : i + "";
  }
  module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"a8c8780df4560174ada7",["ffc6df13d33bb305555d","d8362e1f4a4e80eaa9d4"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function toPrimitive(t, r) {
    if ("object" != _$$_REQUIRE(_dependencyMap[0])["default"](t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (undefined !== e) {
      var i = e.call(t, r || "default");
      if ("object" != _$$_REQUIRE(_dependencyMap[0])["default"](i)) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"ffc6df13d33bb305555d",["d8362e1f4a4e80eaa9d4"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use strict';

  /**
   * Use invariant() to assert state which your program assumes to be true.
   *
   * Provide sprintf-style format (only %s is supported) and arguments
   * to provide information about what broke and what you were
   * expecting.
   *
   * The invariant message will be stripped in production, but the invariant
   * will remain to ensure logic does not differ in production.
   */
  var invariant = function invariant(condition, format, a, b, c, d, e, f) {
    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }
      error.framesToPop = 1; // we don't care about invariant's own frame
      throw error;
    }
  };
  module.exports = invariant;
},"fd099686726b2dfb6f66",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _slicedToArray(r, e) {
    return _$$_REQUIRE(_dependencyMap[0])(r) || _$$_REQUIRE(_dependencyMap[1])(r, e) || _$$_REQUIRE(_dependencyMap[2])(r, e) || _$$_REQUIRE(_dependencyMap[3])();
  }
  module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"606f5f734809feae52ba",["76b27769c179b48d59c3","4a2ce36b8c165946053f","6c4e399b76abfb11b5e1","1bd488cacdc8afd3a0e3"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
  }
  module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"76b27769c179b48d59c3",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e,
        n,
        i,
        u,
        a = [],
        f = true,
        o = false;
      try {
        if (i = (t = t.call(r)).next, 0 === l) {
          if (Object(t) !== t) return;
          f = false;
        } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true);
      } catch (r) {
        o = true, n = r;
      } finally {
        try {
          if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }
  module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"4a2ce36b8c165946053f",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"1bd488cacdc8afd3a0e3",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function nullthrows(x, message) {
    if (x != null) {
      return x;
    }
    var error = new Error(message !== undefined ? message : 'Got unexpected ' + x);
    error.framesToPop = 1; // Skip nullthrows's own stack frame.
    throw error;
  }
  module.exports = nullthrows;
  module.exports.default = nullthrows;
  Object.defineProperty(module.exports, '__esModule', {
    value: true
  });
},"afd4874b36ccd4e13961",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _inherits(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t,
        writable: true,
        configurable: true
      }
    }), Object.defineProperty(t, "prototype", {
      writable: false
    }), e && _$$_REQUIRE(_dependencyMap[0])(t, e);
  }
  module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"73afcd34a88a750f6d69",["412b42f29118fbec0d03"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _setPrototypeOf(t, e) {
    return module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
      return t.__proto__ = e, t;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _setPrototypeOf(t, e);
  }
  module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"412b42f29118fbec0d03",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _readOnlyError(r) {
    throw new TypeError('"' + r + '" is read-only');
  }
  module.exports = _readOnlyError, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"a5c40d8e2e66747ea59e",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _wrapNativeSuper(t) {
    var r = "function" == typeof Map ? new Map() : undefined;
    return module.exports = _wrapNativeSuper = function _wrapNativeSuper(t) {
      if (null === t || !_$$_REQUIRE(_dependencyMap[0])(t)) return t;
      if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
      if (undefined !== r) {
        if (r.has(t)) return r.get(t);
        r.set(t, Wrapper);
      }
      function Wrapper() {
        return _$$_REQUIRE(_dependencyMap[1])(t, arguments, _$$_REQUIRE(_dependencyMap[2])(this).constructor);
      }
      return Wrapper.prototype = Object.create(t.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      }), _$$_REQUIRE(_dependencyMap[3])(Wrapper, t);
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _wrapNativeSuper(t);
  }
  module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"c577b02e1e09b9cd815b",["027ec73415f080702349","980562e5188f0e886758","f391b9d534c3a6bc8659","412b42f29118fbec0d03"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _isNativeFunction(t) {
    try {
      return -1 !== Function.toString.call(t).indexOf("[native code]");
    } catch (n) {
      return "function" == typeof t;
    }
  }
  module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"027ec73415f080702349",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _construct(t, e, r) {
    if (_$$_REQUIRE(_dependencyMap[0])()) return Reflect.construct.apply(null, arguments);
    var o = [null];
    o.push.apply(o, e);
    var p = new (t.bind.apply(t, o))();
    return r && _$$_REQUIRE(_dependencyMap[1])(p, r.prototype), p;
  }
  module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"980562e5188f0e886758",["d5efa6dd0bb9d4bf9bb4","412b42f29118fbec0d03"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    } catch (t) {}
    return (module.exports = _isNativeReflectConstruct = function _isNativeReflectConstruct() {
      return !!t;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
  }
  module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"d5efa6dd0bb9d4bf9bb4",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  var UNKNOWN_FUNCTION = '<unknown>';
  /**
   * This parses the different stack traces and puts them into one format
   * This borrows heavily from TraceKit (https://github.com/csnover/TraceKit)
   */

  function parse(stackString) {
    var lines = stackString.split('\n');
    return lines.reduce(function (stack, line) {
      var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);
      if (parseResult) {
        stack.push(parseResult);
      }
      return stack;
    }, []);
  }
  var chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  var chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  function parseChrome(line) {
    var parts = chromeRe.exec(line);
    if (!parts) {
      return null;
    }
    var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line

    var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line

    var submatch = chromeEvalRe.exec(parts[2]);
    if (isEval && submatch != null) {
      // throw out eval line/column and use top-most line/column number
      parts[2] = submatch[1]; // url

      parts[3] = submatch[2]; // line

      parts[4] = submatch[3]; // column
    }
    return {
      file: !isNative ? parts[2] : null,
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: isNative ? [parts[2]] : [],
      lineNumber: parts[3] ? +parts[3] : null,
      column: parts[4] ? +parts[4] : null
    };
  }
  var winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  function parseWinjs(line) {
    var parts = winjsRe.exec(line);
    if (!parts) {
      return null;
    }
    return {
      file: parts[2],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: [],
      lineNumber: +parts[3],
      column: parts[4] ? +parts[4] : null
    };
  }
  var geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
  var geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
  function parseGecko(line) {
    var parts = geckoRe.exec(line);
    if (!parts) {
      return null;
    }
    var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
    var submatch = geckoEvalRe.exec(parts[3]);
    if (isEval && submatch != null) {
      // throw out eval line/column and use top-most line number
      parts[3] = submatch[1];
      parts[4] = submatch[2];
      parts[5] = null; // no column when eval
    }
    return {
      file: parts[3],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: parts[2] ? parts[2].split(',') : [],
      lineNumber: parts[4] ? +parts[4] : null,
      column: parts[5] ? +parts[5] : null
    };
  }
  var javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
  function parseJSC(line) {
    var parts = javaScriptCoreRe.exec(line);
    if (!parts) {
      return null;
    }
    return {
      file: parts[3],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: [],
      lineNumber: +parts[4],
      column: parts[5] ? +parts[5] : null
    };
  }
  var nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  function parseNode(line) {
    var parts = nodeRe.exec(line);
    if (!parts) {
      return null;
    }
    return {
      file: parts[2],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: [],
      lineNumber: +parts[3],
      column: parts[4] ? +parts[4] : null
    };
  }
  exports.parse = parse;
},"aa725aa4c0b37e1add33",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = _$$_REQUIRE(_dependencyMap[0]);
  _$$_REQUIRE(_dependencyMap[0]).prototype.finally = function (f) {
    return this.then(function (value) {
      return _$$_REQUIRE(_dependencyMap[0]).resolve(f()).then(function () {
        return value;
      });
    }, function (err) {
      return _$$_REQUIRE(_dependencyMap[0]).resolve(f()).then(function () {
        throw err;
      });
    });
  };
},"15bc4ccb25fc2d0c4428",["890f60fa94d3f6854a19"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function noop() {}

  // States:
  //
  // 0 - pending
  // 1 - fulfilled with _value
  // 2 - rejected with _value
  // 3 - adopted the state of another promise, _value
  //
  // once the state is no longer pending (0) it is immutable

  // All `_` prefixed properties will be reduced to `_{random number}`
  // at build time to obfuscate them and discourage their use.
  // We don't use symbols or Object.defineProperty to fully hide them
  // because the performance isn't good enough.

  // to avoid using try/catch inside critical functions, we
  // extract them to here.
  var LAST_ERROR = null;
  var IS_ERROR = {};
  function getThen(obj) {
    try {
      return obj.then;
    } catch (ex) {
      LAST_ERROR = ex;
      return IS_ERROR;
    }
  }
  function tryCallOne(fn, a) {
    try {
      return fn(a);
    } catch (ex) {
      LAST_ERROR = ex;
      return IS_ERROR;
    }
  }
  function tryCallTwo(fn, a, b) {
    try {
      fn(a, b);
    } catch (ex) {
      LAST_ERROR = ex;
      return IS_ERROR;
    }
  }
  module.exports = Promise;
  function Promise(fn) {
    if (typeof this !== 'object') {
      throw new TypeError('Promises must be constructed via new');
    }
    if (typeof fn !== 'function') {
      throw new TypeError('Promise constructor\'s argument is not a function');
    }
    this._x = 0;
    this._y = 0;
    this._z = null;
    this._A = null;
    if (fn === noop) return;
    doResolve(fn, this);
  }
  Promise._B = null;
  Promise._C = null;
  Promise._D = noop;
  Promise.prototype.then = function (onFulfilled, onRejected) {
    if (this.constructor !== Promise) {
      return safeThen(this, onFulfilled, onRejected);
    }
    var res = new Promise(noop);
    handle(this, new Handler(onFulfilled, onRejected, res));
    return res;
  };
  function safeThen(self, onFulfilled, onRejected) {
    return new self.constructor(function (resolve, reject) {
      var res = new Promise(noop);
      res.then(resolve, reject);
      handle(self, new Handler(onFulfilled, onRejected, res));
    });
  }
  function handle(self, deferred) {
    while (self._y === 3) {
      self = self._z;
    }
    if (Promise._B) {
      Promise._B(self);
    }
    if (self._y === 0) {
      if (self._x === 0) {
        self._x = 1;
        self._A = deferred;
        return;
      }
      if (self._x === 1) {
        self._x = 2;
        self._A = [self._A, deferred];
        return;
      }
      self._A.push(deferred);
      return;
    }
    handleResolved(self, deferred);
  }
  function handleResolved(self, deferred) {
    setImmediate(function () {
      var cb = self._y === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        if (self._y === 1) {
          resolve(deferred.promise, self._z);
        } else {
          reject(deferred.promise, self._z);
        }
        return;
      }
      var ret = tryCallOne(cb, self._z);
      if (ret === IS_ERROR) {
        reject(deferred.promise, LAST_ERROR);
      } else {
        resolve(deferred.promise, ret);
      }
    });
  }
  function resolve(self, newValue) {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self) {
      return reject(self, new TypeError('A promise cannot be resolved with itself.'));
    }
    if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
      var then = getThen(newValue);
      if (then === IS_ERROR) {
        return reject(self, LAST_ERROR);
      }
      if (then === self.then && newValue instanceof Promise) {
        self._y = 3;
        self._z = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(then.bind(newValue), self);
        return;
      }
    }
    self._y = 1;
    self._z = newValue;
    finale(self);
  }
  function reject(self, newValue) {
    self._y = 2;
    self._z = newValue;
    if (Promise._C) {
      Promise._C(self, newValue);
    }
    finale(self);
  }
  function finale(self) {
    if (self._x === 1) {
      handle(self, self._A);
      self._A = null;
    }
    if (self._x === 2) {
      for (var i = 0; i < self._A.length; i++) {
        handle(self, self._A[i]);
      }
      self._A = null;
    }
  }
  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, promise) {
    var done = false;
    var res = tryCallTwo(fn, function (value) {
      if (done) return;
      done = true;
      resolve(promise, value);
    }, function (reason) {
      if (done) return;
      done = true;
      reject(promise, reason);
    });
    if (!done && res === IS_ERROR) {
      done = true;
      reject(promise, LAST_ERROR);
    }
  }
},"890f60fa94d3f6854a19",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  //This file contains the ES6 extensions to the core Promises/A+ API
  module.exports = _$$_REQUIRE(_dependencyMap[0]);

  /* Static Functions */

  var TRUE = valuePromise(true);
  var FALSE = valuePromise(false);
  var NULL = valuePromise(null);
  var UNDEFINED = valuePromise(undefined);
  var ZERO = valuePromise(0);
  var EMPTYSTRING = valuePromise('');
  function valuePromise(value) {
    var p = new (_$$_REQUIRE(_dependencyMap[0]))(_$$_REQUIRE(_dependencyMap[0])._D);
    p._y = 1;
    p._z = value;
    return p;
  }
  _$$_REQUIRE(_dependencyMap[0]).resolve = function (value) {
    if (value instanceof _$$_REQUIRE(_dependencyMap[0])) return value;
    if (value === null) return NULL;
    if (value === undefined) return UNDEFINED;
    if (value === true) return TRUE;
    if (value === false) return FALSE;
    if (value === 0) return ZERO;
    if (value === '') return EMPTYSTRING;
    if (typeof value === 'object' || typeof value === 'function') {
      try {
        var then = value.then;
        if (typeof then === 'function') {
          return new (_$$_REQUIRE(_dependencyMap[0]))(then.bind(value));
        }
      } catch (ex) {
        return new (_$$_REQUIRE(_dependencyMap[0]))(function (resolve, reject) {
          reject(ex);
        });
      }
    }
    return valuePromise(value);
  };
  var _iterableToArray = function iterableToArray(iterable) {
    if (typeof Array.from === 'function') {
      // ES2015+, iterables exist
      _iterableToArray = Array.from;
      return Array.from(iterable);
    }

    // ES5, only arrays and array-likes exist
    _iterableToArray = function iterableToArray(x) {
      return Array.prototype.slice.call(x);
    };
    return Array.prototype.slice.call(iterable);
  };
  _$$_REQUIRE(_dependencyMap[0]).all = function (arr) {
    var args = _iterableToArray(arr);
    return new (_$$_REQUIRE(_dependencyMap[0]))(function (resolve, reject) {
      if (args.length === 0) return resolve([]);
      var remaining = args.length;
      function res(i, val) {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          if (val instanceof _$$_REQUIRE(_dependencyMap[0]) && val.then === _$$_REQUIRE(_dependencyMap[0]).prototype.then) {
            while (val._y === 3) {
              val = val._z;
            }
            if (val._y === 1) return res(i, val._z);
            if (val._y === 2) reject(val._z);
            val.then(function (val) {
              res(i, val);
            }, reject);
            return;
          } else {
            var then = val.then;
            if (typeof then === 'function') {
              var p = new (_$$_REQUIRE(_dependencyMap[0]))(then.bind(val));
              p.then(function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      }
      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };
  function onSettledFulfill(value) {
    return {
      status: 'fulfilled',
      value: value
    };
  }
  function onSettledReject(reason) {
    return {
      status: 'rejected',
      reason: reason
    };
  }
  function mapAllSettled(item) {
    if (item && (typeof item === 'object' || typeof item === 'function')) {
      if (item instanceof _$$_REQUIRE(_dependencyMap[0]) && item.then === _$$_REQUIRE(_dependencyMap[0]).prototype.then) {
        return item.then(onSettledFulfill, onSettledReject);
      }
      var then = item.then;
      if (typeof then === 'function') {
        return new (_$$_REQUIRE(_dependencyMap[0]))(then.bind(item)).then(onSettledFulfill, onSettledReject);
      }
    }
    return onSettledFulfill(item);
  }
  _$$_REQUIRE(_dependencyMap[0]).allSettled = function (iterable) {
    return _$$_REQUIRE(_dependencyMap[0]).all(_iterableToArray(iterable).map(mapAllSettled));
  };
  _$$_REQUIRE(_dependencyMap[0]).reject = function (value) {
    return new (_$$_REQUIRE(_dependencyMap[0]))(function (resolve, reject) {
      reject(value);
    });
  };
  _$$_REQUIRE(_dependencyMap[0]).race = function (values) {
    return new (_$$_REQUIRE(_dependencyMap[0]))(function (resolve, reject) {
      _iterableToArray(values).forEach(function (value) {
        _$$_REQUIRE(_dependencyMap[0]).resolve(value).then(resolve, reject);
      });
    });
  };

  /* Prototype Methods */

  _$$_REQUIRE(_dependencyMap[0]).prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };
  function getAggregateError(errors) {
    if (typeof AggregateError === 'function') {
      return new AggregateError(errors, 'All promises were rejected');
    }
    var error = new Error('All promises were rejected');
    error.name = 'AggregateError';
    error.errors = errors;
    return error;
  }
  _$$_REQUIRE(_dependencyMap[0]).any = function promiseAny(values) {
    return new (_$$_REQUIRE(_dependencyMap[0]))(function (resolve, reject) {
      var promises = _iterableToArray(values);
      var hasResolved = false;
      var rejectionReasons = [];
      function resolveOnce(value) {
        if (!hasResolved) {
          hasResolved = true;
          resolve(value);
        }
      }
      function rejectionCheck(reason) {
        rejectionReasons.push(reason);
        if (rejectionReasons.length === promises.length) {
          reject(getAggregateError(rejectionReasons));
        }
      }
      if (promises.length === 0) {
        reject(getAggregateError(rejectionReasons));
      } else {
        promises.forEach(function (value) {
          _$$_REQUIRE(_dependencyMap[0]).resolve(value).then(resolveOnce, rejectionCheck);
        });
      }
    });
  };
},"a7846fdeffeb1ebf6241",["890f60fa94d3f6854a19"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var runtime = function (exports) {
    "use strict";

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    };
    var undefined; // More compressible than void 0.
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }
    try {
      // IE 8 has a broken Object.defineProperty that only works on DOM objects.
      define({}, "");
    } catch (err) {
      define = function define(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);

      // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.
      defineProperty(generator, "_invoke", {
        value: makeInvokeMethod(innerFn, self, context)
      });
      return generator;
    }
    exports.wrap = wrap;

    // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";

    // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.
    var ContinueSentinel = {};

    // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}

    // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = GeneratorFunctionPrototype;
    defineProperty(Gp, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: true
    });
    defineProperty(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: true
    });
    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");

    // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }
    exports.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction ||
      // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };
    exports.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };

    // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.
    exports.awrap = function (arg) {
      return {
        __await: arg
      };
    };
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }
          return PromiseImpl.resolve(value).then(function (unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function (error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }
      var previousPromise;
      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
        // Avoid propagating failures to Promises returned by later
        // invocations of the iterator.
        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }

      // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).
      defineProperty(this, "_invoke", {
        value: enqueue
      });
    }
    defineIteratorMethods(AsyncIterator.prototype);
    define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    });
    exports.AsyncIterator = AsyncIterator;

    // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.
    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === undefined) PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };
    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }
        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
          return doneResult();
        }
        context.method = method;
        context.arg = arg;
        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }
          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }
            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }
          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);
          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;
            if (record.arg === ContinueSentinel) {
              continue;
            }
            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }

    // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.
    function maybeInvokeDelegate(delegate, context) {
      var methodName = context.method;
      var method = delegate.iterator[methodName];
      if (method === undefined) {
        // A .throw or .return when the delegate iterator has no .throw
        // method, or a missing .next mehtod, always terminate the
        // yield* loop.
        context.delegate = null;

        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (methodName === "throw" && delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);
          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }
        if (methodName !== "return") {
          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method");
        }
        return ContinueSentinel;
      }
      var record = tryCatch(method, delegate.iterator, context.arg);
      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }
      var info = record.arg;
      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }
      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value;

        // Resume execution at the desired location (see delegateYield).
        context.next = delegate.nextLoc;

        // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined;
        }
      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      }

      // The delegate iterator is finished, so forget it and continue with
      // the outer generator.
      context.delegate = null;
      return ContinueSentinel;
    }

    // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.
    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator");

    // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.
    define(Gp, iteratorSymbol, function () {
      return this;
    });
    define(Gp, "toString", function () {
      return "[object Generator]";
    });
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      if (1 in locs) {
        entry.catchLoc = locs[1];
      }
      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }
      this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }
    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }
    exports.keys = function (val) {
      var object = Object(val);
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();

      // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.
      return function next() {
        while (keys.length) {
          var key = keys.pop();
          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.
        next.done = true;
        return next;
      };
    };
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }
        if (typeof iterable.next === "function") {
          return iterable;
        }
        if (!isNaN(iterable.length)) {
          var i = -1,
            next = function next() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next.value = iterable[i];
                  next.done = false;
                  return next;
                }
              }
              next.value = undefined;
              next.done = true;
              return next;
            };
          return next.next = next;
        }
      }

      // Return an iterator with no values.
      return {
        next: doneResult
      };
    }
    exports.values = values;
    function doneResult() {
      return {
        value: undefined,
        done: true
      };
    }
    Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.
        this.sent = this._sent = undefined;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined;
        this.tryEntries.forEach(resetTryEntry);
        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined;
            }
          }
        }
      },
      stop: function stop() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }
        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }
        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;
          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined;
          }
          return !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;
          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }
        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;
        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }
        return this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }
        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }
        return ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }

        // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.
        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };
        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined;
        }
        return ContinueSentinel;
      }
    };

    // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.
    return exports;
  }(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {});
  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, in modern engines
    // we can explicitly access globalThis. In older engines we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }
},"af823d9710c534173a4d",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _get() {
    return module.exports = _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {
      var p = _$$_REQUIRE(_dependencyMap[0])(e, t);
      if (p) {
        var n = Object.getOwnPropertyDescriptor(p, t);
        return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
      }
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _get.apply(null, arguments);
  }
  module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"ef4c2223f1078b78bd52",["b44e8fc8ae41fbe9dea8"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _superPropBase(t, o) {
    for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _$$_REQUIRE(_dependencyMap[0])(t)););
    return t;
  }
  module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"b44e8fc8ae41fbe9dea8",["f391b9d534c3a6bc8659"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @author Toru Nagashima <https://github.com/mysticatea>
   * @copyright 2015 Toru Nagashima. All rights reserved.
   * See LICENSE file in root directory for full license.
   */
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });

  /**
   * @typedef {object} PrivateData
   * @property {EventTarget} eventTarget The event target.
   * @property {{type:string}} event The original event object.
   * @property {number} eventPhase The current event phase.
   * @property {EventTarget|null} currentTarget The current event target.
   * @property {boolean} canceled The flag to prevent default.
   * @property {boolean} stopped The flag to stop propagation.
   * @property {boolean} immediateStopped The flag to stop propagation immediately.
   * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.
   * @property {number} timeStamp The unix time.
   * @private
   */

  /**
   * Private data for event wrappers.
   * @type {WeakMap<Event, PrivateData>}
   * @private
   */
  var privateData = new WeakMap();

  /**
   * Cache for wrapper classes.
   * @type {WeakMap<Object, Function>}
   * @private
   */
  var wrappers = new WeakMap();

  /**
   * Get private data.
   * @param {Event} event The event object to get private data.
   * @returns {PrivateData} The private data of the event.
   * @private
   */
  function pd(event) {
    var retv = privateData.get(event);
    console.assert(retv != null, "'this' is expected an Event object, but got", event);
    return retv;
  }

  /**
   * https://dom.spec.whatwg.org/#set-the-canceled-flag
   * @param data {PrivateData} private data.
   */
  function setCancelFlag(data) {
    if (data.passiveListener != null) {
      if (typeof console !== "undefined" && typeof console.error === "function") {
        console.error("Unable to preventDefault inside passive event listener invocation.", data.passiveListener);
      }
      return;
    }
    if (!data.event.cancelable) {
      return;
    }
    data.canceled = true;
    if (typeof data.event.preventDefault === "function") {
      data.event.preventDefault();
    }
  }

  /**
   * @see https://dom.spec.whatwg.org/#interface-event
   * @private
   */
  /**
   * The event wrapper.
   * @constructor
   * @param {EventTarget} eventTarget The event target of this dispatching.
   * @param {Event|{type:string}} event The original event to wrap.
   */
  function Event(eventTarget, event) {
    privateData.set(this, {
      eventTarget: eventTarget,
      event: event,
      eventPhase: 2,
      currentTarget: eventTarget,
      canceled: false,
      stopped: false,
      immediateStopped: false,
      passiveListener: null,
      timeStamp: event.timeStamp || Date.now()
    });

    // https://heycam.github.io/webidl/#Unforgeable
    Object.defineProperty(this, "isTrusted", {
      value: false,
      enumerable: true
    });

    // Define accessors
    var keys = Object.keys(event);
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      if (!(key in this)) {
        Object.defineProperty(this, key, defineRedirectDescriptor(key));
      }
    }
  }

  // Should be enumerable, but class methods are not enumerable.
  Event.prototype = {
    /**
     * The type of this event.
     * @type {string}
     */
    get type() {
      return pd(this).event.type;
    },
    /**
     * The target of this event.
     * @type {EventTarget}
     */
    get target() {
      return pd(this).eventTarget;
    },
    /**
     * The target of this event.
     * @type {EventTarget}
     */
    get currentTarget() {
      return pd(this).currentTarget;
    },
    /**
     * @returns {EventTarget[]} The composed path of this event.
     */
    composedPath: function composedPath() {
      var currentTarget = pd(this).currentTarget;
      if (currentTarget == null) {
        return [];
      }
      return [currentTarget];
    },
    /**
     * Constant of NONE.
     * @type {number}
     */
    get NONE() {
      return 0;
    },
    /**
     * Constant of CAPTURING_PHASE.
     * @type {number}
     */
    get CAPTURING_PHASE() {
      return 1;
    },
    /**
     * Constant of AT_TARGET.
     * @type {number}
     */
    get AT_TARGET() {
      return 2;
    },
    /**
     * Constant of BUBBLING_PHASE.
     * @type {number}
     */
    get BUBBLING_PHASE() {
      return 3;
    },
    /**
     * The target of this event.
     * @type {number}
     */
    get eventPhase() {
      return pd(this).eventPhase;
    },
    /**
     * Stop event bubbling.
     * @returns {void}
     */
    stopPropagation: function stopPropagation() {
      var data = pd(this);
      data.stopped = true;
      if (typeof data.event.stopPropagation === "function") {
        data.event.stopPropagation();
      }
    },
    /**
     * Stop event bubbling.
     * @returns {void}
     */
    stopImmediatePropagation: function stopImmediatePropagation() {
      var data = pd(this);
      data.stopped = true;
      data.immediateStopped = true;
      if (typeof data.event.stopImmediatePropagation === "function") {
        data.event.stopImmediatePropagation();
      }
    },
    /**
     * The flag to be bubbling.
     * @type {boolean}
     */
    get bubbles() {
      return Boolean(pd(this).event.bubbles);
    },
    /**
     * The flag to be cancelable.
     * @type {boolean}
     */
    get cancelable() {
      return Boolean(pd(this).event.cancelable);
    },
    /**
     * Cancel this event.
     * @returns {void}
     */
    preventDefault: function preventDefault() {
      setCancelFlag(pd(this));
    },
    /**
     * The flag to indicate cancellation state.
     * @type {boolean}
     */
    get defaultPrevented() {
      return pd(this).canceled;
    },
    /**
     * The flag to be composed.
     * @type {boolean}
     */
    get composed() {
      return Boolean(pd(this).event.composed);
    },
    /**
     * The unix time of this event.
     * @type {number}
     */
    get timeStamp() {
      return pd(this).timeStamp;
    },
    /**
     * The target of this event.
     * @type {EventTarget}
     * @deprecated
     */
    get srcElement() {
      return pd(this).eventTarget;
    },
    /**
     * The flag to stop event bubbling.
     * @type {boolean}
     * @deprecated
     */
    get cancelBubble() {
      return pd(this).stopped;
    },
    set cancelBubble(value) {
      if (!value) {
        return;
      }
      var data = pd(this);
      data.stopped = true;
      if (typeof data.event.cancelBubble === "boolean") {
        data.event.cancelBubble = true;
      }
    },
    /**
     * The flag to indicate cancellation state.
     * @type {boolean}
     * @deprecated
     */
    get returnValue() {
      return !pd(this).canceled;
    },
    set returnValue(value) {
      if (!value) {
        setCancelFlag(pd(this));
      }
    },
    /**
     * Initialize this event object. But do nothing under event dispatching.
     * @param {string} type The event type.
     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
     * @param {boolean} [cancelable=false] The flag to be possible to cancel.
     * @deprecated
     */
    initEvent: function initEvent() {
      // Do nothing.
    }
  };

  // `constructor` is not enumerable.
  Object.defineProperty(Event.prototype, "constructor", {
    value: Event,
    configurable: true,
    writable: true
  });

  // Ensure `event instanceof window.Event` is `true`.
  if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
    Object.setPrototypeOf(Event.prototype, window.Event.prototype);

    // Make association for wrappers.
    wrappers.set(window.Event.prototype, Event);
  }

  /**
   * Get the property descriptor to redirect a given property.
   * @param {string} key Property name to define property descriptor.
   * @returns {PropertyDescriptor} The property descriptor to redirect the property.
   * @private
   */
  function defineRedirectDescriptor(key) {
    return {
      get: function get() {
        return pd(this).event[key];
      },
      set: function set(value) {
        pd(this).event[key] = value;
      },
      configurable: true,
      enumerable: true
    };
  }

  /**
   * Get the property descriptor to call a given method property.
   * @param {string} key Property name to define property descriptor.
   * @returns {PropertyDescriptor} The property descriptor to call the method property.
   * @private
   */
  function defineCallDescriptor(key) {
    return {
      value: function value() {
        var event = pd(this).event;
        return event[key].apply(event, arguments);
      },
      configurable: true,
      enumerable: true
    };
  }

  /**
   * Define new wrapper class.
   * @param {Function} BaseEvent The base wrapper class.
   * @param {Object} proto The prototype of the original event.
   * @returns {Function} The defined wrapper class.
   * @private
   */
  function defineWrapper(BaseEvent, proto) {
    var keys = Object.keys(proto);
    if (keys.length === 0) {
      return BaseEvent;
    }

    /** CustomEvent */
    function CustomEvent(eventTarget, event) {
      BaseEvent.call(this, eventTarget, event);
    }
    CustomEvent.prototype = Object.create(BaseEvent.prototype, {
      constructor: {
        value: CustomEvent,
        configurable: true,
        writable: true
      }
    });

    // Define accessors.
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      if (!(key in BaseEvent.prototype)) {
        var descriptor = Object.getOwnPropertyDescriptor(proto, key);
        var isFunc = typeof descriptor.value === "function";
        Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));
      }
    }
    return CustomEvent;
  }

  /**
   * Get the wrapper class of a given prototype.
   * @param {Object} proto The prototype of the original event to get its wrapper.
   * @returns {Function} The wrapper class.
   * @private
   */
  function getWrapper(proto) {
    if (proto == null || proto === Object.prototype) {
      return Event;
    }
    var wrapper = wrappers.get(proto);
    if (wrapper == null) {
      wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
      wrappers.set(proto, wrapper);
    }
    return wrapper;
  }

  /**
   * Wrap a given event to management a dispatching.
   * @param {EventTarget} eventTarget The event target of this dispatching.
   * @param {Object} event The event to wrap.
   * @returns {Event} The wrapper instance.
   * @private
   */
  function wrapEvent(eventTarget, event) {
    var Wrapper = getWrapper(Object.getPrototypeOf(event));
    return new Wrapper(eventTarget, event);
  }

  /**
   * Get the immediateStopped flag of a given event.
   * @param {Event} event The event to get.
   * @returns {boolean} The flag to stop propagation immediately.
   * @private
   */
  function isStopped(event) {
    return pd(event).immediateStopped;
  }

  /**
   * Set the current event phase of a given event.
   * @param {Event} event The event to set current target.
   * @param {number} eventPhase New event phase.
   * @returns {void}
   * @private
   */
  function setEventPhase(event, eventPhase) {
    pd(event).eventPhase = eventPhase;
  }

  /**
   * Set the current target of a given event.
   * @param {Event} event The event to set current target.
   * @param {EventTarget|null} currentTarget New current target.
   * @returns {void}
   * @private
   */
  function setCurrentTarget(event, currentTarget) {
    pd(event).currentTarget = currentTarget;
  }

  /**
   * Set a passive listener of a given event.
   * @param {Event} event The event to set current target.
   * @param {Function|null} passiveListener New passive listener.
   * @returns {void}
   * @private
   */
  function setPassiveListener(event, passiveListener) {
    pd(event).passiveListener = passiveListener;
  }

  /**
   * @typedef {object} ListenerNode
   * @property {Function} listener
   * @property {1|2|3} listenerType
   * @property {boolean} passive
   * @property {boolean} once
   * @property {ListenerNode|null} next
   * @private
   */

  /**
   * @type {WeakMap<object, Map<string, ListenerNode>>}
   * @private
   */
  var listenersMap = new WeakMap();

  // Listener types
  var CAPTURE = 1;
  var BUBBLE = 2;
  var ATTRIBUTE = 3;

  /**
   * Check whether a given value is an object or not.
   * @param {any} x The value to check.
   * @returns {boolean} `true` if the value is an object.
   */
  function isObject(x) {
    return x !== null && typeof x === "object"; //eslint-disable-line no-restricted-syntax
  }

  /**
   * Get listeners.
   * @param {EventTarget} eventTarget The event target to get.
   * @returns {Map<string, ListenerNode>} The listeners.
   * @private
   */
  function getListeners(eventTarget) {
    var listeners = listenersMap.get(eventTarget);
    if (listeners == null) {
      throw new TypeError("'this' is expected an EventTarget object, but got another value.");
    }
    return listeners;
  }

  /**
   * Get the property descriptor for the event attribute of a given event.
   * @param {string} eventName The event name to get property descriptor.
   * @returns {PropertyDescriptor} The property descriptor.
   * @private
   */
  function defineEventAttributeDescriptor(eventName) {
    return {
      get: function get() {
        var listeners = getListeners(this);
        var node = listeners.get(eventName);
        while (node != null) {
          if (node.listenerType === ATTRIBUTE) {
            return node.listener;
          }
          node = node.next;
        }
        return null;
      },
      set: function set(listener) {
        if (typeof listener !== "function" && !isObject(listener)) {
          listener = null; // eslint-disable-line no-param-reassign
        }
        var listeners = getListeners(this);

        // Traverse to the tail while removing old value.
        var prev = null;
        var node = listeners.get(eventName);
        while (node != null) {
          if (node.listenerType === ATTRIBUTE) {
            // Remove old value.
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }
          node = node.next;
        }

        // Add new value.
        if (listener !== null) {
          var newNode = {
            listener: listener,
            listenerType: ATTRIBUTE,
            passive: false,
            once: false,
            next: null
          };
          if (prev === null) {
            listeners.set(eventName, newNode);
          } else {
            prev.next = newNode;
          }
        }
      },
      configurable: true,
      enumerable: true
    };
  }

  /**
   * Define an event attribute (e.g. `eventTarget.onclick`).
   * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.
   * @param {string} eventName The event name to define.
   * @returns {void}
   */
  function defineEventAttribute(eventTargetPrototype, eventName) {
    Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
  }

  /**
   * Define a custom EventTarget with event attributes.
   * @param {string[]} eventNames Event names for event attributes.
   * @returns {EventTarget} The custom EventTarget.
   * @private
   */
  function defineCustomEventTarget(eventNames) {
    /** CustomEventTarget */
    function CustomEventTarget() {
      EventTarget.call(this);
    }
    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
      constructor: {
        value: CustomEventTarget,
        configurable: true,
        writable: true
      }
    });
    for (var i = 0; i < eventNames.length; ++i) {
      defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
    }
    return CustomEventTarget;
  }

  /**
   * EventTarget.
   *
   * - This is constructor if no arguments.
   * - This is a function which returns a CustomEventTarget constructor if there are arguments.
   *
   * For example:
   *
   *     class A extends EventTarget {}
   *     class B extends EventTarget("message") {}
   *     class C extends EventTarget("message", "error") {}
   *     class D extends EventTarget(["message", "error"]) {}
   */
  function EventTarget() {
    /*eslint-disable consistent-return */
    if (this instanceof EventTarget) {
      listenersMap.set(this, new Map());
      return;
    }
    if (arguments.length === 1 && Array.isArray(arguments[0])) {
      return defineCustomEventTarget(arguments[0]);
    }
    if (arguments.length > 0) {
      var types = new Array(arguments.length);
      for (var i = 0; i < arguments.length; ++i) {
        types[i] = arguments[i];
      }
      return defineCustomEventTarget(types);
    }
    throw new TypeError("Cannot call a class as a function");
    /*eslint-enable consistent-return */
  }

  // Should be enumerable, but class methods are not enumerable.
  EventTarget.prototype = {
    /**
     * Add a given listener to this event target.
     * @param {string} eventName The event name to add.
     * @param {Function} listener The listener to add.
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
     * @returns {void}
     */
    addEventListener: function addEventListener(eventName, listener, options) {
      if (listener == null) {
        return;
      }
      if (typeof listener !== "function" && !isObject(listener)) {
        throw new TypeError("'listener' should be a function or an object.");
      }
      var listeners = getListeners(this);
      var optionsIsObj = isObject(options);
      var capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
      var listenerType = capture ? CAPTURE : BUBBLE;
      var newNode = {
        listener: listener,
        listenerType: listenerType,
        passive: optionsIsObj && Boolean(options.passive),
        once: optionsIsObj && Boolean(options.once),
        next: null
      };

      // Set it as the first node if the first node is null.
      var node = listeners.get(eventName);
      if (node === undefined) {
        listeners.set(eventName, newNode);
        return;
      }

      // Traverse to the tail while checking duplication..
      var prev = null;
      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType) {
          // Should ignore duplication.
          return;
        }
        prev = node;
        node = node.next;
      }

      // Add it.
      prev.next = newNode;
    },
    /**
     * Remove a given listener from this event target.
     * @param {string} eventName The event name to remove.
     * @param {Function} listener The listener to remove.
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
     * @returns {void}
     */
    removeEventListener: function removeEventListener(eventName, listener, options) {
      if (listener == null) {
        return;
      }
      var listeners = getListeners(this);
      var capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
      var listenerType = capture ? CAPTURE : BUBBLE;
      var prev = null;
      var node = listeners.get(eventName);
      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType) {
          if (prev !== null) {
            prev.next = node.next;
          } else if (node.next !== null) {
            listeners.set(eventName, node.next);
          } else {
            listeners.delete(eventName);
          }
          return;
        }
        prev = node;
        node = node.next;
      }
    },
    /**
     * Dispatch a given event.
     * @param {Event|{type:string}} event The event to dispatch.
     * @returns {boolean} `false` if canceled.
     */
    dispatchEvent: function dispatchEvent(event) {
      if (event == null || typeof event.type !== "string") {
        throw new TypeError('"event.type" should be a string.');
      }

      // If listeners aren't registered, terminate.
      var listeners = getListeners(this);
      var eventName = event.type;
      var node = listeners.get(eventName);
      if (node == null) {
        return true;
      }

      // Since we cannot rewrite several properties, so wrap object.
      var wrappedEvent = wrapEvent(this, event);

      // This doesn't process capturing phase and bubbling phase.
      // This isn't participating in a tree.
      var prev = null;
      while (node != null) {
        // Remove this listener if it's once
        if (node.once) {
          if (prev !== null) {
            prev.next = node.next;
          } else if (node.next !== null) {
            listeners.set(eventName, node.next);
          } else {
            listeners.delete(eventName);
          }
        } else {
          prev = node;
        }

        // Call this listener
        setPassiveListener(wrappedEvent, node.passive ? node.listener : null);
        if (typeof node.listener === "function") {
          try {
            node.listener.call(this, wrappedEvent);
          } catch (err) {
            if (typeof console !== "undefined" && typeof console.error === "function") {
              console.error(err);
            }
          }
        } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
          node.listener.handleEvent(wrappedEvent);
        }

        // Break if `event.stopImmediatePropagation` was called.
        if (isStopped(wrappedEvent)) {
          break;
        }
        node = node.next;
      }
      setPassiveListener(wrappedEvent, null);
      setEventPhase(wrappedEvent, 0);
      setCurrentTarget(wrappedEvent, null);
      return !wrappedEvent.defaultPrevented;
    }
  };

  // `constructor` is not enumerable.
  Object.defineProperty(EventTarget.prototype, "constructor", {
    value: EventTarget,
    configurable: true,
    writable: true
  });

  // Ensure `eventTarget instanceof window.EventTarget` is `true`.
  if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
  }
  exports.defineEventAttribute = defineEventAttribute;
  exports.EventTarget = EventTarget;
  exports.default = EventTarget;
  module.exports = EventTarget;
  module.exports.EventTarget = module.exports["default"] = EventTarget;
  module.exports.defineEventAttribute = defineEventAttribute;
},"2bd3f165b1ed6b916de7",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  exports.byteLength = byteLength;
  exports.toByteArray = toByteArray;
  exports.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  // Support decoding URL-safe base64 strings, as Node.js does.
  // See: https://en.wikipedia.org/wiki/Base64#URL_applications
  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
  function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    }

    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }

  // base64 is 4/3 + up to two characters of the original data
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;

    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for (i = 0; i < len; i += 4) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[curByte++] = tmp >> 16 & 0xFF;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
      output.push(tripletToBase64(tmp));
    }
    return output.join('');
  }
  function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
    }
    return parts.join('');
  }
},"71af70f51435e3e1b37b",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.WHATWGFetch = {});
  })(this, function (exports) {
    'use strict';

    /* eslint-disable no-prototype-builtins */
    var g = typeof globalThis !== 'undefined' && globalThis || typeof self !== 'undefined' && self ||
    // eslint-disable-next-line no-undef
    typeof global !== 'undefined' && global || {};
    var support = {
      searchParams: 'URLSearchParams' in g,
      iterable: 'Symbol' in g && 'iterator' in Symbol,
      blob: 'FileReader' in g && 'Blob' in g && function () {
        try {
          new Blob();
          return true;
        } catch (e) {
          return false;
        }
      }(),
      formData: 'FormData' in g,
      arrayBuffer: 'ArrayBuffer' in g
    };
    function isDataView(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj);
    }
    if (support.arrayBuffer) {
      var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];
      var isArrayBufferView = ArrayBuffer.isView || function (obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
      };
    }
    function normalizeName(name) {
      if (typeof name !== 'string') {
        name = String(name);
      }
      if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
        throw new TypeError('Invalid character in header field name: "' + name + '"');
      }
      return name.toLowerCase();
    }
    function normalizeValue(value) {
      if (typeof value !== 'string') {
        value = String(value);
      }
      return value;
    }

    // Build a destructive iterator for the value list
    function iteratorFor(items) {
      var iterator = {
        next: function next() {
          var value = items.shift();
          return {
            done: value === undefined,
            value: value
          };
        }
      };
      if (support.iterable) {
        iterator[Symbol.iterator] = function () {
          return iterator;
        };
      }
      return iterator;
    }
    function Headers(headers) {
      this.map = {};
      if (headers instanceof Headers) {
        headers.forEach(function (value, name) {
          this.append(name, value);
        }, this);
      } else if (Array.isArray(headers)) {
        headers.forEach(function (header) {
          if (header.length != 2) {
            throw new TypeError('Headers constructor: expected name/value pair to be length 2, found' + header.length);
          }
          this.append(header[0], header[1]);
        }, this);
      } else if (headers) {
        Object.getOwnPropertyNames(headers).forEach(function (name) {
          this.append(name, headers[name]);
        }, this);
      }
    }
    Headers.prototype.append = function (name, value) {
      name = normalizeName(name);
      value = normalizeValue(value);
      var oldValue = this.map[name];
      this.map[name] = oldValue ? oldValue + ', ' + value : value;
    };
    Headers.prototype['delete'] = function (name) {
      delete this.map[normalizeName(name)];
    };
    Headers.prototype.get = function (name) {
      name = normalizeName(name);
      return this.has(name) ? this.map[name] : null;
    };
    Headers.prototype.has = function (name) {
      return this.map.hasOwnProperty(normalizeName(name));
    };
    Headers.prototype.set = function (name, value) {
      this.map[normalizeName(name)] = normalizeValue(value);
    };
    Headers.prototype.forEach = function (callback, thisArg) {
      for (var name in this.map) {
        if (this.map.hasOwnProperty(name)) {
          callback.call(thisArg, this.map[name], name, this);
        }
      }
    };
    Headers.prototype.keys = function () {
      var items = [];
      this.forEach(function (value, name) {
        items.push(name);
      });
      return iteratorFor(items);
    };
    Headers.prototype.values = function () {
      var items = [];
      this.forEach(function (value) {
        items.push(value);
      });
      return iteratorFor(items);
    };
    Headers.prototype.entries = function () {
      var items = [];
      this.forEach(function (value, name) {
        items.push([name, value]);
      });
      return iteratorFor(items);
    };
    if (support.iterable) {
      Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    }
    function consumed(body) {
      if (body._noBody) return;
      if (body.bodyUsed) {
        return Promise.reject(new TypeError('Already read'));
      }
      body.bodyUsed = true;
    }
    function fileReaderReady(reader) {
      return new Promise(function (resolve, reject) {
        reader.onload = function () {
          resolve(reader.result);
        };
        reader.onerror = function () {
          reject(reader.error);
        };
      });
    }
    function readBlobAsArrayBuffer(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsArrayBuffer(blob);
      return promise;
    }
    function readBlobAsText(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
      var encoding = match ? match[1] : 'utf-8';
      reader.readAsText(blob, encoding);
      return promise;
    }
    function readArrayBufferAsText(buf) {
      var view = new Uint8Array(buf);
      var chars = new Array(view.length);
      for (var i = 0; i < view.length; i++) {
        chars[i] = String.fromCharCode(view[i]);
      }
      return chars.join('');
    }
    function bufferClone(buf) {
      if (buf.slice) {
        return buf.slice(0);
      } else {
        var view = new Uint8Array(buf.byteLength);
        view.set(new Uint8Array(buf));
        return view.buffer;
      }
    }
    function Body() {
      this.bodyUsed = false;
      this._initBody = function (body) {
        /*
          fetch-mock wraps the Response object in an ES6 Proxy to
          provide useful test harness features such as flush. However, on
          ES5 browsers without fetch or Proxy support pollyfills must be used;
          the proxy-pollyfill is unable to proxy an attribute unless it exists
          on the object before the Proxy is created. This change ensures
          Response.bodyUsed exists on the instance, while maintaining the
          semantic of setting Request.bodyUsed in the constructor before
          _initBody is called.
        */
        // eslint-disable-next-line no-self-assign
        this.bodyUsed = this.bodyUsed;
        this._bodyInit = body;
        if (!body) {
          this._noBody = true;
          this._bodyText = '';
        } else if (typeof body === 'string') {
          this._bodyText = body;
        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
          this._bodyBlob = body;
        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
          this._bodyFormData = body;
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this._bodyText = body.toString();
        } else if (support.arrayBuffer && support.blob && isDataView(body)) {
          this._bodyArrayBuffer = bufferClone(body.buffer);
          // IE 10-11 can't handle a DataView body.
          this._bodyInit = new Blob([this._bodyArrayBuffer]);
        } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
          this._bodyArrayBuffer = bufferClone(body);
        } else {
          this._bodyText = body = Object.prototype.toString.call(body);
        }
        if (!this.headers.get('content-type')) {
          if (typeof body === 'string') {
            this.headers.set('content-type', 'text/plain;charset=UTF-8');
          } else if (this._bodyBlob && this._bodyBlob.type) {
            this.headers.set('content-type', this._bodyBlob.type);
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
          }
        }
      };
      if (support.blob) {
        this.blob = function () {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return Promise.resolve(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          } else if (this._bodyFormData) {
            throw new Error('could not read FormData body as blob');
          } else {
            return Promise.resolve(new Blob([this._bodyText]));
          }
        };
      }
      this.arrayBuffer = function () {
        if (this._bodyArrayBuffer) {
          var isConsumed = consumed(this);
          if (isConsumed) {
            return isConsumed;
          } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
            return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
          } else {
            return Promise.resolve(this._bodyArrayBuffer);
          }
        } else if (support.blob) {
          return this.blob().then(readBlobAsArrayBuffer);
        } else {
          throw new Error('could not read as ArrayBuffer');
        }
      };
      this.text = function () {
        var rejected = consumed(this);
        if (rejected) {
          return rejected;
        }
        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob);
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text');
        } else {
          return Promise.resolve(this._bodyText);
        }
      };
      if (support.formData) {
        this.formData = function () {
          return this.text().then(decode);
        };
      }
      this.json = function () {
        return this.text().then(JSON.parse);
      };
      return this;
    }

    // HTTP methods whose capitalization should be normalized
    var methods = ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'TRACE'];
    function normalizeMethod(method) {
      var upcased = method.toUpperCase();
      return methods.indexOf(upcased) > -1 ? upcased : method;
    }
    function Request(input, options) {
      if (!(this instanceof Request)) {
        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
      }
      options = options || {};
      var body = options.body;
      if (input instanceof Request) {
        if (input.bodyUsed) {
          throw new TypeError('Already read');
        }
        this.url = input.url;
        this.credentials = input.credentials;
        if (!options.headers) {
          this.headers = new Headers(input.headers);
        }
        this.method = input.method;
        this.mode = input.mode;
        this.signal = input.signal;
        if (!body && input._bodyInit != null) {
          body = input._bodyInit;
          input.bodyUsed = true;
        }
      } else {
        this.url = String(input);
      }
      this.credentials = options.credentials || this.credentials || 'same-origin';
      if (options.headers || !this.headers) {
        this.headers = new Headers(options.headers);
      }
      this.method = normalizeMethod(options.method || this.method || 'GET');
      this.mode = options.mode || this.mode || null;
      this.signal = options.signal || this.signal || function () {
        if ('AbortController' in g) {
          var ctrl = new AbortController();
          return ctrl.signal;
        }
      }();
      this.referrer = null;
      if ((this.method === 'GET' || this.method === 'HEAD') && body) {
        throw new TypeError('Body not allowed for GET or HEAD requests');
      }
      this._initBody(body);
      if (this.method === 'GET' || this.method === 'HEAD') {
        if (options.cache === 'no-store' || options.cache === 'no-cache') {
          // Search for a '_' parameter in the query string
          var reParamSearch = /([?&])_=[^&]*/;
          if (reParamSearch.test(this.url)) {
            // If it already exists then set the value with the current time
            this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
          } else {
            // Otherwise add a new '_' parameter to the end with the current time
            var reQueryString = /\?/;
            this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
          }
        }
      }
    }
    Request.prototype.clone = function () {
      return new Request(this, {
        body: this._bodyInit
      });
    };
    function decode(body) {
      var form = new FormData();
      body.trim().split('&').forEach(function (bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
      return form;
    }
    function parseHeaders(rawHeaders) {
      var headers = new Headers();
      // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
      // https://tools.ietf.org/html/rfc7230#section-3.2
      var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
      // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
      // https://github.com/github/fetch/issues/748
      // https://github.com/zloirock/core-js/issues/751
      preProcessedHeaders.split('\r').map(function (header) {
        return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header;
      }).forEach(function (line) {
        var parts = line.split(':');
        var key = parts.shift().trim();
        if (key) {
          var value = parts.join(':').trim();
          try {
            headers.append(key, value);
          } catch (error) {
            console.warn('Response ' + error.message);
          }
        }
      });
      return headers;
    }
    Body.call(Request.prototype);
    function Response(bodyInit, options) {
      if (!(this instanceof Response)) {
        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
      }
      if (!options) {
        options = {};
      }
      this.type = 'default';
      this.status = options.status === undefined ? 200 : options.status;
      if (this.status < 200 || this.status > 599) {
        throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
      }
      this.ok = this.status >= 200 && this.status < 300;
      this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
      this.headers = new Headers(options.headers);
      this.url = options.url || '';
      this._initBody(bodyInit);
    }
    Body.call(Response.prototype);
    Response.prototype.clone = function () {
      return new Response(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Headers(this.headers),
        url: this.url
      });
    };
    Response.error = function () {
      var response = new Response(null, {
        status: 200,
        statusText: ''
      });
      response.ok = false;
      response.status = 0;
      response.type = 'error';
      return response;
    };
    var redirectStatuses = [301, 302, 303, 307, 308];
    Response.redirect = function (url, status) {
      if (redirectStatuses.indexOf(status) === -1) {
        throw new RangeError('Invalid status code');
      }
      return new Response(null, {
        status: status,
        headers: {
          location: url
        }
      });
    };
    exports.DOMException = g.DOMException;
    try {
      new exports.DOMException();
    } catch (err) {
      exports.DOMException = function (message, name) {
        this.message = message;
        this.name = name;
        var error = Error(message);
        this.stack = error.stack;
      };
      exports.DOMException.prototype = Object.create(Error.prototype);
      exports.DOMException.prototype.constructor = exports.DOMException;
    }
    function fetch(input, init) {
      return new Promise(function (resolve, reject) {
        var request = new Request(input, init);
        if (request.signal && request.signal.aborted) {
          return reject(new exports.DOMException('Aborted', 'AbortError'));
        }
        var xhr = new XMLHttpRequest();
        function abortXhr() {
          xhr.abort();
        }
        xhr.onload = function () {
          var options = {
            statusText: xhr.statusText,
            headers: parseHeaders(xhr.getAllResponseHeaders() || '')
          };
          // This check if specifically for when a user fetches a file locally from the file system
          // Only if the status is out of a normal range
          if (request.url.indexOf('file://') === 0 && (xhr.status < 200 || xhr.status > 599)) {
            options.status = 200;
          } else {
            options.status = xhr.status;
          }
          options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
          var body = 'response' in xhr ? xhr.response : xhr.responseText;
          setTimeout(function () {
            resolve(new Response(body, options));
          }, 0);
        };
        xhr.onerror = function () {
          setTimeout(function () {
            reject(new TypeError('Network request failed'));
          }, 0);
        };
        xhr.ontimeout = function () {
          setTimeout(function () {
            reject(new TypeError('Network request timed out'));
          }, 0);
        };
        xhr.onabort = function () {
          setTimeout(function () {
            reject(new exports.DOMException('Aborted', 'AbortError'));
          }, 0);
        };
        function fixUrl(url) {
          try {
            return url === '' && g.location.href ? g.location.href : url;
          } catch (e) {
            return url;
          }
        }
        xhr.open(request.method, fixUrl(request.url), true);
        if (request.credentials === 'include') {
          xhr.withCredentials = true;
        } else if (request.credentials === 'omit') {
          xhr.withCredentials = false;
        }
        if ('responseType' in xhr) {
          if (support.blob) {
            xhr.responseType = 'blob';
          } else if (support.arrayBuffer) {
            xhr.responseType = 'arraybuffer';
          }
        }
        if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {
          var names = [];
          Object.getOwnPropertyNames(init.headers).forEach(function (name) {
            names.push(normalizeName(name));
            xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
          });
          request.headers.forEach(function (value, name) {
            if (names.indexOf(name) === -1) {
              xhr.setRequestHeader(name, value);
            }
          });
        } else {
          request.headers.forEach(function (value, name) {
            xhr.setRequestHeader(name, value);
          });
        }
        if (request.signal) {
          request.signal.addEventListener('abort', abortXhr);
          xhr.onreadystatechange = function () {
            // DONE (success or failure)
            if (xhr.readyState === 4) {
              request.signal.removeEventListener('abort', abortXhr);
            }
          };
        }
        xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
      });
    }
    fetch.polyfill = true;
    if (!g.fetch) {
      g.fetch = fetch;
      g.Headers = Headers;
      g.Request = Request;
      g.Response = Response;
    }
    exports.Headers = Headers;
    exports.Request = Request;
    exports.Response = Response;
    exports.fetch = fetch;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
  });
},"ca4b0363146267ef3e77",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _objectWithoutProperties(e, t) {
    if (null == e) return {};
    var o,
      r,
      i = _$$_REQUIRE(_dependencyMap[0])(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  module.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"dd1a5f938f6f03510b39",["caf7f4ba910d205ff7d0"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r[n];
    }
    return t;
  }
  module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"caf7f4ba910d205ff7d0",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @author Toru Nagashima <https://github.com/mysticatea>
   * See LICENSE file in root directory for full license.
   */
  'use strict';

  function _callSuper(t, o, e) { return o = _$$_REQUIRE(_dependencyMap[0])(o), _$$_REQUIRE(_dependencyMap[1])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _$$_REQUIRE(_dependencyMap[0])(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  /**
   * The signal class.
   * @see https://dom.spec.whatwg.org/#abortsignal
   */
  var AbortSignal = /*#__PURE__*/function (_eventTargetShim$Even) {
    /**
     * AbortSignal cannot be constructed directly.
     */
    function AbortSignal() {
      var _this;
      _$$_REQUIRE(_dependencyMap[2])(this, AbortSignal);
      _this = _callSuper(this, AbortSignal);
      throw new TypeError("AbortSignal cannot be constructed directly");
      return _this;
    }
    /**
     * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
     */
    _$$_REQUIRE(_dependencyMap[3])(AbortSignal, _eventTargetShim$Even);
    return _$$_REQUIRE(_dependencyMap[4])(AbortSignal, [{
      key: "aborted",
      get: function get() {
        var aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
      }
    }]);
  }(_$$_REQUIRE(_dependencyMap[5]).EventTarget);
  _$$_REQUIRE(_dependencyMap[5]).defineEventAttribute(AbortSignal.prototype, "abort");
  /**
   * Create an AbortSignal object.
   */
  function createAbortSignal() {
    var signal = Object.create(AbortSignal.prototype);
    _$$_REQUIRE(_dependencyMap[5]).EventTarget.call(signal);
    abortedFlags.set(signal, false);
    return signal;
  }
  /**
   * Abort a given signal.
   */
  function abortSignal(signal) {
    if (abortedFlags.get(signal) !== false) {
      return;
    }
    abortedFlags.set(signal, true);
    signal.dispatchEvent({
      type: "abort"
    });
  }
  /**
   * Aborted flag for each instances.
   */
  var abortedFlags = new WeakMap();
  // Properties should be enumerable.
  Object.defineProperties(AbortSignal.prototype, {
    aborted: {
      enumerable: true
    }
  });
  // `toString()` should return `"[object AbortSignal]"`
  if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
    Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
      configurable: true,
      value: "AbortSignal"
    });
  }

  /**
   * The AbortController.
   * @see https://dom.spec.whatwg.org/#abortcontroller
   */
  var AbortController = /*#__PURE__*/function () {
    /**
     * Initialize this controller.
     */
    function AbortController() {
      _$$_REQUIRE(_dependencyMap[2])(this, AbortController);
      signals.set(this, createAbortSignal());
    }
    /**
     * Returns the `AbortSignal` object associated with this object.
     */
    return _$$_REQUIRE(_dependencyMap[4])(AbortController, [{
      key: "signal",
      get: function get() {
        return getSignal(this);
      }
      /**
       * Abort and signal to any observers that the associated activity is to be aborted.
       */
    }, {
      key: "abort",
      value: function abort() {
        abortSignal(getSignal(this));
      }
    }]);
  }();
  /**
   * Associated signals.
   */
  var signals = new WeakMap();
  /**
   * Get the associated signal of a given controller.
   */
  function getSignal(controller) {
    var signal = signals.get(controller);
    if (signal == null) {
      throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
    }
    return signal;
  }
  // Properties should be enumerable.
  Object.defineProperties(AbortController.prototype, {
    signal: {
      enumerable: true
    },
    abort: {
      enumerable: true
    }
  });
  if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
    Object.defineProperty(AbortController.prototype, Symbol.toStringTag, {
      configurable: true,
      value: "AbortController"
    });
  }
  exports.AbortController = AbortController;
  exports.AbortSignal = AbortSignal;
  exports.default = AbortController;
  module.exports = AbortController;
  module.exports.AbortController = module.exports["default"] = AbortController;
  module.exports.AbortSignal = AbortSignal;
},"ea8fcbd647aab1cfcdaa",["f391b9d534c3a6bc8659","4534eb96ece5e83c089a","3508abd8c6b891008c0d","73afcd34a88a750f6d69","5533cec96f6a88041c69","2bd3f165b1ed6b916de7"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  /* eslint no-bitwise: 0 */

  'use strict';

  function normalizeColor(color) {
    if (typeof color === 'number') {
      if (color >>> 0 === color && color >= 0 && color <= 0xffffffff) {
        return color;
      }
      return null;
    }
    if (typeof color !== 'string') {
      return null;
    }
    var matchers = getMatchers();
    var match;

    // Ordered based on occurrences on Facebook codebase
    if (match = matchers.hex6.exec(color)) {
      return parseInt(match[1] + 'ff', 16) >>> 0;
    }
    var colorFromKeyword = normalizeKeyword(color);
    if (colorFromKeyword != null) {
      return colorFromKeyword;
    }
    if (match = matchers.rgb.exec(color)) {
      return (parse255(match[1]) << 24 |
      // r
      parse255(match[2]) << 16 |
      // g
      parse255(match[3]) << 8 |
      // b
      0x000000ff) >>>
      // a
      0;
    }
    if (match = matchers.rgba.exec(color)) {
      // rgba(R G B / A) notation
      if (match[6] !== undefined) {
        return (parse255(match[6]) << 24 |
        // r
        parse255(match[7]) << 16 |
        // g
        parse255(match[8]) << 8 |
        // b
        parse1(match[9])) >>>
        // a
        0;
      }

      // rgba(R, G, B, A) notation
      return (parse255(match[2]) << 24 |
      // r
      parse255(match[3]) << 16 |
      // g
      parse255(match[4]) << 8 |
      // b
      parse1(match[5])) >>>
      // a
      0;
    }
    if (match = matchers.hex3.exec(color)) {
      return parseInt(match[1] + match[1] +
      // r
      match[2] + match[2] +
      // g
      match[3] + match[3] +
      // b
      'ff',
      // a
      16) >>> 0;
    }

    // https://drafts.csswg.org/css-color-4/#hex-notation
    if (match = matchers.hex8.exec(color)) {
      return parseInt(match[1], 16) >>> 0;
    }
    if (match = matchers.hex4.exec(color)) {
      return parseInt(match[1] + match[1] +
      // r
      match[2] + match[2] +
      // g
      match[3] + match[3] +
      // b
      match[4] + match[4],
      // a
      16) >>> 0;
    }
    if (match = matchers.hsl.exec(color)) {
      return (hslToRgb(parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3]) // l
      ) | 0x000000ff) >>>
      // a
      0;
    }
    if (match = matchers.hsla.exec(color)) {
      // hsla(H S L / A) notation
      if (match[6] !== undefined) {
        return (hslToRgb(parse360(match[6]),
        // h
        parsePercentage(match[7]),
        // s
        parsePercentage(match[8]) // l
        ) | parse1(match[9])) >>>
        // a
        0;
      }

      // hsla(H, S, L, A) notation
      return (hslToRgb(parse360(match[2]),
      // h
      parsePercentage(match[3]),
      // s
      parsePercentage(match[4]) // l
      ) | parse1(match[5])) >>>
      // a
      0;
    }
    if (match = matchers.hwb.exec(color)) {
      return (hwbToRgb(parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // w
      parsePercentage(match[3]) // b
      ) | 0x000000ff) >>>
      // a
      0;
    }
    return null;
  }
  function hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }
    if (t > 1) {
      t -= 1;
    }
    if (t < 0.16666666666666666) {
      return p + (q - p) * 6 * t;
    }
    if (t < 0.5) {
      return q;
    }
    if (t < 0.6666666666666666) {
      return p + (q - p) * (0.6666666666666666 - t) * 6;
    }
    return p;
  }
  function hslToRgb(h, s, l) {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    var r = hue2rgb(p, q, h + 0.3333333333333333);
    var g = hue2rgb(p, q, h);
    var b = hue2rgb(p, q, h - 0.3333333333333333);
    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
  }
  function hwbToRgb(h, w, b) {
    if (w + b >= 1) {
      var gray = Math.round(w * 255 / (w + b));
      return gray << 24 | gray << 16 | gray << 8;
    }
    var red = hue2rgb(0, 1, h + 0.3333333333333333) * (1 - w - b) + w;
    var green = hue2rgb(0, 1, h) * (1 - w - b) + w;
    var blue = hue2rgb(0, 1, h - 0.3333333333333333) * (1 - w - b) + w;
    return Math.round(red * 255) << 24 | Math.round(green * 255) << 16 | Math.round(blue * 255) << 8;
  }
  var NUMBER = '[-+]?\\d*\\.?\\d+';
  var PERCENTAGE = "[-+]?\\d*\\.?\\d+%";
  function call() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return '\\(\\s*(' + args.join(')\\s*,?\\s*(') + ')\\s*\\)';
  }
  function callWithSlashSeparator() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return '\\(\\s*(' + args.slice(0, args.length - 1).join(')\\s*,?\\s*(') + ')\\s*/\\s*(' + args[args.length - 1] + ')\\s*\\)';
  }
  function commaSeparatedCall() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return '\\(\\s*(' + args.join(')\\s*,\\s*(') + ')\\s*\\)';
  }
  var cachedMatchers;
  function getMatchers() {
    if (cachedMatchers === undefined) {
      cachedMatchers = {
        rgb: new RegExp('rgb' + call(NUMBER, NUMBER, NUMBER)),
        rgba: new RegExp('rgba(' + commaSeparatedCall(NUMBER, NUMBER, NUMBER, NUMBER) + '|' + callWithSlashSeparator(NUMBER, NUMBER, NUMBER, NUMBER) + ')'),
        hsl: new RegExp('hsl' + call(NUMBER, PERCENTAGE, PERCENTAGE)),
        hsla: new RegExp('hsla(' + commaSeparatedCall(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER) + '|' + callWithSlashSeparator(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER) + ')'),
        hwb: new RegExp('hwb' + call(NUMBER, PERCENTAGE, PERCENTAGE)),
        hex3: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex4: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#([0-9a-fA-F]{6})$/,
        hex8: /^#([0-9a-fA-F]{8})$/
      };
    }
    return cachedMatchers;
  }
  function parse255(str) {
    var int = parseInt(str, 10);
    if (int < 0) {
      return 0;
    }
    if (int > 255) {
      return 255;
    }
    return int;
  }
  function parse360(str) {
    var int = parseFloat(str);
    return (int % 360 + 360) % 360 / 360;
  }
  function parse1(str) {
    var num = parseFloat(str);
    if (num < 0) {
      return 0;
    }
    if (num > 1) {
      return 255;
    }
    return Math.round(num * 255);
  }
  function parsePercentage(str) {
    // parseFloat conveniently ignores the final %
    var int = parseFloat(str);
    if (int < 0) {
      return 0;
    }
    if (int > 100) {
      return 1;
    }
    return int / 100;
  }
  function normalizeKeyword(name) {
    // prettier-ignore
    switch (name) {
      case 'transparent':
        return 0x00000000;
      // http://www.w3.org/TR/css3-color/#svg-color
      case 'aliceblue':
        return 0xf0f8ffff;
      case 'antiquewhite':
        return 0xfaebd7ff;
      case 'aqua':
        return 0x00ffffff;
      case 'aquamarine':
        return 0x7fffd4ff;
      case 'azure':
        return 0xf0ffffff;
      case 'beige':
        return 0xf5f5dcff;
      case 'bisque':
        return 0xffe4c4ff;
      case 'black':
        return 0x000000ff;
      case 'blanchedalmond':
        return 0xffebcdff;
      case 'blue':
        return 0x0000ffff;
      case 'blueviolet':
        return 0x8a2be2ff;
      case 'brown':
        return 0xa52a2aff;
      case 'burlywood':
        return 0xdeb887ff;
      case 'burntsienna':
        return 0xea7e5dff;
      case 'cadetblue':
        return 0x5f9ea0ff;
      case 'chartreuse':
        return 0x7fff00ff;
      case 'chocolate':
        return 0xd2691eff;
      case 'coral':
        return 0xff7f50ff;
      case 'cornflowerblue':
        return 0x6495edff;
      case 'cornsilk':
        return 0xfff8dcff;
      case 'crimson':
        return 0xdc143cff;
      case 'cyan':
        return 0x00ffffff;
      case 'darkblue':
        return 0x00008bff;
      case 'darkcyan':
        return 0x008b8bff;
      case 'darkgoldenrod':
        return 0xb8860bff;
      case 'darkgray':
        return 0xa9a9a9ff;
      case 'darkgreen':
        return 0x006400ff;
      case 'darkgrey':
        return 0xa9a9a9ff;
      case 'darkkhaki':
        return 0xbdb76bff;
      case 'darkmagenta':
        return 0x8b008bff;
      case 'darkolivegreen':
        return 0x556b2fff;
      case 'darkorange':
        return 0xff8c00ff;
      case 'darkorchid':
        return 0x9932ccff;
      case 'darkred':
        return 0x8b0000ff;
      case 'darksalmon':
        return 0xe9967aff;
      case 'darkseagreen':
        return 0x8fbc8fff;
      case 'darkslateblue':
        return 0x483d8bff;
      case 'darkslategray':
        return 0x2f4f4fff;
      case 'darkslategrey':
        return 0x2f4f4fff;
      case 'darkturquoise':
        return 0x00ced1ff;
      case 'darkviolet':
        return 0x9400d3ff;
      case 'deeppink':
        return 0xff1493ff;
      case 'deepskyblue':
        return 0x00bfffff;
      case 'dimgray':
        return 0x696969ff;
      case 'dimgrey':
        return 0x696969ff;
      case 'dodgerblue':
        return 0x1e90ffff;
      case 'firebrick':
        return 0xb22222ff;
      case 'floralwhite':
        return 0xfffaf0ff;
      case 'forestgreen':
        return 0x228b22ff;
      case 'fuchsia':
        return 0xff00ffff;
      case 'gainsboro':
        return 0xdcdcdcff;
      case 'ghostwhite':
        return 0xf8f8ffff;
      case 'gold':
        return 0xffd700ff;
      case 'goldenrod':
        return 0xdaa520ff;
      case 'gray':
        return 0x808080ff;
      case 'green':
        return 0x008000ff;
      case 'greenyellow':
        return 0xadff2fff;
      case 'grey':
        return 0x808080ff;
      case 'honeydew':
        return 0xf0fff0ff;
      case 'hotpink':
        return 0xff69b4ff;
      case 'indianred':
        return 0xcd5c5cff;
      case 'indigo':
        return 0x4b0082ff;
      case 'ivory':
        return 0xfffff0ff;
      case 'khaki':
        return 0xf0e68cff;
      case 'lavender':
        return 0xe6e6faff;
      case 'lavenderblush':
        return 0xfff0f5ff;
      case 'lawngreen':
        return 0x7cfc00ff;
      case 'lemonchiffon':
        return 0xfffacdff;
      case 'lightblue':
        return 0xadd8e6ff;
      case 'lightcoral':
        return 0xf08080ff;
      case 'lightcyan':
        return 0xe0ffffff;
      case 'lightgoldenrodyellow':
        return 0xfafad2ff;
      case 'lightgray':
        return 0xd3d3d3ff;
      case 'lightgreen':
        return 0x90ee90ff;
      case 'lightgrey':
        return 0xd3d3d3ff;
      case 'lightpink':
        return 0xffb6c1ff;
      case 'lightsalmon':
        return 0xffa07aff;
      case 'lightseagreen':
        return 0x20b2aaff;
      case 'lightskyblue':
        return 0x87cefaff;
      case 'lightslategray':
        return 0x778899ff;
      case 'lightslategrey':
        return 0x778899ff;
      case 'lightsteelblue':
        return 0xb0c4deff;
      case 'lightyellow':
        return 0xffffe0ff;
      case 'lime':
        return 0x00ff00ff;
      case 'limegreen':
        return 0x32cd32ff;
      case 'linen':
        return 0xfaf0e6ff;
      case 'magenta':
        return 0xff00ffff;
      case 'maroon':
        return 0x800000ff;
      case 'mediumaquamarine':
        return 0x66cdaaff;
      case 'mediumblue':
        return 0x0000cdff;
      case 'mediumorchid':
        return 0xba55d3ff;
      case 'mediumpurple':
        return 0x9370dbff;
      case 'mediumseagreen':
        return 0x3cb371ff;
      case 'mediumslateblue':
        return 0x7b68eeff;
      case 'mediumspringgreen':
        return 0x00fa9aff;
      case 'mediumturquoise':
        return 0x48d1ccff;
      case 'mediumvioletred':
        return 0xc71585ff;
      case 'midnightblue':
        return 0x191970ff;
      case 'mintcream':
        return 0xf5fffaff;
      case 'mistyrose':
        return 0xffe4e1ff;
      case 'moccasin':
        return 0xffe4b5ff;
      case 'navajowhite':
        return 0xffdeadff;
      case 'navy':
        return 0x000080ff;
      case 'oldlace':
        return 0xfdf5e6ff;
      case 'olive':
        return 0x808000ff;
      case 'olivedrab':
        return 0x6b8e23ff;
      case 'orange':
        return 0xffa500ff;
      case 'orangered':
        return 0xff4500ff;
      case 'orchid':
        return 0xda70d6ff;
      case 'palegoldenrod':
        return 0xeee8aaff;
      case 'palegreen':
        return 0x98fb98ff;
      case 'paleturquoise':
        return 0xafeeeeff;
      case 'palevioletred':
        return 0xdb7093ff;
      case 'papayawhip':
        return 0xffefd5ff;
      case 'peachpuff':
        return 0xffdab9ff;
      case 'peru':
        return 0xcd853fff;
      case 'pink':
        return 0xffc0cbff;
      case 'plum':
        return 0xdda0ddff;
      case 'powderblue':
        return 0xb0e0e6ff;
      case 'purple':
        return 0x800080ff;
      case 'rebeccapurple':
        return 0x663399ff;
      case 'red':
        return 0xff0000ff;
      case 'rosybrown':
        return 0xbc8f8fff;
      case 'royalblue':
        return 0x4169e1ff;
      case 'saddlebrown':
        return 0x8b4513ff;
      case 'salmon':
        return 0xfa8072ff;
      case 'sandybrown':
        return 0xf4a460ff;
      case 'seagreen':
        return 0x2e8b57ff;
      case 'seashell':
        return 0xfff5eeff;
      case 'sienna':
        return 0xa0522dff;
      case 'silver':
        return 0xc0c0c0ff;
      case 'skyblue':
        return 0x87ceebff;
      case 'slateblue':
        return 0x6a5acdff;
      case 'slategray':
        return 0x708090ff;
      case 'slategrey':
        return 0x708090ff;
      case 'snow':
        return 0xfffafaff;
      case 'springgreen':
        return 0x00ff7fff;
      case 'steelblue':
        return 0x4682b4ff;
      case 'tan':
        return 0xd2b48cff;
      case 'teal':
        return 0x008080ff;
      case 'thistle':
        return 0xd8bfd8ff;
      case 'tomato':
        return 0xff6347ff;
      case 'turquoise':
        return 0x40e0d0ff;
      case 'violet':
        return 0xee82eeff;
      case 'wheat':
        return 0xf5deb3ff;
      case 'white':
        return 0xffffffff;
      case 'whitesmoke':
        return 0xf5f5f5ff;
      case 'yellow':
        return 0xffff00ff;
      case 'yellowgreen':
        return 0x9acd32ff;
    }
    return null;
  }
  module.exports = normalizeColor;
},"bab9017c6ff43bb4a95b",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _defineProperty(e, r, t) {
    return (r = _$$_REQUIRE(_dependencyMap[0])(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e[r] = t, e;
  }
  module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"d57b125e535b41806db7",["a8c8780df4560174ada7"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var assets = [];
  function registerAsset(asset) {
    // `push` returns new array length, so the first asset will
    // get id 1 (not 0) to make the value truthy
    return assets.push(asset);
  }
  function getAssetByID(assetId) {
    return assets[assetId - 1];
  }
  module.exports = {
    registerAsset: registerAsset,
    getAssetByID: getAssetByID
  };
},"05d58bec2a6d939f08d8",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  var androidScaleSuffix = {
    '0.75': 'ldpi',
    '1': 'mdpi',
    '1.5': 'hdpi',
    '2': 'xhdpi',
    '3': 'xxhdpi',
    '4': 'xxxhdpi'
  };
  var ANDROID_BASE_DENSITY = 160;

  /**
   * FIXME: using number to represent discrete scale numbers is fragile in essence because of
   * floating point numbers imprecision.
   */
  function getAndroidAssetSuffix(scale) {
    if (scale.toString() in androidScaleSuffix) {
      return androidScaleSuffix[scale.toString()];
    }
    // NOTE: Android Gradle Plugin does not fully support the nnndpi format.
    // See https://issuetracker.google.com/issues/72884435
    if (Number.isFinite(scale) && scale > 0) {
      return Math.round(scale * ANDROID_BASE_DENSITY) + 'dpi';
    }
    throw new Error('no such scale ' + scale.toString());
  }

  // See https://developer.android.com/guide/topics/resources/drawable-resource.html
  var drawableFileTypes = new Set(['gif', 'jpeg', 'jpg', 'ktx', 'png', 'svg', 'webp', 'xml']);
  function getAndroidResourceFolderName(asset, scale) {
    if (!drawableFileTypes.has(asset.type)) {
      return 'raw';
    }
    var suffix = getAndroidAssetSuffix(scale);
    if (!suffix) {
      throw new Error("Don't know which android drawable suffix to use for scale: " + scale + '\nAsset: ' + JSON.stringify(asset, null, '\t') + '\nPossible scales are:' + JSON.stringify(androidScaleSuffix, null, '\t'));
    }
    return 'drawable-' + suffix;
  }
  function getAndroidResourceIdentifier(asset) {
    return (getBasePath(asset) + '/' + asset.name).toLowerCase().replace(/\//g, '_') // Encode folder structure in file name
    .replace(/([^a-z0-9_])/g, '') // Remove illegal chars
    .replace(/^assets_/, ''); // Remove "assets_" prefix
  }
  function getBasePath(asset) {
    var basePath = asset.httpServerLocation;
    return basePath.startsWith('/') ? basePath.substr(1) : basePath;
  }
  module.exports = {
    getAndroidResourceFolderName: getAndroidResourceFolderName,
    getAndroidResourceIdentifier: getAndroidResourceIdentifier,
    getBasePath: getBasePath
  };
},"914260cfb55fe13c431c",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  {
    module.exports = _$$_REQUIRE(_dependencyMap[0]);
  }
},"d57407eff7026d491c8a",["9daefd1335ff675770cb"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * scheduler.native.production.min.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  'use strict';

  function f(a, b) {
    var c = a.length;
    a.push(b);
    a: for (; 0 < c;) {
      var d = c - 1 >>> 1,
        e = a[d];
      if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;else break a;
    }
  }
  function h(a) {
    return 0 === a.length ? null : a[0];
  }
  function k(a) {
    if (0 === a.length) return null;
    var b = a[0],
      c = a.pop();
    if (c !== b) {
      a[0] = c;
      a: for (var d = 0, e = a.length, t = e >>> 1; d < t;) {
        var m = 2 * (d + 1) - 1,
          E = a[m],
          n = m + 1,
          A = a[n];
        if (0 > g(E, c)) n < e && 0 > g(A, E) ? (a[d] = A, a[n] = c, d = n) : (a[d] = E, a[m] = c, d = m);else if (n < e && 0 > g(A, c)) a[d] = A, a[n] = c, d = n;else break a;
      }
    }
    return b;
  }
  function g(a, b) {
    var c = a.sortIndex - b.sortIndex;
    return 0 !== c ? c : a.id - b.id;
  }
  var l;
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var p = performance;
    l = function l() {
      return p.now();
    };
  } else {
    var q = Date,
      r = q.now();
    l = function l() {
      return q.now() - r;
    };
  }
  var u = [],
    v = [],
    w = 1,
    x = null,
    y = 3,
    z = false,
    B = false,
    C = false,
    D = "function" === typeof setTimeout ? setTimeout : null,
    F = "function" === typeof clearTimeout ? clearTimeout : null,
    G = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && undefined !== navigator.scheduling && undefined !== navigator.scheduling.isInputPending ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
  function H(a) {
    for (var b = h(v); null !== b;) {
      if (null === b.callback) k(v);else if (b.startTime <= a) k(v), b.sortIndex = b.expirationTime, f(u, b);else break;
      b = h(v);
    }
  }
  function I(a) {
    C = false;
    H(a);
    if (!B) if (null !== h(u)) B = true, J = K, L || (L = true, M());else {
      var b = h(v);
      null !== b && N(I, b.startTime - a);
    }
  }
  function K(a, b) {
    B = false;
    C && (C = false, F(O), O = -1);
    z = true;
    var c = y;
    try {
      a: {
        H(b);
        for (x = h(u); null !== x && (!(x.expirationTime > b) || a && !P());) {
          var d = x.callback;
          if ("function" === typeof d) {
            x.callback = null;
            y = x.priorityLevel;
            var e = d(x.expirationTime <= b);
            b = l();
            if ("function" === typeof e) {
              x.callback = e;
              H(b);
              var t = true;
              break a;
            } else x === h(u) && k(u), H(b);
          } else k(u);
          x = h(u);
        }
        if (null !== x) t = true;else {
          var m = h(v);
          null !== m && N(I, m.startTime - b);
          t = false;
        }
      }
      return t;
    } finally {
      x = null, y = c, z = false;
    }
  }
  function Q(a, b, c) {
    var d = l();
    "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
    switch (a) {
      case 1:
        var e = -1;
        break;
      case 2:
        e = 250;
        break;
      case 5:
        e = 1073741823;
        break;
      case 4:
        e = 1E4;
        break;
      default:
        e = 5E3;
    }
    e = c + e;
    a = {
      id: w++,
      callback: b,
      priorityLevel: a,
      startTime: c,
      expirationTime: e,
      sortIndex: -1
    };
    c > d ? (a.sortIndex = c, f(v, a), null === h(u) && a === h(v) && (C ? (F(O), O = -1) : C = true, N(I, c - d))) : (a.sortIndex = e, f(u, a), B || z || (B = true, J = K, L || (L = true, M())));
    return a;
  }
  function R(a) {
    a.callback = null;
  }
  function S() {
    return y;
  }
  var L = false,
    J = null,
    O = -1,
    T = -1;
  function P() {
    return 5 > l() - T ? false : true;
  }
  function U() {}
  function V() {
    if (null !== J) {
      var a = l();
      T = a;
      var b = true;
      try {
        b = J(true, a);
      } finally {
        b ? M() : (L = false, J = null);
      }
    } else L = false;
  }
  var M;
  if ("function" === typeof G) M = function M() {
    G(V);
  };else if ("undefined" !== typeof MessageChannel) {
    var W = new MessageChannel(),
      X = W.port2;
    W.port1.onmessage = V;
    M = function M() {
      X.postMessage(null);
    };
  } else M = function M() {
    D(V, 0);
  };
  function N(a, b) {
    O = D(function () {
      a(l());
    }, b);
  }
  var Y = "undefined" !== typeof nativeRuntimeScheduler ? nativeRuntimeScheduler.unstable_UserBlockingPriority : 2,
    aa = "undefined" !== typeof nativeRuntimeScheduler ? nativeRuntimeScheduler.unstable_NormalPriority : 3,
    ba = "undefined" !== typeof nativeRuntimeScheduler ? nativeRuntimeScheduler.unstable_LowPriority : 4,
    ca = "undefined" !== typeof nativeRuntimeScheduler ? nativeRuntimeScheduler.unstable_ImmediatePriority : 1,
    da = "undefined" !== typeof nativeRuntimeScheduler ? nativeRuntimeScheduler.unstable_scheduleCallback : Q,
    ea = "undefined" !== typeof nativeRuntimeScheduler ? nativeRuntimeScheduler.unstable_cancelCallback : R,
    fa = "undefined" !== typeof nativeRuntimeScheduler ? nativeRuntimeScheduler.unstable_getCurrentPriorityLevel : S,
    ha = "undefined" !== typeof nativeRuntimeScheduler ? nativeRuntimeScheduler.unstable_shouldYield : P,
    ia = "undefined" !== typeof nativeRuntimeScheduler ? nativeRuntimeScheduler.unstable_requestPaint : U,
    ja = "undefined" !== typeof nativeRuntimeScheduler ? nativeRuntimeScheduler.unstable_now : l;
  function Z() {
    throw Error("Not implemented.");
  }
  exports.unstable_IdlePriority = "undefined" !== typeof nativeRuntimeScheduler ? nativeRuntimeScheduler.unstable_IdlePriority : 5;
  exports.unstable_ImmediatePriority = ca;
  exports.unstable_LowPriority = ba;
  exports.unstable_NormalPriority = aa;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = Y;
  exports.unstable_cancelCallback = ea;
  exports.unstable_continueExecution = Z;
  exports.unstable_forceFrameRate = Z;
  exports.unstable_getCurrentPriorityLevel = fa;
  exports.unstable_getFirstCallbackNode = Z;
  exports.unstable_next = Z;
  exports.unstable_now = ja;
  exports.unstable_pauseExecution = Z;
  exports.unstable_requestPaint = ia;
  exports.unstable_runWithPriority = Z;
  exports.unstable_scheduleCallback = da;
  exports.unstable_shouldYield = ha;
  exports.unstable_wrapCallback = Z;
},"9daefd1335ff675770cb",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  module.exports = {
    get ColorPropType() {
      return _$$_REQUIRE(_dependencyMap[0]);
    },
    get EdgeInsetsPropType() {
      return _$$_REQUIRE(_dependencyMap[1]);
    },
    get ImagePropTypes() {
      return _$$_REQUIRE(_dependencyMap[2]);
    },
    get PointPropType() {
      return _$$_REQUIRE(_dependencyMap[3]);
    },
    get TextInputPropTypes() {
      return _$$_REQUIRE(_dependencyMap[4]);
    },
    get TextPropTypes() {
      return _$$_REQUIRE(_dependencyMap[5]);
    },
    get ViewPropTypes() {
      return _$$_REQUIRE(_dependencyMap[6]);
    }
  };
},"4b5aec8d0b1af0b13fc9",["0ff2848f3ff6f1a02356","e113bc2a6b8133e753f1","9f1779357aba412bb49f","792d53fa12840d39c921","a287f54379336e9f732c","14b8482f38362fa2f8cd","6a37ec0494ff683c49f2"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   */

  'use strict';

  /**
   * @see facebook/react-native/Libraries/StyleSheet/StyleSheetTypes.js
   */
  var colorPropType = function colorPropType(isRequired, props, propName, componentName, location, propFullName) {
    var color = props[propName];
    if (color == null) {
      if (isRequired) {
        return new Error('Required ' + location + ' `' + (propFullName || propName) + '` was not specified in `' + componentName + '`.');
      }
      return;
    }
    if (typeof color === 'number') {
      // Developers should not use a number, but we are using the prop type
      // both for user provided colors and for transformed ones. This isn't ideal
      // and should be fixed but will do for now...
      return;
    }
    if (typeof color === 'string' && _$$_REQUIRE(_dependencyMap[0])(color) === null) {
      return new Error('Invalid ' + location + ' `' + (propFullName || propName) + '` supplied to `' + componentName + '`: ' + color + '\n' + `Valid color formats are
  - '#f0f' (#rgb)
  - '#f0fc' (#rgba)
  - '#ff00ff' (#rrggbb)
  - '#ff00ff00' (#rrggbbaa)
  - 'rgb(255, 255, 255)'
  - 'rgba(255, 255, 255, 1.0)'
  - 'hsl(360, 100%, 100%)'
  - 'hsla(360, 100%, 100%, 1.0)'
  - 'transparent'
  - 'red'
  - 0xff00ff00 (0xrrggbbaa)
`);
    }
  };
  var ColorPropType = colorPropType.bind(null, false /* isRequired */);
  ColorPropType.isRequired = colorPropType.bind(null, true /* isRequired */);
  module.exports = ColorPropType;
},"0ff2848f3ff6f1a02356",["bab9017c6ff43bb4a95b"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   */

  'use strict';

  /**
   * @see facebook/react-native/Libraries/StyleSheet/Rect.js
   */
  var DeprecatedEdgeInsetsPropType = _$$_REQUIRE(_dependencyMap[0]).shape({
    bottom: _$$_REQUIRE(_dependencyMap[0]).number,
    left: _$$_REQUIRE(_dependencyMap[0]).number,
    right: _$$_REQUIRE(_dependencyMap[0]).number,
    top: _$$_REQUIRE(_dependencyMap[0]).number
  });
  module.exports = DeprecatedEdgeInsetsPropType;
},"e113bc2a6b8133e753f1",["385f56cce85bf58dda18"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  {
    // By explicitly using `prop-types` you are opting into new production behavior.
    // http://fb.me/prop-types-in-prod
    module.exports = _$$_REQUIRE(_dependencyMap[0])();
  }
},"385f56cce85bf58dda18",["211f6d600f40629e26d0"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use strict';

  function emptyFunction() {}
  function emptyFunctionWithReset() {}
  emptyFunctionWithReset.resetWarningCache = emptyFunction;
  module.exports = function () {
    function shim(props, propName, componentName, location, propFullName, secret) {
      if (secret === _$$_REQUIRE(_dependencyMap[0])) {
        // It is still safe when called from React.
        return;
      }
      var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
      err.name = 'Invariant Violation';
      throw err;
    }
    ;
    shim.isRequired = shim;
    function getShim() {
      return shim;
    }
    ;
    // Important!
    // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
    var ReactPropTypes = {
      array: shim,
      bigint: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,
      any: shim,
      arrayOf: getShim,
      element: shim,
      elementType: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
},"211f6d600f40629e26d0",["3ac224506c12c2b4339c"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use strict';

  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
  module.exports = ReactPropTypesSecret;
},"3ac224506c12c2b4339c",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   */

  'use strict';

  /**
   * @see facebook/react-native/Libraries/Image/ImageProps.js
   */
  var DeprecatedImagePropType = Object.assign({}, _$$_REQUIRE(_dependencyMap[0]), {
    alt: _$$_REQUIRE(_dependencyMap[1]).string,
    blurRadius: _$$_REQUIRE(_dependencyMap[1]).number,
    capInsets: _$$_REQUIRE(_dependencyMap[2]),
    crossOrigin: _$$_REQUIRE(_dependencyMap[1]).oneOf(['anonymous', 'use-credentials']),
    defaultSource: _$$_REQUIRE(_dependencyMap[3]),
    fadeDuration: _$$_REQUIRE(_dependencyMap[1]).number,
    height: _$$_REQUIRE(_dependencyMap[1]).number,
    internal_analyticTag: _$$_REQUIRE(_dependencyMap[1]).string,
    loadingIndicatorSource: _$$_REQUIRE(_dependencyMap[1]).oneOfType([_$$_REQUIRE(_dependencyMap[1]).shape({
      uri: _$$_REQUIRE(_dependencyMap[1]).string
    }), _$$_REQUIRE(_dependencyMap[1]).number]),
    onError: _$$_REQUIRE(_dependencyMap[1]).func,
    onLoad: _$$_REQUIRE(_dependencyMap[1]).func,
    onLoadEnd: _$$_REQUIRE(_dependencyMap[1]).func,
    onLoadStart: _$$_REQUIRE(_dependencyMap[1]).func,
    onPartialLoad: _$$_REQUIRE(_dependencyMap[1]).func,
    onProgress: _$$_REQUIRE(_dependencyMap[1]).func,
    progressiveRenderingEnabled: _$$_REQUIRE(_dependencyMap[1]).bool,
    referrerPolicy: _$$_REQUIRE(_dependencyMap[1]).oneOf(['no-referrer', 'no-referrer-when-downgrade', 'origin', 'origin-when-cross-origin', 'same-origin', 'strict-origin', 'strict-origin-when-cross-origin', 'unsafe-url']),
    resizeMethod: _$$_REQUIRE(_dependencyMap[1]).oneOf(['auto', 'resize', 'scale']),
    resizeMode: _$$_REQUIRE(_dependencyMap[1]).oneOf(['cover', 'contain', 'stretch', 'repeat', 'center']),
    source: _$$_REQUIRE(_dependencyMap[3]),
    src: _$$_REQUIRE(_dependencyMap[1]).string,
    srcSet: _$$_REQUIRE(_dependencyMap[1]).string,
    style: _$$_REQUIRE(_dependencyMap[4])(_$$_REQUIRE(_dependencyMap[5])),
    testID: _$$_REQUIRE(_dependencyMap[1]).string,
    tintColor: _$$_REQUIRE(_dependencyMap[6]),
    width: _$$_REQUIRE(_dependencyMap[1]).number
  });
  module.exports = DeprecatedImagePropType;
},"9f1779357aba412bb49f",["6a37ec0494ff683c49f2","385f56cce85bf58dda18","e113bc2a6b8133e753f1","00fed86b64880bf848bf","ecd8893ff4b33ee73955","0b77c2d463c8dbef3508","0ff2848f3ff6f1a02356"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   */

  'use strict';

  var MouseEventPropTypes = {
    onMouseEnter: _$$_REQUIRE(_dependencyMap[0]).func,
    onMouseLeave: _$$_REQUIRE(_dependencyMap[0]).func
  };

  // Experimental/Work in Progress Pointer Event Callbacks (not yet ready for use)
  var PointerEventPropTypes = {
    onPointerEnter: _$$_REQUIRE(_dependencyMap[0]).func,
    onPointerEnterCapture: _$$_REQUIRE(_dependencyMap[0]).func,
    onPointerLeave: _$$_REQUIRE(_dependencyMap[0]).func,
    onPointerLeaveCapture: _$$_REQUIRE(_dependencyMap[0]).func,
    onPointerMove: _$$_REQUIRE(_dependencyMap[0]).func,
    onPointerMoveCapture: _$$_REQUIRE(_dependencyMap[0]).func,
    onPointerCancel: _$$_REQUIRE(_dependencyMap[0]).func,
    onPointerCancelCapture: _$$_REQUIRE(_dependencyMap[0]).func,
    onPointerDown: _$$_REQUIRE(_dependencyMap[0]).func,
    onPointerDownCapture: _$$_REQUIRE(_dependencyMap[0]).func,
    onPointerUp: _$$_REQUIRE(_dependencyMap[0]).func,
    onPointerUpCapture: _$$_REQUIRE(_dependencyMap[0]).func,
    onPointerOver: _$$_REQUIRE(_dependencyMap[0]).func,
    onPointerOverCapture: _$$_REQUIRE(_dependencyMap[0]).func,
    onPointerOut: _$$_REQUIRE(_dependencyMap[0]).func,
    onPointerOutCapture: _$$_REQUIRE(_dependencyMap[0]).func
  };
  var FocusEventPropTypes = {
    onBlur: _$$_REQUIRE(_dependencyMap[0]).func,
    onBlurCapture: _$$_REQUIRE(_dependencyMap[0]).func,
    onFocus: _$$_REQUIRE(_dependencyMap[0]).func,
    onFocusCapture: _$$_REQUIRE(_dependencyMap[0]).func
  };
  var TouchEventPropTypes = {
    onTouchCancel: _$$_REQUIRE(_dependencyMap[0]).func,
    onTouchCancelCapture: _$$_REQUIRE(_dependencyMap[0]).func,
    onTouchEnd: _$$_REQUIRE(_dependencyMap[0]).func,
    onTouchEndCapture: _$$_REQUIRE(_dependencyMap[0]).func,
    onTouchMove: _$$_REQUIRE(_dependencyMap[0]).func,
    onTouchMoveCapture: _$$_REQUIRE(_dependencyMap[0]).func,
    onTouchStart: _$$_REQUIRE(_dependencyMap[0]).func,
    onTouchStartCapture: _$$_REQUIRE(_dependencyMap[0]).func
  };
  var GestureResponderEventPropTypes = {
    onMoveShouldSetResponder: _$$_REQUIRE(_dependencyMap[0]).func,
    onMoveShouldSetResponderCapture: _$$_REQUIRE(_dependencyMap[0]).func,
    onResponderEnd: _$$_REQUIRE(_dependencyMap[0]).func,
    onResponderGrant: _$$_REQUIRE(_dependencyMap[0]).func,
    onResponderMove: _$$_REQUIRE(_dependencyMap[0]).func,
    onResponderReject: _$$_REQUIRE(_dependencyMap[0]).func,
    onResponderRelease: _$$_REQUIRE(_dependencyMap[0]).func,
    onResponderStart: _$$_REQUIRE(_dependencyMap[0]).func,
    onResponderTerminate: _$$_REQUIRE(_dependencyMap[0]).func,
    onResponderTerminationRequest: _$$_REQUIRE(_dependencyMap[0]).func,
    onStartShouldSetResponder: _$$_REQUIRE(_dependencyMap[0]).func,
    onStartShouldSetResponderCapture: _$$_REQUIRE(_dependencyMap[0]).func
  };

  /**
   * @see facebook/react-native/Libraries/Components/View/ViewPropTypes.js
   */
  var DeprecatedViewPropTypes = Object.assign({}, MouseEventPropTypes, PointerEventPropTypes, FocusEventPropTypes, TouchEventPropTypes, GestureResponderEventPropTypes, {
    'aria-busy': _$$_REQUIRE(_dependencyMap[0]).bool,
    'aria-checked': _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).bool, _$$_REQUIRE(_dependencyMap[0]).oneOf(['mixed'])]),
    'aria-disabled': _$$_REQUIRE(_dependencyMap[0]).bool,
    'aria-expanded': _$$_REQUIRE(_dependencyMap[0]).bool,
    'aria-hidden': _$$_REQUIRE(_dependencyMap[0]).bool,
    'aria-label': _$$_REQUIRE(_dependencyMap[0]).string,
    'aria-labelledby': _$$_REQUIRE(_dependencyMap[0]).string,
    'aria-live': _$$_REQUIRE(_dependencyMap[0]).oneOf(['polite', 'assertive', 'off']),
    'aria-modal': _$$_REQUIRE(_dependencyMap[0]).bool,
    'aria-selected': _$$_REQUIRE(_dependencyMap[0]).bool,
    'aria-valuemax': _$$_REQUIRE(_dependencyMap[0]).number,
    'aria-valuemin': _$$_REQUIRE(_dependencyMap[0]).number,
    'aria-valuenow': _$$_REQUIRE(_dependencyMap[0]).number,
    'aria-valuetext': _$$_REQUIRE(_dependencyMap[0]).string,
    accessibilityActions: _$$_REQUIRE(_dependencyMap[0]).arrayOf(_$$_REQUIRE(_dependencyMap[1]).AccessibilityActionInfoPropType),
    accessibilityElementsHidden: _$$_REQUIRE(_dependencyMap[0]).bool,
    accessibilityHint: _$$_REQUIRE(_dependencyMap[0]).string,
    accessibilityIgnoresInvertColors: _$$_REQUIRE(_dependencyMap[0]).bool,
    accessibilityLabel: _$$_REQUIRE(_dependencyMap[0]).node,
    accessibilityLabelledBy: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).string, _$$_REQUIRE(_dependencyMap[0]).arrayOf(_$$_REQUIRE(_dependencyMap[0]).string)]),
    accessibilityLanguage: _$$_REQUIRE(_dependencyMap[0]).string,
    accessibilityLiveRegion: _$$_REQUIRE(_dependencyMap[0]).oneOf(['assertive', 'none', 'polite']),
    accessibilityRole: _$$_REQUIRE(_dependencyMap[1]).AccessibilityRolePropType,
    accessibilityState: _$$_REQUIRE(_dependencyMap[1]).AccessibilityStatePropType,
    accessibilityValue: _$$_REQUIRE(_dependencyMap[1]).AccessibilityValuePropType,
    accessibilityViewIsModal: _$$_REQUIRE(_dependencyMap[0]).bool,
    accessible: _$$_REQUIRE(_dependencyMap[0]).bool,
    collapsable: _$$_REQUIRE(_dependencyMap[0]).bool,
    focusable: _$$_REQUIRE(_dependencyMap[0]).bool,
    hitSlop: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[2]), _$$_REQUIRE(_dependencyMap[0]).number]),
    importantForAccessibility: _$$_REQUIRE(_dependencyMap[0]).oneOf(['auto', 'no', 'no-hide-descendants', 'yes']),
    nativeBackgroundAndroid: _$$_REQUIRE(_dependencyMap[0]).object,
    nativeForegroundAndroid: _$$_REQUIRE(_dependencyMap[0]).object,
    nativeID: _$$_REQUIRE(_dependencyMap[0]).string,
    needsOffscreenAlphaCompositing: _$$_REQUIRE(_dependencyMap[0]).bool,
    onAccessibilityAction: _$$_REQUIRE(_dependencyMap[0]).func,
    onAccessibilityEscape: _$$_REQUIRE(_dependencyMap[0]).func,
    onAccessibilityTap: _$$_REQUIRE(_dependencyMap[0]).func,
    onClick: _$$_REQUIRE(_dependencyMap[0]).func,
    onLayout: _$$_REQUIRE(_dependencyMap[0]).func,
    onMagicTap: _$$_REQUIRE(_dependencyMap[0]).func,
    pointerEvents: _$$_REQUIRE(_dependencyMap[0]).oneOf(['auto', 'box-none', 'box-only', 'none']),
    removeClippedSubviews: _$$_REQUIRE(_dependencyMap[0]).bool,
    renderToHardwareTextureAndroid: _$$_REQUIRE(_dependencyMap[0]).bool,
    role: _$$_REQUIRE(_dependencyMap[1]).RolePropType,
    shouldRasterizeIOS: _$$_REQUIRE(_dependencyMap[0]).bool,
    style: _$$_REQUIRE(_dependencyMap[3])(_$$_REQUIRE(_dependencyMap[4])),
    tabIndex: _$$_REQUIRE(_dependencyMap[0]).oneOf([0, -1]),
    testID: _$$_REQUIRE(_dependencyMap[0]).string
  });
  module.exports = DeprecatedViewPropTypes;
},"6a37ec0494ff683c49f2",["385f56cce85bf58dda18","dc269c006cd52aa8a392","e113bc2a6b8133e753f1","ecd8893ff4b33ee73955","b0bd5168a69d8a903511"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   */

  'use strict';

  /**
   * @see facebook/react-native/Libraries/Components/View/ViewAccessibility.js
   */
  var DeprecatedViewAccessibility = {
    AccessibilityRolePropType: _$$_REQUIRE(_dependencyMap[0]).oneOf(['adjustable', 'alert', 'button', 'checkbox', 'combobox', 'drawerlayout', 'dropdownlist', 'grid', 'header', 'horizontalscrollview', 'iconmenu', 'image', 'imagebutton', 'keyboardkey', 'link', 'list', 'menu', 'menubar', 'menuitem', 'none', 'pager', 'progressbar', 'radio', 'radiogroup', 'scrollbar', 'scrollview', 'search', 'slidingdrawer', 'spinbutton', 'summary', 'switch', 'tab', 'tabbar', 'tablist', 'text', 'timer', 'togglebutton', 'toolbar', 'viewgroup', 'webview']),
    AccessibilityStatePropType: _$$_REQUIRE(_dependencyMap[0]).object,
    AccessibilityActionInfoPropType: _$$_REQUIRE(_dependencyMap[0]).object,
    AccessibilityValuePropType: _$$_REQUIRE(_dependencyMap[0]).object,
    RolePropType: _$$_REQUIRE(_dependencyMap[0]).oneOf(['alert', 'alertdialog', 'application', 'article', 'banner', 'button', 'cell', 'checkbox', 'columnheader', 'combobox', 'complementary', 'contentinfo', 'definition', 'dialog', 'directory', 'document', 'feed', 'figure', 'form', 'grid', 'group', 'heading', 'img', 'link', 'list', 'listitem', 'log', 'main', 'marquee', 'math', 'menu', 'menubar', 'menuitem', 'meter', 'navigation', 'none', 'note', 'option', 'presentation', 'progressbar', 'radio', 'radiogroup', 'region', 'row', 'rowgroup', 'rowheader', 'scrollbar', 'searchbox', 'separator', 'slider', 'spinbutton', 'status', 'summary', 'switch', 'tab', 'table', 'tablist', 'tabpanel', 'term', 'timer', 'toolbar', 'tooltip', 'tree', 'treegrid', 'treeitem'])
  };
  module.exports = DeprecatedViewAccessibility;
},"dc269c006cd52aa8a392",["385f56cce85bf58dda18"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   */

  'use strict';

  function DeprecatedStyleSheetPropType(shape) {
    var shapePropType = _$$_REQUIRE(_dependencyMap[0])(shape);
    return function (props, propName, componentName, location) {
      var newProps = props;
      if (props[propName]) {
        // Just make a dummy prop object with only the flattened style
        newProps = {};
        newProps[propName] = flattenStyle(props[propName]);
      }
      for (var _len = arguments.length, rest = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
        rest[_key - 4] = arguments[_key];
      }
      return shapePropType.apply(undefined, [newProps, propName, componentName, location].concat(rest));
    };
  }
  function flattenStyle(style) {
    if (style === null || typeof style !== 'object') {
      return undefined;
    }
    if (!Array.isArray(style)) {
      return style;
    }
    var result = {};
    for (var i = 0, styleLength = style.length; i < styleLength; ++i) {
      var computedStyle = flattenStyle(style[i]);
      if (computedStyle) {
        for (var key in computedStyle) {
          result[key] = computedStyle[key];
        }
      }
    }
    return result;
  }
  module.exports = DeprecatedStyleSheetPropType;
},"ecd8893ff4b33ee73955",["2c266ae4211321471d0d"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   */

  'use strict';

  function deprecatedCreateStrictShapeTypeChecker(shapeTypes) {
    function checkType(isRequired, props, propName, componentName, location) {
      if (!props[propName]) {
        if (isRequired) {
          _$$_REQUIRE(_dependencyMap[0])(false, `Required object \`${propName}\` was not specified in ` + `\`${componentName}\`.`);
        }
        return;
      }
      var propValue = props[propName];
      var propType = typeof propValue;
      var locationName = location || '(unknown)';
      if (propType !== 'object') {
        _$$_REQUIRE(_dependencyMap[0])(false, `Invalid ${locationName} \`${propName}\` of type \`${propType}\` ` + `supplied to \`${componentName}\`, expected \`object\`.`);
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = Object.assign({}, props[propName], shapeTypes);
      for (var _len = arguments.length, rest = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
        rest[_key - 5] = arguments[_key];
      }
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          _$$_REQUIRE(_dependencyMap[0])(false, `Invalid props.${propName} key \`${key}\` supplied to \`${componentName}\`.` + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
        }
        var error = checker.apply(undefined, [propValue, key, componentName, location].concat(rest));
        if (error) {
          _$$_REQUIRE(_dependencyMap[0])(false, error.message + '\nBad object: ' + JSON.stringify(props[propName], null, '  '));
        }
      }
    }
    function chainedCheckType(props, propName, componentName, location) {
      for (var _len2 = arguments.length, rest = new Array(_len2 > 4 ? _len2 - 4 : 0), _key2 = 4; _key2 < _len2; _key2++) {
        rest[_key2 - 4] = arguments[_key2];
      }
      return checkType.apply(undefined, [false, props, propName, componentName, location].concat(rest));
    }
    chainedCheckType.isRequired = checkType.bind(null, true);
    return chainedCheckType;
  }
  module.exports = deprecatedCreateStrictShapeTypeChecker;
},"2c266ae4211321471d0d",["fd099686726b2dfb6f66"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   */

  'use strict';

  /**
   * @see facebook/react-native/Libraries/StyleSheet/StyleSheetTypes.js
   */
  var DeprecatedViewStylePropTypes = Object.assign({}, _$$_REQUIRE(_dependencyMap[0]), _$$_REQUIRE(_dependencyMap[1]), _$$_REQUIRE(_dependencyMap[2]), {
    backfaceVisibility: _$$_REQUIRE(_dependencyMap[3]).oneOf(['hidden', 'visible']),
    backgroundColor: _$$_REQUIRE(_dependencyMap[4]),
    borderBottomColor: _$$_REQUIRE(_dependencyMap[4]),
    borderBottomEndRadius: _$$_REQUIRE(_dependencyMap[3]).number,
    borderBottomLeftRadius: _$$_REQUIRE(_dependencyMap[3]).number,
    borderBottomRightRadius: _$$_REQUIRE(_dependencyMap[3]).number,
    borderBottomStartRadius: _$$_REQUIRE(_dependencyMap[3]).number,
    borderBottomWidth: _$$_REQUIRE(_dependencyMap[3]).number,
    borderColor: _$$_REQUIRE(_dependencyMap[4]),
    borderCurve: _$$_REQUIRE(_dependencyMap[3]).oneOf(['circular', 'continuous']),
    borderEndColor: _$$_REQUIRE(_dependencyMap[4]),
    borderEndEndRadius: _$$_REQUIRE(_dependencyMap[3]).number,
    borderEndStartRadius: _$$_REQUIRE(_dependencyMap[3]).number,
    borderLeftColor: _$$_REQUIRE(_dependencyMap[4]),
    borderLeftWidth: _$$_REQUIRE(_dependencyMap[3]).number,
    borderRadius: _$$_REQUIRE(_dependencyMap[3]).number,
    borderRightColor: _$$_REQUIRE(_dependencyMap[4]),
    borderRightWidth: _$$_REQUIRE(_dependencyMap[3]).number,
    borderStartColor: _$$_REQUIRE(_dependencyMap[4]),
    borderStartEndRadius: _$$_REQUIRE(_dependencyMap[3]).number,
    borderStartStartRadius: _$$_REQUIRE(_dependencyMap[3]).number,
    borderStyle: _$$_REQUIRE(_dependencyMap[3]).oneOf(['dashed', 'dotted', 'solid']),
    borderTopColor: _$$_REQUIRE(_dependencyMap[4]),
    borderTopEndRadius: _$$_REQUIRE(_dependencyMap[3]).number,
    borderTopLeftRadius: _$$_REQUIRE(_dependencyMap[3]).number,
    borderTopRightRadius: _$$_REQUIRE(_dependencyMap[3]).number,
    borderTopStartRadius: _$$_REQUIRE(_dependencyMap[3]).number,
    borderTopWidth: _$$_REQUIRE(_dependencyMap[3]).number,
    borderWidth: _$$_REQUIRE(_dependencyMap[3]).number,
    elevation: _$$_REQUIRE(_dependencyMap[3]).number,
    opacity: _$$_REQUIRE(_dependencyMap[3]).number,
    pointerEvents: _$$_REQUIRE(_dependencyMap[3]).oneOf(['auto', 'box-none', 'box-only', 'none'])
  });
  module.exports = DeprecatedViewStylePropTypes;
},"b0bd5168a69d8a903511",["fdc284a1196df7b8b1c7","c694fefe532e4748da9d","1dd7395967b3c81dc0f2","385f56cce85bf58dda18","0ff2848f3ff6f1a02356"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   */

  'use strict';

  var DimensionValuePropType = _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]);

  /**
   * @see facebook/react-native/Libraries/StyleSheet/StyleSheetTypes.js
   */
  var DeprecatedLayoutPropTypes = {
    alignContent: _$$_REQUIRE(_dependencyMap[0]).oneOf(['center', 'flex-end', 'flex-start', 'space-around', 'space-between', 'stretch']),
    alignItems: _$$_REQUIRE(_dependencyMap[0]).oneOf(['baseline', 'center', 'flex-end', 'flex-start', 'stretch']),
    alignSelf: _$$_REQUIRE(_dependencyMap[0]).oneOf(['auto', 'baseline', 'center', 'flex-end', 'flex-start', 'stretch']),
    aspectRatio: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    borderBottomWidth: _$$_REQUIRE(_dependencyMap[0]).number,
    borderEndWidth: _$$_REQUIRE(_dependencyMap[0]).number,
    borderLeftWidth: _$$_REQUIRE(_dependencyMap[0]).number,
    borderRightWidth: _$$_REQUIRE(_dependencyMap[0]).number,
    borderStartWidth: _$$_REQUIRE(_dependencyMap[0]).number,
    borderTopWidth: _$$_REQUIRE(_dependencyMap[0]).number,
    borderWidth: _$$_REQUIRE(_dependencyMap[0]).number,
    bottom: DimensionValuePropType,
    columnGap: _$$_REQUIRE(_dependencyMap[0]).number,
    direction: _$$_REQUIRE(_dependencyMap[0]).oneOf(['inherit', 'ltr', 'rtl']),
    display: _$$_REQUIRE(_dependencyMap[0]).oneOf(['flex', 'none']),
    end: DimensionValuePropType,
    flex: _$$_REQUIRE(_dependencyMap[0]).number,
    flexBasis: DimensionValuePropType,
    flexDirection: _$$_REQUIRE(_dependencyMap[0]).oneOf(['column', 'column-reverse', 'row', 'row-reverse']),
    flexGrow: _$$_REQUIRE(_dependencyMap[0]).number,
    flexShrink: _$$_REQUIRE(_dependencyMap[0]).number,
    flexWrap: _$$_REQUIRE(_dependencyMap[0]).oneOf(['nowrap', 'wrap', 'wrap-reverse']),
    gap: _$$_REQUIRE(_dependencyMap[0]).number,
    height: DimensionValuePropType,
    inset: DimensionValuePropType,
    insetBlock: DimensionValuePropType,
    insetBlockEnd: DimensionValuePropType,
    insetBlockStart: DimensionValuePropType,
    insetInline: DimensionValuePropType,
    insetInlineEnd: DimensionValuePropType,
    insetInlineStart: DimensionValuePropType,
    justifyContent: _$$_REQUIRE(_dependencyMap[0]).oneOf(['center', 'flex-end', 'flex-start', 'space-around', 'space-between', 'space-evenly']),
    left: DimensionValuePropType,
    margin: DimensionValuePropType,
    marginBlock: DimensionValuePropType,
    marginBlockEnd: DimensionValuePropType,
    marginBlockStart: DimensionValuePropType,
    marginBottom: DimensionValuePropType,
    marginEnd: DimensionValuePropType,
    marginHorizontal: DimensionValuePropType,
    marginInline: DimensionValuePropType,
    marginInlineEnd: DimensionValuePropType,
    marginInlineStart: DimensionValuePropType,
    marginLeft: DimensionValuePropType,
    marginRight: DimensionValuePropType,
    marginStart: DimensionValuePropType,
    marginTop: DimensionValuePropType,
    marginVertical: DimensionValuePropType,
    maxHeight: DimensionValuePropType,
    maxWidth: DimensionValuePropType,
    minHeight: DimensionValuePropType,
    minWidth: DimensionValuePropType,
    overflow: _$$_REQUIRE(_dependencyMap[0]).oneOf(['hidden', 'scroll', 'visible']),
    padding: DimensionValuePropType,
    paddingBlock: DimensionValuePropType,
    paddingBlockEnd: DimensionValuePropType,
    paddingBlockStart: DimensionValuePropType,
    paddingBottom: DimensionValuePropType,
    paddingEnd: DimensionValuePropType,
    paddingHorizontal: DimensionValuePropType,
    paddingInline: DimensionValuePropType,
    paddingInlineEnd: DimensionValuePropType,
    paddingInlineStart: DimensionValuePropType,
    paddingLeft: DimensionValuePropType,
    paddingRight: DimensionValuePropType,
    paddingStart: DimensionValuePropType,
    paddingTop: DimensionValuePropType,
    paddingVertical: DimensionValuePropType,
    position: _$$_REQUIRE(_dependencyMap[0]).oneOf(['absolute', 'relative']),
    right: DimensionValuePropType,
    rowGap: _$$_REQUIRE(_dependencyMap[0]).number,
    start: DimensionValuePropType,
    top: DimensionValuePropType,
    width: DimensionValuePropType,
    zIndex: _$$_REQUIRE(_dependencyMap[0]).number
  };
  module.exports = DeprecatedLayoutPropTypes;
},"fdc284a1196df7b8b1c7",["385f56cce85bf58dda18"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   */

  'use strict';

  /**
   * @see facebook/react-native/Libraries/StyleSheet/StyleSheetTypes.js
   */
  var DeprecatedShadowPropTypesIOS = {
    shadowColor: _$$_REQUIRE(_dependencyMap[0]),
    shadowOffset: _$$_REQUIRE(_dependencyMap[1]).shape({
      height: _$$_REQUIRE(_dependencyMap[1]).number,
      width: _$$_REQUIRE(_dependencyMap[1]).number
    }),
    shadowOpacity: _$$_REQUIRE(_dependencyMap[1]).number,
    shadowRadius: _$$_REQUIRE(_dependencyMap[1]).number
  };
  module.exports = DeprecatedShadowPropTypesIOS;
},"c694fefe532e4748da9d",["0ff2848f3ff6f1a02356","385f56cce85bf58dda18"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   */

  'use strict';

  /**
   * @see facebook/react-native/Libraries/StyleSheet/private/_TransformStyle.js
   */
  var DeprecatedTransformPropTypes = {
    transform: _$$_REQUIRE(_dependencyMap[0]).arrayOf(_$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).shape({
      perspective: _$$_REQUIRE(_dependencyMap[0]).number
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      rotate: _$$_REQUIRE(_dependencyMap[0]).string
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      rotateX: _$$_REQUIRE(_dependencyMap[0]).string
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      rotateY: _$$_REQUIRE(_dependencyMap[0]).string
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      rotateZ: _$$_REQUIRE(_dependencyMap[0]).string
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      scale: _$$_REQUIRE(_dependencyMap[0]).number
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      scaleX: _$$_REQUIRE(_dependencyMap[0]).number
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      scaleY: _$$_REQUIRE(_dependencyMap[0]).number
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      skewX: _$$_REQUIRE(_dependencyMap[0]).string
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      skewY: _$$_REQUIRE(_dependencyMap[0]).string
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      translateX: _$$_REQUIRE(_dependencyMap[0]).number
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      translateY: _$$_REQUIRE(_dependencyMap[0]).number
    })]))
  };
  module.exports = DeprecatedTransformPropTypes;
},"1dd7395967b3c81dc0f2",["385f56cce85bf58dda18"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   */

  'use strict';

  /**
   * @see facebook/react-native/Libraries/Image/ImageSource.js
   */
  var ImageURISourcePropType = _$$_REQUIRE(_dependencyMap[0]).shape({
    body: _$$_REQUIRE(_dependencyMap[0]).string,
    bundle: _$$_REQUIRE(_dependencyMap[0]).string,
    cache: _$$_REQUIRE(_dependencyMap[0]).oneOf(['default', 'force-cache', 'only-if-cached', 'reload']),
    headers: _$$_REQUIRE(_dependencyMap[0]).objectOf(_$$_REQUIRE(_dependencyMap[0]).string),
    height: _$$_REQUIRE(_dependencyMap[0]).number,
    method: _$$_REQUIRE(_dependencyMap[0]).string,
    scale: _$$_REQUIRE(_dependencyMap[0]).number,
    uri: _$$_REQUIRE(_dependencyMap[0]).string,
    width: _$$_REQUIRE(_dependencyMap[0]).number
  });
  var ImageSourcePropType = _$$_REQUIRE(_dependencyMap[0]).oneOfType([ImageURISourcePropType, _$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).arrayOf(ImageURISourcePropType)]);
  module.exports = ImageSourcePropType;
},"00fed86b64880bf848bf",["385f56cce85bf58dda18"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   */

  'use strict';

  /**
   * @see facebook/react-native/Libraries/StyleSheet/StyleSheetTypes.js
   */
  var DeprecatedImageStylePropTypes = Object.assign({}, _$$_REQUIRE(_dependencyMap[0]), _$$_REQUIRE(_dependencyMap[1]), _$$_REQUIRE(_dependencyMap[2]), {
    backfaceVisibility: _$$_REQUIRE(_dependencyMap[3]).oneOf(['hidden', 'visible']),
    backgroundColor: _$$_REQUIRE(_dependencyMap[4]),
    borderBottomLeftRadius: _$$_REQUIRE(_dependencyMap[3]).number,
    borderBottomRightRadius: _$$_REQUIRE(_dependencyMap[3]).number,
    borderColor: _$$_REQUIRE(_dependencyMap[4]),
    borderRadius: _$$_REQUIRE(_dependencyMap[3]).number,
    borderTopLeftRadius: _$$_REQUIRE(_dependencyMap[3]).number,
    borderTopRightRadius: _$$_REQUIRE(_dependencyMap[3]).number,
    borderWidth: _$$_REQUIRE(_dependencyMap[3]).number,
    objectFit: _$$_REQUIRE(_dependencyMap[3]).oneOf(['contain', 'cover', 'fill', 'scale-down']),
    opacity: _$$_REQUIRE(_dependencyMap[3]).number,
    overflow: _$$_REQUIRE(_dependencyMap[3]).oneOf(['hidden', 'visible']),
    overlayColor: _$$_REQUIRE(_dependencyMap[3]).string,
    tintColor: _$$_REQUIRE(_dependencyMap[4]),
    resizeMode: _$$_REQUIRE(_dependencyMap[3]).oneOf(['center', 'contain', 'cover', 'repeat', 'stretch'])
  });
  module.exports = DeprecatedImageStylePropTypes;
},"0b77c2d463c8dbef3508",["fdc284a1196df7b8b1c7","c694fefe532e4748da9d","1dd7395967b3c81dc0f2","385f56cce85bf58dda18","0ff2848f3ff6f1a02356"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   */

  'use strict';

  /**
   * @see facebook/react-native/Libraries/StyleSheet/StyleSheetTypes.js
   */
  var PointPropType = _$$_REQUIRE(_dependencyMap[0]).shape({
    x: _$$_REQUIRE(_dependencyMap[0]).number,
    y: _$$_REQUIRE(_dependencyMap[0]).number
  });
  module.exports = PointPropType;
},"792d53fa12840d39c921",["385f56cce85bf58dda18"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   */

  'use strict';

  var DataDetectorTypes = ['address', 'all', 'calendarEvent', 'link', 'none', 'phoneNumber'];

  /**
   * @see facebook/react-native/Libraries/TextInput/TextInput.js
   */
  var DeprecatedTextInputPropTypes = Object.assign({}, _$$_REQUIRE(_dependencyMap[0]), {
    allowFontScaling: _$$_REQUIRE(_dependencyMap[1]).bool,
    autoCapitalize: _$$_REQUIRE(_dependencyMap[1]).oneOf(['none', 'sentences', 'words', 'characters']),
    autoComplete: _$$_REQUIRE(_dependencyMap[1]).oneOf(['additional-name', 'address-line1', 'address-line2', 'bday', 'bday-day', 'bday-month', 'bday-year', 'birthdate-day', 'birthdate-full', 'birthdate-month', 'birthdate-year', 'cc-csc', 'cc-exp', 'cc-exp-day', 'cc-exp-month', 'cc-exp-year', 'cc-number', 'country', 'current-password', 'email', 'family-name', 'gender', 'given-name', 'honorific-prefix', 'honorific-suffix', 'name', 'name-family', 'name-given', 'name-middle', 'name-middle-initial', 'name-prefix', 'name-suffix', 'new-password', 'nickname', 'off', 'one-time-code', 'organization', 'organization-title', 'password', 'password-new', 'postal-address', 'postal-address-country', 'postal-address-extended', 'postal-address-extended-postal-code', 'postal-address-locality', 'postal-address-region', 'postal-code', 'sex', 'sms-otp', 'street-address', 'tel', 'tel-country-code', 'tel-device', 'tel-national', 'url', 'username', 'username-new']),
    autoCorrect: _$$_REQUIRE(_dependencyMap[1]).bool,
    autoFocus: _$$_REQUIRE(_dependencyMap[1]).bool,
    blurOnSubmit: _$$_REQUIRE(_dependencyMap[1]).bool,
    caretHidden: _$$_REQUIRE(_dependencyMap[1]).bool,
    clearButtonMode: _$$_REQUIRE(_dependencyMap[1]).oneOf(['always', 'never', 'unless-editing', 'while-editing']),
    clearTextOnFocus: _$$_REQUIRE(_dependencyMap[1]).bool,
    cursorColor: _$$_REQUIRE(_dependencyMap[2]),
    contextMenuHidden: _$$_REQUIRE(_dependencyMap[1]).bool,
    dataDetectorTypes: _$$_REQUIRE(_dependencyMap[1]).oneOfType([_$$_REQUIRE(_dependencyMap[1]).oneOf(DataDetectorTypes), _$$_REQUIRE(_dependencyMap[1]).arrayOf(_$$_REQUIRE(_dependencyMap[1]).oneOf(DataDetectorTypes))]),
    defaultValue: _$$_REQUIRE(_dependencyMap[1]).string,
    disableFullscreenUI: _$$_REQUIRE(_dependencyMap[1]).bool,
    editable: _$$_REQUIRE(_dependencyMap[1]).bool,
    enablesReturnKeyAutomatically: _$$_REQUIRE(_dependencyMap[1]).bool,
    enterKeyHint: _$$_REQUIRE(_dependencyMap[1]).oneOf(['done', 'enter', 'go', 'next', 'previous', 'search', 'send']),
    inlineImageLeft: _$$_REQUIRE(_dependencyMap[1]).string,
    inlineImagePadding: _$$_REQUIRE(_dependencyMap[1]).number,
    inputAccessoryViewID: _$$_REQUIRE(_dependencyMap[1]).string,
    inputMode: _$$_REQUIRE(_dependencyMap[1]).oneOf(['decimal', 'email', 'none', 'numeric', 'search', 'tel', 'text', 'url']),
    keyboardAppearance: _$$_REQUIRE(_dependencyMap[1]).oneOf(['default', 'dark', 'light']),
    keyboardType: _$$_REQUIRE(_dependencyMap[1]).oneOf(['ascii-capable', 'ascii-capable-number-pad', 'decimal-pad', 'default', 'email-address', 'name-phone-pad', 'number-pad', 'numbers-and-punctuation', 'numeric', 'phone-pad', 'twitter', 'url', 'visible-password', 'web-search']),
    lineBreakStrategyIOS: _$$_REQUIRE(_dependencyMap[1]).oneOf(['hangul-word', 'none', 'push-out', 'standard']),
    maxFontSizeMultiplier: _$$_REQUIRE(_dependencyMap[1]).number,
    maxLength: _$$_REQUIRE(_dependencyMap[1]).number,
    multiline: _$$_REQUIRE(_dependencyMap[1]).bool,
    numberOfLines: _$$_REQUIRE(_dependencyMap[1]).number,
    onBlur: _$$_REQUIRE(_dependencyMap[1]).func,
    onChange: _$$_REQUIRE(_dependencyMap[1]).func,
    onChangeText: _$$_REQUIRE(_dependencyMap[1]).func,
    onContentSizeChange: _$$_REQUIRE(_dependencyMap[1]).func,
    onEndEditing: _$$_REQUIRE(_dependencyMap[1]).func,
    onFocus: _$$_REQUIRE(_dependencyMap[1]).func,
    onKeyPress: _$$_REQUIRE(_dependencyMap[1]).func,
    onLayout: _$$_REQUIRE(_dependencyMap[1]).func,
    onScroll: _$$_REQUIRE(_dependencyMap[1]).func,
    onSelectionChange: _$$_REQUIRE(_dependencyMap[1]).func,
    onSubmitEditing: _$$_REQUIRE(_dependencyMap[1]).func,
    onTextInput: _$$_REQUIRE(_dependencyMap[1]).func,
    placeholder: _$$_REQUIRE(_dependencyMap[1]).string,
    placeholderTextColor: _$$_REQUIRE(_dependencyMap[2]),
    readOnly: _$$_REQUIRE(_dependencyMap[1]).bool,
    rejectResponderTermination: _$$_REQUIRE(_dependencyMap[1]).bool,
    returnKeyLabel: _$$_REQUIRE(_dependencyMap[1]).string,
    returnKeyType: _$$_REQUIRE(_dependencyMap[1]).oneOf(['default', 'done', 'emergency-call', 'go', 'google', 'join', 'next', 'none', 'previous', 'route', 'search', 'send', 'yahoo']),
    rows: _$$_REQUIRE(_dependencyMap[1]).number,
    scrollEnabled: _$$_REQUIRE(_dependencyMap[1]).bool,
    secureTextEntry: _$$_REQUIRE(_dependencyMap[1]).bool,
    selection: _$$_REQUIRE(_dependencyMap[1]).shape({
      end: _$$_REQUIRE(_dependencyMap[1]).number,
      start: _$$_REQUIRE(_dependencyMap[1]).number.isRequired
    }),
    selectionColor: _$$_REQUIRE(_dependencyMap[2]),
    selectTextOnFocus: _$$_REQUIRE(_dependencyMap[1]).bool,
    showSoftInputOnFocus: _$$_REQUIRE(_dependencyMap[1]).bool,
    spellCheck: _$$_REQUIRE(_dependencyMap[1]).bool,
    style: _$$_REQUIRE(_dependencyMap[3]).style,
    submitBehavior: _$$_REQUIRE(_dependencyMap[1]).oneOf(['blurAndSubmit', 'newline', 'submit']),
    textBreakStrategy: _$$_REQUIRE(_dependencyMap[1]).oneOf(['balanced', 'highQuality', 'simple']),
    textContentType: _$$_REQUIRE(_dependencyMap[1]).oneOf(['addressCity', 'addressCityAndState', 'addressState', 'countryName', 'creditCardNumber', 'emailAddress', 'familyName', 'fullStreetAddress', 'givenName', 'jobTitle', 'location', 'middleName', 'name', 'namePrefix', 'nameSuffix', 'newPassword', 'nickname', 'none', 'oneTimeCode', 'organizationName', 'password', 'postalCode', 'streetAddressLine1', 'streetAddressLine2', 'sublocality', 'telephoneNumber', 'URL', 'username']),
    underlineColorAndroid: _$$_REQUIRE(_dependencyMap[2]),
    value: _$$_REQUIRE(_dependencyMap[1]).string
  });
  module.exports = DeprecatedTextInputPropTypes;
},"a287f54379336e9f732c",["6a37ec0494ff683c49f2","385f56cce85bf58dda18","0ff2848f3ff6f1a02356","14b8482f38362fa2f8cd"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   */

  'use strict';

  /**
   * @see facebook/react-native/Libraries/Text/TextProps.js
   */
  var DeprecatedTextPropTypes = {
    'aria-busy': _$$_REQUIRE(_dependencyMap[0]).bool,
    'aria-checked': _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).bool, _$$_REQUIRE(_dependencyMap[0]).oneOf(['mixed'])]),
    'aria-disabled': _$$_REQUIRE(_dependencyMap[0]).bool,
    'aria-expanded': _$$_REQUIRE(_dependencyMap[0]).bool,
    'aria-label': _$$_REQUIRE(_dependencyMap[0]).string,
    'aria-labelledby': _$$_REQUIRE(_dependencyMap[0]).string,
    'aria-selected': _$$_REQUIRE(_dependencyMap[0]).bool,
    accessibilityActions: _$$_REQUIRE(_dependencyMap[0]).arrayOf(_$$_REQUIRE(_dependencyMap[1]).AccessibilityActionInfoPropType),
    accessibilityHint: _$$_REQUIRE(_dependencyMap[0]).string,
    accessibilityLabel: _$$_REQUIRE(_dependencyMap[0]).string,
    accessibilityLanguage: _$$_REQUIRE(_dependencyMap[0]).string,
    accessibilityRole: _$$_REQUIRE(_dependencyMap[1]).AccessibilityRolePropType,
    accessibilityState: _$$_REQUIRE(_dependencyMap[1]).AccessibilityStatePropType,
    accessible: _$$_REQUIRE(_dependencyMap[0]).bool,
    adjustsFontSizeToFit: _$$_REQUIRE(_dependencyMap[0]).bool,
    allowFontScaling: _$$_REQUIRE(_dependencyMap[0]).bool,
    dataDetectorType: _$$_REQUIRE(_dependencyMap[0]).oneOf(['all', 'email', 'link', 'none', 'phoneNumber']),
    disabled: _$$_REQUIRE(_dependencyMap[0]).bool,
    dynamicTypeRamp: _$$_REQUIRE(_dependencyMap[0]).oneOf(['body', 'callout', 'caption1', 'caption2', 'footnote', 'headline', 'largeTitle', 'subheadline', 'title1', 'title2', 'title3']),
    ellipsizeMode: _$$_REQUIRE(_dependencyMap[0]).oneOf(['clip', 'head', 'middle', 'tail']),
    id: _$$_REQUIRE(_dependencyMap[0]).string,
    lineBreakStrategyIOS: _$$_REQUIRE(_dependencyMap[0]).oneOf(['hangul-word', 'none', 'push-out', 'standard']),
    maxFontSizeMultiplier: _$$_REQUIRE(_dependencyMap[0]).number,
    minimumFontScale: _$$_REQUIRE(_dependencyMap[0]).number,
    nativeID: _$$_REQUIRE(_dependencyMap[0]).string,
    numberOfLines: _$$_REQUIRE(_dependencyMap[0]).number,
    onAccessibilityAction: _$$_REQUIRE(_dependencyMap[0]).func,
    onLayout: _$$_REQUIRE(_dependencyMap[0]).func,
    onLongPress: _$$_REQUIRE(_dependencyMap[0]).func,
    onMoveShouldSetResponder: _$$_REQUIRE(_dependencyMap[0]).func,
    onPress: _$$_REQUIRE(_dependencyMap[0]).func,
    onPressIn: _$$_REQUIRE(_dependencyMap[0]).func,
    onPressOut: _$$_REQUIRE(_dependencyMap[0]).func,
    onResponderGrant: _$$_REQUIRE(_dependencyMap[0]).func,
    onResponderMove: _$$_REQUIRE(_dependencyMap[0]).func,
    onResponderRelease: _$$_REQUIRE(_dependencyMap[0]).func,
    onResponderTerminate: _$$_REQUIRE(_dependencyMap[0]).func,
    onResponderTerminationRequest: _$$_REQUIRE(_dependencyMap[0]).func,
    onStartShouldSetResponder: _$$_REQUIRE(_dependencyMap[0]).func,
    onTextLayout: _$$_REQUIRE(_dependencyMap[0]).func,
    pressRetentionOffset: _$$_REQUIRE(_dependencyMap[2]),
    role: _$$_REQUIRE(_dependencyMap[1]).RolePropType,
    selectable: _$$_REQUIRE(_dependencyMap[0]).bool,
    selectionColor: _$$_REQUIRE(_dependencyMap[3]),
    style: _$$_REQUIRE(_dependencyMap[4])(_$$_REQUIRE(_dependencyMap[5])),
    suppressHighlighting: _$$_REQUIRE(_dependencyMap[0]).bool,
    testID: _$$_REQUIRE(_dependencyMap[0]).string,
    textBreakStrategy: _$$_REQUIRE(_dependencyMap[0]).oneOf(['balanced', 'highQuality', 'simple'])
  };
  module.exports = DeprecatedTextPropTypes;
},"14b8482f38362fa2f8cd",["385f56cce85bf58dda18","dc269c006cd52aa8a392","e113bc2a6b8133e753f1","0ff2848f3ff6f1a02356","ecd8893ff4b33ee73955","41bd16fe8e2d1af40264"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   */

  'use strict';

  /**
   * @see facebook/react-native/Libraries/StyleSheet/StyleSheetTypes.js
   */
  var DeprecatedTextStylePropTypes = Object.assign({}, _$$_REQUIRE(_dependencyMap[0]), {
    color: _$$_REQUIRE(_dependencyMap[1]),
    fontFamily: _$$_REQUIRE(_dependencyMap[2]).string,
    fontSize: _$$_REQUIRE(_dependencyMap[2]).number,
    fontStyle: _$$_REQUIRE(_dependencyMap[2]).oneOf(['italic', 'normal']),
    fontVariant: _$$_REQUIRE(_dependencyMap[2]).oneOfType([_$$_REQUIRE(_dependencyMap[2]).arrayOf(_$$_REQUIRE(_dependencyMap[2]).oneOf(['lining-nums', 'oldstyle-nums', 'proportional-nums', 'small-caps', 'stylistic-eight', 'stylistic-eighteen', 'stylistic-eleven', 'stylistic-fifteen', 'stylistic-five', 'stylistic-four', 'stylistic-fourteen', 'stylistic-nine', 'stylistic-nineteen', 'stylistic-one', 'stylistic-seven', 'stylistic-seventeen', 'stylistic-six', 'stylistic-sixteen', 'stylistic-ten', 'stylistic-thirteen', 'stylistic-three', 'stylistic-twelve', 'stylistic-twenty', 'stylistic-two', 'tabular-nums'])), _$$_REQUIRE(_dependencyMap[2]).string]),
    fontWeight: _$$_REQUIRE(_dependencyMap[2]).oneOf(['100', '200', '300', '400', '500', '600', '700', '800', '900', 'black', 'bold', 'condensed', 'condensedBold', 'heavy', 'light', 'medium', 'normal', 'regular', 'semibold', 'thin', 'ultralight', 100, 200, 300, 400, 500, 600, 700, 800, 900]),
    includeFontPadding: _$$_REQUIRE(_dependencyMap[2]).bool,
    letterSpacing: _$$_REQUIRE(_dependencyMap[2]).number,
    lineHeight: _$$_REQUIRE(_dependencyMap[2]).number,
    textAlign: _$$_REQUIRE(_dependencyMap[2]).oneOf(['auto', 'center', 'justify', 'left', 'right']),
    textAlignVertical: _$$_REQUIRE(_dependencyMap[2]).oneOf(['auto', 'bottom', 'center', 'top']),
    textDecorationColor: _$$_REQUIRE(_dependencyMap[1]),
    textDecorationLine: _$$_REQUIRE(_dependencyMap[2]).oneOf(['line-through', 'none', 'underline line-through', 'underline']),
    textDecorationStyle: _$$_REQUIRE(_dependencyMap[2]).oneOf(['dashed', 'dotted', 'double', 'solid']),
    textShadowColor: _$$_REQUIRE(_dependencyMap[1]),
    textShadowOffset: _$$_REQUIRE(_dependencyMap[2]).shape({
      height: _$$_REQUIRE(_dependencyMap[2]).number,
      width: _$$_REQUIRE(_dependencyMap[2]).number
    }),
    textShadowRadius: _$$_REQUIRE(_dependencyMap[2]).number,
    textTransform: _$$_REQUIRE(_dependencyMap[2]).oneOf(['capitalize', 'lowercase', 'none', 'uppercase']),
    userSelect: _$$_REQUIRE(_dependencyMap[2]).oneOf(['all', 'auto', 'contain', 'none', 'text']),
    verticalAlign: _$$_REQUIRE(_dependencyMap[2]).oneOf(['auto', 'bottom', 'middle', 'top']),
    writingDirection: _$$_REQUIRE(_dependencyMap[2]).oneOf(['auto', 'ltr', 'rtl'])
  });
  module.exports = DeprecatedTextStylePropTypes;
},"41bd16fe8e2d1af40264",["b0bd5168a69d8a903511","0ff2848f3ff6f1a02356","385f56cce85bf58dda18"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var safeIsNaN = Number.isNaN || function ponyfill(value) {
    return typeof value === 'number' && value !== value;
  };
  function isEqual(first, second) {
    if (first === second) {
      return true;
    }
    if (safeIsNaN(first) && safeIsNaN(second)) {
      return true;
    }
    return false;
  }
  function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
      return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
      if (!isEqual(newInputs[i], lastInputs[i])) {
        return false;
      }
    }
    return true;
  }
  function memoizeOne(resultFn, isEqual) {
    if (isEqual === undefined) {
      isEqual = areInputsEqual;
    }
    var lastThis;
    var lastArgs = [];
    var lastResult;
    var calledOnce = false;
    function memoized() {
      var newArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        newArgs[_i] = arguments[_i];
      }
      if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {
        return lastResult;
      }
      lastResult = resultFn.apply(this, newArgs);
      calledOnce = true;
      lastThis = this;
      lastArgs = newArgs;
      return lastResult;
    }
    return memoized;
  }
  module.exports = memoizeOne;
},"d381691ed29bec5a2050",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  module.exports = {
    keyExtractor: _$$_REQUIRE(_dependencyMap[0]).keyExtractor,
    get VirtualizedList() {
      return _$$_REQUIRE(_dependencyMap[1]);
    },
    get VirtualizedSectionList() {
      return _$$_REQUIRE(_dependencyMap[2]);
    },
    get VirtualizedListContextResetter() {
      var VirtualizedListContext = _$$_REQUIRE(_dependencyMap[3]);
      return VirtualizedListContext.VirtualizedListContextResetter;
    },
    get ViewabilityHelper() {
      return _$$_REQUIRE(_dependencyMap[4]);
    },
    get FillRateHelper() {
      return _$$_REQUIRE(_dependencyMap[5]);
    }
  };
},"27b237d1799650306cb9",["a26dbe2a3afa21c3cf22","c4b46015e44050527820","d2355175ff6609a3def1","e6b1ef1f5b720d640981","8bafab90a37cab64b100","3e01a5bc929e85870fe5"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.computeWindowedRenderLimits = computeWindowedRenderLimits;
  exports.elementsThatOverlapOffsets = elementsThatOverlapOffsets;
  exports.keyExtractor = keyExtractor;
  exports.newRangeCount = newRangeCount;
  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));
  /**
   * Used to find the indices of the frames that overlap the given offsets. Useful for finding the
   * items that bound different windows of content, such as the visible area or the buffered overscan
   * area.
   */
  function elementsThatOverlapOffsets(offsets, props, getFrameMetrics) {
    var zoomScale = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var itemCount = props.getItemCount(props.data);
    var result = [];
    for (var offsetIndex = 0; offsetIndex < offsets.length; offsetIndex++) {
      var currentOffset = offsets[offsetIndex];
      var left = 0;
      var right = itemCount - 1;
      while (left <= right) {
        // eslint-disable-next-line no-bitwise
        var mid = left + (right - left >>> 1);
        var frame = getFrameMetrics(mid, props);
        var scaledOffsetStart = frame.offset * zoomScale;
        var scaledOffsetEnd = (frame.offset + frame.length) * zoomScale;

        // We want the first frame that contains the offset, with inclusive bounds. Thus, for the
        // first frame the scaledOffsetStart is inclusive, while for other frames it is exclusive.
        if (mid === 0 && currentOffset < scaledOffsetStart || mid !== 0 && currentOffset <= scaledOffsetStart) {
          right = mid - 1;
        } else if (currentOffset > scaledOffsetEnd) {
          left = mid + 1;
        } else {
          result[offsetIndex] = mid;
          break;
        }
      }
    }
    return result;
  }

  /**
   * Computes the number of elements in the `next` range that are new compared to the `prev` range.
   * Handy for calculating how many new items will be rendered when the render window changes so we
   * can restrict the number of new items render at once so that content can appear on the screen
   * faster.
   */
  function newRangeCount(prev, next) {
    return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));
  }

  /**
   * Custom logic for determining which items should be rendered given the current frame and scroll
   * metrics, as well as the previous render state. The algorithm may evolve over time, but generally
   * prioritizes the visible area first, then expands that with overscan regions ahead and behind,
   * biased in the direction of scroll.
   */
  function computeWindowedRenderLimits(props, maxToRenderPerBatch, windowSize, prev, getFrameMetricsApprox, scrollMetrics) {
    var itemCount = props.getItemCount(props.data);
    if (itemCount === 0) {
      return {
        first: 0,
        last: -1
      };
    }
    var offset = scrollMetrics.offset,
      velocity = scrollMetrics.velocity,
      visibleLength = scrollMetrics.visibleLength,
      _scrollMetrics$zoomSc = scrollMetrics.zoomScale,
      zoomScale = _scrollMetrics$zoomSc === undefined ? 1 : _scrollMetrics$zoomSc;

    // Start with visible area, then compute maximum overscan region by expanding from there, biased
    // in the direction of scroll. Total overscan area is capped, which should cap memory consumption
    // too.
    var visibleBegin = Math.max(0, offset);
    var visibleEnd = visibleBegin + visibleLength;
    var overscanLength = (windowSize - 1) * visibleLength;

    // Considering velocity seems to introduce more churn than it's worth.
    var leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));

    var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';
    var overscanBegin = Math.max(0, visibleBegin - 0.5 * overscanLength);
    var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);
    var lastItemOffset = getFrameMetricsApprox(itemCount - 1, props).offset * zoomScale;
    if (lastItemOffset < overscanBegin) {
      // Entire list is before our overscan window
      return {
        first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),
        last: itemCount - 1
      };
    }

    // Find the indices that correspond to the items at the render boundaries we're targeting.
    var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], props, getFrameMetricsApprox, zoomScale),
      _elementsThatOverlapO2 = (0, _slicedToArray2.default)(_elementsThatOverlapO, 4),
      overscanFirst = _elementsThatOverlapO2[0],
      first = _elementsThatOverlapO2[1],
      last = _elementsThatOverlapO2[2],
      overscanLast = _elementsThatOverlapO2[3];
    overscanFirst = overscanFirst == null ? 0 : overscanFirst;
    first = first == null ? Math.max(0, overscanFirst) : first;
    overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;
    last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;
    var visible = {
      first: first,
      last: last
    };

    // We want to limit the number of new cells we're rendering per batch so that we can fill the
    // content on the screen quickly. If we rendered the entire overscan window at once, the user
    // could be staring at white space for a long time waiting for a bunch of offscreen content to
    // render.
    var newCellCount = newRangeCount(prev, visible);
    while (true) {
      if (first <= overscanFirst && last >= overscanLast) {
        // If we fill the entire overscan range, we're done.
        break;
      }
      var maxNewCells = newCellCount >= maxToRenderPerBatch;
      var firstWillAddMore = first <= prev.first || first > prev.last;
      var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);
      var lastWillAddMore = last >= prev.last || last < prev.first;
      var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);
      if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {
        // We only want to stop if we've hit maxNewCells AND we cannot increment first or last
        // without rendering new items. This let's us preserve as many already rendered items as
        // possible, reducing render churn and keeping the rendered overscan range as large as
        // possible.
        break;
      }
      if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {
        if (firstWillAddMore) {
          newCellCount++;
        }
        first--;
      }
      if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {
        if (lastWillAddMore) {
          newCellCount++;
        }
        last++;
      }
    }
    if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {
      throw new Error('Bad window calculation ' + JSON.stringify({
        first: first,
        last: last,
        itemCount: itemCount,
        overscanFirst: overscanFirst,
        overscanLast: overscanLast,
        visible: visible
      }));
    }
    return {
      first: first,
      last: last
    };
  }
  function keyExtractor(item, index) {
    if (typeof item === 'object' && (item == null ? undefined : item.key) != null) {
      return item.key;
    }
    if (typeof item === 'object' && (item == null ? undefined : item.id) != null) {
      return item.id;
    }
    return String(index);
  }
},"a26dbe2a3afa21c3cf22",["f9cae617a85336004da4","606f5f734809feae52ba"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));
  var _defineProperty2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));
  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));
  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));
  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));
  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));
  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));
  var _reactNative = _$$_REQUIRE(_dependencyMap[8]);
  var _Batchinator = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));
  var _clamp = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));
  var _infoLog = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));
  var _ChildListCollection = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[12]));
  var _FillRateHelper = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[13]));
  var _StateSafePureComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[14]));
  var _ViewabilityHelper = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[15]));
  var _VirtualizedListCellRenderer = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[16]));
  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[17]));
  var _nullthrows = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[18]));
  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[19]));
  function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
  function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
  function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); } /**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
  var ON_EDGE_REACHED_EPSILON = 0.001;
  var _usedIndexForKey = false;
  var _keylessItemComponentName = '';
  /**
   * Default Props Helper Functions
   * Use the following helper functions for default values
   */

  // horizontalOrDefault(this.props.horizontal)
  function horizontalOrDefault(horizontal) {
    return horizontal != null ? horizontal : false;
  }

  // initialNumToRenderOrDefault(this.props.initialNumToRender)
  function initialNumToRenderOrDefault(initialNumToRender) {
    return initialNumToRender != null ? initialNumToRender : 10;
  }

  // maxToRenderPerBatchOrDefault(this.props.maxToRenderPerBatch)
  function maxToRenderPerBatchOrDefault(maxToRenderPerBatch) {
    return maxToRenderPerBatch != null ? maxToRenderPerBatch : 10;
  }

  // onStartReachedThresholdOrDefault(this.props.onStartReachedThreshold)
  function onStartReachedThresholdOrDefault(onStartReachedThreshold) {
    return onStartReachedThreshold != null ? onStartReachedThreshold : 2;
  }

  // onEndReachedThresholdOrDefault(this.props.onEndReachedThreshold)
  function onEndReachedThresholdOrDefault(onEndReachedThreshold) {
    return onEndReachedThreshold != null ? onEndReachedThreshold : 2;
  }

  // getScrollingThreshold(visibleLength, onEndReachedThreshold)
  function getScrollingThreshold(threshold, visibleLength) {
    return threshold * visibleLength / 2;
  }

  // scrollEventThrottleOrDefault(this.props.scrollEventThrottle)
  function scrollEventThrottleOrDefault(scrollEventThrottle) {
    return scrollEventThrottle != null ? scrollEventThrottle : 50;
  }

  // windowSizeOrDefault(this.props.windowSize)
  function windowSizeOrDefault(windowSize) {
    return windowSize != null ? windowSize : 21;
  }
  function findLastWhere(arr, predicate) {
    for (var i = arr.length - 1; i >= 0; i--) {
      if (predicate(arr[i])) {
        return arr[i];
      }
    }
    return null;
  }

  /**
   * Base implementation for the more convenient [`<FlatList>`](https://reactnative.dev/docs/flatlist)
   * and [`<SectionList>`](https://reactnative.dev/docs/sectionlist) components, which are also better
   * documented. In general, this should only really be used if you need more flexibility than
   * `FlatList` provides, e.g. for use with immutable data instead of plain arrays.
   *
   * Virtualization massively improves memory consumption and performance of large lists by
   * maintaining a finite render window of active items and replacing all items outside of the render
   * window with appropriately sized blank space. The window adapts to scrolling behavior, and items
   * are rendered incrementally with low-pri (after any running interactions) if they are far from the
   * visible area, or with hi-pri otherwise to minimize the potential of seeing blank space.
   *
   * Some caveats:
   *
   * - Internal state is not preserved when content scrolls out of the render window. Make sure all
   *   your data is captured in the item data or external stores like Flux, Redux, or Relay.
   * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-
   *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop
   *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on
   *   changes. This includes the `data` prop and parent component state.
   * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously
   *   offscreen. This means it's possible to scroll faster than the fill rate ands momentarily see
   *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,
   *   and we are working on improving it behind the scenes.
   * - By default, the list looks for a `key` or `id` prop on each item and uses that for the React key.
   *   Alternatively, you can provide a custom `keyExtractor` prop.
   * - As an effort to remove defaultProps, use helper functions when referencing certain props
   *
   */
  var VirtualizedList = /*#__PURE__*/function (_StateSafePureCompone) {
    function VirtualizedList(_props) {
      var _this$props$updateCel, _this$props$maintainV, _this$props$maintainV2;
      var _this;
      (0, _classCallCheck2.default)(this, VirtualizedList);
      _this = _callSuper(this, VirtualizedList, [_props]);
      // $FlowFixMe[missing-local-annot]
      _this._getScrollMetrics = function () {
        return _this._scrollMetrics;
      };
      // $FlowFixMe[missing-local-annot]
      _this._getOutermostParentListRef = function () {
        if (_this._isNestedWithSameOrientation()) {
          return _this.context.getOutermostParentListRef();
        } else {
          return _this;
        }
      };
      _this._registerAsNestedChild = function (childList) {
        _this._nestedChildLists.add(childList.ref, childList.cellKey);
        if (_this._hasInteracted) {
          childList.ref.recordInteraction();
        }
      };
      _this._unregisterAsNestedChild = function (childList) {
        _this._nestedChildLists.remove(childList.ref);
      };
      _this._onUpdateSeparators = function (keys, newProps) {
        keys.forEach(function (key) {
          var ref = key != null && _this._cellRefs[key];
          ref && ref.updateSeparatorProps(newProps);
        });
      };
      _this._getSpacerKey = function (isVertical) {
        return isVertical ? 'height' : 'width';
      };
      _this._averageCellLength = 0;
      _this._cellRefs = {};
      _this._frames = {};
      _this._footerLength = 0;
      // Used for preventing scrollToIndex from being called multiple times for initialScrollIndex
      _this._hasTriggeredInitialScrollToIndex = false;
      _this._hasInteracted = false;
      _this._hasMore = false;
      _this._hasWarned = {};
      _this._headerLength = 0;
      _this._hiPriInProgress = false;
      // flag to prevent infinite hiPri cell limit update
      _this._highestMeasuredFrameIndex = 0;
      _this._indicesToKeys = new Map();
      _this._lastFocusedCellKey = null;
      _this._nestedChildLists = new _ChildListCollection.default();
      _this._offsetFromParentVirtualizedList = 0;
      _this._prevParentOffset = 0;
      // $FlowFixMe[missing-local-annot]
      _this._scrollMetrics = {
        contentLength: 0,
        dOffset: 0,
        dt: 10,
        offset: 0,
        timestamp: 0,
        velocity: 0,
        visibleLength: 0,
        zoomScale: 1
      };
      _this._scrollRef = null;
      _this._sentStartForContentLength = 0;
      _this._sentEndForContentLength = 0;
      _this._totalCellLength = 0;
      _this._totalCellsMeasured = 0;
      _this._viewabilityTuples = [];
      /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's
       * LTI update could not be added via codemod */
      _this._captureScrollRef = function (ref) {
        _this._scrollRef = ref;
      };
      /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's
       * LTI update could not be added via codemod */
      _this._defaultRenderScrollComponent = function (props) {
        var onRefresh = props.onRefresh;
        if (_this._isNestedWithSameOrientation()) {
          // $FlowFixMe[prop-missing] - Typing ReactNativeComponent revealed errors
          return /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[20]).jsx)(_reactNative.View, Object.assign({}, props));
        } else if (onRefresh) {
          var _props$refreshing;
          (0, _invariant.default)(typeof props.refreshing === 'boolean', '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' + JSON.stringify((_props$refreshing = props.refreshing) != null ? _props$refreshing : 'undefined') + '`');
          return (
            /*#__PURE__*/
            // $FlowFixMe[prop-missing] Invalid prop usage
            // $FlowFixMe[incompatible-use]
            (0, _$$_REQUIRE(_dependencyMap[20]).jsx)(_reactNative.ScrollView, Object.assign({}, props, {
              refreshControl: props.refreshControl == null ? /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[20]).jsx)(_reactNative.RefreshControl
              // $FlowFixMe[incompatible-type]
              , {
                refreshing: props.refreshing,
                onRefresh: onRefresh,
                progressViewOffset: props.progressViewOffset
              }) : props.refreshControl
            }))
          );
        } else {
          // $FlowFixMe[prop-missing] Invalid prop usage
          // $FlowFixMe[incompatible-use]
          return /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[20]).jsx)(_reactNative.ScrollView, Object.assign({}, props));
        }
      };
      _this._onCellLayout = function (e, cellKey, index) {
        var layout = e.nativeEvent.layout;
        var next = {
          offset: _this._selectOffset(layout),
          length: _this._selectLength(layout),
          index: index,
          inLayout: true
        };
        var curr = _this._frames[cellKey];
        if (!curr || next.offset !== curr.offset || next.length !== curr.length || index !== curr.index) {
          _this._totalCellLength += next.length - (curr ? curr.length : 0);
          _this._totalCellsMeasured += curr ? 0 : 1;
          _this._averageCellLength = _this._totalCellLength / _this._totalCellsMeasured;
          _this._frames[cellKey] = next;
          _this._highestMeasuredFrameIndex = Math.max(_this._highestMeasuredFrameIndex, index);
          _this._scheduleCellsToRenderUpdate();
        } else {
          _this._frames[cellKey].inLayout = true;
        }
        _this._triggerRemeasureForChildListsInCell(cellKey);
        _this._computeBlankness();
        _this._updateViewableItems(_this.props, _this.state.cellsAroundViewport);
      };
      _this._onCellUnmount = function (cellKey) {
        delete _this._cellRefs[cellKey];
        var curr = _this._frames[cellKey];
        if (curr) {
          _this._frames[cellKey] = Object.assign({}, curr, {
            inLayout: false
          });
        }
      };
      _this._onLayout = function (e) {
        if (_this._isNestedWithSameOrientation()) {
          // Need to adjust our scroll metrics to be relative to our containing
          // VirtualizedList before we can make claims about list item viewability
          _this.measureLayoutRelativeToContainingList();
        } else {
          _this._scrollMetrics.visibleLength = _this._selectLength(e.nativeEvent.layout);
        }
        _this.props.onLayout && _this.props.onLayout(e);
        _this._scheduleCellsToRenderUpdate();
        _this._maybeCallOnEdgeReached();
      };
      _this._onLayoutEmpty = function (e) {
        _this.props.onLayout && _this.props.onLayout(e);
      };
      _this._onLayoutFooter = function (e) {
        _this._triggerRemeasureForChildListsInCell(_this._getFooterCellKey());
        _this._footerLength = _this._selectLength(e.nativeEvent.layout);
      };
      _this._onLayoutHeader = function (e) {
        _this._headerLength = _this._selectLength(e.nativeEvent.layout);
      };
      _this._onContentSizeChange = function (width, height) {
        if (width > 0 && height > 0 && _this.props.initialScrollIndex != null && _this.props.initialScrollIndex > 0 && !_this._hasTriggeredInitialScrollToIndex) {
          if (_this.props.contentOffset == null) {
            if (_this.props.initialScrollIndex < _this.props.getItemCount(_this.props.data)) {
              _this.scrollToIndex({
                animated: false,
                index: (0, _nullthrows.default)(_this.props.initialScrollIndex)
              });
            } else {
              _this.scrollToEnd({
                animated: false
              });
            }
          }
          _this._hasTriggeredInitialScrollToIndex = true;
        }
        if (_this.props.onContentSizeChange) {
          _this.props.onContentSizeChange(width, height);
        }
        _this._scrollMetrics.contentLength = _this._selectLength({
          height: height,
          width: width
        });
        _this._scheduleCellsToRenderUpdate();
        _this._maybeCallOnEdgeReached();
      };
      /* Translates metrics from a scroll event in a parent VirtualizedList into
       * coordinates relative to the child list.
       */
      _this._convertParentScrollMetrics = function (metrics) {
        // Offset of the top of the nested list relative to the top of its parent's viewport
        var offset = metrics.offset - _this._offsetFromParentVirtualizedList;
        // Child's visible length is the same as its parent's
        var visibleLength = metrics.visibleLength;
        var dOffset = offset - _this._scrollMetrics.offset;
        var contentLength = _this._scrollMetrics.contentLength;
        return {
          visibleLength: visibleLength,
          contentLength: contentLength,
          offset: offset,
          dOffset: dOffset
        };
      };
      _this._onScroll = function (e) {
        _this._nestedChildLists.forEach(function (childList) {
          childList._onScroll(e);
        });
        if (_this.props.onScroll) {
          _this.props.onScroll(e);
        }
        var timestamp = e.timeStamp;
        var visibleLength = _this._selectLength(e.nativeEvent.layoutMeasurement);
        var contentLength = _this._selectLength(e.nativeEvent.contentSize);
        var offset = _this._selectOffset(e.nativeEvent.contentOffset);
        var dOffset = offset - _this._scrollMetrics.offset;
        if (_this._isNestedWithSameOrientation()) {
          if (_this._scrollMetrics.contentLength === 0) {
            // Ignore scroll events until onLayout has been called and we
            // know our offset from our offset from our parent
            return;
          }
          var _this$_convertParentS = _this._convertParentScrollMetrics({
            visibleLength: visibleLength,
            offset: offset
          });
          visibleLength = _this$_convertParentS.visibleLength;
          contentLength = _this$_convertParentS.contentLength;
          offset = _this$_convertParentS.offset;
          dOffset = _this$_convertParentS.dOffset;
        }
        var dt = _this._scrollMetrics.timestamp ? Math.max(1, timestamp - _this._scrollMetrics.timestamp) : 1;
        var velocity = dOffset / dt;
        if (dt > 500 && _this._scrollMetrics.dt > 500 && contentLength > 5 * visibleLength && !_this._hasWarned.perf) {
          (0, _infoLog.default)("VirtualizedList: You have a large list that is slow to update - make sure your renderItem function renders components that follow React performance best practices like PureComponent, shouldComponentUpdate, etc.", {
            dt: dt,
            prevDt: _this._scrollMetrics.dt,
            contentLength: contentLength
          });
          _this._hasWarned.perf = true;
        }

        // For invalid negative values (w/ RTL), set this to 1.
        var zoomScale = e.nativeEvent.zoomScale < 0 ? 1 : e.nativeEvent.zoomScale;
        _this._scrollMetrics = {
          contentLength: contentLength,
          dt: dt,
          dOffset: dOffset,
          offset: offset,
          timestamp: timestamp,
          velocity: velocity,
          visibleLength: visibleLength,
          zoomScale: zoomScale
        };
        if (_this.state.pendingScrollUpdateCount > 0) {
          _this.setState(function (state) {
            return {
              pendingScrollUpdateCount: state.pendingScrollUpdateCount - 1
            };
          });
        }
        _this._updateViewableItems(_this.props, _this.state.cellsAroundViewport);
        if (!_this.props) {
          return;
        }
        _this._maybeCallOnEdgeReached();
        if (velocity !== 0) {
          _this._fillRateHelper.activate();
        }
        _this._computeBlankness();
        _this._scheduleCellsToRenderUpdate();
      };
      _this._onScrollBeginDrag = function (e) {
        _this._nestedChildLists.forEach(function (childList) {
          childList._onScrollBeginDrag(e);
        });
        _this._viewabilityTuples.forEach(function (tuple) {
          tuple.viewabilityHelper.recordInteraction();
        });
        _this._hasInteracted = true;
        _this.props.onScrollBeginDrag && _this.props.onScrollBeginDrag(e);
      };
      _this._onScrollEndDrag = function (e) {
        _this._nestedChildLists.forEach(function (childList) {
          childList._onScrollEndDrag(e);
        });
        var velocity = e.nativeEvent.velocity;
        if (velocity) {
          _this._scrollMetrics.velocity = _this._selectOffset(velocity);
        }
        _this._computeBlankness();
        _this.props.onScrollEndDrag && _this.props.onScrollEndDrag(e);
      };
      _this._onMomentumScrollBegin = function (e) {
        _this._nestedChildLists.forEach(function (childList) {
          childList._onMomentumScrollBegin(e);
        });
        _this.props.onMomentumScrollBegin && _this.props.onMomentumScrollBegin(e);
      };
      _this._onMomentumScrollEnd = function (e) {
        _this._nestedChildLists.forEach(function (childList) {
          childList._onMomentumScrollEnd(e);
        });
        _this._scrollMetrics.velocity = 0;
        _this._computeBlankness();
        _this.props.onMomentumScrollEnd && _this.props.onMomentumScrollEnd(e);
      };
      _this._updateCellsToRender = function () {
        _this._updateViewableItems(_this.props, _this.state.cellsAroundViewport);
        _this.setState(function (state, props) {
          var cellsAroundViewport = _this._adjustCellsAroundViewport(props, state.cellsAroundViewport, state.pendingScrollUpdateCount);
          var renderMask = VirtualizedList._createRenderMask(props, cellsAroundViewport, _this._getNonViewportRenderRegions(props));
          if (cellsAroundViewport.first === state.cellsAroundViewport.first && cellsAroundViewport.last === state.cellsAroundViewport.last && renderMask.equals(state.renderMask)) {
            return null;
          }
          return {
            cellsAroundViewport: cellsAroundViewport,
            renderMask: renderMask
          };
        });
      };
      _this._createViewToken = function (index, isViewable, props
      // $FlowFixMe[missing-local-annot]
      ) {
        var data = props.data,
          getItem = props.getItem;
        var item = getItem(data, index);
        return {
          index: index,
          item: item,
          key: VirtualizedList._keyExtractor(item, index, props),
          isViewable: isViewable
        };
      };
      /**
       * Gets an approximate offset to an item at a given index. Supports
       * fractional indices.
       */
      _this._getOffsetApprox = function (index, props) {
        if (Number.isInteger(index)) {
          return _this.__getFrameMetricsApprox(index, props).offset;
        } else {
          var frameMetrics = _this.__getFrameMetricsApprox(Math.floor(index), props);
          var remainder = index - Math.floor(index);
          return frameMetrics.offset + remainder * frameMetrics.length;
        }
      };
      _this.__getFrameMetricsApprox = function (index, props) {
        var frame = _this._getFrameMetrics(index, props);
        if (frame && frame.index === index) {
          // check for invalid frames due to row re-ordering
          return frame;
        } else {
          var data = props.data,
            getItemCount = props.getItemCount,
            getItemLayout = props.getItemLayout;
          (0, _invariant.default)(index >= 0 && index < getItemCount(data), 'Tried to get frame for out of range index ' + index);
          (0, _invariant.default)(!getItemLayout, 'Should not have to estimate frames when a measurement metrics function is provided');
          return {
            length: _this._averageCellLength,
            offset: _this._averageCellLength * index
          };
        }
      };
      _this._getFrameMetrics = function (index, props) {
        var data = props.data,
          getItemCount = props.getItemCount,
          getItemLayout = props.getItemLayout;
        (0, _invariant.default)(index >= 0 && index < getItemCount(data), 'Tried to get frame for out of range index ' + index);
        var frame = _this._frames[VirtualizedList._getItemKey(props, index)];
        if (!frame || frame.index !== index) {
          if (getItemLayout) {
            /* $FlowFixMe[prop-missing] (>=0.63.0 site=react_native_fb) This comment
             * suppresses an error found when Flow v0.63 was deployed. To see the error
             * delete this comment and run Flow. */
            return getItemLayout(data, index);
          }
        }
        return frame;
      };
      _this._getNonViewportRenderRegions = function (props) {
        // Keep a viewport's worth of content around the last focused cell to allow
        // random navigation around it without any blanking. E.g. tabbing from one
        // focused item out of viewport to another.
        if (!(_this._lastFocusedCellKey && _this._cellRefs[_this._lastFocusedCellKey])) {
          return [];
        }
        var lastFocusedCellRenderer = _this._cellRefs[_this._lastFocusedCellKey];
        var focusedCellIndex = lastFocusedCellRenderer.props.index;
        var itemCount = props.getItemCount(props.data);

        // The last cell we rendered may be at a new index. Bail if we don't know
        // where it is.
        if (focusedCellIndex >= itemCount || VirtualizedList._getItemKey(props, focusedCellIndex) !== _this._lastFocusedCellKey) {
          return [];
        }
        var first = focusedCellIndex;
        var heightOfCellsBeforeFocused = 0;
        for (var i = first - 1; i >= 0 && heightOfCellsBeforeFocused < _this._scrollMetrics.visibleLength; i--) {
          first--;
          heightOfCellsBeforeFocused += _this.__getFrameMetricsApprox(i, props).length;
        }
        var last = focusedCellIndex;
        var heightOfCellsAfterFocused = 0;
        for (var _i = last + 1; _i < itemCount && heightOfCellsAfterFocused < _this._scrollMetrics.visibleLength; _i++) {
          last++;
          heightOfCellsAfterFocused += _this.__getFrameMetricsApprox(_i, props).length;
        }
        return [{
          first: first,
          last: last
        }];
      };
      _this._checkProps(_props);
      _this._fillRateHelper = new _FillRateHelper.default(_this._getFrameMetrics);
      _this._updateCellsToRenderBatcher = new _Batchinator.default(_this._updateCellsToRender, (_this$props$updateCel = _this.props.updateCellsBatchingPeriod) != null ? _this$props$updateCel : 50);
      if (_this.props.viewabilityConfigCallbackPairs) {
        _this._viewabilityTuples = _this.props.viewabilityConfigCallbackPairs.map(function (pair) {
          return {
            viewabilityHelper: new _ViewabilityHelper.default(pair.viewabilityConfig),
            onViewableItemsChanged: pair.onViewableItemsChanged
          };
        });
      } else {
        var _this$props = _this.props,
          onViewableItemsChanged = _this$props.onViewableItemsChanged,
          viewabilityConfig = _this$props.viewabilityConfig;
        if (onViewableItemsChanged) {
          _this._viewabilityTuples.push({
            viewabilityHelper: new _ViewabilityHelper.default(viewabilityConfig),
            onViewableItemsChanged: onViewableItemsChanged
          });
        }
      }
      var initialRenderRegion = VirtualizedList._initialRenderRegion(_props);
      var minIndexForVisible = (_this$props$maintainV = (_this$props$maintainV2 = _this.props.maintainVisibleContentPosition) == null ? undefined : _this$props$maintainV2.minIndexForVisible) != null ? _this$props$maintainV : 0;
      _this.state = {
        cellsAroundViewport: initialRenderRegion,
        renderMask: VirtualizedList._createRenderMask(_props, initialRenderRegion),
        firstVisibleItemKey: _this.props.getItemCount(_this.props.data) > minIndexForVisible ? VirtualizedList._getItemKey(_this.props, minIndexForVisible) : null,
        // When we have a non-zero initialScrollIndex, we will receive a
        // scroll event later so this will prevent the window from updating
        // until we get a valid offset.
        pendingScrollUpdateCount: _this.props.initialScrollIndex != null && _this.props.initialScrollIndex > 0 ? 1 : 0
      };
      return _this;
    }
    (0, _inherits2.default)(VirtualizedList, _StateSafePureCompone);
    return (0, _createClass2.default)(VirtualizedList, [{
      key: "scrollToEnd",
      value:
      // scrollToEnd may be janky without getItemLayout prop
      function scrollToEnd(params) {
        var animated = params ? params.animated : true;
        var veryLast = this.props.getItemCount(this.props.data) - 1;
        if (veryLast < 0) {
          return;
        }
        var frame = this.__getFrameMetricsApprox(veryLast, this.props);
        var offset = Math.max(0, frame.offset + frame.length + this._footerLength - this._scrollMetrics.visibleLength);
        if (this._scrollRef == null) {
          return;
        }
        if (this._scrollRef.scrollTo == null) {
          console.warn("No scrollTo method provided. This may be because you have two nested VirtualizedLists with the same orientation, or because you are using a custom component that does not implement scrollTo.");
          return;
        }
        this._scrollRef.scrollTo(horizontalOrDefault(this.props.horizontal) ? {
          x: offset,
          animated: animated
        } : {
          y: offset,
          animated: animated
        });
      }

      // scrollToIndex may be janky without getItemLayout prop
    }, {
      key: "scrollToIndex",
      value: function scrollToIndex(params) {
        var _this$props2 = this.props,
          data = _this$props2.data,
          horizontal = _this$props2.horizontal,
          getItemCount = _this$props2.getItemCount,
          getItemLayout = _this$props2.getItemLayout,
          onScrollToIndexFailed = _this$props2.onScrollToIndexFailed;
        var animated = params.animated,
          index = params.index,
          viewOffset = params.viewOffset,
          viewPosition = params.viewPosition;
        (0, _invariant.default)(index >= 0, `scrollToIndex out of range: requested index ${index} but minimum is 0`);
        (0, _invariant.default)(getItemCount(data) >= 1, `scrollToIndex out of range: item length ${getItemCount(data)} but minimum is 1`);
        (0, _invariant.default)(index < getItemCount(data), `scrollToIndex out of range: requested index ${index} is out of 0 to ${getItemCount(data) - 1}`);
        if (!getItemLayout && index > this._highestMeasuredFrameIndex) {
          (0, _invariant.default)(!!onScrollToIndexFailed, "scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, otherwise there is no way to know the location of offscreen indices or handle failures.");
          onScrollToIndexFailed({
            averageItemLength: this._averageCellLength,
            highestMeasuredFrameIndex: this._highestMeasuredFrameIndex,
            index: index
          });
          return;
        }
        var frame = this.__getFrameMetricsApprox(Math.floor(index), this.props);
        var offset = Math.max(0, this._getOffsetApprox(index, this.props) - (viewPosition || 0) * (this._scrollMetrics.visibleLength - frame.length)) - (viewOffset || 0);
        if (this._scrollRef == null) {
          return;
        }
        if (this._scrollRef.scrollTo == null) {
          console.warn("No scrollTo method provided. This may be because you have two nested VirtualizedLists with the same orientation, or because you are using a custom component that does not implement scrollTo.");
          return;
        }
        this._scrollRef.scrollTo(horizontal ? {
          x: offset,
          animated: animated
        } : {
          y: offset,
          animated: animated
        });
      }

      // scrollToItem may be janky without getItemLayout prop. Required linear scan through items -
      // use scrollToIndex instead if possible.
    }, {
      key: "scrollToItem",
      value: function scrollToItem(params) {
        var item = params.item;
        var _this$props3 = this.props,
          data = _this$props3.data,
          getItem = _this$props3.getItem,
          getItemCount = _this$props3.getItemCount;
        var itemCount = getItemCount(data);
        for (var _index = 0; _index < itemCount; _index++) {
          if (getItem(data, _index) === item) {
            this.scrollToIndex(Object.assign({}, params, {
              index: _index
            }));
            break;
          }
        }
      }

      /**
       * Scroll to a specific content pixel offset in the list.
       *
       * Param `offset` expects the offset to scroll to.
       * In case of `horizontal` is true, the offset is the x-value,
       * in any other case the offset is the y-value.
       *
       * Param `animated` (`true` by default) defines whether the list
       * should do an animation while scrolling.
       */
    }, {
      key: "scrollToOffset",
      value: function scrollToOffset(params) {
        var animated = params.animated,
          offset = params.offset;
        if (this._scrollRef == null) {
          return;
        }
        if (this._scrollRef.scrollTo == null) {
          console.warn("No scrollTo method provided. This may be because you have two nested VirtualizedLists with the same orientation, or because you are using a custom component that does not implement scrollTo.");
          return;
        }
        this._scrollRef.scrollTo(horizontalOrDefault(this.props.horizontal) ? {
          x: offset,
          animated: animated
        } : {
          y: offset,
          animated: animated
        });
      }
    }, {
      key: "recordInteraction",
      value: function recordInteraction() {
        this._nestedChildLists.forEach(function (childList) {
          childList.recordInteraction();
        });
        this._viewabilityTuples.forEach(function (t) {
          t.viewabilityHelper.recordInteraction();
        });
        this._updateViewableItems(this.props, this.state.cellsAroundViewport);
      }
    }, {
      key: "flashScrollIndicators",
      value: function flashScrollIndicators() {
        if (this._scrollRef == null) {
          return;
        }
        this._scrollRef.flashScrollIndicators();
      }

      /**
       * Provides a handle to the underlying scroll responder.
       * Note that `this._scrollRef` might not be a `ScrollView`, so we
       * need to check that it responds to `getScrollResponder` before calling it.
       */
    }, {
      key: "getScrollResponder",
      value: function getScrollResponder() {
        if (this._scrollRef && this._scrollRef.getScrollResponder) {
          return this._scrollRef.getScrollResponder();
        }
      }
    }, {
      key: "getScrollableNode",
      value: function getScrollableNode() {
        if (this._scrollRef && this._scrollRef.getScrollableNode) {
          return this._scrollRef.getScrollableNode();
        } else {
          return (0, _reactNative.findNodeHandle)(this._scrollRef);
        }
      }
    }, {
      key: "getScrollRef",
      value: function getScrollRef() {
        if (this._scrollRef && this._scrollRef.getScrollRef) {
          return this._scrollRef.getScrollRef();
        } else {
          return this._scrollRef;
        }
      }
    }, {
      key: "setNativeProps",
      value: function setNativeProps(props) {
        if (this._scrollRef) {
          this._scrollRef.setNativeProps(props);
        }
      }
    }, {
      key: "_getCellKey",
      value: function _getCellKey() {
        var _this$context;
        return ((_this$context = this.context) == null ? undefined : _this$context.cellKey) || 'rootList';
      }
    }, {
      key: "hasMore",
      value: function hasMore() {
        return this._hasMore;
      }
    }, {
      key: "_checkProps",
      value: function _checkProps(props) {
        var onScroll = props.onScroll,
          windowSize = props.windowSize,
          getItemCount = props.getItemCount,
          data = props.data,
          initialScrollIndex = props.initialScrollIndex;
        (0, _invariant.default)(
        // $FlowFixMe[prop-missing]
        !onScroll || !onScroll.__isNative, "Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent to support native onScroll events with useNativeDriver");
        (0, _invariant.default)(windowSizeOrDefault(windowSize) > 0, 'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.');
        (0, _invariant.default)(getItemCount, 'VirtualizedList: The "getItemCount" prop must be provided');
        var itemCount = getItemCount(data);
        if (initialScrollIndex != null && !this._hasTriggeredInitialScrollToIndex && (initialScrollIndex < 0 || itemCount > 0 && initialScrollIndex >= itemCount) && !this._hasWarned.initialScrollIndex) {
          console.warn(`initialScrollIndex "${initialScrollIndex}" is not valid (list has ${itemCount} items)`);
          this._hasWarned.initialScrollIndex = true;
        }
      }
    }, {
      key: "_adjustCellsAroundViewport",
      value: function _adjustCellsAroundViewport(props, cellsAroundViewport, pendingScrollUpdateCount) {
        var data = props.data,
          getItemCount = props.getItemCount;
        var onEndReachedThreshold = onEndReachedThresholdOrDefault(props.onEndReachedThreshold);
        var _this$_scrollMetrics = this._scrollMetrics,
          contentLength = _this$_scrollMetrics.contentLength,
          offset = _this$_scrollMetrics.offset,
          visibleLength = _this$_scrollMetrics.visibleLength;
        var distanceFromEnd = contentLength - visibleLength - offset;

        // Wait until the scroll view metrics have been set up. And until then,
        // we will trust the initialNumToRender suggestion
        if (visibleLength <= 0 || contentLength <= 0) {
          return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;
        }
        var newCellsAroundViewport;
        if (props.disableVirtualization) {
          var renderAhead = distanceFromEnd < onEndReachedThreshold * visibleLength ? maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch) : 0;
          newCellsAroundViewport = {
            first: 0,
            last: Math.min(cellsAroundViewport.last + renderAhead, getItemCount(data) - 1)
          };
        } else {
          // If we have a pending scroll update, we should not adjust the render window as it
          // might override the correct window.
          if (pendingScrollUpdateCount > 0) {
            return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;
          }
          newCellsAroundViewport = (0, _$$_REQUIRE(_dependencyMap[21]).computeWindowedRenderLimits)(props, maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch), windowSizeOrDefault(props.windowSize), cellsAroundViewport, this.__getFrameMetricsApprox, this._scrollMetrics);
          (0, _invariant.default)(newCellsAroundViewport.last < getItemCount(data), 'computeWindowedRenderLimits() should return range in-bounds');
        }
        if (this._nestedChildLists.size() > 0) {
          // If some cell in the new state has a child list in it, we should only render
          // up through that item, so that we give that list a chance to render.
          // Otherwise there's churn from multiple child lists mounting and un-mounting
          // their items.

          // Will this prevent rendering if the nested list doesn't realize the end?
          var childIdx = this._findFirstChildWithMore(newCellsAroundViewport.first, newCellsAroundViewport.last);
          newCellsAroundViewport.last = childIdx != null ? childIdx : newCellsAroundViewport.last;
        }
        return newCellsAroundViewport;
      }
    }, {
      key: "_findFirstChildWithMore",
      value: function _findFirstChildWithMore(first, last) {
        for (var ii = first; ii <= last; ii++) {
          var cellKeyForIndex = this._indicesToKeys.get(ii);
          if (cellKeyForIndex != null && this._nestedChildLists.anyInCell(cellKeyForIndex, function (childList) {
            return childList.hasMore();
          })) {
            return ii;
          }
        }
        return null;
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        if (this._isNestedWithSameOrientation()) {
          this.context.registerAsNestedChild({
            ref: this,
            cellKey: this.context.cellKey
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._isNestedWithSameOrientation()) {
          this.context.unregisterAsNestedChild({
            ref: this
          });
        }
        this._updateCellsToRenderBatcher.dispose({
          abort: true
        });
        this._viewabilityTuples.forEach(function (tuple) {
          tuple.viewabilityHelper.dispose();
        });
        this._fillRateHelper.deactivateAndFlush();
      }
    }, {
      key: "_pushCells",
      value: function _pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, first, last, inversionStyle) {
        var _this2 = this;
        var _this$props4 = this.props,
          CellRendererComponent = _this$props4.CellRendererComponent,
          ItemSeparatorComponent = _this$props4.ItemSeparatorComponent,
          ListHeaderComponent = _this$props4.ListHeaderComponent,
          ListItemComponent = _this$props4.ListItemComponent,
          data = _this$props4.data,
          debug = _this$props4.debug,
          getItem = _this$props4.getItem,
          getItemCount = _this$props4.getItemCount,
          getItemLayout = _this$props4.getItemLayout,
          horizontal = _this$props4.horizontal,
          renderItem = _this$props4.renderItem;
        var stickyOffset = ListHeaderComponent ? 1 : 0;
        var end = getItemCount(data) - 1;
        var prevCellKey;
        last = Math.min(end, last);
        var _loop = function _loop() {
          var item = getItem(data, ii);
          var key = VirtualizedList._keyExtractor(item, ii, _this2.props);
          _this2._indicesToKeys.set(ii, key);
          if (stickyIndicesFromProps.has(ii + stickyOffset)) {
            stickyHeaderIndices.push(cells.length);
          }
          var shouldListenForLayout = getItemLayout == null || debug || _this2._fillRateHelper.enabled();
          cells.push(/*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[20]).jsx)(_VirtualizedListCellRenderer.default, Object.assign({
            CellRendererComponent: CellRendererComponent,
            ItemSeparatorComponent: ii < end ? ItemSeparatorComponent : undefined,
            ListItemComponent: ListItemComponent,
            cellKey: key,
            horizontal: horizontal,
            index: ii,
            inversionStyle: inversionStyle,
            item: item,
            prevCellKey: prevCellKey,
            onUpdateSeparators: _this2._onUpdateSeparators,
            onCellFocusCapture: function onCellFocusCapture(e) {
              return _this2._onCellFocusCapture(key);
            },
            onUnmount: _this2._onCellUnmount,
            ref: function ref(_ref) {
              _this2._cellRefs[key] = _ref;
            },
            renderItem: renderItem
          }, shouldListenForLayout && {
            onCellLayout: _this2._onCellLayout
          }), key));
          prevCellKey = key;
        };
        for (var ii = first; ii <= last; ii++) {
          _loop();
        }
      }
    }, {
      key: "_isNestedWithSameOrientation",
      value: function _isNestedWithSameOrientation() {
        var nestedContext = this.context;
        return !!(nestedContext && !!nestedContext.horizontal === horizontalOrDefault(this.props.horizontal));
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;
        this._checkProps(this.props);
        var _this$props5 = this.props,
          ListEmptyComponent = _this$props5.ListEmptyComponent,
          ListFooterComponent = _this$props5.ListFooterComponent,
          ListHeaderComponent = _this$props5.ListHeaderComponent;
        var _this$props6 = this.props,
          data = _this$props6.data,
          horizontal = _this$props6.horizontal;
        var inversionStyle = this.props.inverted ? horizontalOrDefault(this.props.horizontal) ? styles.horizontallyInverted : styles.verticallyInverted : null;
        var cells = [];
        var stickyIndicesFromProps = new Set(this.props.stickyHeaderIndices);
        var stickyHeaderIndices = [];

        // 1. Add cell for ListHeaderComponent
        if (ListHeaderComponent) {
          if (stickyIndicesFromProps.has(0)) {
            stickyHeaderIndices.push(0);
          }
          var _element = React.isValidElement(ListHeaderComponent) ? ListHeaderComponent :
          /*#__PURE__*/
          // $FlowFixMe[not-a-component]
          // $FlowFixMe[incompatible-type-arg]
          (0, _$$_REQUIRE(_dependencyMap[20]).jsx)(ListHeaderComponent, {});
          cells.push(/*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[20]).jsx)(_$$_REQUIRE(_dependencyMap[22]).VirtualizedListCellContextProvider, {
            cellKey: this._getCellKey() + '-header',
            children: /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[20]).jsx)(_reactNative.View
            // We expect that header component will be a single native view so make it
            // not collapsable to avoid this view being flattened and make this assumption
            // no longer true.
            , {
              collapsable: false,
              onLayout: this._onLayoutHeader,
              style: _reactNative.StyleSheet.compose(inversionStyle, this.props.ListHeaderComponentStyle),
              children:
              // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors
              _element
            })
          }, "$header"));
        }

        // 2a. Add a cell for ListEmptyComponent if applicable
        var itemCount = this.props.getItemCount(data);
        if (itemCount === 0 && ListEmptyComponent) {
          var _element2 = React.isValidElement(ListEmptyComponent) ? ListEmptyComponent :
          /*#__PURE__*/
          // $FlowFixMe[not-a-component]
          // $FlowFixMe[incompatible-type-arg]
          (0, _$$_REQUIRE(_dependencyMap[20]).jsx)(ListEmptyComponent, {});
          cells.push(/*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[20]).jsx)(_$$_REQUIRE(_dependencyMap[22]).VirtualizedListCellContextProvider, {
            cellKey: this._getCellKey() + '-empty',
            children: React.cloneElement(_element2, {
              onLayout: function onLayout(event) {
                _this3._onLayoutEmpty(event);
                if (_element2.props.onLayout) {
                  _element2.props.onLayout(event);
                }
              },
              style: _reactNative.StyleSheet.compose(inversionStyle, _element2.props.style)
            })
          }, "$empty"));
        }

        // 2b. Add cells and spacers for each item
        if (itemCount > 0) {
          _usedIndexForKey = false;
          _keylessItemComponentName = '';
          var spacerKey = this._getSpacerKey(!horizontal);
          var renderRegions = this.state.renderMask.enumerateRegions();
          var lastSpacer = findLastWhere(renderRegions, function (r) {
            return r.isSpacer;
          });
          for (var section of renderRegions) {
            if (section.isSpacer) {
              // Legacy behavior is to avoid spacers when virtualization is
              // disabled (including head spacers on initial render).
              if (this.props.disableVirtualization) {
                continue;
              }

              // Without getItemLayout, we limit our tail spacer to the _highestMeasuredFrameIndex to
              // prevent the user for hyperscrolling into un-measured area because otherwise content will
              // likely jump around as it renders in above the viewport.
              var isLastSpacer = section === lastSpacer;
              var constrainToMeasured = isLastSpacer && !this.props.getItemLayout;
              var last = constrainToMeasured ? (0, _clamp.default)(section.first - 1, section.last, this._highestMeasuredFrameIndex) : section.last;
              var firstMetrics = this.__getFrameMetricsApprox(section.first, this.props);
              var lastMetrics = this.__getFrameMetricsApprox(last, this.props);
              var spacerSize = lastMetrics.offset + lastMetrics.length - firstMetrics.offset;
              cells.push(/*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[20]).jsx)(_reactNative.View, {
                style: (0, _defineProperty2.default)({}, spacerKey, spacerSize)
              }, `$spacer-${section.first}`));
            } else {
              this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, section.first, section.last, inversionStyle);
            }
          }
          if (!this._hasWarned.keys && _usedIndexForKey) {
            console.warn("VirtualizedList: missing keys for items, make sure to specify a key or id property on each item or provide a custom keyExtractor.", _keylessItemComponentName);
            this._hasWarned.keys = true;
          }
        }

        // 3. Add cell for ListFooterComponent
        if (ListFooterComponent) {
          var _element3 = React.isValidElement(ListFooterComponent) ? ListFooterComponent :
          /*#__PURE__*/
          // $FlowFixMe[not-a-component]
          // $FlowFixMe[incompatible-type-arg]
          (0, _$$_REQUIRE(_dependencyMap[20]).jsx)(ListFooterComponent, {});
          cells.push(/*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[20]).jsx)(_$$_REQUIRE(_dependencyMap[22]).VirtualizedListCellContextProvider, {
            cellKey: this._getFooterCellKey(),
            children: /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[20]).jsx)(_reactNative.View, {
              onLayout: this._onLayoutFooter,
              style: _reactNative.StyleSheet.compose(inversionStyle, this.props.ListFooterComponentStyle),
              children:
              // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors
              _element3
            })
          }, "$footer"));
        }

        // 4. Render the ScrollView
        var scrollProps = Object.assign({}, this.props, {
          onContentSizeChange: this._onContentSizeChange,
          onLayout: this._onLayout,
          onScroll: this._onScroll,
          onScrollBeginDrag: this._onScrollBeginDrag,
          onScrollEndDrag: this._onScrollEndDrag,
          onMomentumScrollBegin: this._onMomentumScrollBegin,
          onMomentumScrollEnd: this._onMomentumScrollEnd,
          scrollEventThrottle: scrollEventThrottleOrDefault(this.props.scrollEventThrottle),
          // TODO: Android support
          invertStickyHeaders: this.props.invertStickyHeaders !== undefined ? this.props.invertStickyHeaders : this.props.inverted,
          stickyHeaderIndices: stickyHeaderIndices,
          style: inversionStyle ? [inversionStyle, this.props.style] : this.props.style,
          isInvertedVirtualizedList: this.props.inverted,
          maintainVisibleContentPosition: this.props.maintainVisibleContentPosition != null ? Object.assign({}, this.props.maintainVisibleContentPosition, {
            // Adjust index to account for ListHeaderComponent.
            minIndexForVisible: this.props.maintainVisibleContentPosition.minIndexForVisible + (this.props.ListHeaderComponent ? 1 : 0)
          }) : undefined
        });
        this._hasMore = this.state.cellsAroundViewport.last < itemCount - 1;
        var innerRet = /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[20]).jsx)(_$$_REQUIRE(_dependencyMap[22]).VirtualizedListContextProvider, {
          value: {
            cellKey: null,
            getScrollMetrics: this._getScrollMetrics,
            horizontal: horizontalOrDefault(this.props.horizontal),
            getOutermostParentListRef: this._getOutermostParentListRef,
            registerAsNestedChild: this._registerAsNestedChild,
            unregisterAsNestedChild: this._unregisterAsNestedChild
          },
          children: React.cloneElement((this.props.renderScrollComponent || this._defaultRenderScrollComponent)(scrollProps), {
            ref: this._captureScrollRef
          }, cells)
        });
        var ret = innerRet;
        if (this.props.debug) {
          return /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[20]).jsxs)(_reactNative.View, {
            style: styles.debug,
            children: [ret, this._renderDebugOverlay()]
          });
        } else {
          return ret;
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var _this$props7 = this.props,
          data = _this$props7.data,
          extraData = _this$props7.extraData;
        if (data !== prevProps.data || extraData !== prevProps.extraData) {
          // clear the viewableIndices cache to also trigger
          // the onViewableItemsChanged callback with the new data
          this._viewabilityTuples.forEach(function (tuple) {
            tuple.viewabilityHelper.resetViewableIndices();
          });
        }
        // The `this._hiPriInProgress` is guaranteeing a hiPri cell update will only happen
        // once per fiber update. The `_scheduleCellsToRenderUpdate` will set it to true
        // if a hiPri update needs to perform. If `componentDidUpdate` is triggered with
        // `this._hiPriInProgress=true`, means it's triggered by the hiPri update. The
        // `_scheduleCellsToRenderUpdate` will check this condition and not perform
        // another hiPri update.
        var hiPriInProgress = this._hiPriInProgress;
        this._scheduleCellsToRenderUpdate();
        // Make sure setting `this._hiPriInProgress` back to false after `componentDidUpdate`
        // is triggered with `this._hiPriInProgress = true`
        if (hiPriInProgress) {
          this._hiPriInProgress = false;
        }
      }
    }, {
      key: "_computeBlankness",
      value: function _computeBlankness() {
        this._fillRateHelper.computeBlankness(this.props, this.state.cellsAroundViewport, this._scrollMetrics);
      }
    }, {
      key: "_onCellFocusCapture",
      value: function _onCellFocusCapture(cellKey) {
        this._lastFocusedCellKey = cellKey;
        this._updateCellsToRender();
      }
    }, {
      key: "_triggerRemeasureForChildListsInCell",
      value: function _triggerRemeasureForChildListsInCell(cellKey) {
        this._nestedChildLists.forEachInCell(cellKey, function (childList) {
          childList.measureLayoutRelativeToContainingList();
        });
      }
    }, {
      key: "measureLayoutRelativeToContainingList",
      value: function measureLayoutRelativeToContainingList() {
        var _this4 = this;
        // TODO (T35574538): findNodeHandle sometimes crashes with "Unable to find
        // node on an unmounted component" during scrolling
        try {
          if (!this._scrollRef) {
            return;
          }
          // We are assuming that getOutermostParentListRef().getScrollRef()
          // is a non-null reference to a ScrollView
          this._scrollRef.measureLayout(this.context.getOutermostParentListRef().getScrollRef(), function (x, y, width, height) {
            _this4._offsetFromParentVirtualizedList = _this4._selectOffset({
              x: x,
              y: y
            });
            _this4._scrollMetrics.contentLength = _this4._selectLength({
              width: width,
              height: height
            });
            var scrollMetrics = _this4._convertParentScrollMetrics(_this4.context.getScrollMetrics());
            var metricsChanged = _this4._scrollMetrics.visibleLength !== scrollMetrics.visibleLength || _this4._scrollMetrics.offset !== scrollMetrics.offset;
            if (metricsChanged) {
              _this4._scrollMetrics.visibleLength = scrollMetrics.visibleLength;
              _this4._scrollMetrics.offset = scrollMetrics.offset;

              // If metrics of the scrollView changed, then we triggered remeasure for child list
              // to ensure VirtualizedList has the right information.
              _this4._nestedChildLists.forEach(function (childList) {
                childList.measureLayoutRelativeToContainingList();
              });
            }
          }, function (error) {
            console.warn("VirtualizedList: Encountered an error while measuring a list's offset from its containing VirtualizedList.");
          });
        } catch (error) {
          console.warn('measureLayoutRelativeToContainingList threw an error', error.stack);
        }
      }
    }, {
      key: "_getFooterCellKey",
      value: function _getFooterCellKey() {
        return this._getCellKey() + '-footer';
      }
    }, {
      key: "_renderDebugOverlay",
      value:
      // $FlowFixMe[missing-local-annot]
      function _renderDebugOverlay() {
        var normalize = this._scrollMetrics.visibleLength / (this._scrollMetrics.contentLength || 1);
        var framesInLayout = [];
        var itemCount = this.props.getItemCount(this.props.data);
        for (var ii = 0; ii < itemCount; ii++) {
          var frame = this.__getFrameMetricsApprox(ii, this.props);
          /* $FlowFixMe[prop-missing] (>=0.68.0 site=react_native_fb) This comment
           * suppresses an error found when Flow v0.68 was deployed. To see the
           * error delete this comment and run Flow. */
          if (frame.inLayout) {
            framesInLayout.push(frame);
          }
        }
        var windowTop = this.__getFrameMetricsApprox(this.state.cellsAroundViewport.first, this.props).offset;
        var frameLast = this.__getFrameMetricsApprox(this.state.cellsAroundViewport.last, this.props);
        var windowLen = frameLast.offset + frameLast.length - windowTop;
        var visTop = this._scrollMetrics.offset;
        var visLen = this._scrollMetrics.visibleLength;
        return /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[20]).jsxs)(_reactNative.View, {
          style: [styles.debugOverlayBase, styles.debugOverlay],
          children: [framesInLayout.map(function (f, ii) {
            return /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[20]).jsx)(_reactNative.View, {
              style: [styles.debugOverlayBase, styles.debugOverlayFrame, {
                top: f.offset * normalize,
                height: f.length * normalize
              }]
            }, 'f' + ii);
          }), /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[20]).jsx)(_reactNative.View, {
            style: [styles.debugOverlayBase, styles.debugOverlayFrameLast, {
              top: windowTop * normalize,
              height: windowLen * normalize
            }]
          }), /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[20]).jsx)(_reactNative.View, {
            style: [styles.debugOverlayBase, styles.debugOverlayFrameVis, {
              top: visTop * normalize,
              height: visLen * normalize
            }]
          })]
        });
      }
    }, {
      key: "_selectLength",
      value: function _selectLength(metrics) {
        return !horizontalOrDefault(this.props.horizontal) ? metrics.height : metrics.width;
      }
    }, {
      key: "_selectOffset",
      value: function _selectOffset(metrics) {
        return !horizontalOrDefault(this.props.horizontal) ? metrics.y : metrics.x;
      }
    }, {
      key: "_maybeCallOnEdgeReached",
      value: function _maybeCallOnEdgeReached() {
        var _this$props8 = this.props,
          data = _this$props8.data,
          getItemCount = _this$props8.getItemCount,
          onStartReached = _this$props8.onStartReached,
          onStartReachedThreshold = _this$props8.onStartReachedThreshold,
          onEndReached = _this$props8.onEndReached,
          onEndReachedThreshold = _this$props8.onEndReachedThreshold;
        // If we have any pending scroll updates it means that the scroll metrics
        // are out of date and we should not call any of the edge reached callbacks.
        if (this.state.pendingScrollUpdateCount > 0) {
          return;
        }
        var _this$_scrollMetrics2 = this._scrollMetrics,
          contentLength = _this$_scrollMetrics2.contentLength,
          visibleLength = _this$_scrollMetrics2.visibleLength,
          offset = _this$_scrollMetrics2.offset;
        var distanceFromStart = offset;
        var distanceFromEnd = contentLength - visibleLength - offset;

        // Especially when oERT is zero it's necessary to 'floor' very small distance values to be 0
        // since debouncing causes us to not fire this event for every single "pixel" we scroll and can thus
        // be at the edge of the list with a distance approximating 0 but not quite there.
        if (distanceFromStart < ON_EDGE_REACHED_EPSILON) {
          distanceFromStart = 0;
        }
        if (distanceFromEnd < ON_EDGE_REACHED_EPSILON) {
          distanceFromEnd = 0;
        }

        // TODO: T121172172 Look into why we're "defaulting" to a threshold of 2px
        // when oERT is not present (different from 2 viewports used elsewhere)
        var DEFAULT_THRESHOLD_PX = 2;
        var startThreshold = onStartReachedThreshold != null ? onStartReachedThreshold * visibleLength : DEFAULT_THRESHOLD_PX;
        var endThreshold = onEndReachedThreshold != null ? onEndReachedThreshold * visibleLength : DEFAULT_THRESHOLD_PX;
        var isWithinStartThreshold = distanceFromStart <= startThreshold;
        var isWithinEndThreshold = distanceFromEnd <= endThreshold;

        // First check if the user just scrolled within the end threshold
        // and call onEndReached only once for a given content length,
        // and only if onStartReached is not being executed
        if (onEndReached && this.state.cellsAroundViewport.last === getItemCount(data) - 1 && isWithinEndThreshold && this._scrollMetrics.contentLength !== this._sentEndForContentLength) {
          this._sentEndForContentLength = this._scrollMetrics.contentLength;
          onEndReached({
            distanceFromEnd: distanceFromEnd
          });
        }

        // Next check if the user just scrolled within the start threshold
        // and call onStartReached only once for a given content length,
        // and only if onEndReached is not being executed
        else if (onStartReached != null && this.state.cellsAroundViewport.first === 0 && isWithinStartThreshold && this._scrollMetrics.contentLength !== this._sentStartForContentLength) {
          this._sentStartForContentLength = this._scrollMetrics.contentLength;
          onStartReached({
            distanceFromStart: distanceFromStart
          });
        }

        // If the user scrolls away from the start or end and back again,
        // cause onStartReached or onEndReached to be triggered again
        else {
          this._sentStartForContentLength = isWithinStartThreshold ? this._sentStartForContentLength : 0;
          this._sentEndForContentLength = isWithinEndThreshold ? this._sentEndForContentLength : 0;
        }
      }
    }, {
      key: "_scheduleCellsToRenderUpdate",
      value: function _scheduleCellsToRenderUpdate() {
        var _this$state$cellsArou = this.state.cellsAroundViewport,
          first = _this$state$cellsArou.first,
          last = _this$state$cellsArou.last;
        var _this$_scrollMetrics3 = this._scrollMetrics,
          offset = _this$_scrollMetrics3.offset,
          visibleLength = _this$_scrollMetrics3.visibleLength,
          velocity = _this$_scrollMetrics3.velocity;
        var itemCount = this.props.getItemCount(this.props.data);
        var hiPri = false;
        var onStartReachedThreshold = onStartReachedThresholdOrDefault(this.props.onStartReachedThreshold);
        var onEndReachedThreshold = onEndReachedThresholdOrDefault(this.props.onEndReachedThreshold);
        // Mark as high priority if we're close to the start of the first item
        // But only if there are items before the first rendered item
        if (first > 0) {
          var distTop = offset - this.__getFrameMetricsApprox(first, this.props).offset;
          hiPri = distTop < 0 || velocity < -2 && distTop < getScrollingThreshold(onStartReachedThreshold, visibleLength);
        }
        // Mark as high priority if we're close to the end of the last item
        // But only if there are items after the last rendered item
        if (!hiPri && last >= 0 && last < itemCount - 1) {
          var distBottom = this.__getFrameMetricsApprox(last, this.props).offset - (offset + visibleLength);
          hiPri = distBottom < 0 || velocity > 2 && distBottom < getScrollingThreshold(onEndReachedThreshold, visibleLength);
        }
        // Only trigger high-priority updates if we've actually rendered cells,
        // and with that size estimate, accurately compute how many cells we should render.
        // Otherwise, it would just render as many cells as it can (of zero dimension),
        // each time through attempting to render more (limited by maxToRenderPerBatch),
        // starving the renderer from actually laying out the objects and computing _averageCellLength.
        // If this is triggered in an `componentDidUpdate` followed by a hiPri cellToRenderUpdate
        // We shouldn't do another hipri cellToRenderUpdate
        if (hiPri && (this._averageCellLength || this.props.getItemLayout) && !this._hiPriInProgress) {
          this._hiPriInProgress = true;
          // Don't worry about interactions when scrolling quickly; focus on filling content as fast
          // as possible.
          this._updateCellsToRenderBatcher.dispose({
            abort: true
          });
          this._updateCellsToRender();
          return;
        } else {
          this._updateCellsToRenderBatcher.schedule();
        }
      }
    }, {
      key: "_updateViewableItems",
      value: function _updateViewableItems(props, cellsAroundViewport) {
        var _this5 = this;
        // If we have any pending scroll updates it means that the scroll metrics
        // are out of date and we should not call any of the visibility callbacks.
        if (this.state.pendingScrollUpdateCount > 0) {
          return;
        }
        this._viewabilityTuples.forEach(function (tuple) {
          tuple.viewabilityHelper.onUpdate(props, _this5._scrollMetrics.offset, _this5._scrollMetrics.visibleLength, _this5._getFrameMetrics, _this5._createViewToken, tuple.onViewableItemsChanged, cellsAroundViewport);
        });
      }
    }], [{
      key: "_findItemIndexWithKey",
      value: function _findItemIndexWithKey(props, key, hint) {
        var itemCount = props.getItemCount(props.data);
        if (hint != null && hint >= 0 && hint < itemCount) {
          var curKey = VirtualizedList._getItemKey(props, hint);
          if (curKey === key) {
            return hint;
          }
        }
        for (var ii = 0; ii < itemCount; ii++) {
          var _curKey = VirtualizedList._getItemKey(props, ii);
          if (_curKey === key) {
            return ii;
          }
        }
        return null;
      }
    }, {
      key: "_getItemKey",
      value: function _getItemKey(props, index) {
        var item = props.getItem(props.data, index);
        return VirtualizedList._keyExtractor(item, index, props);
      }
    }, {
      key: "_createRenderMask",
      value: function _createRenderMask(props, cellsAroundViewport, additionalRegions) {
        var itemCount = props.getItemCount(props.data);
        (0, _invariant.default)(cellsAroundViewport.first >= 0 && cellsAroundViewport.last >= cellsAroundViewport.first - 1 && cellsAroundViewport.last < itemCount, `Invalid cells around viewport "[${cellsAroundViewport.first}, ${cellsAroundViewport.last}]" was passed to VirtualizedList._createRenderMask`);
        var renderMask = new (_$$_REQUIRE(_dependencyMap[23]).CellRenderMask)(itemCount);
        if (itemCount > 0) {
          var allRegions = [cellsAroundViewport].concat((0, _toConsumableArray2.default)(additionalRegions != null ? additionalRegions : []));
          for (var region of allRegions) {
            renderMask.addCells(region);
          }

          // The initially rendered cells are retained as part of the
          // "scroll-to-top" optimization
          if (props.initialScrollIndex == null || props.initialScrollIndex <= 0) {
            var initialRegion = VirtualizedList._initialRenderRegion(props);
            renderMask.addCells(initialRegion);
          }

          // The layout coordinates of sticker headers may be off-screen while the
          // actual header is on-screen. Keep the most recent before the viewport
          // rendered, even if its layout coordinates are not in viewport.
          var stickyIndicesSet = new Set(props.stickyHeaderIndices);
          VirtualizedList._ensureClosestStickyHeader(props, stickyIndicesSet, renderMask, cellsAroundViewport.first);
        }
        return renderMask;
      }
    }, {
      key: "_initialRenderRegion",
      value: function _initialRenderRegion(props) {
        var _props$initialScrollI;
        var itemCount = props.getItemCount(props.data);
        var firstCellIndex = Math.max(0, Math.min(itemCount - 1, Math.floor((_props$initialScrollI = props.initialScrollIndex) != null ? _props$initialScrollI : 0)));
        var lastCellIndex = Math.min(itemCount, firstCellIndex + initialNumToRenderOrDefault(props.initialNumToRender)) - 1;
        return {
          first: firstCellIndex,
          last: lastCellIndex
        };
      }
    }, {
      key: "_ensureClosestStickyHeader",
      value: function _ensureClosestStickyHeader(props, stickyIndicesSet, renderMask, cellIdx) {
        var stickyOffset = props.ListHeaderComponent ? 1 : 0;
        for (var itemIdx = cellIdx - 1; itemIdx >= 0; itemIdx--) {
          if (stickyIndicesSet.has(itemIdx + stickyOffset)) {
            renderMask.addCells({
              first: itemIdx,
              last: itemIdx
            });
            break;
          }
        }
      }
    }, {
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(newProps, prevState) {
        var _newProps$maintainVis, _newProps$maintainVis2;
        // first and last could be stale (e.g. if a new, shorter items props is passed in), so we make
        // sure we're rendering a reasonable range here.
        var itemCount = newProps.getItemCount(newProps.data);
        if (itemCount === prevState.renderMask.numCells()) {
          return prevState;
        }
        var maintainVisibleContentPositionAdjustment = null;
        var prevFirstVisibleItemKey = prevState.firstVisibleItemKey;
        var minIndexForVisible = (_newProps$maintainVis = (_newProps$maintainVis2 = newProps.maintainVisibleContentPosition) == null ? undefined : _newProps$maintainVis2.minIndexForVisible) != null ? _newProps$maintainVis : 0;
        var newFirstVisibleItemKey = newProps.getItemCount(newProps.data) > minIndexForVisible ? VirtualizedList._getItemKey(newProps, minIndexForVisible) : null;
        if (newProps.maintainVisibleContentPosition != null && prevFirstVisibleItemKey != null && newFirstVisibleItemKey != null) {
          if (newFirstVisibleItemKey !== prevFirstVisibleItemKey) {
            // Fast path if items were added at the start of the list.
            var hint = itemCount - prevState.renderMask.numCells() + minIndexForVisible;
            var firstVisibleItemIndex = VirtualizedList._findItemIndexWithKey(newProps, prevFirstVisibleItemKey, hint);
            maintainVisibleContentPositionAdjustment = firstVisibleItemIndex != null ? firstVisibleItemIndex - minIndexForVisible : null;
          } else {
            maintainVisibleContentPositionAdjustment = null;
          }
        }
        var constrainedCells = VirtualizedList._constrainToItemCount(maintainVisibleContentPositionAdjustment != null ? {
          first: prevState.cellsAroundViewport.first + maintainVisibleContentPositionAdjustment,
          last: prevState.cellsAroundViewport.last + maintainVisibleContentPositionAdjustment
        } : prevState.cellsAroundViewport, newProps);
        return {
          cellsAroundViewport: constrainedCells,
          renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells),
          firstVisibleItemKey: newFirstVisibleItemKey,
          pendingScrollUpdateCount: maintainVisibleContentPositionAdjustment != null ? prevState.pendingScrollUpdateCount + 1 : prevState.pendingScrollUpdateCount
        };
      }
    }, {
      key: "_constrainToItemCount",
      value: function _constrainToItemCount(cells, props) {
        var itemCount = props.getItemCount(props.data);
        var last = Math.min(itemCount - 1, cells.last);
        var maxToRenderPerBatch = maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch);
        return {
          first: (0, _clamp.default)(0, itemCount - 1 - maxToRenderPerBatch, cells.first),
          last: last
        };
      }
    }, {
      key: "_keyExtractor",
      value: function _keyExtractor(item, index, props) {
        if (props.keyExtractor != null) {
          return props.keyExtractor(item, index);
        }
        var key = (0, _$$_REQUIRE(_dependencyMap[21]).keyExtractor)(item, index);
        if (key === String(index)) {
          _usedIndexForKey = true;
          if (item.type && item.type.displayName) {
            _keylessItemComponentName = item.type.displayName;
          }
        }
        return key;
      }
    }]);
  }(_StateSafePureComponent.default);
  VirtualizedList.contextType = _$$_REQUIRE(_dependencyMap[22]).VirtualizedListContext;
  var styles = _reactNative.StyleSheet.create({
    verticallyInverted: _reactNative.Platform.OS === 'android' ? {
      transform: [{
        scale: -1
      }]
    } : {
      transform: [{
        scaleY: -1
      }]
    },
    horizontallyInverted: {
      transform: [{
        scaleX: -1
      }]
    },
    debug: {
      flex: 1
    },
    debugOverlayBase: {
      position: 'absolute',
      top: 0,
      right: 0
    },
    debugOverlay: {
      bottom: 0,
      width: 20,
      borderColor: 'blue',
      borderWidth: 1
    },
    debugOverlayFrame: {
      left: 0,
      backgroundColor: 'orange'
    },
    debugOverlayFrameLast: {
      left: 0,
      borderColor: 'green',
      borderWidth: 2
    },
    debugOverlayFrameVis: {
      left: 0,
      borderColor: 'red',
      borderWidth: 2
    }
  });
  module.exports = VirtualizedList;
},"c4b46015e44050527820",["f9cae617a85336004da4","45888e56a711ad3d0182","d57b125e535b41806db7","3508abd8c6b891008c0d","5533cec96f6a88041c69","4534eb96ece5e83c089a","f391b9d534c3a6bc8659","73afcd34a88a750f6d69","26ef620f86acf7f6932a","1953ac0cbf7ac32b33d6","a30729068ebd0dea58f8","4fd7218f700134f011e9","718d6cdfb3fb081a232d","3e01a5bc929e85870fe5","04ffc79d4da370644bce","8bafab90a37cab64b100","ce5f423367f40f3628a8","fd099686726b2dfb6f66","afd4874b36ccd4e13961","6ed0e34da2b23bd3554f","048fed5a64a04bdb7fed","a26dbe2a3afa21c3cf22","e6b1ef1f5b720d640981","de5ab026f9499640d730"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  var _require = _$$_REQUIRE(_dependencyMap[0]),
    InteractionManager = _require.InteractionManager;

  /**
   * A simple class for batching up invocations of a low-pri callback. A timeout is set to run the
   * callback once after a delay, no matter how many times it's scheduled. Once the delay is reached,
   * InteractionManager.runAfterInteractions is used to invoke the callback after any hi-pri
   * interactions are done running.
   *
   * Make sure to cleanup with dispose().  Example:
   *
   *   class Widget extends React.Component {
   *     _batchedSave: new Batchinator(() => this._saveState, 1000);
   *     _saveSate() {
   *       // save this.state to disk
   *     }
   *     componentDidUpdate() {
   *       this._batchedSave.schedule();
   *     }
   *     componentWillUnmount() {
   *       this._batchedSave.dispose();
   *     }
   *     ...
   *   }
   */
  var Batchinator = /*#__PURE__*/function () {
    function Batchinator(callback, delayMS) {
      _$$_REQUIRE(_dependencyMap[1])(this, Batchinator);
      this._delay = delayMS;
      this._callback = callback;
    }
    /*
     * Cleanup any pending tasks.
     *
     * By default, if there is a pending task the callback is run immediately. Set the option abort to
     * true to not call the callback if it was pending.
     */
    return _$$_REQUIRE(_dependencyMap[2])(Batchinator, [{
      key: "dispose",
      value: function dispose() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
          abort: false
        };
        if (this._taskHandle) {
          this._taskHandle.cancel();
          if (!options.abort) {
            this._callback();
          }
          this._taskHandle = null;
        }
      }
    }, {
      key: "schedule",
      value: function schedule() {
        var _this = this;
        if (this._taskHandle) {
          return;
        }
        var timeoutHandle = setTimeout(function () {
          _this._taskHandle = InteractionManager.runAfterInteractions(function () {
            // Note that we clear the handle before invoking the callback so that if the callback calls
            // schedule again, it will actually schedule another task.
            _this._taskHandle = null;
            _this._callback();
          });
        }, this._delay);
        this._taskHandle = {
          cancel: function cancel() {
            return clearTimeout(timeoutHandle);
          }
        };
      }
    }]);
  }();
  module.exports = Batchinator;
},"1953ac0cbf7ac32b33d6",["26ef620f86acf7f6932a","3508abd8c6b891008c0d","5533cec96f6a88041c69"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  function clamp(min, value, max) {
    if (value < min) {
      return min;
    }
    if (value > max) {
      return max;
    }
    return value;
  }
  module.exports = clamp;
},"a30729068ebd0dea58f8",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  /**
   * Intentional info-level logging for clear separation from ad-hoc console debug logging.
   */
  function infoLog() {
    var _console;
    return (_console = console).log.apply(_console, arguments);
  }
  module.exports = infoLog;
},"4fd7218f700134f011e9",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));
  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));
  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */
  var ChildListCollection = exports.default = /*#__PURE__*/function () {
    function ChildListCollection() {
      (0, _classCallCheck2.default)(this, ChildListCollection);
      this._cellKeyToChildren = new Map();
      this._childrenToCellKey = new Map();
    }
    return (0, _createClass2.default)(ChildListCollection, [{
      key: "add",
      value: function add(list, cellKey) {
        var _this$_cellKeyToChild;
        (0, _invariant.default)(!this._childrenToCellKey.has(list), 'Trying to add already present child list');
        var cellLists = (_this$_cellKeyToChild = this._cellKeyToChildren.get(cellKey)) != null ? _this$_cellKeyToChild : new Set();
        cellLists.add(list);
        this._cellKeyToChildren.set(cellKey, cellLists);
        this._childrenToCellKey.set(list, cellKey);
      }
    }, {
      key: "remove",
      value: function remove(list) {
        var cellKey = this._childrenToCellKey.get(list);
        (0, _invariant.default)(cellKey != null, 'Trying to remove non-present child list');
        this._childrenToCellKey.delete(list);
        var cellLists = this._cellKeyToChildren.get(cellKey);
        (0, _invariant.default)(cellLists, '_cellKeyToChildren should contain cellKey');
        cellLists.delete(list);
        if (cellLists.size === 0) {
          this._cellKeyToChildren.delete(cellKey);
        }
      }
    }, {
      key: "forEach",
      value: function forEach(fn) {
        for (var listSet of this._cellKeyToChildren.values()) {
          for (var list of listSet) {
            fn(list);
          }
        }
      }
    }, {
      key: "forEachInCell",
      value: function forEachInCell(cellKey, fn) {
        var _this$_cellKeyToChild2;
        var listSet = (_this$_cellKeyToChild2 = this._cellKeyToChildren.get(cellKey)) != null ? _this$_cellKeyToChild2 : [];
        for (var list of listSet) {
          fn(list);
        }
      }
    }, {
      key: "anyInCell",
      value: function anyInCell(cellKey, fn) {
        var _this$_cellKeyToChild3;
        var listSet = (_this$_cellKeyToChild3 = this._cellKeyToChildren.get(cellKey)) != null ? _this$_cellKeyToChild3 : [];
        for (var list of listSet) {
          if (fn(list)) {
            return true;
          }
        }
        return false;
      }
    }, {
      key: "size",
      value: function size() {
        return this._childrenToCellKey.size;
      }
    }]);
  }();
},"718d6cdfb3fb081a232d",["f9cae617a85336004da4","3508abd8c6b891008c0d","5533cec96f6a88041c69","fd099686726b2dfb6f66"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  var Info = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[0])(function Info() {
    _$$_REQUIRE(_dependencyMap[1])(this, Info);
    this.any_blank_count = 0;
    this.any_blank_ms = 0;
    this.any_blank_speed_sum = 0;
    this.mostly_blank_count = 0;
    this.mostly_blank_ms = 0;
    this.pixels_blank = 0;
    this.pixels_sampled = 0;
    this.pixels_scrolled = 0;
    this.total_time_spent = 0;
    this.sample_count = 0;
  });
  var DEBUG = false;
  var _listeners = [];
  var _minSampleCount = 10;
  var _sampleRate = null;

  /**
   * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.
   * By default the sampling rate is set to zero and this will do nothing. If you want to collect
   * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.
   *
   * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with
   * `SceneTracker.getActiveScene` to determine the context of the events.
   */
  var FillRateHelper = /*#__PURE__*/function () {
    function FillRateHelper(getFrameMetrics) {
      _$$_REQUIRE(_dependencyMap[1])(this, FillRateHelper);
      this._anyBlankStartTime = null;
      this._enabled = false;
      this._info = new Info();
      this._mostlyBlankStartTime = null;
      this._samplesStartTime = null;
      this._getFrameMetrics = getFrameMetrics;
      this._enabled = (_sampleRate || 0) > Math.random();
      this._resetData();
    }
    return _$$_REQUIRE(_dependencyMap[0])(FillRateHelper, [{
      key: "activate",
      value: function activate() {
        if (this._enabled && this._samplesStartTime == null) {
          DEBUG;
          this._samplesStartTime = global.performance.now();
        }
      }
    }, {
      key: "deactivateAndFlush",
      value: function deactivateAndFlush() {
        if (!this._enabled) {
          return;
        }
        var start = this._samplesStartTime; // const for flow
        if (start == null) {
          DEBUG;
          return;
        }
        if (this._info.sample_count < _minSampleCount) {
          // Don't bother with under-sampled events.
          this._resetData();
          return;
        }
        var total_time_spent = global.performance.now() - start;
        var info = Object.assign({}, this._info, {
          total_time_spent: total_time_spent
        });
        _listeners.forEach(function (listener) {
          return listener(info);
        });
        this._resetData();
      }
    }, {
      key: "computeBlankness",
      value: function computeBlankness(props, cellsAroundViewport, scrollMetrics) {
        if (!this._enabled || props.getItemCount(props.data) === 0 || cellsAroundViewport.last < cellsAroundViewport.first || this._samplesStartTime == null) {
          return 0;
        }
        var dOffset = scrollMetrics.dOffset,
          offset = scrollMetrics.offset,
          velocity = scrollMetrics.velocity,
          visibleLength = scrollMetrics.visibleLength;

        // Denominator metrics that we track for all events - most of the time there is no blankness and
        // we want to capture that.
        this._info.sample_count++;
        this._info.pixels_sampled += Math.round(visibleLength);
        this._info.pixels_scrolled += Math.round(Math.abs(dOffset));
        var scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec

        // Whether blank now or not, record the elapsed time blank if we were blank last time.
        var now = global.performance.now();
        if (this._anyBlankStartTime != null) {
          this._info.any_blank_ms += now - this._anyBlankStartTime;
        }
        this._anyBlankStartTime = null;
        if (this._mostlyBlankStartTime != null) {
          this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;
        }
        this._mostlyBlankStartTime = null;
        var blankTop = 0;
        var first = cellsAroundViewport.first;
        var firstFrame = this._getFrameMetrics(first, props);
        while (first <= cellsAroundViewport.last && (!firstFrame || !firstFrame.inLayout)) {
          firstFrame = this._getFrameMetrics(first, props);
          first++;
        }
        // Only count blankTop if we aren't rendering the first item, otherwise we will count the header
        // as blank.
        if (firstFrame && first > 0) {
          blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));
        }
        var blankBottom = 0;
        var last = cellsAroundViewport.last;
        var lastFrame = this._getFrameMetrics(last, props);
        while (last >= cellsAroundViewport.first && (!lastFrame || !lastFrame.inLayout)) {
          lastFrame = this._getFrameMetrics(last, props);
          last--;
        }
        // Only count blankBottom if we aren't rendering the last item, otherwise we will count the
        // footer as blank.
        if (lastFrame && last < props.getItemCount(props.data) - 1) {
          var bottomEdge = lastFrame.offset + lastFrame.length;
          blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));
        }
        var pixels_blank = Math.round(blankTop + blankBottom);
        var blankness = pixels_blank / visibleLength;
        if (blankness > 0) {
          this._anyBlankStartTime = now;
          this._info.any_blank_speed_sum += scrollSpeed;
          this._info.any_blank_count++;
          this._info.pixels_blank += pixels_blank;
          if (blankness > 0.5) {
            this._mostlyBlankStartTime = now;
            this._info.mostly_blank_count++;
          }
        } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {
          this.deactivateAndFlush();
        }
        return blankness;
      }
    }, {
      key: "enabled",
      value: function enabled() {
        return this._enabled;
      }
    }, {
      key: "_resetData",
      value: function _resetData() {
        this._anyBlankStartTime = null;
        this._info = new Info();
        this._mostlyBlankStartTime = null;
        this._samplesStartTime = null;
      }
    }], [{
      key: "addListener",
      value: function addListener(callback) {
        if (_sampleRate === null) {
          console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');
        }
        _listeners.push(callback);
        return {
          remove: function remove() {
            _listeners = _listeners.filter(function (listener) {
              return callback !== listener;
            });
          }
        };
      }
    }, {
      key: "setSampleRate",
      value: function setSampleRate(sampleRate) {
        _sampleRate = sampleRate;
      }
    }, {
      key: "setMinSampleCount",
      value: function setMinSampleCount(minSampleCount) {
        _minSampleCount = minSampleCount;
      }
    }]);
  }();
  module.exports = FillRateHelper;
},"3e01a5bc929e85870fe5",["5533cec96f6a88041c69","3508abd8c6b891008c0d"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));
  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));
  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));
  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));
  var _get2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));
  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));
  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));
  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[8]));
  function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
  function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
  function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  function _superPropGet(t, o, e, r) { var p = (0, _get2.default)((0, _getPrototypeOf2.default)(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; } /**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
  /**
   * `setState` is called asynchronously, and should not rely on the value of
   * `this.props` or `this.state`:
   * https://reactjs.org/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous
   *
   * SafePureComponent adds runtime enforcement, to catch cases where these
   * variables are read in a state updater function, instead of the ones passed
   * in.
   */
  var StateSafePureComponent = exports.default = /*#__PURE__*/function (_React$PureComponent) {
    function StateSafePureComponent(props) {
      var _this;
      (0, _classCallCheck2.default)(this, StateSafePureComponent);
      _this = _callSuper(this, StateSafePureComponent, [props]);
      _this._inAsyncStateUpdate = false;
      _this._installSetStateHooks();
      return _this;
    }
    (0, _inherits2.default)(StateSafePureComponent, _React$PureComponent);
    return (0, _createClass2.default)(StateSafePureComponent, [{
      key: "setState",
      value: function setState(partialState, callback) {
        var _this2 = this;
        if (typeof partialState === 'function') {
          _superPropGet(StateSafePureComponent, "setState", this, 3)([function (state, props) {
            _this2._inAsyncStateUpdate = true;
            var ret;
            try {
              ret = partialState(state, props);
            } catch (err) {
              throw err;
            } finally {
              _this2._inAsyncStateUpdate = false;
            }
            return ret;
          }, callback]);
        } else {
          _superPropGet(StateSafePureComponent, "setState", this, 3)([partialState, callback]);
        }
      }
    }, {
      key: "_installSetStateHooks",
      value: function _installSetStateHooks() {
        var that = this;
        var props = this.props,
          state = this.state;
        Object.defineProperty(this, 'props', {
          get: function get() {
            (0, _invariant.default)(!that._inAsyncStateUpdate, '"this.props" should not be accessed during state updates');
            return props;
          },
          set: function set(newProps) {
            props = newProps;
          }
        });
        Object.defineProperty(this, 'state', {
          get: function get() {
            (0, _invariant.default)(!that._inAsyncStateUpdate, '"this.state" should not be acceessed during state updates');
            return state;
          },
          set: function set(newState) {
            state = newState;
          }
        });
      }
    }]);
  }(React.PureComponent);
},"04ffc79d4da370644bce",["f9cae617a85336004da4","3508abd8c6b891008c0d","5533cec96f6a88041c69","4534eb96ece5e83c089a","f391b9d534c3a6bc8659","ef4c2223f1078b78bd52","73afcd34a88a750f6d69","fd099686726b2dfb6f66","6ed0e34da2b23bd3554f"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  /**
   * A Utility class for calculating viewable items based on current metrics like scroll position and
   * layout.
   *
   * An item is said to be in a "viewable" state when any of the following
   * is true for longer than `minimumViewTime` milliseconds (after an interaction if `waitForInteraction`
   * is true):
   *
   * - Occupying >= `viewAreaCoveragePercentThreshold` of the view area XOR fraction of the item
   *   visible in the view area >= `itemVisiblePercentThreshold`.
   * - Entirely visible on screen
   */
  var ViewabilityHelper = /*#__PURE__*/function () {
    function ViewabilityHelper() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        viewAreaCoveragePercentThreshold: 0
      };
      _$$_REQUIRE(_dependencyMap[0])(this, ViewabilityHelper);
      this._hasInteracted = false;
      this._timers = new Set();
      this._viewableIndices = [];
      this._viewableItems = new Map();
      this._config = config;
    }

    /**
     * Cleanup, e.g. on unmount. Clears any pending timers.
     */
    return _$$_REQUIRE(_dependencyMap[1])(ViewabilityHelper, [{
      key: "dispose",
      value: function dispose() {
        /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
         * comment suppresses an error found when Flow v0.63 was deployed. To see
         * the error delete this comment and run Flow. */
        this._timers.forEach(clearTimeout);
      }

      /**
       * Determines which items are viewable based on the current metrics and config.
       */
    }, {
      key: "computeViewableItems",
      value: function computeViewableItems(props, scrollOffset, viewportHeight, getFrameMetrics,
      // Optional optimization to reduce the scan size
      renderRange) {
        var itemCount = props.getItemCount(props.data);
        var _this$_config = this._config,
          itemVisiblePercentThreshold = _this$_config.itemVisiblePercentThreshold,
          viewAreaCoveragePercentThreshold = _this$_config.viewAreaCoveragePercentThreshold;
        var viewAreaMode = viewAreaCoveragePercentThreshold != null;
        var viewablePercentThreshold = viewAreaMode ? viewAreaCoveragePercentThreshold : itemVisiblePercentThreshold;
        _$$_REQUIRE(_dependencyMap[2])(viewablePercentThreshold != null && itemVisiblePercentThreshold != null !== (viewAreaCoveragePercentThreshold != null), 'Must set exactly one of itemVisiblePercentThreshold or viewAreaCoveragePercentThreshold');
        var viewableIndices = [];
        if (itemCount === 0) {
          return viewableIndices;
        }
        var firstVisible = -1;
        var _ref = renderRange || {
            first: 0,
            last: itemCount - 1
          },
          first = _ref.first,
          last = _ref.last;
        if (last >= itemCount) {
          console.warn('Invalid render range computing viewability ' + JSON.stringify({
            renderRange: renderRange,
            itemCount: itemCount
          }));
          return [];
        }
        for (var idx = first; idx <= last; idx++) {
          var metrics = getFrameMetrics(idx, props);
          if (!metrics) {
            continue;
          }
          var top = metrics.offset - scrollOffset;
          var bottom = top + metrics.length;
          if (top < viewportHeight && bottom > 0) {
            firstVisible = idx;
            if (_isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, metrics.length)) {
              viewableIndices.push(idx);
            }
          } else if (firstVisible >= 0) {
            break;
          }
        }
        return viewableIndices;
      }

      /**
       * Figures out which items are viewable and how that has changed from before and calls
       * `onViewableItemsChanged` as appropriate.
       */
    }, {
      key: "onUpdate",
      value: function onUpdate(props, scrollOffset, viewportHeight, getFrameMetrics, createViewToken, onViewableItemsChanged,
      // Optional optimization to reduce the scan size
      renderRange) {
        var _this = this;
        var itemCount = props.getItemCount(props.data);
        if (this._config.waitForInteraction && !this._hasInteracted || itemCount === 0 || !getFrameMetrics(0, props)) {
          return;
        }
        var viewableIndices = [];
        if (itemCount) {
          viewableIndices = this.computeViewableItems(props, scrollOffset, viewportHeight, getFrameMetrics, renderRange);
        }
        if (this._viewableIndices.length === viewableIndices.length && this._viewableIndices.every(function (v, ii) {
          return v === viewableIndices[ii];
        })) {
          // We might get a lot of scroll events where visibility doesn't change and we don't want to do
          // extra work in those cases.
          return;
        }
        this._viewableIndices = viewableIndices;
        if (this._config.minimumViewTime) {
          var handle = setTimeout(function () {
            /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
             * comment suppresses an error found when Flow v0.63 was deployed. To
             * see the error delete this comment and run Flow. */
            _this._timers.delete(handle);
            _this._onUpdateSync(props, viewableIndices, onViewableItemsChanged, createViewToken);
          }, this._config.minimumViewTime);
          /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
           * comment suppresses an error found when Flow v0.63 was deployed. To see
           * the error delete this comment and run Flow. */
          this._timers.add(handle);
        } else {
          this._onUpdateSync(props, viewableIndices, onViewableItemsChanged, createViewToken);
        }
      }

      /**
       * clean-up cached _viewableIndices to evaluate changed items on next update
       */
    }, {
      key: "resetViewableIndices",
      value: function resetViewableIndices() {
        this._viewableIndices = [];
      }

      /**
       * Records that an interaction has happened even if there has been no scroll.
       */
    }, {
      key: "recordInteraction",
      value: function recordInteraction() {
        this._hasInteracted = true;
      }
    }, {
      key: "_onUpdateSync",
      value: function _onUpdateSync(props, viewableIndicesToCheck, onViewableItemsChanged, createViewToken) {
        var _this2 = this;
        // Filter out indices that have gone out of view since this call was scheduled.
        viewableIndicesToCheck = viewableIndicesToCheck.filter(function (ii) {
          return _this2._viewableIndices.includes(ii);
        });
        var prevItems = this._viewableItems;
        var nextItems = new Map(viewableIndicesToCheck.map(function (ii) {
          var viewable = createViewToken(ii, true, props);
          return [viewable.key, viewable];
        }));
        var changed = [];
        for (var _ref2 of nextItems) {
          var _ref3 = _$$_REQUIRE(_dependencyMap[3])(_ref2, 2);
          var key = _ref3[0];
          var viewable = _ref3[1];
          if (!prevItems.has(key)) {
            changed.push(viewable);
          }
        }
        for (var _ref4 of prevItems) {
          var _ref5 = _$$_REQUIRE(_dependencyMap[3])(_ref4, 2);
          var _key = _ref5[0];
          var _viewable = _ref5[1];
          if (!nextItems.has(_key)) {
            changed.push(Object.assign({}, _viewable, {
              isViewable: false
            }));
          }
        }
        if (changed.length > 0) {
          this._viewableItems = nextItems;
          onViewableItemsChanged({
            viewableItems: Array.from(nextItems.values()),
            changed: changed,
            viewabilityConfig: this._config
          });
        }
      }
    }]);
  }();
  function _isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, itemLength) {
    if (_isEntirelyVisible(top, bottom, viewportHeight)) {
      return true;
    } else {
      var pixels = _getPixelsVisible(top, bottom, viewportHeight);
      var percent = 100 * (viewAreaMode ? pixels / viewportHeight : pixels / itemLength);
      return percent >= viewablePercentThreshold;
    }
  }
  function _getPixelsVisible(top, bottom, viewportHeight) {
    var visibleHeight = Math.min(bottom, viewportHeight) - Math.max(top, 0);
    return Math.max(0, visibleHeight);
  }
  function _isEntirelyVisible(top, bottom, viewportHeight) {
    return top >= 0 && bottom <= viewportHeight && bottom > top;
  }
  module.exports = ViewabilityHelper;
},"8bafab90a37cab64b100",["3508abd8c6b891008c0d","5533cec96f6a88041c69","fd099686726b2dfb6f66","606f5f734809feae52ba"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));
  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));
  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));
  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));
  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));
  var _reactNative = _$$_REQUIRE(_dependencyMap[6]);
  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));
  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[8]));
  function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
  function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
  function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); } /**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
  var CellRenderer = exports.default = /*#__PURE__*/function (_React$Component) {
    function CellRenderer() {
      var _this;
      (0, _classCallCheck2.default)(this, CellRenderer);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _callSuper(this, CellRenderer, [].concat(args));
      _this.state = {
        separatorProps: {
          highlighted: false,
          leadingItem: _this.props.item
        }
      };
      // TODO: consider factoring separator stuff out of VirtualizedList into FlatList since it's not
      // reused by SectionList and we can keep VirtualizedList simpler.
      // $FlowFixMe[missing-local-annot]
      _this._separators = {
        highlight: function highlight() {
          var _this$props = _this.props,
            cellKey = _this$props.cellKey,
            prevCellKey = _this$props.prevCellKey;
          _this.props.onUpdateSeparators([cellKey, prevCellKey], {
            highlighted: true
          });
        },
        unhighlight: function unhighlight() {
          var _this$props2 = _this.props,
            cellKey = _this$props2.cellKey,
            prevCellKey = _this$props2.prevCellKey;
          _this.props.onUpdateSeparators([cellKey, prevCellKey], {
            highlighted: false
          });
        },
        updateProps: function updateProps(select, newProps) {
          var _this$props3 = _this.props,
            cellKey = _this$props3.cellKey,
            prevCellKey = _this$props3.prevCellKey;
          _this.props.onUpdateSeparators([select === 'leading' ? prevCellKey : cellKey], newProps);
        }
      };
      _this._onLayout = function (nativeEvent) {
        _this.props.onCellLayout && _this.props.onCellLayout(nativeEvent, _this.props.cellKey, _this.props.index);
      };
      return _this;
    }
    (0, _inherits2.default)(CellRenderer, _React$Component);
    return (0, _createClass2.default)(CellRenderer, [{
      key: "updateSeparatorProps",
      value: function updateSeparatorProps(newProps) {
        this.setState(function (state) {
          return {
            separatorProps: Object.assign({}, state.separatorProps, newProps)
          };
        });
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.props.onUnmount(this.props.cellKey);
      }
    }, {
      key: "_renderElement",
      value: function _renderElement(renderItem, ListItemComponent, item, index) {
        if (renderItem && ListItemComponent) {
          console.warn("VirtualizedList: Both ListItemComponent and renderItem props are present. ListItemComponent will take precedence over renderItem.");
        }
        if (ListItemComponent) {
          /* $FlowFixMe[not-a-component] (>=0.108.0 site=react_native_fb) This
           * comment suppresses an error found when Flow v0.108 was deployed. To
           * see the error, delete this comment and run Flow. */
          /* $FlowFixMe[incompatible-type-arg] (>=0.108.0 site=react_native_fb)
           * This comment suppresses an error found when Flow v0.108 was deployed.
           * To see the error, delete this comment and run Flow. */
          return React.createElement(ListItemComponent, {
            item: item,
            index: index,
            separators: this._separators
          });
        }
        if (renderItem) {
          return renderItem({
            item: item,
            index: index,
            separators: this._separators
          });
        }
        (0, _invariant.default)(false, 'VirtualizedList: Either ListItemComponent or renderItem props are required but none were found.');
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props4 = this.props,
          CellRendererComponent = _this$props4.CellRendererComponent,
          ItemSeparatorComponent = _this$props4.ItemSeparatorComponent,
          ListItemComponent = _this$props4.ListItemComponent,
          cellKey = _this$props4.cellKey,
          horizontal = _this$props4.horizontal,
          item = _this$props4.item,
          index = _this$props4.index,
          inversionStyle = _this$props4.inversionStyle,
          onCellFocusCapture = _this$props4.onCellFocusCapture,
          onCellLayout = _this$props4.onCellLayout,
          renderItem = _this$props4.renderItem;
        var element = this._renderElement(renderItem, ListItemComponent, item, index);

        // NOTE: that when this is a sticky header, `onLayout` will get automatically extracted and
        // called explicitly by `ScrollViewStickyHeader`.
        var itemSeparator = React.isValidElement(ItemSeparatorComponent) ?
        // $FlowFixMe[incompatible-type]
        ItemSeparatorComponent :
        // $FlowFixMe[incompatible-type]
        ItemSeparatorComponent && /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[9]).jsx)(ItemSeparatorComponent, Object.assign({}, this.state.separatorProps));
        var cellStyle = inversionStyle ? horizontal ? [styles.rowReverse, inversionStyle] : [styles.columnReverse, inversionStyle] : horizontal ? [styles.row, inversionStyle] : inversionStyle;
        var result = !CellRendererComponent ? /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[9]).jsxs)(_reactNative.View, Object.assign({
          style: cellStyle,
          onFocusCapture: onCellFocusCapture
        }, onCellLayout && {
          onLayout: this._onLayout
        }, {
          children: [element, itemSeparator]
        })) : /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[9]).jsxs)(CellRendererComponent, Object.assign({
          cellKey: cellKey,
          index: index,
          item: item,
          style: cellStyle,
          onFocusCapture: onCellFocusCapture
        }, onCellLayout && {
          onLayout: this._onLayout
        }, {
          children: [element, itemSeparator]
        }));
        return /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[9]).jsx)(_$$_REQUIRE(_dependencyMap[10]).VirtualizedListCellContextProvider, {
          cellKey: this.props.cellKey,
          children: result
        });
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(props, prevState) {
        return {
          separatorProps: Object.assign({}, prevState.separatorProps, {
            leadingItem: props.item
          })
        };
      }
    }]);
  }(React.Component);
  var styles = _reactNative.StyleSheet.create({
    row: {
      flexDirection: 'row'
    },
    rowReverse: {
      flexDirection: 'row-reverse'
    },
    columnReverse: {
      flexDirection: 'column-reverse'
    }
  });
},"ce5f423367f40f3628a8",["f9cae617a85336004da4","3508abd8c6b891008c0d","5533cec96f6a88041c69","4534eb96ece5e83c089a","f391b9d534c3a6bc8659","73afcd34a88a750f6d69","26ef620f86acf7f6932a","fd099686726b2dfb6f66","6ed0e34da2b23bd3554f","048fed5a64a04bdb7fed","e6b1ef1f5b720d640981"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VirtualizedListCellContextProvider = VirtualizedListCellContextProvider;
  exports.VirtualizedListContext = undefined;
  exports.VirtualizedListContextProvider = VirtualizedListContextProvider;
  exports.VirtualizedListContextResetter = VirtualizedListContextResetter;
  var _react = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));
  var React = _react;
  function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
  function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  var VirtualizedListContext = exports.VirtualizedListContext = React.createContext(null);
  /**
   * Resets the context. Intended for use by portal-like components (e.g. Modal).
   */
  function VirtualizedListContextResetter(_ref) {
    var children = _ref.children;
    return /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[1]).jsx)(VirtualizedListContext.Provider, {
      value: null,
      children: children
    });
  }

  /**
   * Sets the context with memoization. Intended to be used by `VirtualizedList`.
   */
  function VirtualizedListContextProvider(_ref2) {
    var children = _ref2.children,
      value = _ref2.value;
    // Avoid setting a newly created context object if the values are identical.
    var context = (0, _react.useMemo)(function () {
      return {
        cellKey: null,
        getScrollMetrics: value.getScrollMetrics,
        horizontal: value.horizontal,
        getOutermostParentListRef: value.getOutermostParentListRef,
        registerAsNestedChild: value.registerAsNestedChild,
        unregisterAsNestedChild: value.unregisterAsNestedChild
      };
    }, [value.getScrollMetrics, value.horizontal, value.getOutermostParentListRef, value.registerAsNestedChild, value.unregisterAsNestedChild]);
    return /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[1]).jsx)(VirtualizedListContext.Provider, {
      value: context,
      children: children
    });
  }

  /**
   * Sets the `cellKey`. Intended to be used by `VirtualizedList` for each cell.
   */
  function VirtualizedListCellContextProvider(_ref3) {
    var cellKey = _ref3.cellKey,
      children = _ref3.children;
    // Avoid setting a newly created context object if the values are identical.
    var currContext = (0, _react.useContext)(VirtualizedListContext);
    var context = (0, _react.useMemo)(function () {
      return currContext == null ? null : Object.assign({}, currContext, {
        cellKey: cellKey
      });
    }, [currContext, cellKey]);
    return /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[1]).jsx)(VirtualizedListContext.Provider, {
      value: context,
      children: children
    });
  }
},"e6b1ef1f5b720d640981",["6ed0e34da2b23bd3554f","048fed5a64a04bdb7fed"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.CellRenderMask = undefined;
  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));
  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));
  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));
  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));
  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */
  var CellRenderMask = exports.CellRenderMask = /*#__PURE__*/function () {
    function CellRenderMask(numCells) {
      (0, _classCallCheck2.default)(this, CellRenderMask);
      (0, _invariant.default)(numCells >= 0, 'CellRenderMask must contain a non-negative number os cells');
      this._numCells = numCells;
      if (numCells === 0) {
        this._regions = [];
      } else {
        this._regions = [{
          first: 0,
          last: numCells - 1,
          isSpacer: true
        }];
      }
    }
    return (0, _createClass2.default)(CellRenderMask, [{
      key: "enumerateRegions",
      value: function enumerateRegions() {
        return this._regions;
      }
    }, {
      key: "addCells",
      value: function addCells(cells) {
        var _this$_regions;
        (0, _invariant.default)(cells.first >= 0 && cells.first < this._numCells && cells.last >= -1 && cells.last < this._numCells && cells.last >= cells.first - 1, 'CellRenderMask.addCells called with invalid cell range');

        // VirtualizedList uses inclusive ranges, where zero-count states are
        // possible. E.g. [0, -1] for no cells, starting at 0.
        if (cells.last < cells.first) {
          return;
        }
        var _this$_findRegion = this._findRegion(cells.first),
          _this$_findRegion2 = (0, _slicedToArray2.default)(_this$_findRegion, 2),
          firstIntersect = _this$_findRegion2[0],
          firstIntersectIdx = _this$_findRegion2[1];
        var _this$_findRegion3 = this._findRegion(cells.last),
          _this$_findRegion4 = (0, _slicedToArray2.default)(_this$_findRegion3, 2),
          lastIntersect = _this$_findRegion4[0],
          lastIntersectIdx = _this$_findRegion4[1];

        // Fast-path if the cells to add are already all present in the mask. We
        // will otherwise need to do some mutation.
        if (firstIntersectIdx === lastIntersectIdx && !firstIntersect.isSpacer) {
          return;
        }

        // We need to replace the existing covered regions with 1-3 new regions
        // depending whether we need to split spacers out of overlapping regions.
        var newLeadRegion = [];
        var newTailRegion = [];
        var newMainRegion = Object.assign({}, cells, {
          isSpacer: false
        });
        if (firstIntersect.first < newMainRegion.first) {
          if (firstIntersect.isSpacer) {
            newLeadRegion.push({
              first: firstIntersect.first,
              last: newMainRegion.first - 1,
              isSpacer: true
            });
          } else {
            newMainRegion.first = firstIntersect.first;
          }
        }
        if (lastIntersect.last > newMainRegion.last) {
          if (lastIntersect.isSpacer) {
            newTailRegion.push({
              first: newMainRegion.last + 1,
              last: lastIntersect.last,
              isSpacer: true
            });
          } else {
            newMainRegion.last = lastIntersect.last;
          }
        }
        var replacementRegions = [].concat(newLeadRegion, [newMainRegion], newTailRegion);
        var numRegionsToDelete = lastIntersectIdx - firstIntersectIdx + 1;
        (_this$_regions = this._regions).splice.apply(_this$_regions, [firstIntersectIdx, numRegionsToDelete].concat((0, _toConsumableArray2.default)(replacementRegions)));
      }
    }, {
      key: "numCells",
      value: function numCells() {
        return this._numCells;
      }
    }, {
      key: "equals",
      value: function equals(other) {
        return this._numCells === other._numCells && this._regions.length === other._regions.length && this._regions.every(function (region, i) {
          return region.first === other._regions[i].first && region.last === other._regions[i].last && region.isSpacer === other._regions[i].isSpacer;
        });
      }
    }, {
      key: "_findRegion",
      value: function _findRegion(cellIdx) {
        var firstIdx = 0;
        var lastIdx = this._regions.length - 1;
        while (firstIdx <= lastIdx) {
          var middleIdx = Math.floor((firstIdx + lastIdx) / 2);
          var middleRegion = this._regions[middleIdx];
          if (cellIdx >= middleRegion.first && cellIdx <= middleRegion.last) {
            return [middleRegion, middleIdx];
          } else if (cellIdx < middleRegion.first) {
            lastIdx = middleIdx - 1;
          } else if (cellIdx > middleRegion.last) {
            firstIdx = middleIdx + 1;
          }
        }
        (0, _invariant.default)(false, `A region was not found containing cellIdx ${cellIdx}`);
      }
    }]);
  }();
},"de5ab026f9499640d730",["f9cae617a85336004da4","45888e56a711ad3d0182","606f5f734809feae52ba","3508abd8c6b891008c0d","5533cec96f6a88041c69","fd099686726b2dfb6f66"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));
  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));
  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));
  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));
  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));
  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));
  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));
  var _reactNative = _$$_REQUIRE(_dependencyMap[8]);
  var _VirtualizedList = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));
  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));
  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[11]));
  var _excluded = ["ItemSeparatorComponent", "SectionSeparatorComponent", "renderItem", "renderSectionFooter", "renderSectionHeader", "sections", "stickySectionHeadersEnabled"];
  function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
  function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
  function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); } /**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
  /**
   * Right now this just flattens everything into one list and uses VirtualizedList under the
   * hood. The only operation that might not scale well is concatting the data arrays of all the
   * sections when new props are received, which should be plenty fast for up to ~10,000 items.
   */
  var VirtualizedSectionList = /*#__PURE__*/function (_React$PureComponent) {
    function VirtualizedSectionList() {
      var _this;
      (0, _classCallCheck2.default)(this, VirtualizedSectionList);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _callSuper(this, VirtualizedSectionList, [].concat(args));
      // $FlowFixMe[missing-local-annot]
      _this._keyExtractor = function (item, index) {
        var info = _this._subExtractor(index);
        return info && info.key || String(index);
      };
      _this._convertViewable = function (viewable) {
        var _info$index;
        (0, _invariant.default)(viewable.index != null, 'Received a broken ViewToken');
        var info = _this._subExtractor(viewable.index);
        if (!info) {
          return null;
        }
        var keyExtractorWithNullableIndex = info.section.keyExtractor;
        var keyExtractorWithNonNullableIndex = _this.props.keyExtractor || _$$_REQUIRE(_dependencyMap[12]).keyExtractor;
        var key = keyExtractorWithNullableIndex != null ? keyExtractorWithNullableIndex(viewable.item, info.index) : keyExtractorWithNonNullableIndex(viewable.item, (_info$index = info.index) != null ? _info$index : 0);
        return Object.assign({}, viewable, {
          index: info.index,
          key: key,
          section: info.section
        });
      };
      _this._onViewableItemsChanged = function (_ref) {
        var viewableItems = _ref.viewableItems,
          changed = _ref.changed;
        var onViewableItemsChanged = _this.props.onViewableItemsChanged;
        if (onViewableItemsChanged != null) {
          onViewableItemsChanged({
            viewableItems: viewableItems.map(_this._convertViewable, _this).filter(Boolean),
            changed: changed.map(_this._convertViewable, _this).filter(Boolean)
          });
        }
      };
      _this._renderItem = function (listItemCount) {
        return (
          // eslint-disable-next-line react/no-unstable-nested-components
          function (_ref2) {
            var item = _ref2.item,
              index = _ref2.index;
            var info = _this._subExtractor(index);
            if (!info) {
              return null;
            }
            var infoIndex = info.index;
            if (infoIndex == null) {
              var section = info.section;
              if (info.header === true) {
                var renderSectionHeader = _this.props.renderSectionHeader;
                return renderSectionHeader ? renderSectionHeader({
                  section: section
                }) : null;
              } else {
                var renderSectionFooter = _this.props.renderSectionFooter;
                return renderSectionFooter ? renderSectionFooter({
                  section: section
                }) : null;
              }
            } else {
              var renderItem = info.section.renderItem || _this.props.renderItem;
              var SeparatorComponent = _this._getSeparatorComponent(index, info, listItemCount);
              (0, _invariant.default)(renderItem, 'no renderItem!');
              return /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[13]).jsx)(ItemWithSeparator, {
                SeparatorComponent: SeparatorComponent,
                LeadingSeparatorComponent: infoIndex === 0 ? _this.props.SectionSeparatorComponent : undefined,
                cellKey: info.key,
                index: infoIndex,
                item: item,
                leadingItem: info.leadingItem,
                leadingSection: info.leadingSection,
                prevCellKey: (_this._subExtractor(index - 1) || {}).key
                // Callback to provide updateHighlight for this item
                ,
                setSelfHighlightCallback: _this._setUpdateHighlightFor,
                setSelfUpdatePropsCallback: _this._setUpdatePropsFor
                // Provide child ability to set highlight/updateProps for previous item using prevCellKey
                ,
                updateHighlightFor: _this._updateHighlightFor,
                updatePropsFor: _this._updatePropsFor,
                renderItem: renderItem,
                section: info.section,
                trailingItem: info.trailingItem,
                trailingSection: info.trailingSection,
                inverted: !!_this.props.inverted
              });
            }
          }
        );
      };
      _this._updatePropsFor = function (cellKey, value) {
        var updateProps = _this._updatePropsMap[cellKey];
        if (updateProps != null) {
          updateProps(value);
        }
      };
      _this._updateHighlightFor = function (cellKey, value) {
        var updateHighlight = _this._updateHighlightMap[cellKey];
        if (updateHighlight != null) {
          updateHighlight(value);
        }
      };
      _this._setUpdateHighlightFor = function (cellKey, updateHighlightFn) {
        if (updateHighlightFn != null) {
          _this._updateHighlightMap[cellKey] = updateHighlightFn;
        } else {
          // $FlowFixMe[prop-missing]
          delete _this._updateHighlightFor[cellKey];
        }
      };
      _this._setUpdatePropsFor = function (cellKey, updatePropsFn) {
        if (updatePropsFn != null) {
          _this._updatePropsMap[cellKey] = updatePropsFn;
        } else {
          delete _this._updatePropsMap[cellKey];
        }
      };
      _this._updateHighlightMap = {};
      _this._updatePropsMap = {};
      _this._captureRef = function (ref) {
        _this._listRef = ref;
      };
      return _this;
    }
    (0, _inherits2.default)(VirtualizedSectionList, _React$PureComponent);
    return (0, _createClass2.default)(VirtualizedSectionList, [{
      key: "scrollToLocation",
      value: function scrollToLocation(params) {
        var index = params.itemIndex;
        for (var i = 0; i < params.sectionIndex; i++) {
          index += this.props.getItemCount(this.props.sections[i].data) + 2;
        }
        var viewOffset = params.viewOffset || 0;
        if (this._listRef == null) {
          return;
        }
        if (params.itemIndex > 0 && this.props.stickySectionHeadersEnabled) {
          var frame = this._listRef.__getFrameMetricsApprox(index - params.itemIndex, this._listRef.props);
          viewOffset += frame.length;
        }
        var toIndexParams = Object.assign({}, params, {
          viewOffset: viewOffset,
          index: index
        });
        // $FlowFixMe[incompatible-use]
        this._listRef.scrollToIndex(toIndexParams);
      }
    }, {
      key: "getListRef",
      value: function getListRef() {
        return this._listRef;
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        var _this$props = this.props,
          ItemSeparatorComponent = _this$props.ItemSeparatorComponent,
          SectionSeparatorComponent = _this$props.SectionSeparatorComponent,
          _renderItem = _this$props.renderItem,
          renderSectionFooter = _this$props.renderSectionFooter,
          renderSectionHeader = _this$props.renderSectionHeader,
          _sections = _this$props.sections,
          stickySectionHeadersEnabled = _this$props.stickySectionHeadersEnabled,
          passThroughProps = (0, _objectWithoutProperties2.default)(_this$props, _excluded);
        var listHeaderOffset = this.props.ListHeaderComponent ? 1 : 0;
        var stickyHeaderIndices = this.props.stickySectionHeadersEnabled ? [] : undefined;
        var itemCount = 0;
        for (var section of this.props.sections) {
          // Track the section header indices
          if (stickyHeaderIndices != null) {
            stickyHeaderIndices.push(itemCount + listHeaderOffset);
          }

          // Add two for the section header and footer.
          itemCount += 2;
          itemCount += this.props.getItemCount(section.data);
        }
        var renderItem = this._renderItem(itemCount);
        return /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[13]).jsx)(_VirtualizedList.default, Object.assign({}, passThroughProps, {
          keyExtractor: this._keyExtractor,
          stickyHeaderIndices: stickyHeaderIndices,
          renderItem: renderItem,
          data: this.props.sections,
          getItem: function getItem(sections, index) {
            return _this2._getItem(_this2.props, sections, index);
          },
          getItemCount: function getItemCount() {
            return itemCount;
          },
          onViewableItemsChanged: this.props.onViewableItemsChanged ? this._onViewableItemsChanged : undefined,
          ref: this._captureRef
        }));
      }
    }, {
      key: "_getItem",
      value: function _getItem(props, sections, index) {
        if (!sections) {
          return null;
        }
        var itemIdx = index - 1;
        for (var i = 0; i < sections.length; i++) {
          var section = sections[i];
          var sectionData = section.data;
          var itemCount = props.getItemCount(sectionData);
          if (itemIdx === -1 || itemIdx === itemCount) {
            // We intend for there to be overflow by one on both ends of the list.
            // This will be for headers and footers. When returning a header or footer
            // item the section itself is the item.
            return section;
          } else if (itemIdx < itemCount) {
            // If we are in the bounds of the list's data then return the item.
            return props.getItem(sectionData, itemIdx);
          } else {
            itemIdx -= itemCount + 2; // Add two for the header and footer
          }
        }
        return null;
      }
    }, {
      key: "_subExtractor",
      value: function _subExtractor(index) {
        var itemIndex = index;
        var _this$props2 = this.props,
          getItem = _this$props2.getItem,
          getItemCount = _this$props2.getItemCount,
          keyExtractor = _this$props2.keyExtractor,
          sections = _this$props2.sections;
        for (var i = 0; i < sections.length; i++) {
          var section = sections[i];
          var sectionData = section.data;
          var key = section.key || String(i);
          itemIndex -= 1; // The section adds an item for the header
          if (itemIndex >= getItemCount(sectionData) + 1) {
            itemIndex -= getItemCount(sectionData) + 1; // The section adds an item for the footer.
          } else if (itemIndex === -1) {
            return {
              section: section,
              key: key + ':header',
              index: null,
              header: true,
              trailingSection: sections[i + 1]
            };
          } else if (itemIndex === getItemCount(sectionData)) {
            return {
              section: section,
              key: key + ':footer',
              index: null,
              header: false,
              trailingSection: sections[i + 1]
            };
          } else {
            var extractor = section.keyExtractor || keyExtractor || _$$_REQUIRE(_dependencyMap[12]).keyExtractor;
            return {
              section: section,
              key: key + ':' + extractor(getItem(sectionData, itemIndex), itemIndex),
              index: itemIndex,
              leadingItem: getItem(sectionData, itemIndex - 1),
              leadingSection: sections[i - 1],
              trailingItem: getItem(sectionData, itemIndex + 1),
              trailingSection: sections[i + 1]
            };
          }
        }
      }
    }, {
      key: "_getSeparatorComponent",
      value: function _getSeparatorComponent(index, info, listItemCount) {
        info = info || this._subExtractor(index);
        if (!info) {
          return null;
        }
        var ItemSeparatorComponent = info.section.ItemSeparatorComponent || this.props.ItemSeparatorComponent;
        var SectionSeparatorComponent = this.props.SectionSeparatorComponent;
        var isLastItemInList = index === listItemCount - 1;
        var isLastItemInSection = info.index === this.props.getItemCount(info.section.data) - 1;
        if (SectionSeparatorComponent && isLastItemInSection) {
          return SectionSeparatorComponent;
        }
        if (ItemSeparatorComponent && !isLastItemInSection && !isLastItemInList) {
          return ItemSeparatorComponent;
        }
        return null;
      }
    }]);
  }(React.PureComponent);
  function ItemWithSeparator(props) {
    var LeadingSeparatorComponent = props.LeadingSeparatorComponent,
      SeparatorComponent = props.SeparatorComponent,
      cellKey = props.cellKey,
      prevCellKey = props.prevCellKey,
      setSelfHighlightCallback = props.setSelfHighlightCallback,
      updateHighlightFor = props.updateHighlightFor,
      setSelfUpdatePropsCallback = props.setSelfUpdatePropsCallback,
      updatePropsFor = props.updatePropsFor,
      item = props.item,
      index = props.index,
      section = props.section,
      inverted = props.inverted;
    var _React$useState = React.useState(false),
      _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
      leadingSeparatorHiglighted = _React$useState2[0],
      setLeadingSeparatorHighlighted = _React$useState2[1];
    var _React$useState3 = React.useState(false),
      _React$useState4 = (0, _slicedToArray2.default)(_React$useState3, 2),
      separatorHighlighted = _React$useState4[0],
      setSeparatorHighlighted = _React$useState4[1];
    var _React$useState5 = React.useState({
        leadingItem: props.leadingItem,
        leadingSection: props.leadingSection,
        section: props.section,
        trailingItem: props.item,
        trailingSection: props.trailingSection
      }),
      _React$useState6 = (0, _slicedToArray2.default)(_React$useState5, 2),
      leadingSeparatorProps = _React$useState6[0],
      setLeadingSeparatorProps = _React$useState6[1];
    var _React$useState7 = React.useState({
        leadingItem: props.item,
        leadingSection: props.leadingSection,
        section: props.section,
        trailingItem: props.trailingItem,
        trailingSection: props.trailingSection
      }),
      _React$useState8 = (0, _slicedToArray2.default)(_React$useState7, 2),
      separatorProps = _React$useState8[0],
      setSeparatorProps = _React$useState8[1];
    React.useEffect(function () {
      setSelfHighlightCallback(cellKey, setSeparatorHighlighted);
      // $FlowFixMe[incompatible-call]
      setSelfUpdatePropsCallback(cellKey, setSeparatorProps);
      return function () {
        setSelfUpdatePropsCallback(cellKey, null);
        setSelfHighlightCallback(cellKey, null);
      };
    }, [cellKey, setSelfHighlightCallback, setSeparatorProps, setSelfUpdatePropsCallback]);
    var separators = {
      highlight: function highlight() {
        setLeadingSeparatorHighlighted(true);
        setSeparatorHighlighted(true);
        if (prevCellKey != null) {
          updateHighlightFor(prevCellKey, true);
        }
      },
      unhighlight: function unhighlight() {
        setLeadingSeparatorHighlighted(false);
        setSeparatorHighlighted(false);
        if (prevCellKey != null) {
          updateHighlightFor(prevCellKey, false);
        }
      },
      updateProps: function updateProps(select, newProps) {
        if (select === 'leading') {
          if (LeadingSeparatorComponent != null) {
            setLeadingSeparatorProps(Object.assign({}, leadingSeparatorProps, newProps));
          } else if (prevCellKey != null) {
            // update the previous item's separator
            updatePropsFor(prevCellKey, Object.assign({}, leadingSeparatorProps, newProps));
          }
        } else if (select === 'trailing' && SeparatorComponent != null) {
          setSeparatorProps(Object.assign({}, separatorProps, newProps));
        }
      }
    };
    var element = props.renderItem({
      item: item,
      index: index,
      section: section,
      separators: separators
    });
    var leadingSeparator = LeadingSeparatorComponent != null && /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[13]).jsx)(LeadingSeparatorComponent, Object.assign({
      highlighted: leadingSeparatorHiglighted
    }, leadingSeparatorProps));
    var separator = SeparatorComponent != null && /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[13]).jsx)(SeparatorComponent, Object.assign({
      highlighted: separatorHighlighted
    }, separatorProps));
    return leadingSeparator || separator ? /*#__PURE__*/(0, _$$_REQUIRE(_dependencyMap[13]).jsxs)(_reactNative.View, {
      children: [inverted === false ? leadingSeparator : separator, element, inverted === false ? separator : leadingSeparator]
    }) : element;
  }

  /* $FlowFixMe[class-object-subtyping] added when improving typing for this
   * parameters */
  // $FlowFixMe[method-unbinding]
  module.exports = VirtualizedSectionList;
},"d2355175ff6609a3def1",["f9cae617a85336004da4","606f5f734809feae52ba","dd1a5f938f6f03510b39","3508abd8c6b891008c0d","5533cec96f6a88041c69","4534eb96ece5e83c089a","f391b9d534c3a6bc8659","73afcd34a88a750f6d69","26ef620f86acf7f6932a","c4b46015e44050527820","fd099686726b2dfb6f66","6ed0e34da2b23bd3554f","a26dbe2a3afa21c3cf22","048fed5a64a04bdb7fed"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function asyncGeneratorStep(n, t, e, r, o, a, c) {
    try {
      var i = n[a](c),
        u = i.value;
    } catch (n) {
      return void e(n);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
  }
  function _asyncToGenerator(n) {
    return function () {
      var t = this,
        e = arguments;
      return new Promise(function (r, o) {
        var a = n.apply(t, e);
        function _next(n) {
          asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
        }
        function _throw(n) {
          asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
        }
        _next(undefined);
      });
    };
  }
  module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"ff7d8d645536d793bbec",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  {
    module.exports = _$$_REQUIRE(_dependencyMap[0]);
  }
},"6832e1c00f3f16dfaae5",["e06788c407c9335df771"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * use-sync-external-store-shim.native.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  "use strict";

  var React = _$$_REQUIRE(_dependencyMap[0]);
  function is(x, y) {
    return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is,
    useState = React.useState,
    useEffect = React.useEffect,
    useLayoutEffect = React.useLayoutEffect,
    useDebugValue = React.useDebugValue;
  function useSyncExternalStore$1(subscribe, getSnapshot) {
    var value = getSnapshot(),
      _useState = useState({
        inst: {
          value: value,
          getSnapshot: getSnapshot
        }
      }),
      inst = _useState[0].inst,
      forceUpdate = _useState[1];
    useLayoutEffect(function () {
      inst.value = value;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceUpdate({
        inst: inst
      });
    }, [subscribe, value, getSnapshot]);
    useEffect(function () {
      checkIfSnapshotChanged(inst) && forceUpdate({
        inst: inst
      });
      return subscribe(function () {
        checkIfSnapshotChanged(inst) && forceUpdate({
          inst: inst
        });
      });
    }, [subscribe]);
    useDebugValue(value);
    return value;
  }
  function checkIfSnapshotChanged(inst) {
    var latestGetSnapshot = inst.getSnapshot;
    inst = inst.value;
    try {
      var nextValue = latestGetSnapshot();
      return !objectIs(inst, nextValue);
    } catch (error) {
      return true;
    }
  }
  exports.useSyncExternalStore = undefined !== React.useSyncExternalStore ? React.useSyncExternalStore : useSyncExternalStore$1;
},"e06788c407c9335df771",["6ed0e34da2b23bd3554f"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var id = 0;
  function _classPrivateFieldKey(e) {
    return "__private_" + id++ + "_" + e;
  }
  module.exports = _classPrivateFieldKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"c5dbc1f907bdbe211c48",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _classPrivateFieldBase(e, t) {
    if (!{}.hasOwnProperty.call(e, t)) throw new TypeError("attempted to use private field on non-instance");
    return e;
  }
  module.exports = _classPrivateFieldBase, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"837ca394faf5697cd044",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2023 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  // @ts-ignore
  var registerGeneratedViewConfig_1 = __importDefault(_$$_REQUIRE(_dependencyMap[0]));
  var KeplerCaptionsViewSpec = "KeplerCaptionsViewStable";
  var viewConfig = {
    bubblingEventTypes: {
      topOnCaptionViewCreated: {
        phasedRegistrationNames: {
          bubbled: 'onCaptionViewCreated',
          captured: 'onCaptionViewCreatedCapture'
        }
      }
    },
    validAttributes: {
      show: true
    }
  };
  (0, registerGeneratedViewConfig_1.default)(KeplerCaptionsViewSpec, Object.assign({
    uiViewClassName: KeplerCaptionsViewSpec
  }, viewConfig));
  exports.default = KeplerCaptionsViewSpec;
},"03a3f998e1368ca874e1",["76b52edafd968705fff3"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LogUtil = exports.LogLevel = undefined;
  /**
   * Log levels for controlling verbosity of logging
   */
  var LogLevel;
  (function (LogLevel) {
    LogLevel[LogLevel["NONE"] = 0] = "NONE";
    LogLevel[LogLevel["ERROR"] = 1] = "ERROR";
    LogLevel[LogLevel["WARN"] = 2] = "WARN";
    LogLevel[LogLevel["INFO"] = 3] = "INFO";
    LogLevel[LogLevel["DEBUG"] = 4] = "DEBUG";
    LogLevel[LogLevel["VERBOSE"] = 5] = "VERBOSE"; // All logs
  })(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
  /**
   * Simple utility class for logging with different levels
   */
  var LogUtil = /*#__PURE__*/function () {
    function LogUtil() {
      _$$_REQUIRE(_dependencyMap[0])(this, LogUtil);
    }
    return _$$_REQUIRE(_dependencyMap[1])(LogUtil, null, [{
      key: "setLogLevel",
      value:
      /**
       * Set the log level
       * @param level The log level to set
       */
      function setLogLevel(level) {
        if (level >= LogLevel.NONE && level <= LogLevel.VERBOSE) {
          this.currentLogLevel = level;
        }
      }
      /**
       * Get the current log level
       * @returns The current log level
       */
    }, {
      key: "getLogLevel",
      value: function getLogLevel() {
        return this.currentLogLevel;
      }
      /**
       * Get the current log level as a string
       * @returns The current log level name
       */
    }, {
      key: "getCurrentLogLevelName",
      value: function getCurrentLogLevelName() {
        switch (this.currentLogLevel) {
          case LogLevel.NONE:
            return "NONE";
          case LogLevel.ERROR:
            return "ERROR";
          case LogLevel.WARN:
            return "WARN";
          case LogLevel.INFO:
            return "INFO";
          case LogLevel.DEBUG:
            return "DEBUG";
          case LogLevel.VERBOSE:
            return "VERBOSE";
          default:
            return "UNKNOWN";
        }
      }
      /**
       * Log an error message if error logging is enabled
       * @param message The message to log
       * @param optionalParams Additional parameters to log
       */
    }, {
      key: "error",
      value: function error(message) {
        if (this.currentLogLevel >= LogLevel.ERROR) {
          var _console;
          for (var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            optionalParams[_key - 1] = arguments[_key];
          }
          (_console = console).error.apply(_console, [`${message}`].concat(optionalParams));
        }
      }
      /**
       * Log a warning message if warning logging is enabled
       * @param message The message to log
       * @param optionalParams Additional parameters to log
       */
    }, {
      key: "warn",
      value: function warn(message) {
        if (this.currentLogLevel >= LogLevel.WARN) {
          var _console2;
          for (var _len2 = arguments.length, optionalParams = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            optionalParams[_key2 - 1] = arguments[_key2];
          }
          (_console2 = console).warn.apply(_console2, [`${message}`].concat(optionalParams));
        }
      }
      /**
       * Log an info message if info logging is enabled
       * @param message The message to log
       * @param optionalParams Additional parameters to log
       */
    }, {
      key: "info",
      value: function info(message) {
        if (this.currentLogLevel >= LogLevel.INFO) {
          var _console3;
          for (var _len3 = arguments.length, optionalParams = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            optionalParams[_key3 - 1] = arguments[_key3];
          }
          (_console3 = console).info.apply(_console3, [`${message}`].concat(optionalParams));
        }
      }
      /**
       * Log a debug message if debug logging is enabled
       * @param message The message to log
       * @param optionalParams Additional parameters to log
       */
    }, {
      key: "debug",
      value: function debug(message) {
        if (this.currentLogLevel >= LogLevel.DEBUG) {
          var _console4;
          for (var _len4 = arguments.length, optionalParams = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            optionalParams[_key4 - 1] = arguments[_key4];
          }
          (_console4 = console).debug.apply(_console4, [`${message}`].concat(optionalParams));
        }
      }
      /**
       * Log a verbose message if verbose logging is enabled
       * @param message The message to log
       * @param optionalParams Additional parameters to log
       */
    }, {
      key: "verbose",
      value: function verbose(message) {
        if (this.currentLogLevel >= LogLevel.VERBOSE) {
          var _console5;
          for (var _len5 = arguments.length, optionalParams = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
            optionalParams[_key5 - 1] = arguments[_key5];
          }
          (_console5 = console).log.apply(_console5, [`${message}`].concat(optionalParams));
        }
      }
    }]);
  }();
  // Current log level
  LogUtil.currentLogLevel = LogLevel.INFO;
  exports.LogUtil = LogUtil;
},"1f12e7e43345228dfcad",["3508abd8c6b891008c0d","5533cec96f6a88041c69"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2021-2023 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  function _callSuper(t, o, e) { return o = _$$_REQUIRE(_dependencyMap[0])(o), _$$_REQUIRE(_dependencyMap[1])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _$$_REQUIRE(_dependencyMap[0])(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KeplerVideoSurfaceView = undefined;
  /** This file is copied from ATVKeplerVideoSurface vmpf-dev branch */
  var React = __importStar(_$$_REQUIRE(_dependencyMap[2]));
  var react_native_1 = _$$_REQUIRE(_dependencyMap[3]);
  var KeplerVideoSurfaceViewSpec_1 = __importDefault(_$$_REQUIRE(_dependencyMap[4]));
  var styles = react_native_1.StyleSheet.create({
    base: {
      flexGrow: 1,
      flexShrink: 1
    }
  });
  ;
  /**
   * @brief This is a react native component that Renders video frames on the screen.
   * Use this component only when operating in pre-buffering mode using the `VideoPlayer`
   * component, where more than one player can be pre-buffered simultaneously with
   * different contents. The app then attaches the surface handle passed by the
   * `onSurfaceViewCreated` event callback to the video player instance that needs
   * to be rendered.
   */
  var KeplerVideoSurfaceView = /*#__PURE__*/function (_React$Component) {
    function KeplerVideoSurfaceView(props) {
      _$$_REQUIRE(_dependencyMap[5])(this, KeplerVideoSurfaceView);
      return _callSuper(this, KeplerVideoSurfaceView, [props]);
    }
    /**
     * @hidden
     */
    _$$_REQUIRE(_dependencyMap[6])(KeplerVideoSurfaceView, _React$Component);
    return _$$_REQUIRE(_dependencyMap[7])(KeplerVideoSurfaceView, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        _$$_REQUIRE(_dependencyMap[8]).LogUtil.info('KeplerVideoSurfaceView: componentDidMount');
        if (this.props.onComponentDidMount !== undefined) {
          this.props.onComponentDidMount();
        }
      }
      /**
       * @hidden
       */
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        _$$_REQUIRE(_dependencyMap[8]).LogUtil.info('KeplerVideoSurfaceView: componentWillUnmount');
        if (this.props.onComponentWillUnmount !== undefined) {
          this.props.onComponentWillUnmount();
        }
      }
      /**
       * @hidden
       */
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
          scalingmode = _this$props.scalingmode,
          onSurfaceViewCreated = _this$props.onSurfaceViewCreated,
          onSurfaceViewDestroyed = _this$props.onSurfaceViewDestroyed,
          style = _this$props.style;
        _$$_REQUIRE(_dependencyMap[8]).LogUtil.info('render KeplerVideoSurfaceView');
        return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[9]).jsx(KeplerVideoSurfaceViewSpec_1.default, {
          scalingmode: scalingmode,
          onKeplerVideoSurfaceViewCreated: function onKeplerVideoSurfaceViewCreated(ev) {
            _$$_REQUIRE(_dependencyMap[8]).LogUtil.info('KeplerVideoSurfaceView: onKeplerVideoSurfaceViewCreated');
            onSurfaceViewCreated == null ? undefined : onSurfaceViewCreated(ev.nativeEvent.value);
          },
          onKeplerVideoSurfaceViewDestroyed: function onKeplerVideoSurfaceViewDestroyed(ev) {
            _$$_REQUIRE(_dependencyMap[8]).LogUtil.info('KeplerVideoSurfaceView: onKeplerVideoSurfaceViewDestroyed');
            onSurfaceViewDestroyed == null ? undefined : onSurfaceViewDestroyed(ev.nativeEvent.value);
          },
          style: [styles.base, style]
        });
      }
    }]);
  }(React.Component);
  exports.KeplerVideoSurfaceView = KeplerVideoSurfaceView;
  ;
},"d280120de7a05ead75ef",["f391b9d534c3a6bc8659","4534eb96ece5e83c089a","6ed0e34da2b23bd3554f","26ef620f86acf7f6932a","6ad60af8a946dfe295b6","3508abd8c6b891008c0d","73afcd34a88a750f6d69","5533cec96f6a88041c69","1f12e7e43345228dfcad","048fed5a64a04bdb7fed"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  // @ts-ignore
  var registerGeneratedViewConfig_1 = __importDefault(_$$_REQUIRE(_dependencyMap[0]));
  // This is left commented out because it is needed for codegen. When you run codegen, uncomment this.
  // export const Commands: NativeCommands = codegenNativeCommands<NativeCommands>({
  //     supportedCommands: ["setValue"],
  // });
  var KeplerVideoSurfaceViewSpec = "KeplerVideoSurfaceViewStable";
  // This is left commented out because it is needed for codegen. When you run codegen, uncomment this.
  // export default codegenNativeComponent<NativeProps>("SampleUIComponent");
  var viewConfig = {
    validAttributes: {
      scalingmode: true
    },
    bubblingEventTypes: {
      topOnKeplerVideoSurfaceViewCreated: {
        phasedRegistrationNames: {
          bubbled: 'onKeplerVideoSurfaceViewCreated',
          captured: 'onKeplerVideoSurfaceViewCreatedCapture'
        }
      },
      topOnKeplerVideoSurfaceViewDestroyed: {
        phasedRegistrationNames: {
          bubbled: 'onKeplerVideoSurfaceViewDestroyed',
          captured: 'onKeplerVideoSurfaceViewDestroyedCapture'
        }
      }
    }
  };
  (0, registerGeneratedViewConfig_1.default)(KeplerVideoSurfaceViewSpec, Object.assign({
    uiViewClassName: KeplerVideoSurfaceViewSpec
  }, viewConfig));
  // Comment out this line, when you run codegen.
  exports.default = KeplerVideoSurfaceViewSpec;
},"6ad60af8a946dfe295b6",["76b52edafd968705fff3"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  function _callSuper(t, o, e) { return o = _$$_REQUIRE(_dependencyMap[0])(o), _$$_REQUIRE(_dependencyMap[1])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _$$_REQUIRE(_dependencyMap[0])(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KeplerShareableSurfaceView = undefined;
  /** This file is copied from ATVKeplerVideoSurface vmpf-dev branch */
  var React = __importStar(_$$_REQUIRE(_dependencyMap[2]));
  var react_native_1 = _$$_REQUIRE(_dependencyMap[3]);
  var KeplerShareableSurfaceView_1 = __importDefault(_$$_REQUIRE(_dependencyMap[4]));
  var styles = react_native_1.StyleSheet.create({
    base: {
      flexGrow: 1,
      flexShrink: 1
    }
  });
  /**
   * @brief This is a react native component that Renders video frames on the screen.
   * Use this component only when operating in pre-buffering mode using the `VideoPlayer`
   * component, where more than one player can be pre-buffered simultaneously with
   * different contents. The app then attaches the surface handle passed by the
   * `onSurfaceViewCreated` event callback to the video player instance that needs
   * to be rendered.
   */
  var KeplerShareableSurfaceView = /*#__PURE__*/function (_React$Component) {
    function KeplerShareableSurfaceView(props) {
      _$$_REQUIRE(_dependencyMap[5])(this, KeplerShareableSurfaceView);
      return _callSuper(this, KeplerShareableSurfaceView, [props]);
    }
    /**
     * @hidden
     */
    _$$_REQUIRE(_dependencyMap[6])(KeplerShareableSurfaceView, _React$Component);
    return _$$_REQUIRE(_dependencyMap[7])(KeplerShareableSurfaceView, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        _$$_REQUIRE(_dependencyMap[8]).LogUtil.info('KeplerShareableSurfaceView: componentDidMount');
        if (this.props.onComponentDidMount !== undefined) {
          this.props.onComponentDidMount();
        }
      }
      /**
       * @hidden
       */
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        _$$_REQUIRE(_dependencyMap[8]).LogUtil.info('KeplerShareableSurfaceView: componentWillUnmount');
        if (this.props.onComponentWillUnmount !== undefined) {
          this.props.onComponentWillUnmount();
        }
      }
      /**
       * @hidden
       */
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
          scalingmode = _this$props.scalingmode,
          onSurfaceViewCreated = _this$props.onSurfaceViewCreated,
          onSurfaceViewDestroyed = _this$props.onSurfaceViewDestroyed,
          style = _this$props.style;
        _$$_REQUIRE(_dependencyMap[8]).LogUtil.info('render KeplerShareableSurfaceView');
        return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[9]).jsx(KeplerShareableSurfaceView_1.default, {
          scalingmode: scalingmode,
          onKeplerShareableSurfaceViewCreated: function onKeplerShareableSurfaceViewCreated(ev) {
            _$$_REQUIRE(_dependencyMap[8]).LogUtil.info('KeplerShareableSurfaceView: onKeplerShareableSurfaceViewCreated');
            onSurfaceViewCreated == null ? undefined : onSurfaceViewCreated(ev.nativeEvent.value);
          },
          onKeplerShareableSurfaceViewDestroyed: function onKeplerShareableSurfaceViewDestroyed(ev) {
            _$$_REQUIRE(_dependencyMap[8]).LogUtil.info('KeplerShareableSurfaceView: onKeplerShareableSurfaceViewDestroyed');
            onSurfaceViewDestroyed == null ? undefined : onSurfaceViewDestroyed(ev.nativeEvent.value);
          },
          style: [styles.base, style]
        });
      }
    }]);
  }(React.Component);
  exports.KeplerShareableSurfaceView = KeplerShareableSurfaceView;
  ;
},"0d7ab8d53799eecfef8c",["f391b9d534c3a6bc8659","4534eb96ece5e83c089a","6ed0e34da2b23bd3554f","26ef620f86acf7f6932a","6b50c6e1e4f9b7955ef8","3508abd8c6b891008c0d","73afcd34a88a750f6d69","5533cec96f6a88041c69","1f12e7e43345228dfcad","048fed5a64a04bdb7fed"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  /** This file is copied from ATVKeplerVideoSurface vmpf-dev branch */
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  // @ts-ignore
  var registerGeneratedViewConfig_1 = __importDefault(_$$_REQUIRE(_dependencyMap[0]));
  // This is left commented out because it is needed for codegen. When you run codegen, uncomment this.
  // export const Commands: NativeCommands = codegenNativeCommands<NativeCommands>({
  //     supportedCommands: ["setValue"],
  // });
  var KeplerShareableSurfaceViewSpec = "KeplerShareableSurfaceViewStable";
  // This is left commented out because it is needed for codegen. When you run codegen, uncomment this.
  // export default codegenNativeComponent<NativeProps>("SampleUIComponent");
  var viewConfig = {
    validAttributes: {
      scalingmode: true
    },
    bubblingEventTypes: {
      topOnKeplerShareableSurfaceViewCreated: {
        phasedRegistrationNames: {
          bubbled: 'onKeplerShareableSurfaceViewCreated',
          captured: 'onKeplerShareableSurfaceViewCreatedCapture'
        }
      },
      topOnKeplerShareableSurfaceViewDestroyed: {
        phasedRegistrationNames: {
          bubbled: 'onKeplerShareableSurfaceViewDestroyed',
          captured: 'onKeplerShareableSurfaceViewDestroyedCapture'
        }
      }
    }
  };
  (0, registerGeneratedViewConfig_1.default)(KeplerShareableSurfaceViewSpec, Object.assign({
    uiViewClassName: KeplerShareableSurfaceViewSpec
  }, viewConfig));
  // Comment out this line, when you run codegen.
  exports.default = KeplerShareableSurfaceViewSpec;
},"6b50c6e1e4f9b7955ef8",["76b52edafd968705fff3"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KeplerVideoView = undefined;
  /*
   * Copyright 2022-2023 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  var React = __importStar(_$$_REQUIRE(_dependencyMap[0]));
  var MediaControls_1 = __importDefault(_$$_REQUIRE(_dependencyMap[1]));
  /**
   * @brief This is a react native component that renders the following as specified
   * by optional props set by the app developer:
   *
   * * Video frames on the screen.
   * * Closed captions and subtitles on the screen (optional).
   * * Media controls (optional).
   *
   */
  var KeplerVideoView = function KeplerVideoView(props) {
    var showKeplerCaptionsView = props.showCaptions;
    var showControls = props.showControls;
    var surfaceViewHandle = React.useRef(null);
    var videoPlayer = props.videoPlayer;
    var scalingmode = props.scalingmode;
    /**
     * @hidden
     */
    var onSurfaceViewCreated = function onSurfaceViewCreated(_surfaceViewHandle) {
      _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`KeplerVideoView: onSurfaceViewCreated ${_surfaceViewHandle}`);
      surfaceViewHandle.current = _surfaceViewHandle;
      if (videoPlayer) {
        videoPlayer.setSurfaceHandle(surfaceViewHandle.current);
        videoPlayer.play();
      }
    };
    /**
     * @hidden
     */
    var onSurfaceViewDestroyed = function onSurfaceViewDestroyed(_surfaceViewHandle) {
      _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`KeplerVideoView: onSurfaceViewDestroyed: ${_surfaceViewHandle}`);
      if (surfaceViewHandle.current === _surfaceViewHandle) {
        videoPlayer == null ? undefined : videoPlayer.clearSurfaceHandle(_surfaceViewHandle);
        surfaceViewHandle.current = null;
      }
    };
    /**
     * @hidden
     */
    var onCaptionViewCreated = function onCaptionViewCreated(_captionsViewHandle) {
      _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`KeplerVideoView: onCaptionViewCreated ${_captionsViewHandle}`);
      if (videoPlayer) {
        videoPlayer.setCaptionViewHandle(_captionsViewHandle);
      }
    };
    /**
     * @hidden
     */
    var onCaptionViewDestroyed = function onCaptionViewDestroyed(_captionsViewHandle) {
      _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`KeplerVideoView: onCaptionViewDestroyed ${_captionsViewHandle}`);
      videoPlayer == null ? undefined : videoPlayer.clearCaptionViewHandle(_captionsViewHandle);
    };
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[3]).jsxs(_$$_REQUIRE(_dependencyMap[3]).Fragment, {
      children: [/*#__PURE__*/_$$_REQUIRE(_dependencyMap[3]).jsx(_$$_REQUIRE(_dependencyMap[4]).KeplerVideoSurfaceView, {
        style: {
          zIndex: 0
        },
        scalingmode: scalingmode,
        onSurfaceViewCreated: onSurfaceViewCreated,
        onSurfaceViewDestroyed: onSurfaceViewDestroyed
      }), showKeplerCaptionsView ? /*#__PURE__*/_$$_REQUIRE(_dependencyMap[3]).jsx(_$$_REQUIRE(_dependencyMap[5]).KeplerCaptionsView, {
        onCaptionViewCreated: onCaptionViewCreated,
        onCaptionViewDestroyed: onCaptionViewDestroyed,
        show: props.showCaptions,
        style: {
          width: '100%',
          height: '100%',
          top: 0,
          left: 0,
          position: 'absolute',
          backgroundColor: "transparent",
          flexDirection: 'column',
          alignItems: 'center',
          zIndex: 2
        }
      }) : null, showControls ? /*#__PURE__*/_$$_REQUIRE(_dependencyMap[3]).jsx(MediaControls_1.default, {
        initFocus: true,
        mediaPlayer: videoPlayer,
        style: {
          zIndex: 3
        }
      }) : null]
    });
  };
  exports.KeplerVideoView = KeplerVideoView;
  KeplerVideoView.defaultProps = {
    showControls: true,
    showCaptions: true,
    scalingmode: 'fit'
  };
},"9d5e7fd998ee3b3e6c71",["6ed0e34da2b23bd3554f","57cfca0008596c8d64b2","1f12e7e43345228dfcad","048fed5a64a04bdb7fed","d280120de7a05ead75ef","0d9a17d8c6f7cb480e97"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2022-2024 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  // rs_out
  // @ts-nocheck
  var react_1 = _$$_REQUIRE(_dependencyMap[0]);
  var react_native_1 = _$$_REQUIRE(_dependencyMap[1]);
  var CaptionButton_1 = __importDefault(_$$_REQUIRE(_dependencyMap[2]));
  var FloatingButton_1 = __importStar(_$$_REQUIRE(_dependencyMap[3]));
  var FloatingList_1 = __importDefault(_$$_REQUIRE(_dependencyMap[4]));
  var Slider_1 = __importDefault(_$$_REQUIRE(_dependencyMap[5]));
  var SliderMetaData_1 = __importDefault(_$$_REQUIRE(_dependencyMap[6]));
  var styles = react_native_1.StyleSheet.create({
    container: {
      width: '100%',
      height: '100%',
      top: 0,
      left: 0,
      position: 'absolute',
      backgroundColor: 'transparent',
      flexDirection: 'column',
      alignItems: 'center'
    },
    buttonsContainer: {
      width: '100%',
      height: '100%',
      top: 0,
      left: 0,
      position: 'absolute',
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: 'rgba(0, 0, 0, 0.5)'
    },
    otherOptionsContainer: {
      bottom: 0,
      right: 0,
      padding: 5,
      position: 'absolute',
      flexDirection: 'row',
      justifyContent: 'flex-end',
      alignItems: 'flex-end'
    },
    captionList: {
      position: 'absolute',
      right: 10,
      bottom: 90
    },
    playbackSpeedList: {
      position: 'absolute',
      right: 10,
      bottom: 90
    },
    imageContainer: {
      width: 80,
      height: 80
    },
    playPauseImageContainer: {
      width: 170,
      height: 170
    },
    imageContainerForPlaybackButton: {
      minWidth: 160,
      width: 'auto',
      height: 80
    },
    slider: {
      width: '100%',
      position: 'absolute',
      bottom: 125
    },
    seekBox: {
      width: '100%',
      position: 'absolute',
      bottom: 50,
      flexDirection: 'row',
      justifyContent: 'space-between'
    },
    timeShifter: {
      backgroundColor: '#FF474D'
    }
  });
  // This is the initial speed of seekbar thumb
  // while starting the seek 
  var DEFAULT_STEP = 150;
  var PROGRESS_UPDATE_INTERVAL = 500; // milliseconds
  var ONE_SECOND = 1000; // milliseconds
  var CAPTION_OFF = 'Off';
  var DEFAULT_CAPTION = CAPTION_OFF;
  var DEFAULT_PLAYBACK_SPEED = '1';
  var MediaControls = function MediaControls(props) {
    var _props$mediaPlayer, _props$mediaPlayer2, _props$mediaPlayer3;
    var stepInterval = (0, react_1.useRef)(0);
    var previousPlaybackState = (0, react_1.useRef)(false);
    var refPlay = (0, react_1.useRef)(null);
    var refMute = (0, react_1.useRef)(null);
    var refLoop = (0, react_1.useRef)(null);
    var refCaption = (0, react_1.useRef)(null);
    var refCaptionList = (0, react_1.useRef)(null);
    var refPlaybackSpeed = (0, react_1.useRef)(null);
    var refPlaybackSpeedList = (0, react_1.useRef)(null);
    var _ref = (0, react_1.useState)(!((_props$mediaPlayer = props.mediaPlayer) != null && _props$mediaPlayer.paused)),
      _ref2 = _$$_REQUIRE(_dependencyMap[7])(_ref, 2),
      isPlaying = _ref2[0],
      setIsPlaying = _ref2[1];
    var _ref3 = (0, react_1.useState)((_props$mediaPlayer2 = props.mediaPlayer) == null ? undefined : _props$mediaPlayer2.muted),
      _ref4 = _$$_REQUIRE(_dependencyMap[7])(_ref3, 2),
      isMute = _ref4[0],
      setIsMute = _ref4[1];
    var _ref5 = (0, react_1.useState)((_props$mediaPlayer3 = props.mediaPlayer) == null ? undefined : _props$mediaPlayer3.loop),
      _ref6 = _$$_REQUIRE(_dependencyMap[7])(_ref5, 2),
      isLoopEnabled = _ref6[0],
      setEnableLoop = _ref6[1];
    var _ref7 = (0, react_1.useState)(false),
      _ref8 = _$$_REQUIRE(_dependencyMap[7])(_ref7, 2),
      isCaptionListVisible = _ref8[0],
      setIsCaptionListVisible = _ref8[1];
    var _ref9 = (0, react_1.useState)(false),
      _ref10 = _$$_REQUIRE(_dependencyMap[7])(_ref9, 2),
      isPlaybackListVisible = _ref10[0],
      setIsPlaybackListVisible = _ref10[1];
    var captionValue = (0, react_1.useRef)(DEFAULT_CAPTION);
    var playbackSpeedValue = (0, react_1.useRef)(DEFAULT_PLAYBACK_SPEED);
    var captionData = (0, react_1.useRef)(null);
    var _ref11 = (0, react_1.useState)(0),
      _ref12 = _$$_REQUIRE(_dependencyMap[7])(_ref11, 2),
      currentTrackTime = _ref12[0],
      setCurrentTrackTime = _ref12[1];
    var _ref13 = (0, react_1.useState)(DEFAULT_STEP),
      _ref14 = _$$_REQUIRE(_dependencyMap[7])(_ref13, 2),
      stepValue = _ref14[0],
      setStepValue = _ref14[1];
    var _ref15 = (0, react_1.useState)(0),
      _ref16 = _$$_REQUIRE(_dependencyMap[7])(_ref15, 2),
      thumbValue = _ref16[0],
      setThumbValue = _ref16[1];
    (0, react_1.useEffect)(function () {
      var currentinterval = setInterval(function () {
        setCurrentTrackTime(props.mediaPlayer.currentTime * ONE_SECOND);
      }, PROGRESS_UPDATE_INTERVAL);
      return function () {
        return clearInterval(currentinterval);
      };
    }, [props.mediaPlayer]);
    (0, react_1.useEffect)(function () {
      setUpEventListener();
      return function () {
        var _props$mediaPlayer4;
        removeEventListeners();
        if (props.mediaPlayer === null || ((_props$mediaPlayer4 = props.mediaPlayer) == null ? undefined : _props$mediaPlayer4.textTracks) === null) {
          captionData.length = 0;
        }
      };
    }, [props.mediaPlayer]);
    var handleOnSlidingStart = function handleOnSlidingStart() {
      if (props.mediaPlayer) {
        previousPlaybackState.current = !props.mediaPlayer.paused;
        props.mediaPlayer.pause();
      }
      stepInterval.current = setInterval(function () {
        setStepValue(function (prev) {
          return prev * 3;
        });
      }, 3000);
    };
    var handleOnSlidingEnd = function handleOnSlidingEnd() {
      clearInterval(stepInterval.current);
      setStepValue(DEFAULT_STEP);
      props.mediaPlayer.currentTime = thumbValue / ONE_SECOND;
      if (previousPlaybackState.current) {
        props.mediaPlayer.play();
      }
    };
    var onChangeValueHandler = function onChangeValueHandler(value) {
      setThumbValue(value);
    };
    var closeFloatingList = function closeFloatingList() {
      if (isPlaybackListVisible) {
        setIsPlaybackListVisible(false);
      }
      if (isCaptionListVisible) {
        setIsCaptionListVisible(false);
      }
    };
    var onPausePlayToggle = function onPausePlayToggle(mediaPlayer) {
      _$$_REQUIRE(_dependencyMap[8]).LogUtil.info(`MediaControls:onPausePlayToggle: isPlaying is ${isPlaying}`);
      closeFloatingList();
      if (mediaPlayer != null && mediaPlayer.paused) {
        mediaPlayer == null ? undefined : mediaPlayer.play();
      } else {
        mediaPlayer == null ? undefined : mediaPlayer.pause();
      }
      if (props.onPressHandler) {
        props.onPressHandler();
      }
    };
    var onMuteUnmuteToggle = function onMuteUnmuteToggle(mediaPlayer) {
      _$$_REQUIRE(_dependencyMap[8]).LogUtil.info(`MediaControls:onMuteUnmuteToggle: isMute is ${isMute}`);
      closeFloatingList();
      if (mediaPlayer === undefined) {
        return;
      }
      mediaPlayer.muted = !mediaPlayer.muted;
      setIsMute(mediaPlayer.muted);
    };
    var onLoopToggle = function onLoopToggle(mediaPlayer) {
      _$$_REQUIRE(_dependencyMap[8]).LogUtil.info(`MediaControls:onEnableDisableLoopToggle: isLoop is ${isLoopEnabled}`);
      closeFloatingList();
      if (mediaPlayer === undefined) {
        return;
      }
      mediaPlayer.loop = !mediaPlayer.loop;
      setEnableLoop(mediaPlayer.loop);
    };
    var onCaptionToggle = function onCaptionToggle() {
      _$$_REQUIRE(_dependencyMap[8]).LogUtil.info(`MediaControls:onEnableDisableCaptionToggle: isCaptionListVisible is ${!isCaptionListVisible}`);
      if (isPlaybackListVisible) {
        setIsPlaybackListVisible(false);
      }
      if (captionData.current !== null) {
        setIsCaptionListVisible(!isCaptionListVisible);
      }
    };
    var onPlaybackSpeedToggle = function onPlaybackSpeedToggle() {
      _$$_REQUIRE(_dependencyMap[8]).LogUtil.info(`MediaControls:onPlaybackSpeedToggle: isPlaybackListVisible is ${!isPlaybackListVisible}`);
      if (isCaptionListVisible) {
        setIsCaptionListVisible(false);
      }
      setIsPlaybackListVisible(!isPlaybackListVisible);
    };
    var onCaptionValueToggle = function onCaptionValueToggle(mediaPlayer, newLanguage) {
      _$$_REQUIRE(_dependencyMap[8]).LogUtil.info(`MediaControls:onCaptionValueToggle: previous id ${captionValue.current}`);
      var track = mediaPlayer.textTracks.getTrackById(captionValue.current);
      if (track) {
        track.mode = "hidden";
      }
      captionValue.current = newLanguage;
      _$$_REQUIRE(_dependencyMap[8]).LogUtil.info(`MediaControls:onCaptionValueToggle: new id ${captionValue.current}`);
      setIsCaptionListVisible(false);
      if (mediaPlayer === undefined) {
        return;
      }
      var newTrack = mediaPlayer.textTracks.getTrackById(captionValue.current);
      if (newTrack) {
        mediaPlayer.captioning = true;
        newTrack.mode = "showing";
      } else {
        mediaPlayer.captioning = false;
      }
    };
    var onPlaybackSpeedValueToggle = function onPlaybackSpeedValueToggle(mediaPlayer, newSpeed) {
      _$$_REQUIRE(_dependencyMap[8]).LogUtil.info(`MediaControls:onPlaybackSpeedValueToggle: previous playbackSpeedValue
         is ${playbackSpeedValue.current}`);
      playbackSpeedValue.current = newSpeed;
      setIsPlaybackListVisible(false);
      if (mediaPlayer === undefined) {
        return;
      }
      mediaPlayer.playbackRate = Number(playbackSpeedValue.current);
      _$$_REQUIRE(_dependencyMap[8]).LogUtil.info(`MediaControls:onPlaybackSpeedValueToggle: current playbackSpeedValue
         is ${playbackSpeedValue.current}`);
    };
    var button = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[9]).jsx(react_native_1.View, {
      style: styles.playPauseImageContainer,
      accessibilityLabel: "MediaControls PLAY/PAUSE",
      children: /*#__PURE__*/_$$_REQUIRE(_dependencyMap[9]).jsx(FloatingButton_1.default, {
        ref: refPlay,
        hasTVPreferredFocus: true,
        onPressHandler: function onPressHandler() {
          onPausePlayToggle(props.mediaPlayer);
        },
        buttonType: isPlaying ? FloatingButton_1.ButtonType.PAUSE : FloatingButton_1.ButtonType.PLAY
      })
    });
    var muteUnmuteButton = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[9]).jsx(react_native_1.View, {
      style: styles.imageContainer,
      accessibilityLabel: "MediaControls MUTE/UNMUTE",
      children: /*#__PURE__*/_$$_REQUIRE(_dependencyMap[9]).jsx(FloatingButton_1.default, {
        ref: refMute,
        onPressHandler: function onPressHandler() {
          onMuteUnmuteToggle(props.mediaPlayer);
        },
        buttonType: isMute ? FloatingButton_1.ButtonType.MUTE : FloatingButton_1.ButtonType.UNMUTE
      })
    });
    var toggleLoop = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[9]).jsx(react_native_1.View, {
      style: styles.imageContainer,
      accessibilityLabel: "MediaControls Enable/Disable Loop",
      children: /*#__PURE__*/_$$_REQUIRE(_dependencyMap[9]).jsx(FloatingButton_1.default, {
        ref: refLoop,
        onPressHandler: function onPressHandler() {
          onLoopToggle(props.mediaPlayer);
        },
        buttonType: isLoopEnabled ? FloatingButton_1.ButtonType.ENABLE_LOOP : FloatingButton_1.ButtonType.DISABLE_LOOP
      })
    });
    var toggleCaptionButton = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[9]).jsx(CaptionButton_1.default, {
      ref: refCaption,
      onPressHandler: function onPressHandler() {
        if (!isCaptionListVisible) {
          var _refCaptionList$curre;
          (_refCaptionList$curre = refCaptionList.current) == null ? undefined : _refCaptionList$curre.focus();
        }
        onCaptionToggle();
      },
      captionDataAvailable: captionData.current !== null,
      captionOff: captionValue.current === CAPTION_OFF
    });
    var SliderMetaDataView = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[9]).jsx(SliderMetaData_1.default, {
      currentTime: currentTrackTime,
      totalTime: props.mediaPlayer.duration * ONE_SECOND
    });
    var SeekBar = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[9]).jsx(Slider_1.default, {
      currentValue: currentTrackTime,
      totalValue: props.mediaPlayer.duration === Infinity ? currentTrackTime : props.mediaPlayer.duration * ONE_SECOND,
      onFocus: function onFocus() {
        closeFloatingList();
      },
      step: stepValue,
      onValueChange: onChangeValueHandler,
      onSlidingStart: handleOnSlidingStart,
      onSlidingEnd: handleOnSlidingEnd,
      longPressIntervalDuration: 10,
      barTrackColor: 'rgba(113, 31, 34,0.3)',
      currentValueIndicatorColor: "red",
      disableThumbnail: true,
      timeShiftIndicatorStyle: styles.timeShifter
    });
    var playbackButton = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[9]).jsx(react_native_1.View, {
      style: styles.imageContainerForPlaybackButton,
      accessibilityLabel: "MediaControls Playback Speed",
      children: /*#__PURE__*/_$$_REQUIRE(_dependencyMap[9]).jsx(FloatingButton_1.default, {
        ref: refPlaybackSpeed,
        onPressHandler: function onPressHandler() {
          if (!isPlaybackListVisible) {
            var _refPlaybackSpeedList;
            (_refPlaybackSpeedList = refPlaybackSpeedList.current) == null ? undefined : _refPlaybackSpeedList.focus();
          }
          onPlaybackSpeedToggle();
        },
        value: playbackSpeedValue.current,
        buttonType: FloatingButton_1.ButtonType.PLAYBACK_SPEED
      })
    });
    var onPlayingUpdate = function onPlayingUpdate() {
      setIsPlaying(true);
    };
    var onPausedUpdate = function onPausedUpdate() {
      setIsPlaying(false);
    };
    var onEndedUpdate = function onEndedUpdate() {
      // Playback has ENDED.
      // Go to the earliest possible position.
      // and change icon to play.
      if (props.mediaPlayer !== undefined && props.mediaPlayer !== null) {
        props.mediaPlayer.currentTime = 0;
        setIsPlaying(false);
      }
    };
    var onSeekCompleted = function onSeekCompleted() {
      if (props.mediaPlayer !== undefined && props.mediaPlayer !== null) {
        _$$_REQUIRE(_dependencyMap[8]).LogUtil.info("MediaControls:onSeekCompleted: seeked event triggered");
      }
    };
    var onMuteUpdated = function onMuteUpdated() {
      if (props.mediaPlayer !== undefined && props.mediaPlayer !== null) {
        _$$_REQUIRE(_dependencyMap[8]).LogUtil.info("MediaControls:onMuteUpdated: volume change event triggered");
        if (props.mediaPlayer.muted) {
          setIsMute(true);
        } else {
          setIsMute(false);
        }
      }
    };
    var onTextTrackAdded = function onTextTrackAdded() {
      var _props$mediaPlayer5;
      _$$_REQUIRE(_dependencyMap[8]).LogUtil.info("MediaControls:onTextTrackAdded: addTrack change event triggered");
      captionDataFetch((_props$mediaPlayer5 = props.mediaPlayer) == null ? undefined : _props$mediaPlayer5.textTracks);
    };
    var captionDataFetch = function captionDataFetch(textTrackList) {
      if (textTrackList === undefined || textTrackList === null) {
        return;
      }
      var tempTrackInfo = [{
        id: 'Off',
        value: 'Off'
      }];
      for (var i = 0; i < textTrackList.length; i++) {
        // @ts-ignore
        var textTrack = textTrackList[i];
        _$$_REQUIRE(_dependencyMap[8]).LogUtil.info(`MediaControls: text track id = ${textTrack.id} \
                kind = ${textTrack.kind} \
                language = ${textTrack.language} \
                label = ${textTrack.label} \
                mode = ${textTrack.mode} `);
        tempTrackInfo.push({
          id: textTrack.id,
          value: textTrack.language
        });
        if (textTrack.mode === 'showing') {
          captionValue.current = textTrack.id;
        }
      }
      if (tempTrackInfo.length > 1) {
        captionData.current = tempTrackInfo;
      }
    };
    var setUpEventListener = function setUpEventListener() {
      var _props$mediaPlayer6, _props$mediaPlayer7, _props$mediaPlayer8, _props$mediaPlayer9, _props$mediaPlayer10, _props$mediaPlayer11, _props$mediaPlayer11$;
      (_props$mediaPlayer6 = props.mediaPlayer) == null ? undefined : _props$mediaPlayer6.addEventListener("play", onPlayingUpdate);
      (_props$mediaPlayer7 = props.mediaPlayer) == null ? undefined : _props$mediaPlayer7.addEventListener("pause", onPausedUpdate);
      (_props$mediaPlayer8 = props.mediaPlayer) == null ? undefined : _props$mediaPlayer8.addEventListener("ended", onEndedUpdate);
      (_props$mediaPlayer9 = props.mediaPlayer) == null ? undefined : _props$mediaPlayer9.addEventListener("seeked", onSeekCompleted);
      (_props$mediaPlayer10 = props.mediaPlayer) == null ? undefined : _props$mediaPlayer10.addEventListener("volumechange", onMuteUpdated);
      (_props$mediaPlayer11 = props.mediaPlayer) == null ? undefined : (_props$mediaPlayer11$ = _props$mediaPlayer11.textTracks) == null ? undefined : _props$mediaPlayer11$.addEventListener("addtrack", onTextTrackAdded);
    };
    var removeEventListeners = function removeEventListeners() {
      var _props$mediaPlayer12, _props$mediaPlayer13, _props$mediaPlayer14, _props$mediaPlayer15, _props$mediaPlayer16, _props$mediaPlayer17, _props$mediaPlayer17$;
      (_props$mediaPlayer12 = props.mediaPlayer) == null ? undefined : _props$mediaPlayer12.removeEventListener("play", onPlayingUpdate);
      (_props$mediaPlayer13 = props.mediaPlayer) == null ? undefined : _props$mediaPlayer13.removeEventListener("pause", onPausedUpdate);
      (_props$mediaPlayer14 = props.mediaPlayer) == null ? undefined : _props$mediaPlayer14.removeEventListener("ended", onEndedUpdate);
      (_props$mediaPlayer15 = props.mediaPlayer) == null ? undefined : _props$mediaPlayer15.removeEventListener("seeked", onSeekCompleted);
      (_props$mediaPlayer16 = props.mediaPlayer) == null ? undefined : _props$mediaPlayer16.removeEventListener("volumechange", onMuteUpdated);
      (_props$mediaPlayer17 = props.mediaPlayer) == null ? undefined : (_props$mediaPlayer17$ = _props$mediaPlayer17.textTracks) == null ? undefined : _props$mediaPlayer17$.removeEventListener("addtrack", onTextTrackAdded);
    };
    var onPressHandler = function onPressHandler() {
      var _refPlay$current;
      closeFloatingList();
      (_refPlay$current = refPlay.current) == null ? undefined : _refPlay$current.focus();
    };
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[9]).jsx(react_native_1.TouchableOpacity, {
      style: styles.container,
      onPress: onPressHandler,
      activeOpacity: 1,
      children: /*#__PURE__*/_$$_REQUIRE(_dependencyMap[9]).jsxs(react_native_1.View, {
        style: styles.buttonsContainer,
        children: [button, /*#__PURE__*/_$$_REQUIRE(_dependencyMap[9]).jsx(react_native_1.View, {
          style: styles.seekBox,
          children: SliderMetaDataView
        }), /*#__PURE__*/_$$_REQUIRE(_dependencyMap[9]).jsx(react_native_1.View, {
          style: styles.slider,
          children: SeekBar
        }), /*#__PURE__*/_$$_REQUIRE(_dependencyMap[9]).jsxs(react_native_1.View, {
          style: styles.otherOptionsContainer,
          children: [muteUnmuteButton, toggleLoop, toggleCaptionButton, playbackButton, captionData.current !== null && isCaptionListVisible ? /*#__PURE__*/_$$_REQUIRE(_dependencyMap[9]).jsx(FloatingList_1.default, {
            defaultValue: captionValue.current,
            listContainerPositioning: styles.captionList,
            data: captionData.current,
            onPressHandler: function onPressHandler(arg) {
              var _refPlay$current2;
              onCaptionValueToggle(props.mediaPlayer, arg);
              (_refPlay$current2 = refPlay.current) == null ? undefined : _refPlay$current2.focus();
            },
            ref: refCaptionList
          }) : null, isPlaybackListVisible ? /*#__PURE__*/_$$_REQUIRE(_dependencyMap[9]).jsx(FloatingList_1.default, {
            defaultValue: playbackSpeedValue.current,
            listContainerPositioning: styles.playbackSpeedList,
            data: _$$_REQUIRE(_dependencyMap[10]).PLAYBACK_SPEED_DATA,
            onPressHandler: function onPressHandler(arg) {
              var _refPlay$current3;
              onPlaybackSpeedValueToggle(props.mediaPlayer, arg);
              (_refPlay$current3 = refPlay.current) == null ? undefined : _refPlay$current3.focus();
            },
            ref: refPlaybackSpeedList
          }) : null]
        })]
      })
    });
  };
  exports.default = MediaControls;
},"57cfca0008596c8d64b2",["6ed0e34da2b23bd3554f","26ef620f86acf7f6932a","62bcc3f11b76a5170113","7457c7b31ff994f45f69","e62e4e3e2fb194312203","364e6b4f12b4528f3c20","2d5cb8c3a1dae3cc17c3","606f5f734809feae52ba","1f12e7e43345228dfcad","048fed5a64a04bdb7fed","da12c436ef5f9124e680"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _excluded = ["onPressHandler", "captionDataAvailable", "captionOff"];
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /*
   * Copyright 2023 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  // rs_out
  // @ts-nocheck
  var react_1 = _$$_REQUIRE(_dependencyMap[0]);
  var react_native_1 = _$$_REQUIRE(_dependencyMap[1]);
  var FloatingButton_1 = __importStar(_$$_REQUIRE(_dependencyMap[2]));
  var styles = react_native_1.StyleSheet.create({
    imageContainer: {
      width: "80",
      height: "80",
      alignItems: "center",
      justifyContent: "center"
    }
  });
  var CaptionButton = (0, react_1.forwardRef)(function (props, ref) {
    var onPressHandler = props.onPressHandler,
      captionDataAvailable = props.captionDataAvailable,
      captionOff = props.captionOff,
      rest = _$$_REQUIRE(_dependencyMap[3])(props, _excluded);
    var onClickHandler = function onClickHandler() {
      if (onPressHandler) {
        onPressHandler();
      }
    };
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[4]).jsx(react_native_1.View, {
      style: styles.imageContainer,
      children: captionDataAvailable ? /*#__PURE__*/_$$_REQUIRE(_dependencyMap[4]).jsx(FloatingButton_1.default, Object.assign({
        ref: ref,
        onPressHandler: onClickHandler,
        buttonType: captionOff ? FloatingButton_1.ButtonType.CAPTION_DISABLED : FloatingButton_1.ButtonType.CAPTION_ENABLED
      }, rest)) : /*#__PURE__*/_$$_REQUIRE(_dependencyMap[4]).jsx(FloatingButton_1.default, Object.assign({
        ref: ref,
        onPressHandler: onClickHandler,
        buttonType: FloatingButton_1.ButtonType.CAPTION_NOT_AVAILABLE
      }, rest))
    });
  });
  exports.default = CaptionButton;
},"62bcc3f11b76a5170113",["6ed0e34da2b23bd3554f","26ef620f86acf7f6932a","7457c7b31ff994f45f69","dd1a5f938f6f03510b39","048fed5a64a04bdb7fed"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _excluded = ["buttonType", "onPressHandler", "value", "hasTVPreferredFocus"];
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ButtonType = undefined;
  /*
   * Copyright 2022-2023 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  // rs_out
  // @ts-nocheck
  var react_1 = _$$_REQUIRE(_dependencyMap[0]);
  var react_native_1 = _$$_REQUIRE(_dependencyMap[1]);
  var ic_caption_greyed_png_1 = __importDefault(_$$_REQUIRE(_dependencyMap[2]));
  var ic_caption_off_png_1 = __importDefault(_$$_REQUIRE(_dependencyMap[3]));
  var ic_caption_on_png_1 = __importDefault(_$$_REQUIRE(_dependencyMap[4]));
  var ic_disable_loop_png_1 = __importDefault(_$$_REQUIRE(_dependencyMap[5]));
  var ic_enable_loop_png_1 = __importDefault(_$$_REQUIRE(_dependencyMap[6]));
  var ic_jump_back_10_144dp_png_1 = __importDefault(_$$_REQUIRE(_dependencyMap[7]));
  var ic_jump_forward_10_144dp_png_1 = __importDefault(_$$_REQUIRE(_dependencyMap[8]));
  var ic_pause_144dp_png_1 = __importDefault(_$$_REQUIRE(_dependencyMap[9]));
  var ic_play_144dp_png_1 = __importDefault(_$$_REQUIRE(_dependencyMap[10]));
  var ic_volume_mute_png_1 = __importDefault(_$$_REQUIRE(_dependencyMap[11]));
  var ic_volume_unmute_png_1 = __importDefault(_$$_REQUIRE(_dependencyMap[12]));
  var ButtonType;
  (function (ButtonType) {
    ButtonType["PLAY"] = "Play Button";
    ButtonType["PAUSE"] = "Pause Button";
    ButtonType["SEEK_FORWARD"] = "Forward Button";
    ButtonType["SEEK_BACKWARD"] = "Backward Button";
    ButtonType["MUTE"] = "Mute Button";
    ButtonType["UNMUTE"] = "Unmute Button";
    ButtonType["ENABLE_LOOP"] = "Enable Loop";
    ButtonType["DISABLE_LOOP"] = "Disable Loop";
    ButtonType["PLAYBACK_SPEED"] = "Playback Speed Button";
    ButtonType["CAPTION_ENABLED"] = "Caption Enabled";
    ButtonType["CAPTION_DISABLED"] = "Caption Disabled";
    ButtonType["CAPTION_NOT_AVAILABLE"] = "Caption Not Available";
  })(ButtonType = exports.ButtonType || (exports.ButtonType = {}));
  var PlayButtonImage = function PlayButtonImage() {
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(react_native_1.Image, {
      style: styles.playPauseImageContainer,
      source: ic_play_144dp_png_1.default
    });
  };
  var PauseButtonImage = function PauseButtonImage() {
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(react_native_1.Image, {
      style: styles.playPauseImageContainer,
      source: ic_pause_144dp_png_1.default
    });
  };
  var SeekForwardButtonImage = function SeekForwardButtonImage() {
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(react_native_1.Image, {
      style: styles.imageContainer,
      source: ic_jump_forward_10_144dp_png_1.default
    });
  };
  var SeekBackwardButtonImage = function SeekBackwardButtonImage() {
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(react_native_1.Image, {
      style: styles.imageContainer,
      source: ic_jump_back_10_144dp_png_1.default
    });
  };
  var MuteButtonImage = function MuteButtonImage() {
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(react_native_1.Image, {
      style: styles.imageContainer,
      source: ic_volume_mute_png_1.default
    });
  };
  var UnMuteButtonImage = function UnMuteButtonImage() {
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(react_native_1.Image, {
      style: styles.imageContainer,
      source: ic_volume_unmute_png_1.default
    });
  };
  var EnableLoopButtonImage = function EnableLoopButtonImage() {
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(react_native_1.Image, {
      style: styles.imageContainer,
      source: ic_enable_loop_png_1.default
    });
  };
  var DisableLoopButtonImage = function DisableLoopButtonImage() {
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(react_native_1.Image, {
      style: styles.imageContainer,
      source: ic_disable_loop_png_1.default
    });
  };
  var EnableCaptionButtonImage = function EnableCaptionButtonImage() {
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(react_native_1.Image, {
      style: styles.imageContainer,
      source: ic_caption_on_png_1.default
    });
  };
  var DisableCaptionButtonImage = function DisableCaptionButtonImage() {
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(react_native_1.Image, {
      style: styles.imageContainer,
      source: ic_caption_off_png_1.default
    });
  };
  var CaptionNotAvailableButtonImage = function CaptionNotAvailableButtonImage() {
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(react_native_1.Image, {
      style: styles.imageContainer,
      source: ic_caption_greyed_png_1.default
    });
  };
  var PlaybackSpeedButtonImage = function PlaybackSpeedButtonImage(props) {
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(react_native_1.Text, {
      style: styles.textButton,
      children: `${props.value}X`
    });
  };
  var DEFAULT_FONT_FAMILY = 'Amazon-Ember-Regular';
  var DEFAULT_PLAYBACK_SPEED = '1';
  var FloatingButton = (0, react_1.forwardRef)(function (props, ref) {
    var buttonType = props.buttonType,
      onPressHandler = props.onPressHandler,
      value = props.value,
      hasTVPreferredFocus = props.hasTVPreferredFocus,
      rest = _$$_REQUIRE(_dependencyMap[14])(props, _excluded);
    var _ref = (0, react_1.useState)(''),
      _ref2 = _$$_REQUIRE(_dependencyMap[15])(_ref, 2),
      color = _ref2[0],
      setColor = _ref2[1];
    var updateColor = function updateColor(color_) {
      return setColor(color_);
    };
    var button;
    switch (buttonType) {
      case ButtonType.PLAY:
        button = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(PlayButtonImage, {});
        break;
      case ButtonType.PAUSE:
        button = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(PauseButtonImage, {});
        break;
      case ButtonType.SEEK_FORWARD:
        button = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(SeekForwardButtonImage, {});
        break;
      case ButtonType.SEEK_BACKWARD:
        button = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(SeekBackwardButtonImage, {});
        break;
      case ButtonType.MUTE:
        button = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(MuteButtonImage, {});
        break;
      case ButtonType.UNMUTE:
        button = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(UnMuteButtonImage, {});
        break;
      case ButtonType.ENABLE_LOOP:
        button = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(EnableLoopButtonImage, {});
        break;
      case ButtonType.DISABLE_LOOP:
        button = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(DisableLoopButtonImage, {});
        break;
      case ButtonType.CAPTION_ENABLED:
        button = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(EnableCaptionButtonImage, {});
        break;
      case ButtonType.CAPTION_DISABLED:
        button = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(DisableCaptionButtonImage, {});
        break;
      case ButtonType.CAPTION_NOT_AVAILABLE:
        button = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(CaptionNotAvailableButtonImage, {});
        break;
      case ButtonType.PLAYBACK_SPEED:
        button = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(PlaybackSpeedButtonImage, {
          value: typeof value === 'string' ? value : DEFAULT_PLAYBACK_SPEED
        });
        break;
      default:
        button = null;
    }
    var isPlayPauseButton = buttonType === ButtonType.PLAY || buttonType === ButtonType.PAUSE;
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(react_native_1.TouchableOpacity, Object.assign({
      accessibilityLabel: buttonType,
      accessibilityRole: "button",
      hasTVPreferredFocus: hasTVPreferredFocus,
      ref: ref,
      onFocus: function onFocus() {
        updateColor(styles.pressedColor.color);
      },
      onBlur: function onBlur() {
        updateColor('');
      },
      onPress: function onPress(e) {
        onPressHandler();
        e.stopPropagation();
      },
      onPressIn: function onPressIn() {
        updateColor(styles.pressedColor.color);
      },
      onPressOut: function onPressOut() {
        updateColor('');
      }
    }, rest, {
      activeOpacity: 1,
      children: /*#__PURE__*/_$$_REQUIRE(_dependencyMap[13]).jsx(react_native_1.View, {
        nativeID: "FloatingButtonContainer",
        style: [isPlayPauseButton ? styles.backgroundContainerPlayPause : styles.backgroundContainer, value != null && styles.playbackContainer, {
          backgroundColor: color
        }],
        children: button
      })
    }));
  });
  var styles = react_native_1.StyleSheet.create({
    backgroundContainerPlayPause: {
      width: 230,
      height: 230,
      alignItems: 'center',
      justifyContent: 'center',
      alignContent: 'center',
      borderRadius: 115,
      bottom: 30,
      right: 30
    },
    backgroundContainer: {
      width: 80,
      height: 80,
      alignItems: 'center',
      justifyContent: 'center',
      borderRadius: 40
    },
    playbackContainer: {
      minWidth: 160,
      width: 'auto',
      overflow: 'hidden'
    },
    imageContainer: {
      width: 60,
      height: 60
    },
    playPauseImageContainer: {
      width: 170,
      height: 170
    },
    textButton: {
      fontFamily: DEFAULT_FONT_FAMILY,
      color: 'white',
      fontSize: 50
    },
    pressedColor: {
      color: 'rgba(43, 47, 53, 0.4)'
    }
  });
  exports.default = FloatingButton;
},"7457c7b31ff994f45f69",["6ed0e34da2b23bd3554f","26ef620f86acf7f6932a","dafaa2aa6fccd8593a79","9f5d757f6909ba23689a","1d5fc9c62aafb64b5896","f5d31e94d87fcf776124","b10af95a7d66269521cd","d53240bc78a2556dd3d8","33c292ade263bb29ff84","c722dcfee156ee93fe18","7f1728c84d2b1bab2bdb","84793f08c2bfc6eaf7d1","2e1f4afacbaa5358324c","048fed5a64a04bdb7fed","dd1a5f938f6f03510b39","606f5f734809feae52ba"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/node_modules/@amzn/react-native-w3cmedia/image",
    "width": 96,
    "height": 96,
    "scales": [1],
    "hash": "d6c4e97ec298bf68ebefe461e7cd68f3",
    "name": "ic_caption_greyed",
    "type": "png"
  });
},"dafaa2aa6fccd8593a79",["3e8f526b186b95d97924"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/node_modules/@amzn/react-native-w3cmedia/image",
    "width": 96,
    "height": 96,
    "scales": [1],
    "hash": "8cc24ad84e6092ece4bf13fe1ceddbed",
    "name": "ic_caption_off",
    "type": "png"
  });
},"9f5d757f6909ba23689a",["3e8f526b186b95d97924"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/node_modules/@amzn/react-native-w3cmedia/image",
    "width": 96,
    "height": 96,
    "scales": [1],
    "hash": "4de7e779c356ff09aeb829c9dd1a0154",
    "name": "ic_caption_on",
    "type": "png"
  });
},"1d5fc9c62aafb64b5896",["3e8f526b186b95d97924"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/node_modules/@amzn/react-native-w3cmedia/image",
    "width": 512,
    "height": 512,
    "scales": [1],
    "hash": "cfb99af356efe224c17f0a3d9a49cf5e",
    "name": "ic_disable_loop",
    "type": "png"
  });
},"f5d31e94d87fcf776124",["3e8f526b186b95d97924"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/node_modules/@amzn/react-native-w3cmedia/image",
    "width": 512,
    "height": 512,
    "scales": [1],
    "hash": "095f9df69443de58a9055df9446babea",
    "name": "ic_enable_loop",
    "type": "png"
  });
},"b10af95a7d66269521cd",["3e8f526b186b95d97924"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/node_modules/@amzn/react-native-w3cmedia/image",
    "width": 432,
    "height": 432,
    "scales": [1],
    "hash": "34326d2c8cec2033de89546f625a0ae2",
    "name": "ic_jump_back_10_144dp",
    "type": "png"
  });
},"d53240bc78a2556dd3d8",["3e8f526b186b95d97924"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/node_modules/@amzn/react-native-w3cmedia/image",
    "width": 432,
    "height": 432,
    "scales": [1],
    "hash": "8e65e7db114af8dc24a97fd74a0dd4fc",
    "name": "ic_jump_forward_10_144dp",
    "type": "png"
  });
},"33c292ade263bb29ff84",["3e8f526b186b95d97924"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/node_modules/@amzn/react-native-w3cmedia/image",
    "width": 144,
    "height": 144,
    "scales": [1],
    "hash": "0efe8b750923c1093f4cb7ad5f21c4a0",
    "name": "ic_pause_144dp",
    "type": "png"
  });
},"c722dcfee156ee93fe18",["3e8f526b186b95d97924"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/node_modules/@amzn/react-native-w3cmedia/image",
    "width": 144,
    "height": 144,
    "scales": [1],
    "hash": "56802e108cb33ec805250987f247da52",
    "name": "ic_play_144dp",
    "type": "png"
  });
},"7f1728c84d2b1bab2bdb",["3e8f526b186b95d97924"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/node_modules/@amzn/react-native-w3cmedia/image",
    "width": 227,
    "height": 224,
    "scales": [1],
    "hash": "1405facfb5f4081a8df6b86b0b0f2c42",
    "name": "ic_volume_mute",
    "type": "png"
  });
},"84793f08c2bfc6eaf7d1",["3e8f526b186b95d97924"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/node_modules/@amzn/react-native-w3cmedia/image",
    "width": 227,
    "height": 224,
    "scales": [1],
    "hash": "174baf7d6feb8b8479994539dff468ed",
    "name": "ic_volume_unmute",
    "type": "png"
  });
},"2e1f4afacbaa5358324c",["3e8f526b186b95d97924"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2023 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var React = __importStar(_$$_REQUIRE(_dependencyMap[0]));
  var react_1 = _$$_REQUIRE(_dependencyMap[0]);
  var react_native_1 = _$$_REQUIRE(_dependencyMap[1]);
  var FocusableButton_1 = __importDefault(_$$_REQUIRE(_dependencyMap[2]));
  var FloatingList = (0, react_1.forwardRef)(function (props, ref) {
    var data = props.data,
      defaultValue = props.defaultValue,
      listContainerPositioning = props.listContainerPositioning,
      onPressHandler = props.onPressHandler;
    var _ref = (0, react_1.useState)(defaultValue),
      _ref2 = _$$_REQUIRE(_dependencyMap[3])(_ref, 2),
      selectedId = _ref2[0],
      setSelectedId = _ref2[1];
    var refItems = (0, react_1.useRef)([]);
    refItems.current = data.map(function (_, i) {
      var _refItems$current$i;
      return (_refItems$current$i = refItems.current[i]) != null ? _refItems$current$i : React.createRef();
    });
    (0, react_1.useEffect)(function () {
      refItems.current[0].current.focus();
    }, []);
    var renderItem = function renderItem(_ref3) {
      var item = _ref3.item,
        index = _ref3.index;
      return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[4]).jsx(FocusableButton_1.default, {
        title: item.value,
        ref: refItems.current[index],
        selected: item.id === selectedId,
        onPress: function onPress() {
          setSelectedId(item.id);
          onPressHandler(item.id);
        }
      });
    };
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[4]).jsx(react_native_1.View, {
      style: [listContainerPositioning, styles.container],
      children: /*#__PURE__*/_$$_REQUIRE(_dependencyMap[4]).jsx(react_native_1.FlatList, {
        ref: ref,
        hasTVPreferredFocus: true,
        data: data,
        renderItem: renderItem,
        keyExtractor: function keyExtractor(item) {
          return item.id;
        },
        extraData: selectedId
      })
    });
  });
  var styles = react_native_1.StyleSheet.create({
    container: {
      borderRadius: 10,
      overflow: 'hidden',
      zIndex: 3
    }
  });
  exports.default = FloatingList;
},"e62e4e3e2fb194312203",["6ed0e34da2b23bd3554f","26ef620f86acf7f6932a","3ef0a7e415136a8069aa","606f5f734809feae52ba","048fed5a64a04bdb7fed"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /*
   * Copyright 2023 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  var react_1 = __importStar(_$$_REQUIRE(_dependencyMap[0]));
  var react_native_1 = _$$_REQUIRE(_dependencyMap[1]);
  var DEFAULT_FONT_FAMILY = 'Amazon-Ember-Regular';
  var DEFAULT_STYLE = react_native_1.StyleSheet.create({
    BUTTON: {
      minWidth: 140,
      backgroundColor: '#7F7F7F',
      paddingVertical: 10,
      paddingLeft: 10,
      paddingRight: 50,
      justifyContent: 'center'
    },
    BUTTON_FOCUSED: {
      backgroundColor: '#2B2F35'
    },
    TITLE: {
      color: 'black',
      fontFamily: DEFAULT_FONT_FAMILY,
      fontSize: 20
    },
    TITLE_SELECTED: {
      fontWeight: 'bold',
      fontSize: 23
    }
  });
  var FocusableButton = (0, react_1.forwardRef)(function (props, ref) {
    var _ref = (0, react_1.useState)(false),
      _ref2 = _$$_REQUIRE(_dependencyMap[2])(_ref, 2),
      focused = _ref2[0],
      setFocused = _ref2[1];
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[3]).jsx(react_native_1.TouchableOpacity, Object.assign({}, props, {
      ref: ref
      // @ts-ignore
      ,
      focusable: true,
      onPress: function onPress() {
        if (props.onPress) {
          props == null ? undefined : props.onPress();
        }
      },
      onFocus: function onFocus() {
        setFocused(true);
      },
      onBlur: function onBlur() {
        setFocused(false);
      },
      hasTVPreferredFocus: props.hasTVPreferredFocus,
      style: [DEFAULT_STYLE.BUTTON, focused && DEFAULT_STYLE.BUTTON_FOCUSED],
      activeOpacity: 1,
      children: /*#__PURE__*/_$$_REQUIRE(_dependencyMap[3]).jsx(react_native_1.Text, {
        style: [DEFAULT_STYLE.TITLE, props.selected && DEFAULT_STYLE.TITLE_SELECTED],
        children: props.title
      })
    }));
  });
  exports.default = FocusableButton;
},"3ef0a7e415136a8069aa",["6ed0e34da2b23bd3554f","26ef620f86acf7f6932a","606f5f734809feae52ba","048fed5a64a04bdb7fed"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright (c) 2024 Amazon.com, Inc. or its affiliates.  All rights reserved.
   *
   * PROPRIETARY/CONFIDENTIAL.  USE IS SUBJECT TO LICENSE TERMS.
   */
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  //Referenced {SeekBar,ProgressBar} folder from  - https://tiny.amazon.com/10ftogofw/KeplerComponentLibrary
  var react_1 = __importStar(_$$_REQUIRE(_dependencyMap[0]));
  var react_native_1 = _$$_REQUIRE(_dependencyMap[1]);
  var ProgressBar_1 = __importDefault(_$$_REQUIRE(_dependencyMap[2]));
  /**
   * Renders a Slider component specific to the SeekBar, that allows users to
   * track and control the Slider value by interacting with the Slider's thumb.
   *
   * @returns Slider component
   */
  var Slider = function Slider(_ref) {
    var _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === undefined ? false : _ref$disabled,
      currentValue = _ref.currentValue,
      totalValue = _ref.totalValue,
      onValueChange = _ref.onValueChange,
      onSlidingStart = _ref.onSlidingStart,
      onSlidingEnd = _ref.onSlidingEnd,
      onRewindPress = _ref.onRewindPress,
      onFastForwardPress = _ref.onFastForwardPress,
      _onFocus = _ref.onFocus,
      _onBlur = _ref.onBlur,
      onPress = _ref.onPress,
      step = _ref.step,
      markers = _ref.markers,
      displayAboveThumb = _ref.displayAboveThumb,
      displayBelowThumb = _ref.displayBelowThumb,
      thumbIcon = _ref.thumbIcon,
      barStyle = _ref.barStyle,
      barTrackColor = _ref.barTrackColor,
      currentValueIndicatorColor = _ref.currentValueIndicatorColor,
      currentValueIndicatorStyle = _ref.currentValueIndicatorStyle,
      timeShiftIndicatorStyleOverride = _ref.timeShiftIndicatorStyle,
      longPressIntervalDuration = _ref.longPressIntervalDuration;
    var thumbContainerStyle = (0, _$$_REQUIRE(_dependencyMap[3]).resolveThumbContainerTokens)();
    var timeShiftIndicatorStyle = (0, _$$_REQUIRE(_dependencyMap[3]).resolveTimeShiftIndicatorTokens)();
    var centeredNodeStyle = (0, _$$_REQUIRE(_dependencyMap[3]).resolveCenteredNodeTokens)();
    var barContainerStyle = (0, _$$_REQUIRE(_dependencyMap[3]).resolveBarContainerTokens)();
    var markerStyle = (0, _$$_REQUIRE(_dependencyMap[3]).resolveMarkerTokens)();
    var progressBarStyle = (0, _$$_REQUIRE(_dependencyMap[3]).resolveProgressBarTokens)();
    var keyPressTimeout = (0, react_1.useRef)(0);
    var longPressInterval = (0, react_1.useRef)(0);
    var _ref2 = (0, react_1.useState)(currentValue),
      _ref3 = _$$_REQUIRE(_dependencyMap[4])(_ref2, 2),
      thumbValue = _ref3[0],
      setThumbValue = _ref3[1];
    var _ref4 = (0, react_1.useState)(0),
      _ref5 = _$$_REQUIRE(_dependencyMap[4])(_ref4, 2),
      barWidth = _ref5[0],
      setBarWidth = _ref5[1];
    var _ref6 = (0, react_1.useState)(0),
      _ref7 = _$$_REQUIRE(_dependencyMap[4])(_ref6, 2),
      barHeight = _ref7[0],
      setBarHeight = _ref7[1];
    var _ref8 = (0, react_1.useState)(false),
      _ref9 = _$$_REQUIRE(_dependencyMap[4])(_ref8, 2),
      focused = _ref9[0],
      setFocused = _ref9[1];
    var translateXVal = (0, react_1.useRef)(new react_native_1.Animated.Value(0));
    var DEFAULT_LONG_PRESS_INITIAL_DELAY = 1500;
    var DEFAULT_LONG_PRESS_INTERVAL_DURATION = 300;
    var DEFAULT_STEP = 10000;
    var stepValue = (0, react_1.useRef)(step === 0 ? 0 : step || DEFAULT_STEP);
    var keyIsHeld = react_1.default.useRef(false);
    var onPressHandler = function onPressHandler() {
      resetKeyPressDependencies();
      onPress == null ? undefined : onPress(thumbValue);
    };
    var handleKeyPress = function handleKeyPress(key) {
      if (stepValue.current === 0) {
        return;
      }
      var adjustedStep = key === 'left' ? -stepValue.current : stepValue.current;
      setThumbValue(function (previousThumbValue) {
        var thumbValue = previousThumbValue;
        if (previousThumbValue + adjustedStep < 0) {
          thumbValue = 0;
        } else if (previousThumbValue + adjustedStep > totalValue) {
          thumbValue = totalValue;
        } else {
          thumbValue = previousThumbValue + adjustedStep;
        }
        translateXVal.current = new react_native_1.Animated.Value(normalizeToXPosition(thumbValue, totalValue, barWidth));
        return thumbValue;
      });
    };
    var handleLongPress = function handleLongPress(key) {
      clearInterval(longPressInterval.current);
      // @ts-ignore
      longPressInterval.current = setInterval(function () {
        handleKeyPress(key);
      }, longPressIntervalDuration || DEFAULT_LONG_PRESS_INTERVAL_DURATION);
    };
    var resetKeyPressDependencies = function resetKeyPressDependencies() {
      clearInterval(longPressInterval.current);
      clearTimeout(keyPressTimeout.current);
    };
    (0, _$$_REQUIRE(_dependencyMap[5]).useTVEventHandler)(function (_ref10) {
      var eventType = _ref10.eventType,
        eventKeyAction = _ref10.eventKeyAction;
      if (disabled) {
        resetKeyPressDependencies();
        return;
      }
      if (eventKeyAction === 1) {
        keyIsHeld.current = false;
      }
      if (focused && (eventType === "left" || eventType === "right")) {
        if (eventKeyAction === 1) {
          onSlidingEnd == null ? undefined : onSlidingEnd();
          resetKeyPressDependencies();
          return;
        }
        if (eventKeyAction !== 0 || keyIsHeld.current) return;
        resetKeyPressDependencies();
        onSlidingStart == null ? undefined : onSlidingStart();
        handleKeyPress(eventType);
        // @ts-ignore
        keyPressTimeout.current = setTimeout(function () {
          handleLongPress(eventType);
        }, DEFAULT_LONG_PRESS_INITIAL_DELAY);
        keyIsHeld.current = true;
      }
    });
    (0, react_1.useEffect)(function () {
      if (step === 0) {
        stepValue.current = 0;
      } else {
        stepValue.current = step || DEFAULT_STEP;
      }
    }, [step]);
    (0, react_1.useEffect)(function () {
      onValueChange == null ? undefined : onValueChange(thumbValue);
    }, [thumbValue]);
    (0, react_1.useEffect)(function () {
      if (currentValue !== undefined) {
        setThumbValue(currentValue);
        translateXVal.current = new react_native_1.Animated.Value(normalizeToXPosition(currentValue, totalValue, barWidth));
      }
    }, [currentValue]);
    (0, react_1.useEffect)(function () {
      return function () {
        resetKeyPressDependencies();
        keyIsHeld.current = false;
      };
    }, []);
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[6]).jsxs(react_native_1.Pressable, {
      onFocus: function onFocus() {
        _onFocus == null ? undefined : _onFocus();
        setFocused(true);
      },
      onBlur: function onBlur() {
        _onBlur == null ? undefined : _onBlur();
        setFocused(false);
      },
      onPress: onPressHandler,
      disabled: disabled,
      children: [/*#__PURE__*/_$$_REQUIRE(_dependencyMap[6]).jsx(react_native_1.Animated.View, {
        style: [centeredNodeStyle, {
          opacity: barWidth !== 0 ? 1 : 0,
          transform: [{
            translateX: translateXVal.current
          }]
        }],
        children: displayAboveThumb
      }), /*#__PURE__*/_$$_REQUIRE(_dependencyMap[6]).jsxs(react_native_1.View, {
        style: barContainerStyle,
        children: [/*#__PURE__*/_$$_REQUIRE(_dependencyMap[6]).jsxs(react_native_1.View, {
          onLayout: function onLayout(_ref11) {
            var nativeEvent = _ref11.nativeEvent;
            var _nativeEvent$layout = nativeEvent.layout,
              width = _nativeEvent$layout.width,
              height = _nativeEvent$layout.height;
            setBarWidth(width);
            setBarHeight(height);
            translateXVal.current = new react_native_1.Animated.Value(normalizeToXPosition(currentValue, totalValue, width));
          },
          style: progressBarStyle,
          children: [/*#__PURE__*/_$$_REQUIRE(_dependencyMap[6]).jsx(ProgressBar_1.default, {
            barStyle: [{
              width: 1850
            }, barStyle],
            progress: currentValue / totalValue * 100,
            animationDuration: 0,
            indicatorStyle: currentValueIndicatorStyle,
            indicatorColor: currentValueIndicatorColor,
            trackColor: barTrackColor
          }), /*#__PURE__*/_$$_REQUIRE(_dependencyMap[6]).jsx(react_native_1.Animated.View, {
            style: [timeShiftIndicatorStyle, timeShiftIndicatorStyleOverride, {
              height: barHeight,
              width: Math.abs(normalizeToXPosition(thumbValue, totalValue, barWidth) - normalizeToXPosition(currentValue, totalValue, barWidth))
            }, {
              transform: [{
                translateX: thumbValue >= currentValue ? normalizeToXPosition(currentValue, totalValue, barWidth) : normalizeToXPosition(thumbValue, totalValue, barWidth)
              }]
            }]
          })]
        }), barWidth !== 0 && markers !== undefined && markers.map(function (marker) {
          return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[6]).jsx(react_native_1.View, {
            style: [markerStyle, {
              height: barHeight,
              transform: [{
                translateX: marker.position / totalValue * barWidth
              }]
            }],
            children: marker.node
          }, marker.position);
        }), focused ? /*#__PURE__*/_$$_REQUIRE(_dependencyMap[6]).jsx(react_native_1.Animated.View, {
          style: [centeredNodeStyle, thumbContainerStyle, {
            opacity: barWidth === 0 ? 0 : 1,
            transform: [{
              translateX: translateXVal.current
            }]
          }],
          children: thumbIcon !== undefined ? thumbIcon : /*#__PURE__*/_$$_REQUIRE(_dependencyMap[6]).jsx(DefaultThumbIcon, {})
        }) : null]
      }), /*#__PURE__*/_$$_REQUIRE(_dependencyMap[6]).jsx(react_native_1.Animated.View, {
        style: [centeredNodeStyle, {
          opacity: barWidth !== 0 ? 1 : 0,
          transform: [{
            translateX: translateXVal.current
          }]
        }],
        children: displayBelowThumb
      })]
    });
  };
  var DefaultThumbIcon = function DefaultThumbIcon() {
    var thumbDotStyle = (0, _$$_REQUIRE(_dependencyMap[3]).resolveThumbDotTokens)();
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[6]).jsx(react_native_1.View, {
      style: thumbDotStyle
    });
  };
  var normalizeToXPosition = function normalizeToXPosition(value, totalValue, barWidth) {
    return value / totalValue * barWidth;
  };
  exports.default = Slider;
},"364e6b4f12b4528f3c20",["6ed0e34da2b23bd3554f","26ef620f86acf7f6932a","3bfb8bb5f955de0b2a20","685d7651d9bee93d2af6","606f5f734809feae52ba","26ef620f86acf7f6932a","048fed5a64a04bdb7fed"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright (c) 2024 Amazon.com, Inc. or its affiliates.  All rights reserved.
   *
   * PROPRIETARY/CONFIDENTIAL.  USE IS SUBJECT TO LICENSE TERMS.
   */
  var _excluded = ["progress", "animationDuration", "indicatorColor", "trackColor", "size", "barStyle", "indicatorStyle"];
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  //Referenced {SeekBar,ProgressBar} folder from  - https://tiny.amazon.com/10ftogofw/KeplerComponentLibrary
  // @ts-nocheck
  var react_1 = __importStar(_$$_REQUIRE(_dependencyMap[0]));
  var react_native_1 = _$$_REQUIRE(_dependencyMap[1]);
  /**
   * ProgressBar is a component that visualizes the status and progress of a given task.
   * If the progress is not specified or cannot be determined, an indeterminate indicator is shown.
   *
   * @returns ProgressBar component
   */
  var ProgressBar = function ProgressBar(_ref) {
    var progress = _ref.progress,
      animationDuration = _ref.animationDuration,
      indicatorColor = _ref.indicatorColor,
      trackColor = _ref.trackColor,
      _ref$size = _ref.size,
      size = _ref$size === undefined ? 'md' : _ref$size,
      barStyle = _ref.barStyle,
      indicatorStyle = _ref.indicatorStyle,
      rest = _$$_REQUIRE(_dependencyMap[2])(_ref, _excluded);
    var theme = (0, _$$_REQUIRE(_dependencyMap[3]).useTheme)();
    var animatedProgress = (0, react_1.useRef)(new react_native_1.Animated.Value(progress || 0)).current;
    var _ref2 = (0, react_1.useState)(0),
      _ref3 = _$$_REQUIRE(_dependencyMap[4])(_ref2, 2),
      barWidth = _ref3[0],
      setBarWidth = _ref3[1];
    var isIndeterminate = progress === undefined;
    var accessibilityRole = 'progressbar';
    var accessibilityValue = isIndeterminate ? {
      text: `Progress is indeterminate.`
    } : {
      text: `Current progress is, ${Math.round(progress)} percent.`
    };
    var trackTokenStyle = (0, _$$_REQUIRE(_dependencyMap[5]).resolveTrackTokens)({
      tokens: theme.progressBar,
      size: size,
      trackColor: trackColor
    });
    var indicatorTokenStyle = (0, _$$_REQUIRE(_dependencyMap[5]).resolveIndicatorTokens)({
      tokens: theme.progressBar,
      size: size,
      indicatorColor: indicatorColor
    });
    var resolvedIndicatorAnimationDuration = (0, _$$_REQUIRE(_dependencyMap[5]).resolveIndicatorAnimationDuration)({
      isIndeterminate: isIndeterminate,
      tokens: theme.progressBar,
      animationDuration: animationDuration
    });
    var progressedWidth = animatedProgress.interpolate({
      inputRange: [0, 100],
      outputRange: ['0%', '100%'],
      extrapolate: 'clamp'
    });
    var indeterminateIndicatorSizeRatio = 0.5;
    var indeterminateIndicatorTranslateX = (0, react_1.useRef)(new react_native_1.Animated.Value(-(barWidth * indeterminateIndicatorSizeRatio))).current;
    (0, react_1.useEffect)(function () {
      if (!isIndeterminate) {
        react_native_1.Animated.timing(animatedProgress, {
          toValue: progress,
          duration: resolvedIndicatorAnimationDuration,
          useNativeDriver: false
        }).start();
      }
    }, [progress, isIndeterminate]);
    (0, react_1.useEffect)(function () {
      if (isIndeterminate && barWidth != 0) {
        indeterminateIndicatorTranslateX.setValue(-(barWidth * indeterminateIndicatorSizeRatio));
        react_native_1.Animated.loop(react_native_1.Animated.timing(indeterminateIndicatorTranslateX, {
          toValue: barWidth,
          duration: resolvedIndicatorAnimationDuration,
          easing: react_native_1.Easing.linear,
          useNativeDriver: true
        })).start();
      }
    }, [barWidth, isIndeterminate]);
    var initializeBarLayout = function initializeBarLayout(event) {
      var width = event.nativeEvent.layout.width;
      setBarWidth(width);
    };
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[6]).jsx(react_native_1.View, Object.assign({
      onLayout: initializeBarLayout,
      accessibilityRole: accessibilityRole,
      accessibilityValue: accessibilityValue,
      style: [defaultBarStyle.trackAlignment, trackTokenStyle, barStyle]
    }, rest, {
      children: isIndeterminate ? /*#__PURE__*/_$$_REQUIRE(_dependencyMap[6]).jsx(_$$_REQUIRE(_dependencyMap[7]).IndeterminateIndicator, {
        width: barWidth,
        sizeRatio: indeterminateIndicatorSizeRatio,
        position: indeterminateIndicatorTranslateX,
        tokenStyle: indicatorTokenStyle,
        style: indicatorStyle
      }) : /*#__PURE__*/_$$_REQUIRE(_dependencyMap[6]).jsx(_$$_REQUIRE(_dependencyMap[7]).DeterminateIndicator, {
        progressedWidth: progressedWidth,
        tokenStyle: indicatorTokenStyle,
        style: indicatorStyle
      })
    }));
  };
  var defaultBarStyle = react_native_1.StyleSheet.create({
    trackAlignment: {
      justifyContent: 'flex-start'
    }
  });
  exports.default = ProgressBar;
},"3bfb8bb5f955de0b2a20",["6ed0e34da2b23bd3554f","26ef620f86acf7f6932a","dd1a5f938f6f03510b39","58d20fa48c4d540088f0","606f5f734809feae52ba","b759e9cbd67ab0135cb6","048fed5a64a04bdb7fed","4bdad087eb179ee38036"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright (c) 2022 - 2024 Amazon.com, Inc. or its affiliates.  All rights reserved.
   *
   * PROPRIETARY/CONFIDENTIAL.  USE IS SUBJECT TO LICENSE TERMS.
   */
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useTheme = exports.ThemeContext = exports.defaultContext = exports.getDefaultTheme = exports.defaultThemes = undefined;
  //Referenced {SeekBar,ProgressBar} folder from  - https://tiny.amazon.com/10ftogofw/KeplerComponentLibrary
  var react_1 = __importStar(_$$_REQUIRE(_dependencyMap[0]));
  var makeTheme = function makeTheme(type) {
    return {
      progressBar: (0, _$$_REQUIRE(_dependencyMap[1]).progressBarTokens)(type)
    };
  };
  exports.defaultThemes = {
    light: makeTheme('light'),
    dark: makeTheme('dark')
  };
  var getDefaultTheme = function getDefaultTheme() {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'dark';
    return exports.defaultThemes[type];
  };
  exports.getDefaultTheme = getDefaultTheme;
  exports.defaultContext = {
    theme: (0, exports.getDefaultTheme)(),
    setTheme: function setTheme() {
      _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('[Theming] setTheme() is not implemented');
    }
  };
  exports.ThemeContext = react_1.default.createContext(exports.defaultContext);
  /**
   *
   * The `useTheme` hook returns the current theme. If the theme is not set, or
   * useTheme is called outside the context of the ThemeProvider the default theme
   * will be returned. The theme can also be set using the `setTheme` function
   * provided by the {@link useSetTheme `useSetTheme`} hook.
   * @returns theme
   */
  var useTheme = function useTheme() {
    var theme = (0, react_1.useContext)(exports.ThemeContext).theme;
    if (!theme) {
      return (0, exports.getDefaultTheme)();
    }
    return theme;
  };
  exports.useTheme = useTheme;
},"58d20fa48c4d540088f0",["6ed0e34da2b23bd3554f","722f5144ccc57c352fae","1f12e7e43345228dfcad"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright (c) 2024 Amazon.com, Inc. or its affiliates.  All rights reserved.
   *
   * PROPRIETARY/CONFIDENTIAL.  USE IS SUBJECT TO LICENSE TERMS.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.progressBarTokens = undefined;
  var progressBarTokens = function progressBarTokens(type) {
    return {
      track: {
        color: {
          backgroundColor: _$$_REQUIRE(_dependencyMap[0]).base[type].color.gray[200]
        },
        size: {
          borderRadius: {
            xs: 8,
            sm: 8,
            md: 10,
            lg: 12,
            xl: 14
          },
          height: {
            xs: 8,
            sm: 8,
            md: 10,
            lg: 12,
            xl: 14
          },
          width: {
            xs: 350,
            sm: 556,
            md: 700,
            lg: 800,
            xl: 1000
          }
        }
      },
      indicator: {
        color: {
          backgroundColor: _$$_REQUIRE(_dependencyMap[0]).base[type].color.gray[600]
        },
        size: {
          borderRadius: {
            xs: 8,
            sm: 8,
            md: 10,
            lg: 12,
            xl: 14
          },
          width: {
            indeterminate: 70
          }
        },
        motion: {
          duration: {
            determinate: 250,
            indeterminate: 1000
          }
        }
      },
      buffer: {
        color: {
          backgroundColor: _$$_REQUIRE(_dependencyMap[0]).base[type].color.gray[400]
        },
        size: {
          borderRadius: {
            xs: 8,
            sm: 8,
            md: 10,
            lg: 12,
            xl: 14
          }
        }
      },
      thumb: {
        color: {
          backgroundColor: {
            enabled: _$$_REQUIRE(_dependencyMap[0]).base[type].color.white,
            disabled: _$$_REQUIRE(_dependencyMap[0]).base[type].color.gray[200]
          }
        },
        size: {
          xs: 12,
          sm: 18,
          md: 24,
          lg: 36,
          xl: 48,
          opacity: {
            disabled: 1
          }
        }
      }
    };
  };
  exports.progressBarTokens = progressBarTokens;
},"722f5144ccc57c352fae",["2569b1917a06e622bc66"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright (c) 2024 Amazon.com, Inc. or its affiliates.  All rights reserved.
   *
   * PROPRIETARY/CONFIDENTIAL.  USE IS SUBJECT TO LICENSE TERMS.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.base = exports.baseTokensDark = exports.baseTokensLight = exports.baseColorTokensDark = exports.baseColorTokensLight = exports.baseSizes = undefined;
  exports.baseSizes = {
    minimumTouchArea: 18,
    spacing: {
      xxs: 2,
      xs: 4,
      sm: 8,
      md: 12,
      lg: 16,
      xl: 20,
      xxl: 24
    }
  };
  exports.baseColorTokensLight = {
    black: '#000000',
    white: '#FFFFFF',
    shadow: '#000000',
    gray: {
      100: '#F4F4F5',
      200: '#E1E1E2',
      300: '#D0D0D4',
      400: '#A1A1AA',
      500: '#7A7A83',
      600: '#52525B',
      700: '#3F3F46',
      800: '#27272A',
      900: '#202024'
    },
    red: {
      100: '#F5BDB9',
      200: '#F19D97',
      300: '#EA7168',
      400: '#E6554A',
      500: '#E02B1D',
      600: '#CC271A',
      700: '#9F1F15',
      800: '#7B1810',
      900: '#5E120C'
    },
    darkgray: {
      100: '#BEBFC0',
      200: '#9EA0A2',
      300: '#727477',
      400: '#57595D',
      500: '#2D3034',
      600: '#292C2F',
      700: '#202225',
      800: '#191A1D',
      900: '#131416'
    },
    lightgray: {
      100: '#F9F9F9',
      200: '#F2F2F2',
      300: '#ECECEC',
      400: '#E5E5E6',
      500: '#DFDFE0',
      600: '#D8D9D9',
      700: '#D2D2D3',
      800: '#CBCCCD',
      900: '#C5C5C6'
    }
  };
  exports.baseColorTokensDark = {
    black: '#000000',
    white: '#FFFFFF',
    shadow: '#000000',
    gray: {
      100: '#333333',
      200: '#3D3D3D',
      300: '#5F5F5F',
      400: '#747474',
      500: '#878787',
      600: '#9B9B9B',
      700: '#B9B9B9',
      800: '#D7D7D7',
      900: '#EFEFEF'
    },
    red: {
      100: '#F5BDB9',
      200: '#F19D97',
      300: '#EA7168',
      400: '#E6554A',
      500: '#E02B1D',
      600: '#CC271A',
      700: '#9F1F15',
      800: '#7B1810',
      900: '#5E120C'
    },
    darkgray: {
      100: '#BEBFC0',
      200: '#9EA0A2',
      300: '#727477',
      400: '#57595D',
      500: '#2D3034',
      600: '#292C2F',
      700: '#202225',
      800: '#191A1D',
      900: '#131416'
    },
    lightgray: {
      100: '#F9F9F9',
      200: '#F2F2F2',
      300: '#ECECEC',
      400: '#E5E5E6',
      500: '#DFDFE0',
      600: '#D8D9D9',
      700: '#D2D2D3',
      800: '#CBCCCD',
      900: '#C5C5C6'
    }
  };
  exports.baseTokensLight = {
    size: exports.baseSizes,
    color: exports.baseColorTokensLight
  };
  exports.baseTokensDark = {
    size: exports.baseSizes,
    color: exports.baseColorTokensDark
  };
  exports.base = {
    light: exports.baseTokensLight,
    dark: exports.baseTokensDark
  };
},"2569b1917a06e622bc66",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright (c) 2024 Amazon.com, Inc. or its affiliates.  All rights reserved.
   *
   * PROPRIETARY/CONFIDENTIAL.  USE IS SUBJECT TO LICENSE TERMS.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.resolveIndicatorAnimationDuration = exports.resolveIndicatorTokens = exports.resolveTrackTokens = undefined;
  var resolveTrackTokens = function resolveTrackTokens(_ref) {
    var _tokens$track, _tokens$track$size, _tokens$track$size$bo, _tokens$track2, _tokens$track2$size, _tokens$track2$size$h, _tokens$track3, _tokens$track3$size, _tokens$track3$size$w, _tokens$track4, _tokens$track4$color;
    var tokens = _ref.tokens,
      size = _ref.size,
      trackColor = _ref.trackColor;
    if (!tokens) {
      return undefined;
    }
    var borderRadius = (_tokens$track = tokens.track) == null ? undefined : (_tokens$track$size = _tokens$track.size) == null ? undefined : (_tokens$track$size$bo = _tokens$track$size.borderRadius) == null ? undefined : _tokens$track$size$bo[size];
    var height = (_tokens$track2 = tokens.track) == null ? undefined : (_tokens$track2$size = _tokens$track2.size) == null ? undefined : (_tokens$track2$size$h = _tokens$track2$size.height) == null ? undefined : _tokens$track2$size$h[size];
    var width = (_tokens$track3 = tokens.track) == null ? undefined : (_tokens$track3$size = _tokens$track3.size) == null ? undefined : (_tokens$track3$size$w = _tokens$track3$size.width) == null ? undefined : _tokens$track3$size$w[size];
    var backgroundColor = trackColor || ((_tokens$track4 = tokens.track) == null ? undefined : (_tokens$track4$color = _tokens$track4.color) == null ? undefined : _tokens$track4$color.backgroundColor);
    return {
      borderRadius: borderRadius,
      height: height,
      width: width,
      backgroundColor: backgroundColor,
      flexDirection: 'row',
      overflow: 'hidden'
    };
  };
  exports.resolveTrackTokens = resolveTrackTokens;
  var resolveIndicatorTokens = function resolveIndicatorTokens(_ref2) {
    var _tokens$indicator, _tokens$indicator$siz, _tokens$indicator$siz2, _tokens$indicator2, _tokens$indicator2$co;
    var tokens = _ref2.tokens,
      size = _ref2.size,
      indicatorColor = _ref2.indicatorColor;
    if (!tokens) {
      return undefined;
    }
    var borderRadius = (_tokens$indicator = tokens.indicator) == null ? undefined : (_tokens$indicator$siz = _tokens$indicator.size) == null ? undefined : (_tokens$indicator$siz2 = _tokens$indicator$siz.borderRadius) == null ? undefined : _tokens$indicator$siz2[size];
    var backgroundColor = indicatorColor || ((_tokens$indicator2 = tokens.indicator) == null ? undefined : (_tokens$indicator2$co = _tokens$indicator2.color) == null ? undefined : _tokens$indicator2$co.backgroundColor);
    return {
      borderRadius: borderRadius,
      backgroundColor: backgroundColor
    };
  };
  exports.resolveIndicatorTokens = resolveIndicatorTokens;
  var resolveIndicatorAnimationDuration = function resolveIndicatorAnimationDuration(_ref3) {
    var _tokens$indicator3, _tokens$indicator3$mo, _tokens$indicator3$mo2, _tokens$indicator4, _tokens$indicator4$mo, _tokens$indicator4$mo2;
    var isIndeterminate = _ref3.isIndeterminate,
      tokens = _ref3.tokens,
      animationDuration = _ref3.animationDuration;
    var determinateDurationToken = tokens == null ? undefined : (_tokens$indicator3 = tokens.indicator) == null ? undefined : (_tokens$indicator3$mo = _tokens$indicator3.motion) == null ? undefined : (_tokens$indicator3$mo2 = _tokens$indicator3$mo.duration) == null ? undefined : _tokens$indicator3$mo2.determinate;
    var indeterminateDurationToken = tokens == null ? undefined : (_tokens$indicator4 = tokens.indicator) == null ? undefined : (_tokens$indicator4$mo = _tokens$indicator4.motion) == null ? undefined : (_tokens$indicator4$mo2 = _tokens$indicator4$mo.duration) == null ? undefined : _tokens$indicator4$mo2.indeterminate;
    if (animationDuration === 0) {
      return 0;
    } else if (!isIndeterminate) {
      return animationDuration || determinateDurationToken || 250;
    } else if (isIndeterminate) {
      return animationDuration || indeterminateDurationToken || 1000;
    }
    return false;
  };
  exports.resolveIndicatorAnimationDuration = resolveIndicatorAnimationDuration;
},"b759e9cbd67ab0135cb6",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright (c) 2024 Amazon.com, Inc. or its affiliates.  All rights reserved.
   *
   * PROPRIETARY/CONFIDENTIAL.  USE IS SUBJECT TO LICENSE TERMS.
   */
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.IndeterminateIndicator = exports.DeterminateIndicator = undefined;
  //Referenced {SeekBar,ProgressBar} folder from  - https://tiny.amazon.com/10ftogofw/KeplerComponentLibrary
  var react_1 = __importDefault(_$$_REQUIRE(_dependencyMap[0]));
  var react_native_1 = _$$_REQUIRE(_dependencyMap[1]);
  var DeterminateIndicator = function DeterminateIndicator(_ref) {
    var progressedWidth = _ref.progressedWidth,
      tokenStyle = _ref.tokenStyle,
      style = _ref.style;
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[2]).jsx(react_native_1.Animated.View, {
      style: [tokenStyle, style, {
        width: progressedWidth
      }]
    });
  };
  exports.DeterminateIndicator = DeterminateIndicator;
  var IndeterminateIndicator = function IndeterminateIndicator(_ref2) {
    var width = _ref2.width,
      sizeRatio = _ref2.sizeRatio,
      position = _ref2.position,
      tokenStyle = _ref2.tokenStyle,
      style = _ref2.style;
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[2]).jsx(react_native_1.Animated.View, {
      style: [tokenStyle, style, {
        width: width * sizeRatio,
        transform: [{
          translateX: position
        }]
      }]
    });
  };
  exports.IndeterminateIndicator = IndeterminateIndicator;
},"4bdad087eb179ee38036",["6ed0e34da2b23bd3554f","26ef620f86acf7f6932a","048fed5a64a04bdb7fed"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright (c) 2024 Amazon.com, Inc. or its affiliates.  All rights reserved.
   *
   * PROPRIETARY/CONFIDENTIAL.  USE IS SUBJECT TO LICENSE TERMS.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.resolveProgressBarTokens = exports.resolveMarkerTokens = exports.resolveCenteredNodeTokens = exports.resolveTimeShiftIndicatorTokens = exports.resolveBarContainerTokens = exports.resolveThumbDotTokens = exports.resolveThumbContainerTokens = exports.thumbRippleRadius = exports.thumbRippleSize = undefined;
  exports.thumbRippleSize = 80;
  exports.thumbRippleRadius = exports.thumbRippleSize / 2;
  var thumbSize = 24;
  var thumbColor = 'red';
  var resolveThumbContainerTokens = function resolveThumbContainerTokens() {
    return {
      zIndex: 1,
      position: 'absolute',
      width: 1850,
      alignItems: 'flex-start',
      marginLeft: 16
    };
  };
  exports.resolveThumbContainerTokens = resolveThumbContainerTokens;
  var resolveThumbDotTokens = function resolveThumbDotTokens() {
    return {
      width: thumbSize,
      height: thumbSize,
      borderRadius: 12,
      position: 'absolute',
      backgroundColor: thumbColor,
      opacity: 1.0,
      shadowColor: '#00000035',
      shadowOffset: {
        width: 0,
        height: 0
      },
      shadowRadius: 6
    };
  };
  exports.resolveThumbDotTokens = resolveThumbDotTokens;
  var resolveBarContainerTokens = function resolveBarContainerTokens() {
    return {
      width: 1920,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-start',
      paddingLeft: 32
    };
  };
  exports.resolveBarContainerTokens = resolveBarContainerTokens;
  var resolveTimeShiftIndicatorTokens = function resolveTimeShiftIndicatorTokens() {
    return {
      position: 'absolute',
      backgroundColor: '#808080',
      width: 1850,
      justifyContent: 'center'
    };
  };
  exports.resolveTimeShiftIndicatorTokens = resolveTimeShiftIndicatorTokens;
  var resolveCenteredNodeTokens = function resolveCenteredNodeTokens() {
    return {
      width: 0,
      justifyContent: 'center',
      alignItems: 'center'
    };
  };
  exports.resolveCenteredNodeTokens = resolveCenteredNodeTokens;
  var resolveMarkerTokens = function resolveMarkerTokens() {
    return {
      zIndex: 1,
      position: 'absolute',
      overflow: 'visible',
      width: 1850
    };
  };
  exports.resolveMarkerTokens = resolveMarkerTokens;
  var resolveProgressBarTokens = function resolveProgressBarTokens() {
    return {
      width: 1850,
      flexDirection: "row",
      alignItems: "center",
      justifyContent: 'flex-start'
    };
  };
  exports.resolveProgressBarTokens = resolveProgressBarTokens;
},"685d7651d9bee93d2af6",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var react_1 = __importDefault(_$$_REQUIRE(_dependencyMap[0]));
  var react_2 = _$$_REQUIRE(_dependencyMap[0]);
  var react_native_1 = _$$_REQUIRE(_dependencyMap[1]);
  var styles = react_native_1.StyleSheet.create({
    seekContainer: {
      width: '100%',
      bottom: 25,
      position: 'absolute',
      flexDirection: 'row',
      justifyContent: 'space-between',
      paddingLeft: "2%",
      paddingRight: "2%"
    },
    seekValue: {
      padding: 10,
      color: '#fafafa',
      fontSize: 20,
      fontWeight: '500',
      backgroundColor: 'rgba(33, 33, 33, 0.23)',
      borderRadius: 5,
      fontFamily: 'Amazon Ember Display'
    },
    liveValue: {
      padding: 10,
      color: '#fafafa',
      fontSize: 20,
      fontWeight: '500',
      backgroundColor: 'rgba(33, 33, 33, 0.23)',
      borderRadius: 5,
      fontFamily: 'Amazon Ember Display'
    }
  });
  var formatTime = function formatTime(milliseconds) {
    var totalSeconds = Math.floor(milliseconds / 1000);
    var hours = Math.floor(totalSeconds / 3600);
    var minutes = Math.floor(totalSeconds % 3600 / 60).toString().padStart(2, '0');
    var seconds = (totalSeconds % 60).toString().padStart(2, '0');
    var hoursComponent = hours.toString().padStart(2, '0');
    return hours > 0 ? `${hoursComponent}:${minutes}:${seconds}` : `${minutes}:${seconds}`;
  };
  var SliderMetaData = (0, react_2.forwardRef)(function (props) {
    return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[2]).jsxs(react_native_1.View, {
      style: styles.seekContainer,
      children: [props.totalTime === Infinity ? null : /*#__PURE__*/_$$_REQUIRE(_dependencyMap[2]).jsx(react_native_1.Text, {
        style: styles.seekValue,
        children: formatTime(props.currentTime)
      }), props.totalTime === Infinity ? /*#__PURE__*/_$$_REQUIRE(_dependencyMap[2]).jsxs(react_native_1.Text, {
        style: styles.liveValue,
        children: ["\uD83D\uDD34", " LIVE"]
      }) : /*#__PURE__*/_$$_REQUIRE(_dependencyMap[2]).jsx(react_native_1.Text, {
        style: styles.seekValue,
        children: formatTime(props.totalTime)
      })]
    });
  });
  exports.default = SliderMetaData;
},"2d5cb8c3a1dae3cc17c3",["6ed0e34da2b23bd3554f","26ef620f86acf7f6932a","048fed5a64a04bdb7fed"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2023 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PLAYBACK_SPEED_DATA = undefined;
  exports.PLAYBACK_SPEED_DATA = [
  // id : uniquely specify the "value value" from others in a list.
  // value : value to be displayed to the user in a playback value controls list. 
  {
    id: '0.25',
    value: '0.25'
  }, {
    id: '0.5',
    value: '0.5'
  }, {
    id: '0.75',
    value: '0.75'
  }, {
    id: '1',
    value: 'Normal'
  }, {
    id: '1.25',
    value: '1.25'
  }, {
    id: '1.5',
    value: '1.5'
  }, {
    id: '1.75',
    value: '1.75'
  }, {
    id: '2',
    value: '2'
  }];
},"da12c436ef5f9124e680",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2022-2023 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.requestMediaKeySystemAccess = exports.requestMediaKeysSystemAccess = exports.MediaKeysSystemAccessImpl = exports.MediaKeysImpl = exports.MediaKeySessionImpl = exports.MediaKeyStatusMapImpl = undefined;
  var base64js = __importStar(_$$_REQUIRE(_dependencyMap[0]));
  var W3CMediaTurboModule_1 = __importDefault(_$$_REQUIRE(_dependencyMap[1]));
  var WIDEVINE = "com.widevine.alpha";
  var PLAYREADY = "com.microsoft.playready.recommendation";
  var DEBUG_TAG = "EncryptedMediaImpl:";
  var MediaKeyStatusMapImpl = /*#__PURE__*/function () {
    function MediaKeyStatusMapImpl(size, statusMap) {
      _$$_REQUIRE(_dependencyMap[2])(this, MediaKeyStatusMapImpl);
      this.size = 0;
      _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} MediaKeyStatusMapImpl::ctor ${size} ${statusMap.size}`);
      this.size = size;
      this.statusMap = statusMap;
    }
    return _$$_REQUIRE(_dependencyMap[4])(MediaKeyStatusMapImpl, [{
      key: "get",
      value: function get(keyId) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} MediaKeyStatusMapImpl::get`);
        return this.statusMap.get(keyId);
      }
    }, {
      key: "has",
      value: function has(keyId) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} MediaKeyStatusMapImpl::has`);
        return this.statusMap.has(keyId);
      }
    }, {
      key: "forEach",
      value: function forEach(callbackfn, thisArg) {
        this.statusMap.forEach(callbackfn, thisArg);
      }
    }]);
  }();
  exports.MediaKeyStatusMapImpl = MediaKeyStatusMapImpl;
  var MediaKeySessionImpl = /*#__PURE__*/function () {
    function MediaKeySessionImpl(sessionType, nmk) {
      _$$_REQUIRE(_dependencyMap[2])(this, MediaKeySessionImpl);
      this._nmks = null;
      this._nmk = null;
      this._sessionType = "temporary";
      this.sessionId = "";
      this.expiration = Number.NaN;
      this.closed = null;
      this.keyStatuses = null;
      this.onkeystatuseschange = null;
      this.onmessage = null;
      _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} MediaKeySessionImpl::ctor`);
      this._nmk = nmk;
      this._sessionType = sessionType;
    }
    return _$$_REQUIRE(_dependencyMap[4])(MediaKeySessionImpl, [{
      key: "setnmks",
      value: function setnmks(nmks) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} MediaKeySessionImpl::setnmks`);
        this._nmks = nmks;
      }
    }, {
      key: "generateRequest",
      value: function () {
        var _generateRequest = _$$_REQUIRE(_dependencyMap[5])(function* (initDataType, initData) {
          var _this = this;
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} generateRequest`);
          return new Promise(function (resolve, reject) {
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} generateRequest inside the promise`);
            if (initDataType === "" || initData.byteLength === 0) {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.error(`${DEBUG_TAG} generateRequest Invalid data passed`);
              reject(TypeError("Invalid data passed"));
            }
            if (_this._nmks === null && _this._nmk) {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`${DEBUG_TAG} generateRequest Native obj is not present`);
              _this.createSession_(_this._sessionType, _this._nmk).then(function () {
                var typedArrayInput = ArrayBuffer.isView(initData) ? new Uint8Array(initData.buffer, initData.byteOffset, initData.byteLength) : new Uint8Array(initData);
                var base64Init = base64js.fromByteArray(typedArrayInput);
                // TODO: Modify below as key_ids_csv should not be required.
                if (_this._nmks) {
                  W3CMediaTurboModule_1.default.cdmiSession_GenerateRequest(_this._nmks, base64Init, [], function (event) {
                    if (event.result.error_code === 0) {
                      _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} generateRequest License request successfully submitted!`);
                      resolve();
                    } else {
                      _$$_REQUIRE(_dependencyMap[3]).LogUtil.error(`${DEBUG_TAG} generateRequest Could not get request license request!`);
                      reject(TypeError("Failed to generate request"));
                    }
                  });
                } else {
                  _$$_REQUIRE(_dependencyMap[3]).LogUtil.error(`${DEBUG_TAG} generateRequest Native obj is not present`);
                  reject((0, _$$_REQUIRE(_dependencyMap[6]).InvalidStateError)("Native obj is not present"));
                }
              }).catch(function () {
                reject((0, _$$_REQUIRE(_dependencyMap[6]).InvalidStateError)("Native obj is not present"));
              });
            }
          });
        });
        function generateRequest(_x, _x2) {
          return _generateRequest.apply(this, arguments);
        }
        return generateRequest;
      }()
    }, {
      key: "load",
      value: function load(sessionId) {
        var _this2 = this;
        if (sessionId === "") {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.error(`${DEBUG_TAG} load Empty sessionId passed`);
          return new Promise(function (resolve, reject) {
            reject(TypeError("Empty Session Id"));
          });
        }
        return new Promise(function (resolve, reject) {
          if (!_this2._nmks) {
            reject((0, _$$_REQUIRE(_dependencyMap[6]).InvalidStateError)("Native obj is not present"));
          } else {
            W3CMediaTurboModule_1.default.cdmiSession_Load(_this2._nmks, sessionId, function (event) {
              if (event.result.error_code === 0) {
                _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} load Load Session successfully submitted!`);
                resolve(true);
              } else {
                _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`${DEBUG_TAG} load Could not load session!`);
                reject(TypeError("Failed to load session"));
              }
            });
          }
        });
      }
    }, {
      key: "update",
      value: function update(response) {
        var _this3 = this;
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} DRM: update`);
        if (!response.byteLength) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.error(`${DEBUG_TAG} update Empty response passed`);
          return new Promise(function (resolve, reject) {
            reject(TypeError("Empty Response"));
          });
        }
        return new Promise(function (resolve, reject) {
          if (!_this3._nmks) {
            reject((0, _$$_REQUIRE(_dependencyMap[6]).InvalidStateError)("Native obj is not present"));
          } else {
            var typedResponse = ArrayBuffer.isView(response) ? new Uint8Array(response.buffer, response.byteOffset, response.byteLength) : new Uint8Array(response);
            var base64Resp = base64js.fromByteArray(typedResponse);
            W3CMediaTurboModule_1.default.cdmiSession_Update(_this3._nmks, base64Resp, function (event) {
              if (event.result.error_code === 0) {
                _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} update License response successfully submitted!`);
                resolve();
              } else {
                _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`${DEBUG_TAG} update Could not post license response!`);
                reject(TypeError("Failed to process response"));
              }
            });
          }
        });
      }
    }, {
      key: "close",
      value: function close() {
        var _this4 = this;
        return new Promise(function (resolve, reject) {
          if (!_this4._nmks) {
            reject((0, _$$_REQUIRE(_dependencyMap[6]).InvalidStateError)("Native obj is not present"));
          } else {
            W3CMediaTurboModule_1.default.cdmiSession_Close(_this4._nmks, function (event) {
              if (event.result.error_code === 0) {
                _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} close Close Session successfully submitted!`);
                resolve();
              } else {
                _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`${DEBUG_TAG} close Could not close session!`);
                reject(TypeError("Failed to close session"));
              }
            });
          }
        });
      }
      // TODO: Implement this
    }, {
      key: "remove",
      value: function remove() {
        var _this5 = this;
        return new Promise(function (resolve, reject) {
          if (!_this5._nmks) {
            reject((0, _$$_REQUIRE(_dependencyMap[6]).InvalidStateError)("Native obj is not present"));
          } else {
            W3CMediaTurboModule_1.default.cdmiSession_Remove(_this5._nmks, function (event) {
              if (event.result.error_code === 0) {
                _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} remove Remove Session Keys successfully submitted!`);
                resolve();
              } else {
                _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`${DEBUG_TAG} remove Could not remove session keys!`);
                reject(TypeError("Failed to remove session"));
              }
            });
          }
        });
      }
      // EventTarget APIs
      /**
       * Adds a event listener
       */
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} MediaKeySession:addEventListener: ${type}`);
        if (type === "message") {
          this.onmessage = listener;
        } else if (type === "keystatuseschange") {
          this.onkeystatuseschange = listener;
        } else {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.error(`${DEBUG_TAG} addEventListener: Unsupported listener type`);
        }
      }
      /**
       * Removes event listener
       */
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} Media:removeEventListener: ${type}`);
        if (type === "message") {
          this.onmessage = null;
        } else if (type === "keystatuseschange") {
          this.onkeystatuseschange = null;
        } else {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.error(`${DEBUG_TAG} removeEventListener: Unsupported listener type`);
        }
      }
    }, {
      key: "convertToMediaKeyStatus",
      value: function convertToMediaKeyStatus(input) {
        switch (input) {
          case 0:
            return "usable";
          case 1:
            return "expired";
          case 2:
            return "released";
          case 3:
            return "output-restricted";
          case 4:
            return "output-downscaled";
          case 6:
            return "status-pending";
          case 7:
          default:
            return "internal-error";
        }
      }
    }, {
      key: "setMap",
      value: function setMap(map) {
        this.keyStatuses = map;
      }
    }, {
      key: "createSession_",
      value: function createSession_(sessionType, nativemk) {
        var _this6 = this;
        // TODO: SessionType not used in TurboModule.
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} createSession with type ${sessionType}`);
        return new Promise(function (resolve, reject) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} createSession_ inside Promise`);
          W3CMediaTurboModule_1.default.cdmiMediaKeys_CreateSession(nativemk, sessionType, function (event) {
            if (event.result.error_code === 0) {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} createSession inside CB. Got mks! Id = ${event.id}, Event = ${event.event}`);
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} createSession Got Media Key Session! ${event.session._tag} sId: ${event.integer}`);
              _this6.sessionId = event.integer.toString();
              _this6.setnmks(event.session);
              resolve();
            } else {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.error(`${DEBUG_TAG} Could not get MediaKey Session!`);
              reject((0, _$$_REQUIRE(_dependencyMap[6]).InvalidStateError)("Failed to get MediaKeys"));
            }
          }, function (onMessage, buffer) {
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} createSession got Message in session! Id = ${onMessage.id}, Event = ${onMessage.event}`);
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} createSession Message size = ${buffer.byteLength}`);
            if (_this6.onmessage == null) {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.error(`onMessage not set!!!`);
            } else {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} Calling onMessage!!!`);
              var ev = {
                messageType: 'license-request',
                message: buffer,
                target: _this6
              };
              _this6.onmessage(ev);
            }
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} createSession Message = ${buffer.toString()}`);
          }, function (onKeyStatusesChanged, buffer) {
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} createSession key statuses changed! Id = ${onKeyStatusesChanged.id}, Event = ${onKeyStatusesChanged.event}`);
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} createSession key statuses changed size = ${buffer.byteLength} ${buffer.byteLength % 20}`);
            if (buffer.byteLength > 0 && buffer.byteLength % 20 === 0) {
              var uint32tmp = new Uint32Array(buffer);
              var myMap = new Map();
              for (var i = 0; i < buffer.byteLength / 20; i++) {
                _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} Key status = ${_this6.convertToMediaKeyStatus(uint32tmp[i * 5 + 4])} from val ${uint32tmp[i * 5 + 4]}`);
                myMap.set(buffer.slice(i * 20, i * 20 + 16), _this6.convertToMediaKeyStatus(uint32tmp[i * 5 + 4]));
              }
              var keyStatusMap = new MediaKeyStatusMapImpl(buffer.byteLength / 20, myMap);
              _this6.setMap(keyStatusMap);
            }
            if (_this6.onkeystatuseschange == null) {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.error(`${DEBUG_TAG} onKeyStatusesChanged not set!!!`);
            } else {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} Calling onKeyStatusesChanged!!!`);
              var ev = {
                target: _this6
              };
              _this6.onkeystatuseschange(ev);
            }
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} createSession Usable = ${onKeyStatusesChanged.integer}`);
          }, function (onCloseCallback) {
            if (onCloseCallback.result.error_code !== 0) {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.error(`${DEBUG_TAG} Could not close the DRM system. Error: ${onCloseCallback.result.error_code}, MpbError: ${onCloseCallback.result.mpb_error}`);
            } else {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} Closed Media Key Session`);
            }
          });
        });
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} returning from createSession_`);
      }
    }]);
  }();
  exports.MediaKeySessionImpl = MediaKeySessionImpl;
  var MediaKeysImpl = /*#__PURE__*/function () {
    function MediaKeysImpl(nmk) {
      _$$_REQUIRE(_dependencyMap[2])(this, MediaKeysImpl);
      // TODO: NFP turbo does not allow to set the session type during session creation
      this._nativemk = null;
      _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} MediaKeysImpl::ctor`);
      this._nativemk = nmk;
    }
    return _$$_REQUIRE(_dependencyMap[4])(MediaKeysImpl, [{
      key: "getnmk",
      value: function getnmk() {
        return this._nativemk;
      }
    }, {
      key: "createSession",
      value: function createSession(sessionType) {
        var session_type = "temporary";
        if (sessionType) {
          session_type = sessionType;
        }
        if (this._nativemk) {
          var mks = new MediaKeySessionImpl(session_type, this._nativemk);
          return mks;
        } else {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.error(`${DEBUG_TAG} No Native MediaKeys present. Returning empty shell`);
          var _mks = new MediaKeySessionImpl(session_type, null);
          return _mks;
        }
      }
    }, {
      key: "setServerCertificate",
      value: function setServerCertificate(serverCertificate) {
        var _this7 = this;
        return new Promise(function (resolve, reject) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} setServerCertificate inside Promise`);
          if (!serverCertificate.byteLength) {
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.error(`${DEBUG_TAG} setServerCertificate Empty serverCertificate passed`);
            reject(TypeError("Empty Server Certificate"));
          }
          if (!_this7._nativemk) {
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.error(`${DEBUG_TAG} setServerCertificate Native obj not present`);
            reject((0, _$$_REQUIRE(_dependencyMap[6]).InvalidStateError)("Native obj is not present"));
          } else {
            var typedCert = ArrayBuffer.isView(serverCertificate) ? new Uint8Array(serverCertificate.buffer, serverCertificate.byteOffset, serverCertificate.byteLength) : new Uint8Array(serverCertificate);
            var base64Cert = base64js.fromByteArray(typedCert);
            W3CMediaTurboModule_1.default.cdmiMediaKeys_SetServerCertificate(_this7._nativemk, base64Cert, function (event) {
              if (event.result.error_code === 0) {
                _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} setServerCertificate successfully submitted!`);
                resolve(true);
              } else {
                _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} setServerCertificate Could not set server certificate!`);
                reject(TypeError("Failed to set server certificate"));
              }
            });
          }
        });
      }
    }, {
      key: "getStatusForPolicy",
      value: function getStatusForPolicy(policy) {
        var _this8 = this;
        return new Promise(function (resolve, reject) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} getStatusForPolicy inside Promise`);
          if (!policy || policy.minHdcpVersion === "") {
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.error(`${DEBUG_TAG} getStatusForPolicy empty policy/minHdcpVersion passed`);
            reject(TypeError("Empty policy/minHdcpVersion"));
          }
          if (!_this8._nativemk) {
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.error(`${DEBUG_TAG} getStatusForPolicy Native obj not present`);
            reject((0, _$$_REQUIRE(_dependencyMap[6]).InvalidStateError)("Native obj is not present"));
          } else {
            var nativePolicy = {
              minHdcpVersion: policy.minHdcpVersion
            };
            W3CMediaTurboModule_1.default.cdmiMediaKeys_GetStatusForPolicy(_this8._nativemk, nativePolicy, function (event) {
              if (event.result.error_code === 0) {
                _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} getStatusForPolicy succeeded: native status=${event.integer}`);
                var nativeMediaKeyStatuses = W3CMediaTurboModule_1.default.getCdmMediaKeyStatus();
                if (event.integer === nativeMediaKeyStatuses.USABLE || event.integer === nativeMediaKeyStatuses.OUTPUT_RESTRICTED) {
                  var status = event.integer === nativeMediaKeyStatuses.USABLE ? "usable" : "output-restricted";
                  resolve(status);
                } else {
                  _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`${DEBUG_TAG} getStatusForPolicy unexpected status!`);
                  reject(TypeError("Unexpected status for policy"));
                }
              } else {
                _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`${DEBUG_TAG} getStatusForPolicy Could not get status for policy`);
                reject(TypeError("Failed to get status for policy"));
              }
            });
          }
        });
      }
    }]);
  }();
  exports.MediaKeysImpl = MediaKeysImpl;
  var MediaKeysSystemAccessImpl = /*#__PURE__*/function () {
    function MediaKeysSystemAccessImpl(keysystem, nativemksa) {
      _$$_REQUIRE(_dependencyMap[2])(this, MediaKeysSystemAccessImpl);
      this._configuration = null;
      this._nativemksa = null;
      this._nativecfg = null;
      this.keySystem = "";
      _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} MediaKeysSystemAccessImpl::ctor key system = ${keysystem}`);
      this._nativemksa = nativemksa;
      this.keySystem = keysystem;
      _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} MediaKeysSystemAccessImpl::ctor native config = ${this._nativecfg}`);
    }
    // Helper method for deep cloning
    return _$$_REQUIRE(_dependencyMap[4])(MediaKeysSystemAccessImpl, [{
      key: "clone",
      value: function clone() {
        var cloned = new MediaKeysSystemAccessImpl(this.keySystem, this._nativemksa ? MediaKeysSystemAccessImpl.deepClone(this._nativemksa) : null);
        cloned._configuration = this._configuration ? MediaKeysSystemAccessImpl.deepClone(this._configuration) : null;
        cloned._nativecfg = this._nativecfg ? MediaKeysSystemAccessImpl.deepClone(this._nativecfg) : null;
        return cloned;
      }
    }, {
      key: "getConfiguration",
      value: function getConfiguration() {
        if (this._configuration === null) {
          if (this._nativecfg === null) {
            this._nativecfg = W3CMediaTurboModule_1.default.cdmiAccess_GetConfiguration(this._nativemksa);
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} getConfiguration _nativecfg = ${this._nativecfg}`);
          }
          if (this._nativecfg !== null) {
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} getConfiguration label = ${this._nativecfg.label}`);
            var nativeInitDataTypes = W3CMediaTurboModule_1.default.getCdmInitDataType();
            var initDataTypes = new Array();
            for (var i = 0; i < this._nativecfg.init_data_types.length; i++) {
              var initDataType = this._nativecfg.init_data_types[i];
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} getConfiguration init_data_types[{i}] = ${initDataType}`);
              if (initDataType === nativeInitDataTypes.CENC) {
                initDataTypes[i] = "cenc";
              } else if (initDataType === nativeInitDataTypes.KEYIDS) {
                initDataTypes[i] = "keyids";
              } else if (initDataType === nativeInitDataTypes.WEBM) {
                initDataTypes[i] = "webm";
              }
            }
            var nativeMediaRobustness = W3CMediaTurboModule_1.default.getCdmMediaRobustness();
            var audioCapabilities = new Array();
            for (var _i = 0; _i < this._nativecfg.audio_capabilities.length; _i++) {
              var cap = this._nativecfg.audio_capabilities[_i];
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} getConfiguration audio_capabilities[{i}]: mime=${cap.mime} robustness=${cap.robustness}`);
              audioCapabilities.push({
                contentType: cap.mime,
                robustness: nativeMediaRobustness.SECURE === cap.robustness ? "SECURE" : "NON-SECURE"
              });
            }
            var videoCapabilities = new Array();
            for (var _i2 = 0; _i2 < this._nativecfg.video_capabilities.length; _i2++) {
              var _cap = this._nativecfg.video_capabilities[_i2];
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} getConfiguration video_capabilities[{i}]: mime=${_cap.mime} robustness=${_cap.robustness}`);
              videoCapabilities.push({
                contentType: _cap.mime,
                robustness: nativeMediaRobustness.SECURE === _cap.robustness ? "SECURE" : "NON-SECURE"
              });
            }
            var nativeMediaKeyRequirement = W3CMediaTurboModule_1.default.getCdmMediaKeyRequirement();
            var distinctiveId = nativeMediaKeyRequirement.REQUIRED === this._nativecfg.distinctive_identifier ? "required" : nativeMediaKeyRequirement.NOT_ALLOWED === this._nativecfg.distinctive_identifier ? "not-allowed" : "optional";
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} getConfiguration distinctive_identifier = ${this._nativecfg.distinctive_identifier} => ${distinctiveId}`);
            var persistentState = nativeMediaKeyRequirement.REQUIRED === this._nativecfg.persistent_state ? "required" : nativeMediaKeyRequirement.NOT_ALLOWED === this._nativecfg.persistent_state ? "not-allowed" : "optional";
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} getConfiguration persistent_state = ${this._nativecfg.persistent_state} => ${persistentState}`);
            var nativeSessionType = W3CMediaTurboModule_1.default.getCdmSessionType();
            var sessionTypes = new Array();
            for (var _i3 = 0; _i3 < this._nativecfg.session_types.length; _i3++) {
              var st = nativeSessionType.PERSISTENT === this._nativecfg.session_types[_i3] ? "persistent-license" : "temporary";
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} getConfiguration session_types[{i}] = ${this._nativecfg.session_types[_i3]} => ${st}`);
              sessionTypes.push(st);
            }
            this._configuration = {
              label: this._nativecfg.label,
              initDataTypes: initDataTypes,
              audioCapabilities: audioCapabilities,
              videoCapabilities: videoCapabilities,
              distinctiveIdentifier: distinctiveId,
              persistentState: persistentState,
              sessionTypes: sessionTypes
            };
          }
        }
        if (this._configuration !== null && this._configuration.videoCapabilities !== undefined && this._configuration.videoCapabilities.length > 0) {
          var _this$_configuration;
          var tmp_cap = this._configuration.videoCapabilities[0];
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} getConfiguration where number of config = ${this._configuration.videoCapabilities.length}`);
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} getConfiguration where contentType = ${tmp_cap.contentType}`);
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} getConfiguration where robustness = ${tmp_cap.robustness}`);
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} getConfiguration where config label = ${(_this$_configuration = this._configuration) == null ? undefined : _this$_configuration.label}`);
        }
        return this._configuration;
      }
    }, {
      key: "createMediaKeys",
      value: function createMediaKeys() {
        var _this9 = this;
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`${DEBUG_TAG} MediaKeysSystemAccessImpl::createMediaKeys`);
        return new Promise(function (resolve, reject) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} createMediaKeys Inside the promise`);
          if (_this9._nativemksa == null) {
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} Something is wrong with mksa. Rejecting`);
            reject((0, _$$_REQUIRE(_dependencyMap[6]).InvalidStateError)("Native obj is not present"));
          } else {
            W3CMediaTurboModule_1.default.cdmiAccess_CreateMediaKeys(_this9._nativemksa, function (event) {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} createMediaKeys Inside the CB`);
              if (event.result.error_code === 0) {
                var cdmiKeysResult = new MediaKeysImpl(event.media_keys);
                _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} createMediaKeys Got MediaKeys!`);
                resolve(cdmiKeysResult);
              } else {
                _$$_REQUIRE(_dependencyMap[3]).LogUtil.error(`${DEBUG_TAG} createMediaKeys Could not get MediaKeys!`);
                reject((0, _$$_REQUIRE(_dependencyMap[6]).InvalidStateError)("Failed to get MediaKeys"));
              }
            });
          }
        });
      }
    }], [{
      key: "deepClone",
      value: function deepClone(obj) {
        if (obj === null || typeof obj !== 'object') {
          return obj;
        }
        if (obj instanceof Date) {
          return new Date(obj.getTime());
        }
        if (Array.isArray(obj)) {
          return obj.map(function (item) {
            return MediaKeysSystemAccessImpl.deepClone(item);
          });
        }
        if (obj instanceof Object) {
          var copy = {};
          Object.keys(obj).forEach(function (key) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              copy[key] = MediaKeysSystemAccessImpl.deepClone(obj[key]);
            }
          });
          return copy;
        }
        throw new Error(`Unable to copy obj! Its type isn't supported.`);
      }
    }]);
  }();
  exports.MediaKeysSystemAccessImpl = MediaKeysSystemAccessImpl;
  /**
   * TODO: Deprectate the 'requestMediaKeysSystemAccess' in future release (after MR32).
   * PROJXXXX-139032
   */
  function requestMediaKeysSystemAccess(keySystem, supportedConfigurations) {
    _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} requestMediaKeysSystemAccess ${keySystem}`);
    return requestMediaKeySystemAccess(keySystem, supportedConfigurations);
  }
  exports.requestMediaKeysSystemAccess = requestMediaKeysSystemAccess;
  /**
   * https://www.w3.org/TR/encrypted-media/#dom-navigator-requestmediakeysystemaccess
   * @param keySystem
   * @param supportedConfigurations
   * @returns
   */
  function requestMediaKeySystemAccess(keySystem, supportedConfigurations) {
    _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} requestMediaKeySystemAccess ${keySystem}`);
    if (!keySystem.length) {
      _$$_REQUIRE(_dependencyMap[3]).LogUtil.error(`${DEBUG_TAG} requestMediaKeySystemAccess Invalid inputs`);
      return new Promise(function (_resolve, reject) {
        reject(TypeError("Empty Key System"));
      });
    }
    // TODO: move to its own function
    var init_types = W3CMediaTurboModule_1.default.getCdmInitDataType();
    var session_types = W3CMediaTurboModule_1.default.getCdmSessionType();
    var media_robustness = W3CMediaTurboModule_1.default.getCdmMediaRobustness();
    var media_requirement = W3CMediaTurboModule_1.default.getCdmMediaKeyRequirement();
    var tmp_supported_configurations = new Array();
    if (supportedConfigurations && supportedConfigurations.length === 0) {
      _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} Creating default CDM Configuration. Temporary non-secure`);
      tmp_supported_configurations.push({
        label: "Default Kepler Configuration",
        init_data_types: [init_types.CENC],
        audio_capabilities: [{
          mime: "audio",
          robustness: media_robustness.NOT_SECURE
        }],
        video_capabilities: [{
          mime: "video",
          robustness: media_robustness.NOT_SECURE
        }],
        distinctive_identifier: media_requirement.NOT_ALLOWED,
        persistent_state: media_requirement.NOT_ALLOWED,
        session_types: [session_types.TEMPORARY]
      });
    } else {
      _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} Supported Configs size = ${supportedConfigurations.length}`);
      for (var j = 0; j < supportedConfigurations.length; j++) {
        var _supportedConfigurati, _supportedConfigurati2, _supportedConfigurati3;
        var tmp_init_types = new Array();
        var tmp_audio_caps = new Array();
        var tmp_video_caps = new Array();
        var tmp_session_types = new Array();
        var tmp_distinctive_identifier = media_requirement.NOT_ALLOWED;
        var tmp_persistent_storage = media_requirement.NOT_ALLOWED;
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} Init Types: ${supportedConfigurations[j].initDataTypes}`);
        if (supportedConfigurations[j].initDataTypes !== undefined) {
          var curr_init_types = supportedConfigurations[j].initDataTypes;
          if (curr_init_types.length > 0) {
            for (var i = 0; i < curr_init_types.length; i++) {
              var init_t = curr_init_types[i];
              if (init_t === "cenc") {
                tmp_init_types[i] = init_types.CENC;
              } else if (init_t === "keyids") {
                tmp_init_types[i] = init_types.KEYIDS;
              } else if (init_t === "webm") {
                tmp_init_types[i] = init_types.WEBM;
              } else {
                tmp_init_types[i] = init_types.CENC;
              }
            }
          } else {
            tmp_init_types[0] = init_types.CENC;
          }
        } else {
          tmp_init_types[0] = init_types.CENC;
        }
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} Audio caps count: ${(_supportedConfigurati = supportedConfigurations[j].audioCapabilities) == null ? undefined : _supportedConfigurati.length}`);
        if (supportedConfigurations[j].audioCapabilities !== undefined) {
          var curr_audio_caps = supportedConfigurations[j].audioCapabilities;
          if (curr_audio_caps.length > 0) {
            for (var _i4 = 0; _i4 < curr_audio_caps.length; _i4++) {
              var tmp_aud_cap = {
                mime: "audio",
                robustness: media_robustness.NOT_SECURE,
                encryptionScheme: null
              };
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`Cap [${_i4}]: ${curr_audio_caps[_i4].contentType} : ${curr_audio_caps[_i4].robustness}`);
              tmp_aud_cap.mime = curr_audio_caps[_i4].contentType;
              var robustness = curr_audio_caps[_i4].robustness;
              if (robustness === "SECURE") {
                tmp_aud_cap.robustness = media_robustness.SECURE;
              } else {
                _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`Cap [${_i4}]: setting non-secure`);
                tmp_aud_cap.robustness = media_robustness.NOT_SECURE;
              }
              if (curr_audio_caps[_i4].encryptionScheme != null) {
                if (curr_audio_caps[_i4].encryptionScheme !== "cenc" || curr_audio_caps[_i4].encryptionScheme !== "cbcs" || curr_audio_caps[_i4].encryptionScheme !== "cbcs-1-9") {
                  _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`${DEBUG_TAG} requestMediaKeySystemAccess. Unsupported encryptionScheme passed: ${curr_audio_caps[_i4].encryptionScheme}. skipping`);
                  continue;
                }
              } else if (curr_audio_caps[_i4].encryptionScheme !== undefined) {
                _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`${DEBUG_TAG} requestMediaKeySystemAccess. Empty encryptionScheme passed for Audio. Skipping`);
                continue;
              }
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} Cap [${_i4}]: ${tmp_aud_cap.mime} : ${tmp_aud_cap.robustness} : ${tmp_aud_cap.encryptionScheme}`);
              tmp_audio_caps.push(tmp_aud_cap);
            }
          } else {
            var _tmp_aud_cap = {
              mime: "audio",
              robustness: media_robustness.NOT_SECURE,
              encryptionScheme: null
            };
            tmp_audio_caps.push(_tmp_aud_cap);
          }
        } else {
          var _tmp_aud_cap2 = {
            mime: "audio",
            robustness: media_robustness.NOT_SECURE,
            encryptionScheme: null
          };
          tmp_audio_caps.push(_tmp_aud_cap2);
        }
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} Video caps count:  ${(_supportedConfigurati2 = supportedConfigurations[j].videoCapabilities) == null ? undefined : _supportedConfigurati2.length}`);
        if (supportedConfigurations[j].videoCapabilities !== undefined) {
          var curr_video_caps = supportedConfigurations[j].videoCapabilities;
          if (curr_video_caps.length > 0) {
            for (var _i5 = 0; _i5 < curr_video_caps.length; _i5++) {
              var tmp_vid_cap = {
                mime: "video",
                robustness: media_robustness.NOT_SECURE,
                encryptionScheme: null
              };
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} Cap [${_i5}]: ${curr_video_caps[_i5].contentType} : ${curr_video_caps[_i5].robustness}`);
              tmp_vid_cap.mime = curr_video_caps[_i5].contentType;
              var _robustness = curr_video_caps[_i5].robustness;
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} Cap [${_i5}] : ${_robustness}`);
              if (_robustness === "SECURE" || _robustness === "HW_SECURE_ALL" || _robustness === "3000" || _robustness === "2000") {
                tmp_vid_cap.robustness = media_robustness.SECURE;
              } else {
                tmp_vid_cap.robustness = media_robustness.NOT_SECURE;
              }
              if (curr_video_caps[_i5].encryptionScheme != null) {
                if (curr_video_caps[_i5].encryptionScheme !== "cenc" || curr_video_caps[_i5].encryptionScheme !== "cbcs" || curr_video_caps[_i5].encryptionScheme !== "cbcs-1-9") {
                  _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`${DEBUG_TAG} requestMediaKeySystemAccess. Unsupported encryptionScheme passed: ${curr_video_caps[_i5].encryptionScheme}. Skipping`);
                  continue;
                }
              } else if (curr_video_caps[_i5].encryptionScheme !== undefined) {
                _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`${DEBUG_TAG} requestMediaKeySystemAccess. Empty encryptionScheme passed for Video. Skipping`);
                continue;
              }
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} Cap [${_i5}]: ${tmp_vid_cap.mime} : ${tmp_vid_cap.robustness} : ${tmp_vid_cap.encryptionScheme}`);
              tmp_video_caps.push(tmp_vid_cap);
            }
          } else {
            var _tmp_vid_cap = {
              mime: "video",
              robustness: media_robustness.NOT_SECURE,
              encryptionScheme: null
            };
            tmp_video_caps.push(_tmp_vid_cap);
          }
        } else {
          var _tmp_vid_cap2 = {
            mime: "video",
            robustness: media_robustness.NOT_SECURE,
            encryptionScheme: null
          };
          tmp_video_caps.push(_tmp_vid_cap2);
        }
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} Distinctive ID: ${supportedConfigurations[j].distinctiveIdentifier}`);
        if (supportedConfigurations[j].distinctiveIdentifier !== undefined) {
          if (supportedConfigurations[j].distinctiveIdentifier === "required") {
            tmp_distinctive_identifier = media_requirement.REQUIRED;
          } else if (supportedConfigurations[j].distinctiveIdentifier === "optional") {
            tmp_distinctive_identifier = media_requirement.OPTIONAL;
          }
        }
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} Persistent Storage: ${supportedConfigurations[j].persistentState}`);
        if (supportedConfigurations[j].persistentState !== undefined) {
          if (supportedConfigurations[j].persistentState === "required") {
            tmp_persistent_storage = media_requirement.REQUIRED;
          } else if (supportedConfigurations[j].persistentState === "optional") {
            tmp_persistent_storage = media_requirement.OPTIONAL;
          }
        }
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} Session Types: ${supportedConfigurations[j].sessionTypes}`);
        if (supportedConfigurations[j].sessionTypes !== undefined) {
          var curr_session_types = supportedConfigurations[j].sessionTypes;
          if (curr_session_types.length > 0) {
            for (var _i6 = 0; _i6 < curr_session_types.length; _i6++) {
              var session_t = curr_session_types[_i6];
              if (session_t === "persistent-license") {
                tmp_session_types[_i6] = session_types.PERSISTENT;
              } else if (session_t === "temporary") {
                tmp_session_types[_i6] = session_types.TEMPORARY;
              }
            }
          } else {
            tmp_session_types[0] = session_types.TEMPORARY;
          }
        } else {
          tmp_session_types[0] = session_types.TEMPORARY;
        }
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} Label ${supportedConfigurations[j].label}`);
        var tmp_label = "Kepler SDK";
        if (typeof supportedConfigurations[j].label !== 'undefined' && ((_supportedConfigurati3 = supportedConfigurations[j].label) == null ? undefined : _supportedConfigurati3.length) !== 0) {
          tmp_label = supportedConfigurations[j].label;
        }
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} Getting Native CDM Configuration`);
        tmp_supported_configurations.push({
          label: tmp_label,
          init_data_types: tmp_init_types,
          audio_capabilities: tmp_audio_caps,
          video_capabilities: tmp_video_caps,
          distinctive_identifier: tmp_distinctive_identifier,
          persistent_state: tmp_persistent_storage,
          session_types: tmp_session_types
        });
      }
    }
    return new Promise(function (resolve, reject) {
      _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} requestMediaKeySystemAccess Inside the promise`);
      W3CMediaTurboModule_1.default.cdmiAccess_New(keySystem, tmp_supported_configurations, function (event) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} requestMediaKeySystemAccess Inside the CB`);
        if (event.result.error_code === 0) {
          var cdmiAccessResult = new MediaKeysSystemAccessImpl(keySystem, event.access);
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} requestMediaKeySystemAccess Got SystemAcccess with name = ${cdmiAccessResult.keySystem}`);
          resolve(cdmiAccessResult);
        } else {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.error(`${DEBUG_TAG} requestMediaKeySystemAccess Could not get SystemAcccess!`);
          reject(TypeError("Failed to get the MediaKeySystemAccess"));
        }
      }, function (onCloseCallback) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} requestMediaKeySystemAccess Inside the OC`);
        if (onCloseCallback.result.error_code !== 0) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.error(`${DEBUG_TAG} requestMediaKeySystemAccess Could not close the DRM system. Error: ${onCloseCallback.result.error_code}, MpbError: ${onCloseCallback.result.mpb_error}`);
        } else {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} requestMediaKeySystemAccess Closed system Access`);
        }
      });
      _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`${DEBUG_TAG} requestMediaKeySystemAccess After cdmiAccess_New`);
    });
  }
  exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess;
},"7d1995a852866a3b5fa6",["71af70f51435e3e1b37b","0814a269c2fb50034991","3508abd8c6b891008c0d","1f12e7e43345228dfcad","5533cec96f6a88041c69","ff7d8d645536d793bbec","28b38b2de31c42119bdb"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2022-2023 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  /** This file is copied from ATVKeplerNFPBindings vmpf-dev branch */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  // tslint:disable-next-line
  exports.default = _$$_REQUIRE(_dependencyMap[0]).TurboModuleRegistry.getEnforcing("KeplerW3CMediaTurboModule");
},"0814a269c2fb50034991",["8a35a86b7946c72e0207"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Copyright (c) 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.
   *
   * PROPRIETARY/CONFIDENTIAL
   *
   * Use is subject to license terms.
   *
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TurboModuleRegistry = undefined;
  exports.TurboModuleRegistry = _$$_REQUIRE(_dependencyMap[0]);
},"8a35a86b7946c72e0207",["33d6b98d6e39f6b0a8f9"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * Portions of this file are copyright (c) 2023 Amazon.com, Inc. or its
   * affiliates.  All rights reserved.
   *
   * PORTIONS OF THIS FILE ARE AMAZON PROPRIETARY/CONFIDENTIAL.  USE IS SUBJECT TO
   * LICENSE TERMS.
   *
   * Amazon modifications are indicated by [amznmod_* comments].
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getEnforcing = exports.get = undefined;
  var turboModuleProxy = global.__turboModuleProxy;
  function requireModule(name) {
    if (turboModuleProxy != null) {
      return turboModuleProxy(name);
    }
    return null;
  }
  function get(name) {
    return requireModule(name);
  }
  exports.get = get;
  function getEnforcing(name) {
    var module = requireModule(name);
    (0, _$$_REQUIRE(_dependencyMap[0]).default)(module != null, `TurboModuleRegistry.getEnforcing(...): '${name}' could not be found. ` + 'Verify that a module by this name is registered in the native binary.');
    return module;
  }
  exports.getEnforcing = getEnforcing;
},"33d6b98d6e39f6b0a8f9",["8d9475a2cb77b53e450d"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * Portions of this file are copyright (c) 2023 Amazon.com, Inc. or its
   * affiliates.  All rights reserved.
   *
   * PORTIONS OF THIS FILE ARE AMAZON PROPRIETARY/CONFIDENTIAL.  USE IS SUBJECT TO
   * LICENSE TERMS.
   *
   * Amazon modifications are indicated by [amznmod_* comments].
   */
  /**
   * amznmod_tmapi: Migrated to typescript
   */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * Use invariant() to assert state which your program assumes to be true.
   *
   * Provide sprintf-style format (only %s is supported) and arguments
   * to provide information about what broke and what you were
   * expecting.
   *
   * The invariant message will be stripped in production, but the invariant
   * will remain to ensure logic does not differ in production.
   */
  var NODE_ENV = "production";
  var invariant = function invariant(condition, format) {
    for (var _len = arguments.length, extraArgs = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      extraArgs[_key - 2] = arguments[_key];
    }
    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      } else {
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return extraArgs[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }
      // @ts-ignore `framesToPop` is not part of Error type but something Meta (and maybe RN) uses.
      error.framesToPop = 1; // we don't care about invariant's own frame
      throw error;
    }
  };
  exports.default = invariant;
},"8d9475a2cb77b53e450d",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2022 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
},"28b38b2de31c42119bdb",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2022-2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  function _callSuper(t, o, e) { return o = _$$_REQUIRE(_dependencyMap[0])(o), _$$_REQUIRE(_dependencyMap[1])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _$$_REQUIRE(_dependencyMap[0])(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  function _superPropSet(t, e, o, r, p, f) { return _$$_REQUIRE(_dependencyMap[2])(_$$_REQUIRE(_dependencyMap[0])(f ? t.prototype : t), e, o, r, p); }
  function _superPropGet(t, o, e, r) { var p = _$$_REQUIRE(_dependencyMap[3])(_$$_REQUIRE(_dependencyMap[0])(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Audio = undefined;
  var React = __importStar(_$$_REQUIRE(_dependencyMap[4]));
  var react_native_1 = _$$_REQUIRE(_dependencyMap[5]);
  var MediaControls_1 = __importDefault(_$$_REQUIRE(_dependencyMap[6]));
  /**
   * A react native component that Implements the `HTMLAudioElement` interface that extends
   * `HTMLMediaElement` interface..
   */
  var Audio = /*#__PURE__*/function (_Media_1$Media) {
    function Audio(props) {
      var _this;
      _$$_REQUIRE(_dependencyMap[7])(this, Audio);
      _this = _callSuper(this, Audio, [props, new (_$$_REQUIRE(_dependencyMap[8]).AudioPlayer)(props.audioType, props.audioUsage)]);
      _this.isMediaPlayerInitialized = false;
      if (_this.props.mediaControlFocus !== undefined) {
        _superPropGet((_this, Audio), "setMediaControlFocus", _this, 3)([_this.props.mediaControlFocus, _this.props.overrideMediaControlHandler]).then(function () {
          _$$_REQUIRE(_dependencyMap[9]).LogUtil.info("Audio: setMediaControlFocus is configured..");
        });
      } else {
        _$$_REQUIRE(_dependencyMap[9]).LogUtil.warn("Audio: setMediaControlFocus is not configured..");
      }
      _this.initializeMediaPlayer().then(function () {
        _$$_REQUIRE(_dependencyMap[9]).LogUtil.info("Audio: Media Player Initialized");
        _this.isMediaPlayerInitialized = true;
        _superPropGet((_this, Audio), "onMediaPlayerInitialized", _this, 3)([]);
      });
      return _this;
    }
    /**
     * @hidden
     */
    _$$_REQUIRE(_dependencyMap[10])(Audio, _Media_1$Media);
    return _$$_REQUIRE(_dependencyMap[11])(Audio, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        _$$_REQUIRE(_dependencyMap[9]).LogUtil.info("Audio: componentDidMount");
      }
      /**
       * @hidden
       */
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        _$$_REQUIRE(_dependencyMap[9]).LogUtil.info("Audio: componentWillUnmount");
        if (this.isMediaPlayerInitialized && this.mediaPlayer_ !== null) {
          if (this.captionsViewHandle_ !== null) {
            var _this$mediaPlayer_;
            (_this$mediaPlayer_ = this.mediaPlayer_) == null ? undefined : _this$mediaPlayer_.clearCaptionViewHandle(this.captionsViewHandle_);
            this.captionsViewHandle_ = null;
          }
        }
        this.destroyMediaPlayer().then(function () {
          _$$_REQUIRE(_dependencyMap[9]).LogUtil.info("Audio: media player destroyed");
        });
      }
      /**
       * @hidden
       */
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        _$$_REQUIRE(_dependencyMap[9]).LogUtil.info("Audio: componentDidUpdate");
        /* check if seek interval updated by app */
        if (prevProps.defaultSeekIntervalInSec !== this.props.defaultSeekIntervalInSec) {
          _superPropSet(Audio, "defaultSeekIntervalInSec", this.props.defaultSeekIntervalInSec, this, 1, 1);
        }
      }
      /**
       * @brief DeInitiailzes the player synchronously
       * @param timeoutInMs timeout threshold set by client
       * @returns MediaPlayerDeInitStatus
       */
    }, {
      key: "destroyMediaPlayerSync",
      value: function destroyMediaPlayerSync(timeoutInMs) {
        return _superPropGet(Audio, "destroyMediaPlayerSync", this, 3)([timeoutInMs]);
      }
      /**
       * @hidden
       */
    }, {
      key: "render",
      value: function render() {
        var _this$props$showCapti;
        return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[12]).jsxs(react_native_1.View, {
          children: [/*#__PURE__*/_$$_REQUIRE(_dependencyMap[12]).jsx(_$$_REQUIRE(_dependencyMap[13]).KeplerCaptionsView, {
            onCaptionViewCreated: this.onCaptionViewCreated,
            show: (_this$props$showCapti = this.props.showCaptions) != null ? _this$props$showCapti : true,
            style: {
              zIndex: 1
            }
          }), this.controls ? /*#__PURE__*/_$$_REQUIRE(_dependencyMap[12]).jsx(MediaControls_1.default, {
            initFocus: true,
            mediaPlayer: this.mediaPlayer_,
            style: {
              zIndex: 2
            }
          }) : null]
        });
      }
    }]);
  }(_$$_REQUIRE(_dependencyMap[14]).Media);
  exports.Audio = Audio;
  ;
},"a5190f43c80aab78cbe5",["f391b9d534c3a6bc8659","4534eb96ece5e83c089a","0a5aa7067dba858ecaf2","ef4c2223f1078b78bd52","6ed0e34da2b23bd3554f","26ef620f86acf7f6932a","57cfca0008596c8d64b2","3508abd8c6b891008c0d","866b49a5fba376b39fa2","1f12e7e43345228dfcad","73afcd34a88a750f6d69","5533cec96f6a88041c69","048fed5a64a04bdb7fed","0d9a17d8c6f7cb480e97","372fa0c50373b8a1a1df"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function set(e, r, t, o) {
    return set = "undefined" != typeof Reflect && Reflect.set ? Reflect.set : function (e, r, t, o) {
      var f,
        i = _$$_REQUIRE(_dependencyMap[0])(e, r);
      if (i) {
        if ((f = Object.getOwnPropertyDescriptor(i, r)).set) return f.set.call(o, t), true;
        if (!f.writable) return false;
      }
      if (f = Object.getOwnPropertyDescriptor(o, r)) {
        if (!f.writable) return false;
        f.value = t, Object.defineProperty(o, r, f);
      } else _$$_REQUIRE(_dependencyMap[1])(o, r, t);
      return true;
    }, set(e, r, t, o);
  }
  function _set(e, r, t, o, f) {
    if (!set(e, r, t, o || e) && f) throw new TypeError("failed to set property");
    return t;
  }
  module.exports = _set, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"0a5aa7067dba858ecaf2",["b44e8fc8ae41fbe9dea8","d57b125e535b41806db7"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2022-2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  function _callSuper(t, o, e) { return o = _$$_REQUIRE(_dependencyMap[0])(o), _$$_REQUIRE(_dependencyMap[1])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _$$_REQUIRE(_dependencyMap[0])(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  function _superPropGet(t, o, e, r) { var p = _$$_REQUIRE(_dependencyMap[2])(_$$_REQUIRE(_dependencyMap[0])(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AudioPlayer = undefined;
  /** *
  * @brief `AudioPlayer` is a component that implements the `HTMLAudioElement` interface
   * that extends `HTMLMediaElement` interface.
   * @remarks This is a typescript class and not a react native component. Apps
   * need to create an instance of `AudioPlayer` and use it to start buffering
   * the content without starting playback. It does not render the media controls GUI.
   * Apps are expected to build their own media controls UI and control the playback experience.
   *
   */
  var AudioPlayer = /*#__PURE__*/function (_MediaPlayer_1$MediaP) {
    /**
     * @brief Creates a `AudioPlayer` instance.
     * @param audioType Type of audio to play.
     * @param audioUsage  Reason for audio playback.
     */
    function AudioPlayer(audioType, audioUsage) {
      _$$_REQUIRE(_dependencyMap[3])(this, AudioPlayer);
      _$$_REQUIRE(_dependencyMap[4]).LogUtil.info("AudioPlayer: +constructor");
      return _callSuper(this, AudioPlayer, ["audio", audioType, audioUsage]);
    }
    /**
     * @brief Initiailzes the player.
     * Wait for the promise to be fulfilled before calling any other function.
     * @returns Promise that is resolved when the player is initialized.
     */
    _$$_REQUIRE(_dependencyMap[5])(AudioPlayer, _MediaPlayer_1$MediaP);
    return _$$_REQUIRE(_dependencyMap[6])(AudioPlayer, [{
      key: "initialize",
      value: function initialize() {
        return _superPropGet(AudioPlayer, "initialize", this, 3)([]);
      }
      /**
       * @brief DeInitiailzes the player.
       *
       * @returns Promise that is resolved when the player is deinitialized.
       */
    }, {
      key: "deinitialize",
      value: function deinitialize() {
        return _superPropGet(AudioPlayer, "deinitialize", this, 3)([]);
      }
      /**
       * @brief DeInitiailzes the player synchronously
       * @param timeoutInMs time out threshold set by client to return the deinit control.
       * @returns MediaPlayerDeInitStatus
       */
    }, {
      key: "deinitializeSync",
      value: function deinitializeSync(timeoutInMs) {
        return _superPropGet(AudioPlayer, "deinitializeSync", this, 3)([timeoutInMs]);
      }
      /**
       * @brief setup the component instance with current mediaplayer being used and pass mediaControlHandler
       *        in case client wants to opt handling of mediacontrol commands.
       */
    }, {
      key: "setMediaControlFocus",
      value: function setMediaControlFocus(componentInstance, mediaControlHandler) {
        return _superPropGet(AudioPlayer, "setMediaControlFocus", this, 3)([componentInstance, mediaControlHandler]);
      }
    }]);
  }(_$$_REQUIRE(_dependencyMap[7]).MediaPlayer);
  exports.AudioPlayer = AudioPlayer;
  ;
},"866b49a5fba376b39fa2",["f391b9d534c3a6bc8659","4534eb96ece5e83c089a","ef4c2223f1078b78bd52","3508abd8c6b891008c0d","1f12e7e43345228dfcad","73afcd34a88a750f6d69","5533cec96f6a88041c69","afef45745b99fd25fb6a"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  function _callSuper(t, o, e) { return o = _$$_REQUIRE(_dependencyMap[0])(o), _$$_REQUIRE(_dependencyMap[1])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _$$_REQUIRE(_dependencyMap[0])(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MediaPlayer = undefined;
  /*
   * Copyright 2022-2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  var base64js = __importStar(_$$_REQUIRE(_dependencyMap[2]));

  // temporary till we import from audio turbo module

  var W3CMediaTurboModule_1 = __importDefault(_$$_REQUIRE(_dependencyMap[3]));
  var parseClientPackageManifest = /*#__PURE__*/function () {
    var _ref = _$$_REQUIRE(_dependencyMap[4])(function* () {
      if (MediaPlayer.isAppManifestParsed) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(" MediaPlayer: Manifest was parsed.");
        return true;
      }
      try {
        var kmcResult = W3CMediaTurboModule_1.default.checkClientManifestForKMC();
        var componentId = kmcResult["component.id"] || "unknown";
        var hasKMC = kmcResult["hasKMC"] || false;
        _$$_REQUIRE(_dependencyMap[6]).appClientKMCMapTable.set(componentId, hasKMC);
        MediaPlayer.isAppManifestParsed = true;
        return true;
      } catch (error) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.warn(`MediaPlayer: checkClientManifestForKMC failed: ${error.message}`);
        return false;
      }
    });
    return function parseClientPackageManifest() {
      return _ref.apply(this, arguments);
    };
  }();
  /**
   * @hidden
   * https://html.spec.whatwg.org/multipage/media.html#htmlmediaelement
   */
  var MediaPlayer = /*#__PURE__*/function (_HTMLMediaElement_1$H) {
    function MediaPlayer(nodeName, audioType, audioUsage) {
      var _this;
      _$$_REQUIRE(_dependencyMap[7])(this, MediaPlayer);
      _this = _callSuper(this, MediaPlayer);
      _this.volume_ = 1.0;
      _this.muted_ = false;
      _this.defaultMuted_ = false;
      _this.playbackRate_ = 1.0;
      _this.preload_ = "auto";
      _this.autoplay_ = false;
      _this.defaultPlaybackRate_ = 1.0;
      _this.loop_ = false;
      _this.captioning_ = false;
      _this.seekIntervalInSec_ = _$$_REQUIRE(_dependencyMap[8]).DEFAULT_SEEK_SECONDS;
      _this.mSessionId = {
        id: 0
      };
      _this.mediaControlHandler = null;
      _this.mediaControlStateUtil = null;
      _this.tmoa = null;
      /**
       * https://www.w3.org/TR/encrypted-media/#htmlmediaelement-extensions
       */
      _this.attachingMediaKeys_ = false;
      _this.decryptionBlockedOnKey_ = false;
      _this.playbackBlockedOnKey_ = false;
      _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaPlayer:+constructor: audioType = ${_this.audioType_}, audioUsage = ${_this.audioUsage_}, w3cmediaVersion = ${_$$_REQUIRE(_dependencyMap[9]).W3CMEDIA_VERSION}`);
      // Initialize logging system
      (0, _$$_REQUIRE(_dependencyMap[10]).initializeLogging)();
      // Refer : https://shepherd.a2z.com/issues/d1e58029-de66-4a87-986e-25b9fee68079
      if (audioType === undefined || !Object.values(_$$_REQUIRE(_dependencyMap[11]).AudioContentType).includes(audioType)) {
        // default
        _this.audioType_ = nodeName === "audio" ? _$$_REQUIRE(_dependencyMap[11]).AudioContentType.CONTENT_TYPE_MUSIC : _$$_REQUIRE(_dependencyMap[11]).AudioContentType.CONTENT_TYPE_MOVIE;
      } else {
        _this.audioType_ = audioType;
      }
      if (audioUsage === undefined || !Object.values(_$$_REQUIRE(_dependencyMap[11]).AudioUsageType).includes(audioUsage)) {
        _this.audioUsage_ = _$$_REQUIRE(_dependencyMap[11]).AudioUsageType.USAGE_MEDIA; // default
      } else {
        _this.audioUsage_ = audioUsage;
      }
      _this.surfaceHandle = null;
      _this.captionViewHandle = null;
      _this.mediaElement = null;
      _this.mediaElementEventRouter = null;
      _this.eventEmitter = new (_$$_REQUIRE(_dependencyMap[12]).MediaEventEmitterImpl)();
      _this.nodeName_ = nodeName;
      _this.src_ = "";
      _this.audioTrackList = new (_$$_REQUIRE(_dependencyMap[13]).AudioTrackListImpl)();
      _this.videoTrackList = new (_$$_REQUIRE(_dependencyMap[14]).VideoTrackListImpl)();
      _this.textTrackList = new (_$$_REQUIRE(_dependencyMap[15]).TextTrackListImpl)();
      var mediaEventSource = W3CMediaTurboModule_1.default.getMediaEventSource();
      _this.MEDIA_EVENT_SOURCE_AUDIO_TRACKLIST = mediaEventSource.AUDIO_TRACKLIST;
      _this.MEDIA_EVENT_SOURCE_HTMLMEDIAELEMENT = mediaEventSource.HTMLMEDIAELEMENT;
      _this.MEDIA_EVENT_SOURCE_VIDEO_TRACKLIST = mediaEventSource.VIDEO_TRACKLIST;
      _this.MEDIA_EVENT_SOURCE_TEXT_TRACKLIST = mediaEventSource.TEXT_TRACKLIST;
      _this.trackListEventHandler = new (_$$_REQUIRE(_dependencyMap[16]).TrackListEventHandler)();
      _this.newlyIntroducedCues = new Set();
      // assign the session ID to mediaControlSessionID
      _this.mSessionId.id = MediaPlayer.mediaSessionID_;
      // create MediaControlStateUtils by default
      _this.mediaControlStateUtil = new (_$$_REQUIRE(_dependencyMap[17]).MediaControlStateUtil)(_this);
      //mediaControlSessionMapTable.set(this.mSessionId.id, mediaControlStateUtil);
      // increase the session ID associated with MP instance
      MediaPlayer.mediaSessionID_++;
      _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaPlayer:-constructor`);
      return _this;
    }
    /**
     * @hidden
     * Configure the App client componentinstance which is using MediaPlayer.
     */
    _$$_REQUIRE(_dependencyMap[18])(MediaPlayer, _HTMLMediaElement_1$H);
    return _$$_REQUIRE(_dependencyMap[19])(MediaPlayer, [{
      key: "setMediaControlFocus",
      value: (function () {
        var _setMediaControlFocus = _$$_REQUIRE(_dependencyMap[4])(function* (componentInstance, mediaControlHandler) {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaPlayer: componentInstance:  = ${componentInstance.name}, type = ${componentInstance.type} id = ${componentInstance.id}`);
          // check if manifest is parsed either by init() or need to parse
          var isPackageParsed = yield parseClientPackageManifest();
          /*
           * Set the component instance to enable Kepler Media Controls by default to handle pause,
           * play and seek commands. If component instance is not set, app is expected to handle Kepler
           * Media Controls.
           * For further details please see
           * https://developer.amazon.com/docs/kepler-tv/media-controls-guide.html
          */
          /* validate the component instance configured by App client with parsed manifest components.
           *
           * 1. If KMC category not found during manifest parsing.
           *    i.  legacy mode i.e PlayerSession based media control will be enabled via W3cMedia.
           * 2. If componentInstance is configured by AppClient and KMC category found in parsing
           *   i.   default mode i.e KMC interface will be enabled via W3cMedia.
           *   ii.  Basic media controls (play/pause/seek/playbackspeed/startover) will provided by W3cMedia.
           *   iii. Server state / capabilities etc.. will be updated by W3cMedia.
           *   iii. W3cMedia will provide an option to override the mediacontrolhandler and let AppClient
           *        choose to implement override APIs (handleplay/handlepasue etc).
           *   iv.  App clients choose to override mediacontrolhandler are considered to be semi-advance mode :).
           * 3. If componentInstance is not configured and KMC category is present in manifest,
           *   i. This is considered as Advanced Mode of MediaControls where App Client has to handle
           *      all KMC features by itself. W3cMedia will have no role to handle any media control commands
          */
          // validate the componentinstance and type
          if (isPackageParsed && componentInstance.type === _$$_REQUIRE(_dependencyMap[20]).ComponentType.INTERACTIVE) {
            if (_$$_REQUIRE(_dependencyMap[6]).appClientKMCMapTable.get(componentInstance.name) === true) {
              var _this$mediaControlSta, _this$mediaControlHan;
              // Check if Client has opt-in for media control or opt-out
              if (mediaControlHandler === undefined || mediaControlHandler === null) {
                _$$_REQUIRE(_dependencyMap[5]).LogUtil.info("MediaPlayer:  App client opted for default mediacontrols.");
                this.mediaControlHandler = new (_$$_REQUIRE(_dependencyMap[21]).KeplerMediaControlHandler)();
              } else {
                this.mediaControlHandler = mediaControlHandler;
                _$$_REQUIRE(_dependencyMap[5]).LogUtil.info("MediaPlayer: App client may override mediacontrols.");
              }
              // get KMC server
              this.mediaControlServer = _$$_REQUIRE(_dependencyMap[22]).MediaControlServerComponentAsync.getOrMakeServer();
              // configure the KMC event callback handler
              this.mediaControlServer.setHandlerForComponent(this.mediaControlHandler, componentInstance);
              // configure the controlserver.
              (_this$mediaControlSta = this.mediaControlStateUtil) == null ? undefined : _this$mediaControlSta.setMediaControlServer(this.mediaControlServer);
              // configure the mediaplayer to handler.
              (_this$mediaControlHan = this.mediaControlHandler) == null ? undefined : _this$mediaControlHan.setMediaPlayer(this);
              _$$_REQUIRE(_dependencyMap[5]).LogUtil.info("MediaPlayer: Initializing MediaControlHandler done.");
            } else {
              _$$_REQUIRE(_dependencyMap[5]).LogUtil.warn("MediaPlayer: KMC interface not build as component does not declared KMC category in manifest");
            }
          } else {
            _$$_REQUIRE(_dependencyMap[5]).LogUtil.warn("MediaPlayer: KMC interface not build as component is non-interactive");
          }
          Promise.resolve();
        });
        function setMediaControlFocus(_x, _x2) {
          return _setMediaControlFocus.apply(this, arguments);
        }
        return setMediaControlFocus;
      }()
      /**
       * @hidden
       */
      )
    }, {
      key: "initialize",
      value: (function () {
        var _initialize = _$$_REQUIRE(_dependencyMap[4])(function* () {
          var _this2 = this;
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaPlayer: initialize: audioType = ${this.audioType_}, audioUsage = ${this.audioUsage_}`);
          // check if manifest is parsed either by setupMediaControlComponentInstance() or need to parse
          var isPackageParsed = yield parseClientPackageManifest();
          return new Promise(function (resolve, reject) {
            if (_this2.mediaElement) {
              _$$_REQUIRE(_dependencyMap[5]).LogUtil.info("MediaPlayer: Media Element already created..skipping");
              resolve();
              return;
            }
            // check if KMC category is enabled in Manifest , if not create legacy mode (playersessionclient)
            if (isPackageParsed) {
              for (var clientKMCComponent of _$$_REQUIRE(_dependencyMap[6]).appClientKMCMapTable.values()) {
                if (clientKMCComponent === true) {
                  MediaPlayer.isPlayerSessionEnabled = false;
                  break;
                }
              }
            } else {
              _$$_REQUIRE(_dependencyMap[5]).LogUtil.warn("MediaPlayer: Package parsing was not done");
            }
            // Init the playerSessionClient in case of legacy mediacontrols
            if (MediaPlayer.isPlayerSessionEnabled === true && MediaPlayer.playerSessionClient === null) {
              var _MediaPlayer$playerSe;
              MediaPlayer.playerSessionClient = new (_$$_REQUIRE(_dependencyMap[23]).PlayerSessionClient)();
              (_MediaPlayer$playerSe = MediaPlayer.playerSessionClient) == null ? undefined : _MediaPlayer$playerSe.initialize();
              _$$_REQUIRE(_dependencyMap[5]).LogUtil.info("MediaPlayer: Initializing PlayerSessionClient done.");
            }
            var config = W3CMediaTurboModule_1.default.newMediaElementConfig();
            W3CMediaTurboModule_1.default.setWaitForAudioToCompleteSeek(config, false);
            W3CMediaTurboModule_1.default.setAudioConfig(config, _this2.audioType_, _this2.audioUsage_);
            W3CMediaTurboModule_1.default.newMediaElement(config, function (nativeMediaElement) {
              _$$_REQUIRE(_dependencyMap[5]).LogUtil.info("MediaPlayer: Native Media Element Created");
              var eventRouter_ = new (_$$_REQUIRE(_dependencyMap[24]).MediaElementEventRouter)(nativeMediaElement);
              eventRouter_.registerHTMLMediaElement(_this2);
              _this2.mediaElement = nativeMediaElement;
              _this2.mediaElementEventRouter = eventRouter_;
              // see if legacy mode is enabled
              if (MediaPlayer.isPlayerSessionEnabled) {
                var _MediaPlayer$playerSe2, _MediaPlayer$playerSe3;
                (_MediaPlayer$playerSe2 = MediaPlayer.playerSessionClient) == null ? undefined : _MediaPlayer$playerSe2.setMediaPlayer(_this2);
                (_MediaPlayer$playerSe3 = MediaPlayer.playerSessionClient) == null ? undefined : _MediaPlayer$playerSe3.setDefaultSeekIntervalInSec(_this2.seekIntervalInSec_);
                // clear the KMC Map table as legacy mode is enabled
                // @TODO Do we need to free MediaControlStateUtil? let garbage collector do the job.
                // just settle with clearing the map table.
                _$$_REQUIRE(_dependencyMap[6]).mediaControlSessionMapTable.clear();
                _$$_REQUIRE(_dependencyMap[6]).appClientKMCMapTable.clear();
              }
              if (_this2.surfaceHandle !== undefined && _this2.surfaceHandle !== null) {
                _$$_REQUIRE(_dependencyMap[5]).LogUtil.debug("MediaPlayer: setSurface.");
                W3CMediaTurboModule_1.default.setSurface(_this2.mediaElement, _this2.surfaceHandle);
              }
              if (_this2.captionViewHandle !== undefined && _this2.captionViewHandle !== null) {
                _$$_REQUIRE(_dependencyMap[5]).LogUtil.debug("MediaPlayer: setCaptionConsumer.");
                W3CMediaTurboModule_1.default.setCaptionConsumer(_this2.mediaElement, _this2.captionViewHandle);
              }
              // set the audio stream mute/unmute
              if (_this2.defaultMuted_ || _this2.muted_) {
                _$$_REQUIRE(_dependencyMap[5]).LogUtil.debug("MediaPlayer: muteAudio");
                W3CMediaTurboModule_1.default.muteAudio(_this2.mediaElement);
              }
              // set the stream volume if not 1.0
              if (_this2.volume_ !== 1.0) {
                _$$_REQUIRE(_dependencyMap[5]).LogUtil.debug("MediaPlayer: setVolumeLevel");
                W3CMediaTurboModule_1.default.setVolumeLevel(_this2.mediaElement, _this2.volume_);
              }
              // set playback rate if not 1.0
              if (_this2.playbackRate_ !== 1.0) {
                _$$_REQUIRE(_dependencyMap[5]).LogUtil.debug("MediaPlayer: playbackRate_:setPlaybackRate");
                W3CMediaTurboModule_1.default.setPlaybackRate(_this2.mediaElement, _this2.playbackRate_);
              } else if (_this2.defaultPlaybackRate_ !== 1.0) {
                _$$_REQUIRE(_dependencyMap[5]).LogUtil.debug("MediaPlayer: defaultPlaybackRate_:setPlaybackRate");
                W3CMediaTurboModule_1.default.setPlaybackRate(_this2.mediaElement, _this2.defaultPlaybackRate_);
              }
              _$$_REQUIRE(_dependencyMap[5]).LogUtil.info("MediaPlayer: Native Media Element Resolve now..");
              resolve();
            });
          });
        });
        function initialize() {
          return _initialize.apply(this, arguments);
        }
        return initialize;
      }()
      /**
       * @hidden
       */
      )
    }, {
      key: "deinitialize",
      value: function deinitialize() {
        var _this$mediaElementEve,
          _this3 = this;
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info("MediaPlayer: deinitialize");
        (_this$mediaElementEve = this.mediaElementEventRouter) == null ? undefined : _this$mediaElementEve.deregisterMediaElement();
        if (MediaPlayer.isPlayerSessionEnabled) {
          var _MediaPlayer$playerSe4;
          (_MediaPlayer$playerSe4 = MediaPlayer.playerSessionClient) == null ? undefined : _MediaPlayer$playerSe4.clearMediaPlayer(this);
        } else if (this.mediaControlHandler) {
          var _this$mediaControlSta2;
          (_this$mediaControlSta2 = this.mediaControlStateUtil) == null ? undefined : _this$mediaControlSta2.clearMediaPlayer(this);
        }
        return new Promise(function (resolve, reject) {
          if (_this3.mediaElement) {
            _$$_REQUIRE(_dependencyMap[5]).LogUtil.info("MediaPlayer: destroying media element asynchronously");
            W3CMediaTurboModule_1.default.destroy(_this3.mediaElement, function () {
              _$$_REQUIRE(_dependencyMap[5]).LogUtil.info("MediaPlayer: MediaElement destroyed");
              _this3.mediaElement = null;
              resolve();
            });
            return;
          }
          reject();
        });
      }
      /**
       * @hidden
       */
    }, {
      key: "deinitializeSync",
      value: function deinitializeSync(timeoutInMs) {
        var _this$mediaElementEve2;
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info("MediaPlayer: ++ deinitializeSync");
        (_this$mediaElementEve2 = this.mediaElementEventRouter) == null ? undefined : _this$mediaElementEve2.deregisterMediaElement();
        if (MediaPlayer.isPlayerSessionEnabled) {
          var _MediaPlayer$playerSe5;
          (_MediaPlayer$playerSe5 = MediaPlayer.playerSessionClient) == null ? undefined : _MediaPlayer$playerSe5.clearMediaPlayer(this);
        } else if (this.mediaControlHandler) {
          var _this$mediaControlSta3;
          (_this$mediaControlSta3 = this.mediaControlStateUtil) == null ? undefined : _this$mediaControlSta3.clearMediaPlayer(this);
        }
        if (this.mediaElement) {
          var status = W3CMediaTurboModule_1.default.destroySync(this.mediaElement, timeoutInMs);
          this.mediaElement = null;
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.info("MediaPlayer: -- deinitializeSync");
          return status;
        }
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.warn("MediaPlayer: not a valid MediaElement to deinit");
        return "invalid";
      }
      // EventTarget APIs
      /**
       * @hidden
       * Adds a event listener
       */
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        var _this$eventEmitter;
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaPlayer:addEventListener: ${type}`);
        (_this$eventEmitter = this.eventEmitter) == null ? undefined : _this$eventEmitter.addEventListener(type, listener);
      }
      /**
       * @hidden
       * Removes event listener
       */
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        var _this$eventEmitter2;
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaPlayer:removeEventListener: ${type}`);
        (_this$eventEmitter2 = this.eventEmitter) == null ? undefined : _this$eventEmitter2.removeEventListener(type, listener);
      }
      /**
       * @hidden
       */
    }, {
      key: "nodeName",
      get: function get() {
        return this.nodeName_;
      }
      /**
       * @hidden
       */
    }, {
      key: "src",
      get:
      /**
       * @hidden
       */
      function get() {
        return this.src_;
      }
      /**
       * @hidden
       */,
      set: function set(url) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`Src URL`);
        var blobUrlPrefix = "blob:///";
        var isBlob = url.startsWith(blobUrlPrefix);
        if (isBlob) {
          // most likely mse
          // extract the index from url blob:///xxxx?offset=0&size=0
          var endIndex = url.indexOf('?');
          var mediaSourceId = url.slice(blobUrlPrefix.length, endIndex);
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.debug(`MediaPlayer: mediaSourceId = ${mediaSourceId}`);
          var mediaSourceIdKey = parseInt(mediaSourceId, 10);
          var ms = _$$_REQUIRE(_dependencyMap[25]).GlobalMediaSources.get(mediaSourceIdKey);
          if (ms === null || ms === undefined) {
            _$$_REQUIRE(_dependencyMap[5]).LogUtil.error('invalid media source!!!');
            return;
          }
          // now trigger the setter on srcObject
          this.srcObject = ms;
          // Now we should remove the entry from the global map, oherwise,
          // the MediaSource instance will never get reclaimed by JS VM's Garbage Collector
          // when all other references are removed.
          _$$_REQUIRE(_dependencyMap[25]).GlobalMediaSources.delete(mediaSourceIdKey);
        } else {
          this.src_ = url;
          if (!this.mediaElement) {
            _$$_REQUIRE(_dependencyMap[5]).LogUtil.warn("MediaPlayer: media element not found...skipping set src");
            return;
          }
          // we assume that autoPlay is set before src
          W3CMediaTurboModule_1.default.setSrc(this.mediaElement, url, this.autoplay_);
        }
        this.decryptionBlockedOnKey_ = false;
        this.playbackBlockedOnKey_ = false;
      }
      /**
       * @hidden
       */
    }, {
      key: "defaultSeekIntervalInSec",
      get:
      /**
       * @hidden
       */
      function get() {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.debug(`MediaPlayer: defaultSeekIntervalInSec: ${this.seekIntervalInSec_}`);
        return this.seekIntervalInSec_;
      },
      set: function set(seekInterval) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.debug(`MediaPlayer: defaultSeekIntervalInSec: ${seekInterval}`);
        if (seekInterval && Number.isInteger(seekInterval) && seekInterval > 0) {
          this.seekIntervalInSec_ = seekInterval;
          if (MediaPlayer.isPlayerSessionEnabled) {
            var _MediaPlayer$playerSe6;
            (_MediaPlayer$playerSe6 = MediaPlayer.playerSessionClient) == null ? undefined : _MediaPlayer$playerSe6.setDefaultSeekIntervalInSec(this.seekIntervalInSec_);
          } else if (this.mediaControlHandler) {
            var _this$mediaControlSta4;
            (_this$mediaControlSta4 = this.mediaControlStateUtil) == null ? undefined : _this$mediaControlSta4.setDefaultSeekIntervalInSec(this.seekIntervalInSec_);
          }
        }
      }
    }, {
      key: "srcObject",
      set: function set(srcObj) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info('MediaPlayer: setting srcObject');
        srcObj.setMediaEventRouter(this.mediaElementEventRouter);
        srcObj.setMediaElementHandle(this.mediaElement);
      }
      /**
       * @hidden
       */
    }, {
      key: "error",
      get: function get() {
        if (!this.mediaElement) {
          return null;
        }
        var err = W3CMediaTurboModule_1.default.getError(this.mediaElement);
        if (err.type === 0) {
          return null;
        }
        return new (_$$_REQUIRE(_dependencyMap[26]).MediaErrorImpl)(err.type, err.error_message);
      }
      /**
       * @hidden
       */
    }, {
      key: "currentSrc",
      get: function get() {
        return this.src_;
      }
      /**
       * @hidden
       */
    }, {
      key: "networkState",
      get: function get() {
        // TODO: Not supported by NFP
        return 0;
      }
      /**
       * @hidden
       */
    }, {
      key: "buffered",
      get: function get() {
        if (!this.mediaElement) {
          return new (_$$_REQUIRE(_dependencyMap[27]).TimeRangesImpl)(null);
        }
        return new (_$$_REQUIRE(_dependencyMap[27]).TimeRangesImpl)(W3CMediaTurboModule_1.default.getBuffered(this.mediaElement));
      }
      /**
       * @hidden
       */
    }, {
      key: "load",
      value: function load() {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaPlayer: load`);
        if (!this.mediaElement || !this.src_) {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.warn("not loading as media element not ready or src_ is not set");
          return;
        }
        W3CMediaTurboModule_1.default.load(this.mediaElement);
        this.decryptionBlockedOnKey_ = false;
        this.playbackBlockedOnKey_ = false;
      }
      /**
       *@hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-navigator-canplaytype
       * @param type mime type
       */
    }, {
      key: "canPlayType",
      value: function canPlayType(type) {
        return W3CMediaTurboModule_1.default.canPlayType(this.mediaElement, type);
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-readystate
       */
    }, {
      key: "readyState",
      get: function get() {
        if (!this.mediaElement) {
          return 0;
        }
        return W3CMediaTurboModule_1.default.getReadyState(this.mediaElement);
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-seeking
       */
    }, {
      key: "seeking",
      get: function get() {
        if (!this.mediaElement) {
          return false;
        }
        return W3CMediaTurboModule_1.default.getSeeking(this.mediaElement);
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-fastseek
       */
    }, {
      key: "fastSeek",
      value: function fastSeek(time) {
        if (!this.mediaElement) {
          return;
        }
        W3CMediaTurboModule_1.default.seek(this.mediaElement, time);
        this.decryptionBlockedOnKey_ = false;
        this.playbackBlockedOnKey_ = false;
      }
      /**
       * @hidden
       *  https://html.spec.whatwg.org/multipage/media.html#dom-media-duration
       */
    }, {
      key: "duration",
      get: function get() {
        if (!this.mediaElement) {
          return NaN;
        }
        return W3CMediaTurboModule_1.default.getDuration(this.mediaElement);
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-getstartdate
       */
    }, {
      key: "getStartDate",
      value: function getStartDate() {
        // TODO: NFP doesn't support this yet.
        return new Date();
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-paused
       */
    }, {
      key: "paused",
      get: function get() {
        if (!this.mediaElement) {
          return true;
        }
        return W3CMediaTurboModule_1.default.getPaused(this.mediaElement);
      }
      /**
       * @hidden
       *
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-played
       */
    }, {
      key: "played",
      get: function get() {
        // TODO: NFP doesn't support this
        return new (_$$_REQUIRE(_dependencyMap[27]).TimeRangesImpl)(null);
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-seekable
       */
    }, {
      key: "seekable",
      get: function get() {
        if (!this.mediaElement) {
          return new (_$$_REQUIRE(_dependencyMap[27]).TimeRangesImpl)(null);
        }
        return new (_$$_REQUIRE(_dependencyMap[27]).TimeRangesImpl)(W3CMediaTurboModule_1.default.getSeekable(this.mediaElement));
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-ended
       */
    }, {
      key: "ended",
      get: function get() {
        if (!this.mediaElement) {
          return false;
        }
        return W3CMediaTurboModule_1.default.getEnded(this.mediaElement);
      }
      /**
       * @hidden
       *  https://html.spec.whatwg.org/multipage/media.html#dom-media-play
       */
    }, {
      key: "play",
      value: function play() {
        var _this4 = this;
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info("MediaPlayer: play");
        return new Promise(function (resolve, reject) {
          if (_this4.mediaElement) {
            W3CMediaTurboModule_1.default.play(_this4.mediaElement);
            _$$_REQUIRE(_dependencyMap[5]).LogUtil.info("MediaPlayer:play resolved");
            resolve();
          }
          reject();
        });
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-pause
       */
    }, {
      key: "pause",
      value: function pause() {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info("MediaPlayer: pause");
        if (this.mediaElement) {
          W3CMediaTurboModule_1.default.pause(this.mediaElement);
        }
      }
      /**
       * @hidden
      * https://html.spec.whatwg.org/multipage/media.html#dom-media-audiotracks
      */
    }, {
      key: "audioTracks",
      get: function get() {
        return this.audioTrackList;
      }
      /**
       * @hidden
      *  https://html.spec.whatwg.org/multipage/media.html#dom-media-videotracks
      */
    }, {
      key: "videoTracks",
      get: function get() {
        return this.videoTrackList;
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-texttracks
       */
    }, {
      key: "textTracks",
      get: function get() {
        return this.textTrackList;
      }
      /**
       * @hidden
       * @brief https://html.spec.whatwg.org/multipage/media.html#dom-media-addtexttrack
       * @param kind The kind attribute must return the text track kind of the text track that the TextTrack object represents.
       * @param label The label attribute must return the text track label of the text track that the TextTrack object represents.
       * @param language The language attribute must return the text track language of the text track that the TextTrack object represents.
       * @param uri The uri attribute must return the uri of the out of band subtitle of the text track that the TextTrack object represents.
       * This is a custom addition (not as per w3c spec). If uri is provided, this component will take care of parsing and rendering subtitles.
       * @param mimeType The mimeType attribute must return the mime type of the out of band subtitle of the text track that the TextTrack
       * object represents. This is a custom addition (not as per w3c spec).
       */
    }, {
      key: "addTextTrack",
      value: function addTextTrack(kind, label, language, uri, mimeType) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.debug(`MediaPlayer:+addtexttrack ${kind} ${label} ${language} ${uri} ${mimeType}`);
        if (kind && kind != 'subtitles' && kind != 'captions' && kind != 'metadata') {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.warn('Only `subtitles` or `captions` or `metadata` kind of TextTracks are supported');
          return null;
        }
        var track = new (_$$_REQUIRE(_dependencyMap[28]).TextTrackImpl)(this, this.mediaElement, null, kind, label != null ? label : "", language != null ? language : "", uri != null ? uri : "", mimeType != null ? mimeType : "");
        this.textTrackList.addTrack(track);
        if (!this.tmoa && track.id.startsWith(_$$_REQUIRE(_dependencyMap[28]).TextTrackImpl.JS_TRACK_ID_PREFIX)) {
          this.tmoa = new (_$$_REQUIRE(_dependencyMap[29]).TimeMarchesOnAlgo)();
        }
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.debug(`MediaPlayer:-addtexttrack num of tracks ${this.textTrackList.length}`);
        return track;
      }
      /**
       * TextTrackManager Should take care of these
       * @param cue
       */
    }, {
      key: "addCue",
      value: function addCue(cue) {
        this.newlyIntroducedCues.add(cue);
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.debug(`MediaPlayer:addCue ${cue.id} and runTMOAAlgo`);
        this.triggerTMOAIfNeeded(cue);
      }
    }, {
      key: "removeCue",
      value: function removeCue(cue) {
        if (!this.newlyIntroducedCues.delete(cue)) {
          var _this$tmoa;
          var wasCueActive = cue.isActive;
          (_this$tmoa = this.tmoa) == null ? undefined : _this$tmoa.removeCue(cue);
          if (wasCueActive) {
            // It is an actively rendered cue. Run TMO Algo immediately.
            this.runTMOAlgo();
          }
        }
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.debug(`MediaPlayer:removeCue ${cue.id} and runTMOAAlgo`);
        this.triggerTMOAIfNeeded(cue);
      }
    }, {
      key: "triggerTMOAIfNeeded",
      value: function triggerTMOAIfNeeded(cue) {
        var _this$tmoa2;
        var refPos = 0;
        refPos = (_this$tmoa2 = this.tmoa) == null ? undefined : _this$tmoa2.getLastRunPosition();
        // @TODO query it dynamically from the MediaElement
        var margin = 0.25;
        if (cue.startTime >= refPos && cue.startTime < refPos + margin || cue.endTime >= refPos && cue.endTime < refPos + margin) {
          this.runTMOAlgo();
        }
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#attr-media-preload
       */
    }, {
      key: "preload",
      get: function get() {
        return this.preload_;
      }
      /**
       * @hidden
       */,
      set: function set(preload) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaPlayer: setter preload ${preload}`);
        this.preload_ = preload;
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-currenttime
       */
    }, {
      key: "currentTime",
      get: function get() {
        if (this.mediaElement === null) {
          return NaN;
        }
        var pos = W3CMediaTurboModule_1.default.getCurrentTime(this.mediaElement);
        return pos;
      }
      /**
       * @hidden
       */,
      set: function set(time) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.debug(`MediaPlayer: set currentTime ${time}`);
        W3CMediaTurboModule_1.default.seek(this.mediaElement, time);
        this.decryptionBlockedOnKey_ = false;
        this.playbackBlockedOnKey_ = false;
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-defaultplaybackrate
       */
    }, {
      key: "defaultPlaybackRate",
      get: function get() {
        return this.defaultPlaybackRate_;
      }
      /**
       * @hidden
       */,
      set: function set(rate) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.debug(`MediaPlayer: set defaultPlaybackRate ${rate}`);
        this.defaultPlaybackRate_ = rate;
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-playbackrate
       */
    }, {
      key: "playbackRate",
      get: function get() {
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.warn("MediaPlayer: MediaElement is not available...default returns");
          return this.defaultPlaybackRate_;
        }
        this.playbackRate_ = W3CMediaTurboModule_1.default.getPlaybackRate(this.mediaElement);
        return this.playbackRate_;
      }
      /**
       * @hidden
       */,
      set: function set(rate) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.debug(`MediaPlayer: set playbackRate ${rate}`);
        this.playbackRate_ = rate;
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.warn("MediaPlayer: MediaElement is not available, cache the playbackrate value for now");
          return;
        }
        W3CMediaTurboModule_1.default.setPlaybackRate(this.mediaElement, rate);
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-preservespitch
       * @note Not implemented
       */
    }, {
      key: "autoplay",
      get:
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-autoplay
       */
      function get() {
        return this.autoplay_;
      }
      /**
       * @hidden
       */,
      set: function set(autoplay) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaPlayer: set autoplay ${autoplay}`);
        this.autoplay_ = autoplay;
        if (this.autoplay_) {
          this.play();
        }
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-loop
       */
    }, {
      key: "loop",
      get: function get() {
        return this.loop_;
      }
      /**
       * @hidden
       */,
      set: function set(loop) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaPlayer: set loop ${loop}`);
        this.loop_ = loop;
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-volume
       */
    }, {
      key: "volume",
      get: function get() {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaPlayer: get volume`);
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.warn("MediaPlayer: MediaElement is not available...default returns");
          return this.volume_;
        }
        this.volume_ = W3CMediaTurboModule_1.default.getVolumeLevel(this.mediaElement);
        return this.volume_;
      }
      /**
       * @hidden
       */,
      set: function set(volume) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaPlayer: set volume ${volume}`);
        this.volume_ = volume;
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.warn("MediaPlayer: MediaElement is not available, cache the volume value for now");
          return;
        }
        W3CMediaTurboModule_1.default.setVolumeLevel(this.mediaElement, volume);
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-muted
       */
    }, {
      key: "muted",
      get: function get() {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaPlayer: get muted`);
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.warn("MediaPlayer: media element not found...default returns");
          return this.defaultMuted_;
        }
        this.muted_ = W3CMediaTurboModule_1.default.isAudioMuted(this.mediaElement);
        return this.muted_;
      }
      /**
       * @hidden
       */,
      set: function set(muted) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaPlayer: set muted ${muted}`);
        this.muted_ = muted;
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.warn("MediaPlayer: MediaElement is not available, cache the mute value for now");
          return;
        }
        if (muted) {
          W3CMediaTurboModule_1.default.muteAudio(this.mediaElement);
        } else {
          W3CMediaTurboModule_1.default.unMuteAudio(this.mediaElement);
        }
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-defaultmuted
       */
    }, {
      key: "defaultMuted",
      get: function get() {
        return this.defaultMuted_;
      }
      /**
       * @hidden
       */,
      set: function set(defaultMuted) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaPlayer: set defaultMuted ${defaultMuted}`);
        this.defaultMuted_ = defaultMuted;
      }
      /**
       * @hidden
       */
    }, {
      key: "setMediaKeys",
      value: function setMediaKeys(mediaKeys) {
        var _this5 = this;
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaPlayer: setMediaKeys`, mediaKeys ? mediaKeys : null);
        return new Promise(function (resolve, reject) {
          if (!_this5.mediaElement) {
            _$$_REQUIRE(_dependencyMap[5]).LogUtil.error(`MediaPlayer: Invalid State. Media Element not inittialized`);
            reject();
          }
          if (mediaKeys) {
            _this5.mediaKeys = mediaKeys;
            var tmp = mediaKeys;
            var nmk = tmp.getnmk();
            if (nmk !== null) {
              W3CMediaTurboModule_1.default.setMediaKeys(_this5.mediaElement, nmk);
            }
          }
          resolve();
        });
      }
      /**
       * @hidden
       * Handle all media element and audio/video track list events.
       */
    }, {
      key: "handleEvent",
      value: function handleEvent(event) {
        // validate the event sent from native
        if (event) {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.debug(`MediaPlayer: handleEvent src = ${event.src}, event = ${event.name}`);
          switch (event.src) {
            case this.MEDIA_EVENT_SOURCE_AUDIO_TRACKLIST:
              {
                this.trackListEventHandler.handleAudioTrackListEvent(event, this.audioTrackList, this.mediaElement);
              }
              break;
            case this.MEDIA_EVENT_SOURCE_VIDEO_TRACKLIST:
              {
                this.trackListEventHandler.handleVideoTrackListEvent(event, this.videoTrackList, this.mediaElement);
              }
              break;
            case this.MEDIA_EVENT_SOURCE_TEXT_TRACKLIST:
              {
                this.trackListEventHandler.handleTextTrackListEvent(event, this.textTrackList, this.mediaElement);
              }
              break;
            default:
              {
                _$$_REQUIRE(_dependencyMap[5]).LogUtil.debug(`MediaPlayer:handleEvent: emit event ${event.name}`);
                if (event.name === 'play' || event.name === 'timeupdate') {
                  /**
                   * Relying on native side events, for hooking into the sequences being run on the native side.
                   * This is not the ideal place, as the algo should run before firing this event
                   * It is already late, so let us run TMOA first.
                   * Moreover, we should take the startTime of the next cue and then schedule it.
                   * */
                  this.runTMOAlgo();
                }
                if (event.name === 'encrypted') {
                  var typedInit = ArrayBuffer.isView(event.buffer) ? new Uint8Array(event.buffer.buffer, event.buffer.byteOffset, event.buffer.byteLength) : new Uint8Array(event.buffer);
                  var base64Init = base64js.fromByteArray(typedInit);
                  _$$_REQUIRE(_dependencyMap[5]).LogUtil.debug(`MediaPlayer:handleEvent: Player initType ${event.init_type} initData = ${base64Init}`);
                  this.eventEmitter.emit(event.name, new (_$$_REQUIRE(_dependencyMap[30]).MediaEncryptedEvent)(event.name, this, event.init_type, event.buffer));
                } else if (event.name === 'ended' && this.loop_ === true) {
                  _$$_REQUIRE(_dependencyMap[5]).LogUtil.debug(`MediaPlayer:handleEvent: looping`);
                  this.play();
                } else {
                  this.eventEmitter.emit(event.name, new (_$$_REQUIRE(_dependencyMap[30]).Event)(event.name, this));
                }
              }
              break;
          }
        } else {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.error(`MediaPlayer: handleEvent invalid event passed to JS `);
        }
      }
      /**
       * @brief Sets the captions view handle to the player.
       * @param[in] captionViewHandle Handle to the captions view.
       */
    }, {
      key: "setCaptionViewHandle",
      value: function setCaptionViewHandle(captionViewHandle) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaPlayer:setCaptionViewHandle ${captionViewHandle}`);
        if (captionViewHandle !== null && captionViewHandle.length > 0) {
          this.captionViewHandle = captionViewHandle;
          if (this.mediaElement) {
            W3CMediaTurboModule_1.default.setCaptionConsumer(this.mediaElement, captionViewHandle);
          } else {
            _$$_REQUIRE(_dependencyMap[5]).LogUtil.warn("MediaPlayer: media element not found...skipping set caption for now");
          }
        } else {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.error(`MediaPlayer: invalid caption surface passed to setCaptionViewHandle`);
        }
      }
    }, {
      key: "clearCaptionViewHandle",
      value:
      /**
       * @brief Clears the captions view handle to the player.
       * @param[in] captionViewHandle Handle to the captions view.
       */
      function clearCaptionViewHandle(captionViewHandle) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaPlayer:clearCaptionViewHandle ${captionViewHandle}`);
        if (this.captionViewHandle !== null && captionViewHandle === this.captionViewHandle) {
          if (this.mediaElement) {
            W3CMediaTurboModule_1.default.clearCaptionConsumer(this.mediaElement, captionViewHandle);
          } else {
            _$$_REQUIRE(_dependencyMap[5]).LogUtil.warn("MediaPlayer: media element not found...skipping reset caption");
          }
          // reset to null.
          this.captionViewHandle = null;
        }
      }
    }, {
      key: "captioning",
      get:
      /**
       * @hidden
       */
      function get() {
        return this.captioning_;
      }
      /**
       * @hidden
       */,
      set: function set(captioning) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaPlayer: set captioning ${captioning}`);
        this.captioning_ = captioning;
        this.eventEmitter.emit("captioningchange", new (_$$_REQUIRE(_dependencyMap[30]).Event)("captioningchange", this));
      }
    }, {
      key: "runTMOAlgo",
      value: function runTMOAlgo() {
        var _this$tmoa3;
        if (!this.captionViewHandle) {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.debug(`runTMOAlgo: No captions consumer set, so skip this run`);
          return;
        }
        (_this$tmoa3 = this.tmoa) == null ? undefined : _this$tmoa3.run(this.captionViewHandle, this.currentTime, this.newlyIntroducedCues);
      }
    }]);
  }(_$$_REQUIRE(_dependencyMap[31]).HTMLMediaElement);
  MediaPlayer.playerSessionClient = null;
  MediaPlayer.isPlayerSessionEnabled = true;
  //static  isKMCEnabled: boolean = false;
  MediaPlayer.isAppManifestParsed = false;
  MediaPlayer.mediaSessionID_ = 0;
  exports.MediaPlayer = MediaPlayer;
},"afef45745b99fd25fb6a",["f391b9d534c3a6bc8659","4534eb96ece5e83c089a","71af70f51435e3e1b37b","0814a269c2fb50034991","ff7d8d645536d793bbec","1f12e7e43345228dfcad","58fc2ad6e920899fc998","3508abd8c6b891008c0d","7be972a45ac7eda0538a","8cbe917c3d0e523c2fea","dad8d5d48a2bf4b892f5","4bdd62aa245a27756882","92ad024a633394b0493f","966f939aa33c9c57d996","57be0424162b51212025","c3e5f31ce01fcbdfdc92","3b6ed7af067745bc566f","82bdb147a9dfce5d0d15","73afcd34a88a750f6d69","5533cec96f6a88041c69","89aa33ccb4236a17dc33","0b93a73a8c0720588336","50f17b882ad6b57cfe9e","bc928d93d4283a83c808","bce3d776a4d73e681b59","559b56212f65a51c1441","7f2298a3ae35e640412a","4251f58144b964061b21","d574e06103bb046b60b8","3c3fa916cfb66a71c0b6","9e1e5e085598ef3ad539","27520dc71d42ce3c8e40"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.appClientKMCMapTable = exports.mediaControlSessionMapTable = undefined;
  exports.mediaControlSessionMapTable = new Map();
  exports.appClientKMCMapTable = new Map();
},"58fc2ad6e920899fc998",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DEFAULT_SEEK_STEPS = exports.DEFAULT_SEEK_SECONDS = exports.DEFAULT_ERROR_CODE_STRING = exports.DEFAULT_ERROR_CODE = undefined;
  exports.DEFAULT_ERROR_CODE = _$$_REQUIRE(_dependencyMap[0]).ErrorCode.ERROR_APP_NONE;
  exports.DEFAULT_ERROR_CODE_STRING = 'No Error';
  exports.DEFAULT_SEEK_SECONDS = 10;
  exports.DEFAULT_SEEK_STEPS = 1;
},"7be972a45ac7eda0538a",["91f63a0279037d488e06"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * This file is auto-generated during the build process.
   * Do not modify this file directly.
   * Generated for: release environment
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.W3CMEDIA_VERSION = undefined;
  exports.W3CMEDIA_VERSION = "2.1.87";
},"8cbe917c3d0e523c2fea",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.initializeLogging = undefined;
  /*
   * Copyright 2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */

  /**
   * Initialize logging system
   *
   * This function configures the logging system based on compile-time constants.
   * It should be called during media player construction.
   */
  function initializeLogging() {
    // Determine if we're in development mode
    var isDev = false;
    // Use compile-time log level, or fall back to default based on development mode
    var logLevel = _$$_REQUIRE(_dependencyMap[0]).W3CMEDIA_LOG_LEVEL;
    if (logLevel === undefined) {
      logLevel = _$$_REQUIRE(_dependencyMap[1]).LogLevel.INFO;
      _$$_REQUIRE(_dependencyMap[1]).LogUtil.warn('No compile-time log level found, using default');
    }
    // Set the log level
    if (logLevel >= _$$_REQUIRE(_dependencyMap[1]).LogLevel.NONE && logLevel <= _$$_REQUIRE(_dependencyMap[1]).LogLevel.VERBOSE) {
      _$$_REQUIRE(_dependencyMap[1]).LogUtil.setLogLevel(logLevel);
      _$$_REQUIRE(_dependencyMap[1]).LogUtil.info(`Log level set to: ${_$$_REQUIRE(_dependencyMap[1]).LogUtil.getCurrentLogLevelName()}`);
    } else {
      // Invalid log level, use default
      var defaultLevel = _$$_REQUIRE(_dependencyMap[1]).LogLevel.INFO;
      _$$_REQUIRE(_dependencyMap[1]).LogUtil.setLogLevel(defaultLevel);
      _$$_REQUIRE(_dependencyMap[1]).LogUtil.warn(`Invalid log level: ${logLevel}, using default: ${_$$_REQUIRE(_dependencyMap[1]).LogUtil.getCurrentLogLevelName()}`);
    }
  }
  exports.initializeLogging = initializeLogging;
},"dad8d5d48a2bf4b892f5",["218ff45dfd86ad0166ff","1f12e7e43345228dfcad"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * This file is auto-generated during the build process.
   * Do not modify this file directly.
   * Generated for: release environment
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.W3CMEDIA_LOG_LEVEL = undefined;
  /**
   * Log levels:
   * 0 = None (silent)
   * 1 = Error only
   * 2 = Error + Warning
   * 3 = Error + Warning + Info
   * 4 = Error + Warning + Info + Debug
   * 5 = All (including verbose)
   */
  exports.W3CMEDIA_LOG_LEVEL = 3;
},"218ff45dfd86ad0166ff",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2022 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AudioUsageType = exports.AudioContentType = undefined;
  // temporary definition of AudioContentType and AudioUsageType till we import from audio turbo module
  /**
   *  Describes audio content types.
   */
  var AudioContentType;
  (function (AudioContentType) {
    AudioContentType[AudioContentType["CONTENT_TYPE_NONE"] = 0] = "CONTENT_TYPE_NONE";
    AudioContentType[AudioContentType["CONTENT_TYPE_SPEECH"] = 1] = "CONTENT_TYPE_SPEECH";
    AudioContentType[AudioContentType["CONTENT_TYPE_MUSIC"] = 2] = "CONTENT_TYPE_MUSIC";
    AudioContentType[AudioContentType["CONTENT_TYPE_MOVIE"] = 3] = "CONTENT_TYPE_MOVIE";
    AudioContentType[AudioContentType["CONTENT_TYPE_SONIFICATION"] = 4] = "CONTENT_TYPE_SONIFICATION";
  })(AudioContentType = exports.AudioContentType || (exports.AudioContentType = {}));
  ;
  /**
   * Describes audio usage types.
   */
  var AudioUsageType;
  (function (AudioUsageType) {
    AudioUsageType[AudioUsageType["USAGE_NONE"] = 0] = "USAGE_NONE";
    AudioUsageType[AudioUsageType["USAGE_MEDIA"] = 1] = "USAGE_MEDIA";
    AudioUsageType[AudioUsageType["USAGE_COMMUNICATION"] = 2] = "USAGE_COMMUNICATION";
    AudioUsageType[AudioUsageType["USAGE_ALARM"] = 3] = "USAGE_ALARM";
    AudioUsageType[AudioUsageType["USAGE_NOTIFICATION"] = 4] = "USAGE_NOTIFICATION";
    AudioUsageType[AudioUsageType["USAGE_ACCESSIBILITY"] = 5] = "USAGE_ACCESSIBILITY";
    AudioUsageType[AudioUsageType["USAGE_GAME"] = 6] = "USAGE_GAME";
    AudioUsageType[AudioUsageType["USAGE_NAVIGATION"] = 7] = "USAGE_NAVIGATION";
    AudioUsageType[AudioUsageType["USAGE_RING"] = 8] = "USAGE_RING";
    AudioUsageType[AudioUsageType["USAGE_VOICE_ASSISTANT"] = 9] = "USAGE_VOICE_ASSISTANT";
  })(AudioUsageType = exports.AudioUsageType || (exports.AudioUsageType = {}));
  ;
},"4bdd62aa245a27756882",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  function _callSuper(t, o, e) { return o = _$$_REQUIRE(_dependencyMap[0])(o), _$$_REQUIRE(_dependencyMap[1])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _$$_REQUIRE(_dependencyMap[0])(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  function _superPropGet(t, o, e, r) { var p = _$$_REQUIRE(_dependencyMap[2])(_$$_REQUIRE(_dependencyMap[0])(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MediaEventEmitterImpl = undefined;
  /*
   * Copyright 2022 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  /**
   * This common helper class manages event listeners and emit events. Used
   * by other components
   */
  var MediaEventEmitterImpl = /*#__PURE__*/function (_eventemitter3_1$Even) {
    function MediaEventEmitterImpl() {
      _$$_REQUIRE(_dependencyMap[3])(this, MediaEventEmitterImpl);
      return _callSuper(this, MediaEventEmitterImpl);
    }
    _$$_REQUIRE(_dependencyMap[4])(MediaEventEmitterImpl, _eventemitter3_1$Even);
    return _$$_REQUIRE(_dependencyMap[5])(MediaEventEmitterImpl, [{
      key: "addEventListener",
      value: function addEventListener(type, listener) {
        _$$_REQUIRE(_dependencyMap[6]).LogUtil.info(`MediaEventEmitterImpl:addEventListener: ${type}`);
        _superPropGet(MediaEventEmitterImpl, "addListener", this, 3)([type, listener]);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener) {
        _$$_REQUIRE(_dependencyMap[6]).LogUtil.info(`MediaEventEmitterImpl:removeEventListener: ${type}`);
        _superPropGet(MediaEventEmitterImpl, "removeListener", this, 3)([type, listener]);
      }
    }]);
  }(_$$_REQUIRE(_dependencyMap[7]).EventEmitter);
  exports.MediaEventEmitterImpl = MediaEventEmitterImpl;
},"92ad024a633394b0493f",["f391b9d534c3a6bc8659","4534eb96ece5e83c089a","ef4c2223f1078b78bd52","3508abd8c6b891008c0d","73afcd34a88a750f6d69","5533cec96f6a88041c69","1f12e7e43345228dfcad","6066b3e2bd1f5a0f80c6"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var has = Object.prototype.hasOwnProperty,
    prefix = '~';

  /**
   * Constructor to create a storage for our `EE` objects.
   * An `Events` instance is a plain object whose properties are event names.
   *
   * @constructor
   * @private
   */
  function Events() {}

  //
  // We try to not inherit from `Object.prototype`. In some engines creating an
  // instance in this way is faster than calling `Object.create(null)` directly.
  // If `Object.create(null)` is not supported we prefix the event names with a
  // character to make sure that the built-in object properties are not
  // overridden or used as an attack vector.
  //
  if (Object.create) {
    Events.prototype = Object.create(null);

    //
    // This hack is needed because the `__proto__` property is still inherited in
    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    //
    if (!new Events().__proto__) prefix = false;
  }

  /**
   * Representation of a single event listener.
   *
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
   * @constructor
   * @private
   */
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }

  /**
   * Add a listener for a given event.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} once Specify if the listener is a one-time listener.
   * @returns {EventEmitter}
   * @private
   */
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== 'function') {
      throw new TypeError('The listener must be a function');
    }
    var listener = new EE(fn, context || emitter, once),
      evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }

  /**
   * Clear event by name.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} evt The Event name.
   * @private
   */
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
  }

  /**
   * Minimal `EventEmitter` interface that is molded against the Node.js
   * `EventEmitter` interface.
   *
   * @constructor
   * @public
   */
  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }

  /**
   * Return an array listing the events for which the emitter has registered
   * listeners.
   *
   * @returns {Array}
   * @public
   */
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [],
      events,
      name;
    if (this._eventsCount === 0) return names;
    for (name in events = this._events) {
      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };

  /**
   * Return the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Array} The registered listeners.
   * @public
   */
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event,
      handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };

  /**
   * Return the number of listeners listening to a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Number} The number of listeners.
   * @public
   */
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event,
      listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };

  /**
   * Calls each of the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Boolean} `true` if the event had listeners, else `false`.
   * @public
   */
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt],
      len = arguments.length,
      args,
      i;
    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length,
        j;
      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
              args[j - 1] = arguments[j];
            }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };

  /**
   * Add a listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };

  /**
   * Add a one-time listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };

  /**
   * Remove the listeners of a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn Only remove the listeners that match this function.
   * @param {*} context Only remove the listeners that have this context.
   * @param {Boolean} once Only remove one-time listeners.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }

      //
      // Reset the array, or remove it completely if we have no more listeners.
      //
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
    }
    return this;
  };

  /**
   * Remove all listeners, or those of the specified event.
   *
   * @param {(String|Symbol)} [event] The event name.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };

  //
  // Alias methods names because people roll like that.
  //
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  //
  // Expose the prefix.
  //
  EventEmitter.prefixed = prefix;

  //
  // Allow `EventEmitter` to be imported as module namespace.
  //
  EventEmitter.EventEmitter = EventEmitter;

  //
  // Expose the module.
  //
  if ('undefined' !== typeof module) {
    module.exports = EventEmitter;
  }
},"6066b3e2bd1f5a0f80c6",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AudioTrackListImpl = undefined;
  /**
   * Proxies to support [ ] operator on AudioTrackList
   */
  var proxyHandlers = {
    get: function get(target, key) {
      if (!(key in target)) {
        return target.audioTracks[key];
      } else {
        return Reflect.get(target, key);
      }
    }
  };
  /**
   * Implement AudioTrackList interface
   */
  var AudioTrackListImpl = /*#__PURE__*/function () {
    function AudioTrackListImpl() {
      _$$_REQUIRE(_dependencyMap[0])(this, AudioTrackListImpl);
      this.audioTracks = new Array();
      this.eventEmitter = new (_$$_REQUIRE(_dependencyMap[1]).MediaEventEmitterImpl)();
      return new Proxy(this, proxyHandlers);
    }
    // AudioTrackList interface API implementation
    return _$$_REQUIRE(_dependencyMap[2])(AudioTrackListImpl, [{
      key: "length",
      get: function get() {
        return this.audioTracks.length;
      }
    }, {
      key: "onchange",
      set: function set(listener) {
        this.eventEmitter.addEventListener("change", listener);
      }
    }, {
      key: "onaddtrack",
      set: function set(listener) {
        this.eventEmitter.addEventListener("addtrack", listener);
      }
    }, {
      key: "onremovetrack",
      set: function set(listener) {
        this.eventEmitter.addEventListener("removetrack", listener);
      }
    }, {
      key: "getTrackById",
      value: function getTrackById(id) {
        if (this.audioTracks.length === 0) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`no audio tracks available`);
          return undefined;
        }
        var track = undefined;
        this.audioTracks.forEach(function (audioTrack) {
          if (audioTrack.id === id) {
            track = audioTrack;
          }
        });
        return track;
      }
      // other public APIs
      /**
       * Emits the Track list related events
       * @param eventName name of the track
       * @param audioTrack track
       */
    }, {
      key: "emitEvent",
      value: function emitEvent(eventName, audioTrack) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`AudioTrackListImpl: emitEvent ${eventName}`);
        if (eventName === "change") {
          this.eventEmitter.emit(eventName, new (_$$_REQUIRE(_dependencyMap[4]).Event)(eventName, this));
        } else {
          if (audioTrack) {
            this.eventEmitter.emit(eventName, new (_$$_REQUIRE(_dependencyMap[4]).TrackEvent)(eventName, this, audioTrack));
          } else {
            this.eventEmitter.emit(eventName, new (_$$_REQUIRE(_dependencyMap[4]).Event)(eventName, this));
          }
        }
      }
      /**
       * Adds a track to the tracks list
       */
    }, {
      key: "addTrack",
      value: function addTrack(track) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`AudioTrackListImpl: addTrack id ${track.id}`);
        this.audioTracks.push(track);
      }
    }, {
      key: "removeTrack",
      value: function removeTrack(id) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`AudioTrackListImpl: removeTrack id ${id}`);
        // find the track
        var trackIndex = undefined;
        this.audioTracks.forEach(function (audioTrack, index) {
          if (audioTrack.id === id) {
            trackIndex = index;
          }
        });
        // remove track if found
        if (trackIndex !== undefined) {
          this.audioTracks.splice(trackIndex, 1);
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`audio track id ${id} removed`);
        } else {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`audio track id ${id} not found`);
        }
      }
      // EventTarget API implementation
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`AudioTrackListImpl:addEventListener ${type}`);
        this.eventEmitter.addEventListener(type, listener);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`AudioTrackListImpl:removeEventListener ${type}`);
        this.eventEmitter.removeEventListener(type, listener);
      }
    }]);
  }();
  exports.AudioTrackListImpl = AudioTrackListImpl;
},"966f939aa33c9c57d996",["3508abd8c6b891008c0d","92ad024a633394b0493f","5533cec96f6a88041c69","1f12e7e43345228dfcad","9e1e5e085598ef3ad539"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2022 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  function _callSuper(t, o, e) { return o = _$$_REQUIRE(_dependencyMap[0])(o), _$$_REQUIRE(_dependencyMap[1])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _$$_REQUIRE(_dependencyMap[0])(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MediaEncryptedEvent = exports.TrackEvent = exports.Event = undefined;
  ;
  var Event = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[2])(function Event() {
    _$$_REQUIRE(_dependencyMap[3])(this, Event);
    if (arguments.length === 2) {
      this.type = arguments.length <= 0 ? undefined : arguments[0];
      this.target = arguments.length <= 1 ? undefined : arguments[1];
    }
  });
  exports.Event = Event;
  /**
   * https://html.spec.whatwg.org/multipage/media.html#trackevent
   */
  var TrackEvent = /*#__PURE__*/function (_Event) {
    /**
     * https://html.spec.whatwg.org/multipage/media.html#dom-trackevent-track
     */

    function TrackEvent(type, target, track) {
      var _this;
      _$$_REQUIRE(_dependencyMap[3])(this, TrackEvent);
      _this = _callSuper(this, TrackEvent, [type, target]);
      _this.track = track;
      return _this;
    }
    _$$_REQUIRE(_dependencyMap[4])(TrackEvent, _Event);
    return _$$_REQUIRE(_dependencyMap[2])(TrackEvent);
  }(Event);
  exports.TrackEvent = TrackEvent;
  var MediaEncryptedEvent = /*#__PURE__*/function (_Event2) {
    function MediaEncryptedEvent(type, target, initDataType, initData) {
      var _this2;
      _$$_REQUIRE(_dependencyMap[3])(this, MediaEncryptedEvent);
      _this2 = _callSuper(this, MediaEncryptedEvent, [type, target]);
      _this2.initDataType = initDataType;
      _this2.initData = initData;
      return _this2;
    }
    _$$_REQUIRE(_dependencyMap[4])(MediaEncryptedEvent, _Event2);
    return _$$_REQUIRE(_dependencyMap[2])(MediaEncryptedEvent);
  }(Event);
  exports.MediaEncryptedEvent = MediaEncryptedEvent;
  ;
  ;
},"9e1e5e085598ef3ad539",["f391b9d534c3a6bc8659","4534eb96ece5e83c089a","5533cec96f6a88041c69","3508abd8c6b891008c0d","73afcd34a88a750f6d69"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VideoTrackListImpl = undefined;
  /*
   * Copyright 2022 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */

  /**
   * Proxies to support [ ] operator on VideoTrackList
   */
  var proxyHandlers = {
    get: function get(target, key) {
      if (!(key in target)) {
        return target.videoTracks[key];
      } else {
        return Reflect.get(target, key);
      }
    }
  };
  /**
   * Implement VideoTrackList interface
   */
  var VideoTrackListImpl = /*#__PURE__*/function () {
    function VideoTrackListImpl() {
      _$$_REQUIRE(_dependencyMap[0])(this, VideoTrackListImpl);
      this.videoTracks = new Array();
      this.eventEmitter = new (_$$_REQUIRE(_dependencyMap[1]).MediaEventEmitterImpl)();
      return new Proxy(this, proxyHandlers);
    }
    // EventTarget API implementation
    return _$$_REQUIRE(_dependencyMap[2])(VideoTrackListImpl, [{
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`VideoTrackListImpl:addEventListener ${type}`);
        this.eventEmitter.addEventListener(type, listener);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`VideoTrackListImpl:removeEventListener ${type}`);
        this.eventEmitter.removeEventListener(type, listener);
      }
      // VideoTrackList interface API implementation
    }, {
      key: "length",
      get: function get() {
        return this.videoTracks.length;
      }
    }, {
      key: "selectedIndex",
      get: function get() {
        return 0;
      }
    }, {
      key: "onchange",
      set: function set(listener) {
        this.eventEmitter.addEventListener("change", listener);
      }
    }, {
      key: "onaddtrack",
      set: function set(listener) {
        this.eventEmitter.addEventListener("addtrack", listener);
      }
    }, {
      key: "onremovetrack",
      set: function set(listener) {
        this.eventEmitter.addEventListener("removetrack", listener);
      }
    }, {
      key: "getTrackById",
      value: function getTrackById(id) {
        if (this.videoTracks.length === 0) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`VideoTrackListImpl: no video tracks available`);
          return undefined;
        }
        var track = undefined;
        this.videoTracks.forEach(function (videoTrack) {
          if (videoTrack.id === id) {
            track = videoTrack;
          }
        });
        return track;
      }
      // other public APIs
      /**
       * Emits the Track list related events
       * @param eventName name of the track
       * @param videoTrack track
       */
    }, {
      key: "emitEvent",
      value: function emitEvent(eventName, videoTrack) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`VideoTrackListImpl: emitEvent ${eventName}`);
        if (eventName === "change") {
          this.eventEmitter.emit(eventName, new (_$$_REQUIRE(_dependencyMap[4]).Event)(eventName, this));
        } else {
          if (videoTrack) {
            this.eventEmitter.emit(eventName, new (_$$_REQUIRE(_dependencyMap[4]).TrackEvent)(eventName, this, videoTrack));
          } else {
            this.eventEmitter.emit(eventName, new (_$$_REQUIRE(_dependencyMap[4]).Event)(eventName, this));
          }
        }
      }
      /**
       * Adds a track to the tracks list
       */
    }, {
      key: "addTrack",
      value: function addTrack(track) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`VideoTrackListImpl: addTrack id ${track.id}`);
        this.videoTracks.push(track);
      }
    }, {
      key: "removeTrack",
      value: function removeTrack(id) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`VideoTrackListImpl: removeTrack id ${id}`);
        // find the track
        var trackIndex = undefined;
        this.videoTracks.forEach(function (videoTrack, index) {
          if (videoTrack.id === id) {
            trackIndex = index;
          }
        });
        // remove track if found
        if (trackIndex !== undefined) {
          this.videoTracks.splice(trackIndex, 1);
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`video track id ${id} removed`);
        } else {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`video track id ${id} not found`);
        }
      }
    }]);
  }();
  exports.VideoTrackListImpl = VideoTrackListImpl;
},"57be0424162b51212025",["3508abd8c6b891008c0d","92ad024a633394b0493f","5533cec96f6a88041c69","1f12e7e43345228dfcad","9e1e5e085598ef3ad539"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TextTrackListImpl = undefined;
  /*
   * Copyright 2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */

  /**
   * Proxies to support [ ] operator on TextTrackList
   */
  var proxyHandlers = {
    get: function get(target, key) {
      if (!(key in target)) {
        return target.textTracks[key];
      } else {
        return Reflect.get(target, key);
      }
    }
  };
  var TextTrackListImpl = /*#__PURE__*/function () {
    function TextTrackListImpl() {
      _$$_REQUIRE(_dependencyMap[0])(this, TextTrackListImpl);
      this.textTracks = new Array();
      this.eventEmitter = new (_$$_REQUIRE(_dependencyMap[1]).MediaEventEmitterImpl)();
      return new Proxy(this, proxyHandlers);
    }
    // EventTarget API implementation
    return _$$_REQUIRE(_dependencyMap[2])(TextTrackListImpl, [{
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`TextTrackListImpl:addEventListener ${type}`);
        this.eventEmitter.addEventListener(type, listener);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`TextTrackListImpl:removeEventListener ${type}`);
        this.eventEmitter.removeEventListener(type, listener);
      }
    }, {
      key: "length",
      get: function get() {
        return this.textTracks.length;
      }
      /**
       * https://html.spec.whatwg.org/multipage/media.html#text-track-api
       */
      // FIXME: Seems like a wrong implementation of eventhandler
    }, {
      key: "onchange",
      set: function set(listener) {
        this.eventEmitter.addEventListener("change", listener);
      }
      // FIXME: Seems like a wrong implementation of eventhandler
    }, {
      key: "onaddtrack",
      set: function set(listener) {
        this.eventEmitter.addEventListener("addtrack", listener);
      }
      // FIXME: Seems like a wrong implementation of eventhandler
    }, {
      key: "onremovetrack",
      set: function set(listener) {
        this.eventEmitter.addEventListener("removetrack", listener);
      }
    }, {
      key: "getTrackById",
      value: function getTrackById(id) {
        var idx = this.findTrackIndex(id);
        if (idx === -1) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`TextTrackListImpl: getTrackById ${id} not found`);
          return undefined;
        }
        return this.textTracks[idx];
      }
      // other public APIs
      /**
       * Emits the Track list related events
       * @param eventName name of the track
       * @param textTrack track
       */
    }, {
      key: "emitEvent",
      value: function emitEvent(eventName, textTrack) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`TextTrackListImpl: emitEvent ${eventName} in track: ${textTrack} `);
        if (eventName === "change") {
          this.eventEmitter.emit(eventName, new (_$$_REQUIRE(_dependencyMap[4]).Event)(eventName, this));
        } else {
          if (textTrack) {
            //@TODO PROJXXXX-192523
            this.eventEmitter.emit(eventName, new (_$$_REQUIRE(_dependencyMap[4]).Event)(eventName, this));
            //this.eventEmitter.emit(eventName, new TrackEvent(eventName, this, textTrack));
          } else {
            this.eventEmitter.emit(eventName, new (_$$_REQUIRE(_dependencyMap[4]).Event)(eventName, this));
          }
        }
      }
      /**
       * Adds a track to the tracks list
       */
    }, {
      key: "addTrack",
      value: function addTrack(track) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`TextTrackListImpl: addTrack id ${track.id}`);
        this.textTracks.push(track);
        /**
         * List should fire the events when tracks are added
         * For Native tracks handleTextTrackListEvent does that
         */
        if (track.id.startsWith(_$$_REQUIRE(_dependencyMap[5]).TextTrackImpl.JS_TRACK_ID_PREFIX)) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`TextTrackListImpl: Inform listeners for TextTrack id ${track.id} addition`);
          this.emitEvent("addtrack", track);
        }
      }
    }, {
      key: "removeTrack",
      value: function removeTrack(id) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`TextTrackListImpl: removeTrack id ${id}`);
        var trackIndex = this.findTrackIndex(id);
        if (trackIndex === -1) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`TextTrackListImpl: removeTrack ${id} not found`);
          return;
        }
        var removedTrack = this.textTracks.splice(trackIndex, 1); //remove element from array
        /**
         * List should fire the events when tracks are removed
         * For Native tracks handleTextTrackListEvent does that
         * For JS track this is unexpected.
         */
        if (removedTrack.length > 0 && removedTrack[0].id.startsWith(_$$_REQUIRE(_dependencyMap[5]).TextTrackImpl.JS_TRACK_ID_PREFIX)) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`TextTrackListImpl: unexpected removal of TextTrack id ${removedTrack[0].id}`);
          this.emitEvent("removetrack", removedTrack[0]);
        }
      }
    }, {
      key: "findTrackIndex",
      value: function findTrackIndex(id) {
        return this.textTracks.findIndex(function (tt) {
          return tt.id === id;
        }); //find index in your array
      }
    }]);
  }();
  exports.TextTrackListImpl = TextTrackListImpl;
},"c3e5f31ce01fcbdfdc92",["3508abd8c6b891008c0d","92ad024a633394b0493f","5533cec96f6a88041c69","1f12e7e43345228dfcad","9e1e5e085598ef3ad539","d574e06103bb046b60b8"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TextTrackImpl = undefined;
  var W3CMediaTurboModule_1 = __importDefault(_$$_REQUIRE(_dependencyMap[0]));
  /**
   * @TODO We need to have separate implementations for
   * JS and native TextTracks, if we want to support both.
   * This looks messed up right now.
   */
  var TextTrackImpl = /*#__PURE__*/function () {
    /**
     * @TODO : Get rid of native TextTracks.
     * Try using JS implementation itself.
     * */

    /**
     * This is the creation order and
     * not the TrackList insertion order
     */

    //@TODO implement

    /**
     * extra added args
     */

    function TextTrackImpl(mediaPlayer, mediaElement, textTrack, kind, label, language, uri, mimeType) {
      var _this = this;
      _$$_REQUIRE(_dependencyMap[1])(this, TextTrackImpl);
      this.oncuechange = function (e) {
        _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`TextTrackImpl: ${_this._id} Default Handler event : ` + (e == null ? undefined : e.type));
      };
      this._mediaPlayer = mediaPlayer;
      this._inBandMetadataTrackDispatchType = "";
      this._mode = "hidden";
      this._readinessState = "loaded";
      this.mediaElement = mediaElement;
      this.textTrack = null;
      this.textTrackCueList = null;
      this.activeCueList = null;
      _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`TextTrackImpl::+constructor textTrack: ${textTrack} uri: ${uri} ME: ${mediaElement}`);
      if (textTrack || uri && this.mediaElement) {
        var _this$textTrack;
        if (!textTrack) {
          this.textTrack = W3CMediaTurboModule_1.default.addTextTrack(this.mediaElement, kind, label != null ? label : "", language != null ? language : "", uri != null ? uri : "", mimeType != null ? mimeType : "");
        } else {
          this.textTrack = textTrack;
        }
        this._id = TextTrackImpl.NATIVE_TRACK_ID_PREFIX + ((_this$textTrack = this.textTrack) == null ? undefined : _this$textTrack.id);
      } else {
        this._kind = kind;
        this._label = label;
        this._language = language || "";
        this.textTrackCueList = new (_$$_REQUIRE(_dependencyMap[3]).TextTrackCueListImpl)();
        this.activeCueList = new (_$$_REQUIRE(_dependencyMap[3]).TextTrackCueListImpl)();
        this._id = TextTrackImpl.JS_TRACK_ID_PREFIX + TextTrackImpl.orderId.toString();
      }
      this.eventEmitter = new (_$$_REQUIRE(_dependencyMap[4]).MediaEventEmitterImpl)();
      this._orderId = TextTrackImpl.orderId;
      TextTrackImpl.orderId++;
      _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`TextTrackImpl: constructed TextTrack ${this._id}`);
    }
    return _$$_REQUIRE(_dependencyMap[5])(TextTrackImpl, [{
      key: "cues",
      get: function get() {
        return this.textTrackCueList;
      }
    }, {
      key: "activeCues",
      get: function get() {
        this.activeCueList.removeAllCues();
        /**
         * @TODO optimize by listening to cue's enter/exit events
         * But this looks more safe, as user may be the first listener.
         */
        for (var i = 0; i < this.textTrackCueList.length; i++) {
          var cue = this.textTrackCueList[i];
          if (cue.isActive) {
            this.activeCueList.addCue(cue);
          }
        }
        return this.activeCueList;
      }
      /**
       * @param {TextTrackCue} cue
       */
    }, {
      key: "addCue",
      value: function addCue(cue) {
        if (this.textTrack) {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.warn(`TextTrackImpl(${this._id}):addCue Supported only for Tracks added by the user`);
          return;
        }
        if (cue instanceof _$$_REQUIRE(_dependencyMap[6]).VTTCue) {
          cue.setTrack(this);
        }
        this.textTrackCueList.addCue(cue);
        if (this._mediaPlayer && this._mode !== "disabled") {
          this._mediaPlayer.addCue(cue);
        }
      }
    }, {
      key: "removeCue",
      value: function removeCue(cue) {
        var _this$_mediaPlayer;
        _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`TextTrackImpl: remove Cue: ${cue.id} ${cue.startTime} - ${cue.endTime} from ${this._id}`);
        this.textTrackCueList.removeCue(cue);
        (_this$_mediaPlayer = this._mediaPlayer) == null ? undefined : _this$_mediaPlayer.removeCue(cue);
      }
    }, {
      key: "id",
      get: function get() {
        return this._id;
      }
    }, {
      key: "orderId",
      get: function get() {
        return this._orderId;
      }
      // @CHECK : Do we really need to fetch these properties from the native track?
    }, {
      key: "kind",
      get: function get() {
        if (this.textTrack === null) {
          return this._kind;
        }
        return this.textTrack.kind;
      }
    }, {
      key: "label",
      get: function get() {
        if (this.textTrack === null) {
          return this._label;
        }
        return this.textTrack.label;
      }
    }, {
      key: "language",
      get: function get() {
        if (this.textTrack === null) {
          return this._language;
        }
        return this.textTrack.language;
      }
      /**
       * @TODO implement
       */
    }, {
      key: "inBandMetadataTrackDispatchType",
      get: function get() {
        _$$_REQUIRE(_dependencyMap[2]).LogUtil.warn(`TextTrackImpl(${this._id}): inBandMetadataTrackDispatchType not supported`);
        return this._inBandMetadataTrackDispatchType;
      }
    }, {
      key: "mode",
      get: function get() {
        if (this.textTrack === null) {
          return this._mode;
        }
        var textTrack = W3CMediaTurboModule_1.default.getTextTrackById(this.mediaElement, this.id.replace(TextTrackImpl.NATIVE_TRACK_ID_PREFIX, ''));
        return textTrack == null ? undefined : textTrack.mode;
      },
      set: function set(aMode) {
        _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`TextTrackImpl(${this._id}): set mode ${aMode}`);
        if (this.textTrack) {
          this.textTrack.mode = aMode;
          if (this.textTrack.mode === "showing") {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`enable text track id ${this.textTrack.id}`);
            W3CMediaTurboModule_1.default.enableTextTrack(this.mediaElement, this.textTrack.id);
          } else if (this.textTrack.mode === "hidden") {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`hide text track id ${this.textTrack.id}`);
            /**
             * @Check This seems wrong
             * "Hidden : Indicates that the text track is active, but that the
             * user agent is not actively displaying the cues. If no
             * attempt has yet been made to obtain the track's cues,
             * the user agent will perform such an attempt momentarily.
             * The user agent is maintaining a list of which cues are
             * active, and events are being fired accordingly."
             */
            W3CMediaTurboModule_1.default.disableTextTrack(this.mediaElement, this.textTrack.id);
          } else {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`disable text track id ${this.textTrack.id}`);
          }
        } else {
          var _this$_mediaPlayer4;
          /**
           * @TODO handle mode switching of the JS text tracks.
           * This is inefficient.
           */
          if (this._mode !== "disabled" && aMode === "disabled") {
            for (var i = 0; i < this.textTrackCueList.length; i++) {
              var _this$_mediaPlayer2;
              (_this$_mediaPlayer2 = this._mediaPlayer) == null ? undefined : _this$_mediaPlayer2.removeCue(this.textTrackCueList[i]);
            }
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`Track ${this._id} Disabled on user request`);
          } else if (this._mode === "disabled" && aMode !== "disabled") {
            for (var _i = 0; _i < this.textTrackCueList.length; _i++) {
              var _this$_mediaPlayer3;
              (_this$_mediaPlayer3 = this._mediaPlayer) == null ? undefined : _this$_mediaPlayer3.addCue(this.textTrackCueList[_i]);
            }
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`Track ${this._id} Enabled on user request`);
          }
          this._mode = aMode;
          (_this$_mediaPlayer4 = this._mediaPlayer) == null ? undefined : _this$_mediaPlayer4.runTMOAlgo();
        }
      }
    }, {
      key: "addEventListener",
      value:
      // EventTarget API implementation
      function addEventListener(type, listener, options) {
        _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`TextTrackImpl:addEventListener ${type}`);
        this.eventEmitter.addEventListener(type, listener);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`TextTrackImpl:removeEventListener ${type}`);
        this.eventEmitter.removeEventListener(type, listener);
      }
      /**
       * @TODO Handle cuechange event
       * @param event
       * @returns
       */
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`TextTrackImpl: ${this._id} dispatchEvent ${event.type}`);
        if (event.type === "cuechange") {
          // If we register this as listener with the emitter, we need not do this
          this.oncuechange(event);
        }
        return this.eventEmitter.emit(event.type, new (_$$_REQUIRE(_dependencyMap[7]).Event)(event.type, this));
      }
    }, {
      key: "refresh",
      value: function refresh() {
        if (!this.textTrack && this._mode !== "disabled") {
          var _this$_mediaPlayer5;
          (_this$_mediaPlayer5 = this._mediaPlayer) == null ? undefined : _this$_mediaPlayer5.runTMOAlgo();
        }
      }
    }]);
  }();
  /**
   * We support multiple instances of MediaElement.
   * Let JS TextTrack ids be unique across MediaElements as well.
   */
  TextTrackImpl.orderId = 0;
  TextTrackImpl.NATIVE_TRACK_ID_PREFIX = "NATIVE_";
  TextTrackImpl.JS_TRACK_ID_PREFIX = "JS_";
  exports.TextTrackImpl = TextTrackImpl;
},"d574e06103bb046b60b8",["0814a269c2fb50034991","3508abd8c6b891008c0d","1f12e7e43345228dfcad","82a2a8632011dfcc1350","92ad024a633394b0493f","5533cec96f6a88041c69","a13467c443d8b8a7e966","9e1e5e085598ef3ad539"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TextTrackCueListImpl = undefined;
  /**
   * Proxies to support [ ] operator on VideoTrackList
   * @TODO get rid of this proxy, instead extend an Array
   */
  var proxyHandlers = {
    get: function get(target, key) {
      if (!(key in target)) {
        return target.textTrackCueList[key];
      } else {
        return Reflect.get(target, key);
      }
    }
  };
  /**
   * Implement TextTrackCueList interface
   */
  var TextTrackCueListImpl = /*#__PURE__*/function () {
    function TextTrackCueListImpl() {
      _$$_REQUIRE(_dependencyMap[0])(this, TextTrackCueListImpl);
      this.textTrackCueList = new Array();
      // Map has an advantage over Set, when we need getCueById(id)
      this.cueMap = new Map();
      this.eventEmitter = new (_$$_REQUIRE(_dependencyMap[1]).MediaEventEmitterImpl)();
      return new Proxy(this, proxyHandlers);
    }
    // TextTrackCueList interface API implementation
    return _$$_REQUIRE(_dependencyMap[2])(TextTrackCueListImpl, [{
      key: "length",
      get: function get() {
        return this.textTrackCueList.length;
      }
    }, {
      key: "getCueById",
      value: function getCueById(id) {
        if (this.isEmpty()) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`TextTrackCueListImpl: no cues available`);
          return undefined;
        }
        return this.cueMap.get(id);
      }
      /**
       * Adds a cue to the TTCue list
       */
    }, {
      key: "addCue",
      value: function addCue(cue) {
        if (cue instanceof _$$_REQUIRE(_dependencyMap[4]).VTTCue) {
          /**
           * Step 3 : "If the given cue is in a text track list of cues, then remove
           * cue from that text track list of cues."
           * @TODO Do we need to remove the cue??
           * Specs says if the same cue exists, then remove it.
           * Cues are passed by reference, if it is duplicate should it be ignored??
           */
          this.removeCue(cue);
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`TextTrackCueListImpl: addCue id ${cue.id} with text ${cue.text}`);
          if (!this.checkAndAppend(cue)) {
            this.textTrackCueList.splice(this.findInsertionIdx(cue), 0, cue);
          }
          this.cueMap.set(cue.id, cue);
        } else {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.error('addCue failed, only VTTCue is supported');
        }
      }
      /**
       * removes a cue from the TTCue list
       */
    }, {
      key: "removeCue",
      value: function removeCue(cue) {
        if (this.isEmpty()) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`TextTrackCueListImpl::removeCue no cues in the list`);
          return;
        }
        if (this.cueMap.has(cue.id)) {
          this.cueMap.delete(cue.id);
          var cueIndex = this.findCueIndex(cue);
          if (cueIndex === -1) {
            // This may happen when a user modifies the cue timing and adds it
            // back. The older entry gets modified in place.
            // Binary search will fail. Try brute force to be sure.
            cueIndex = this.textTrackCueList.findIndex(function (vttcue) {
              return vttcue === cue || vttcue.id === cue.id;
            });
          }
          if (cueIndex >= 0) {
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug('TextTrackCueListImpl::removeCue @index : ' + cueIndex);
            this.textTrackCueList.splice(cueIndex, 1); //remove element from array
          } else {
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn('TextTrackCueListImpl::removeCue cue list seems to be corrupt');
          }
        }
      }
    }, {
      key: "removeAllCues",
      value: function removeAllCues() {
        this.textTrackCueList.length = 0;
        this.cueMap.clear();
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return this.textTrackCueList.length === 0;
      }
    }, {
      key: "checkAndAppend",
      value: function checkAndAppend(cue) {
        var appended = false;
        var num = this.textTrackCueList.length;
        if (num === 0 || this.checkRelativePosition(this.textTrackCueList[num - 1], cue) !== "before") {
          this.textTrackCueList[num] = cue;
          appended = true;
        }
        return appended;
      }
      /**
       * In-order cues are not guaranteed, so find the insertion index
       * https://html.spec.whatwg.org/multipage/media.html#text-track-cue-order
       * If multiple cues have the same start and end timestamps, then
       * insert this cue after the last matching cue.
       */
    }, {
      key: "findInsertionIdx",
      value: function findInsertionIdx(cue) {
        if (this.textTrackCueList.length === 0) {
          return 0;
        }
        var start = 0;
        var end = this.textTrackCueList.length;
        while (start < end) {
          var mid = start + (end - start >> 1);
          if (this.checkRelativePosition(this.textTrackCueList[mid], cue) === "before") {
            end = mid;
          } else {
            start = mid + 1;
          }
        }
        return start;
      }
    }, {
      key: "findCueIndex",
      value: function findCueIndex(cue) {
        var start = 0;
        var end = this.textTrackCueList.length;
        var firstSimilarIndex = -1;
        // There may be multiple cues with same start/end time
        while (start <= end) {
          var mid = start + (end - start >> 1);
          var pos = this.checkRelativePosition(this.textTrackCueList[mid], cue);
          if (pos === "before") {
            end = mid - 1;
          } else if (pos === "same") {
            if (cue.id === this.textTrackCueList[mid].id) {
              // cue is found
              return mid;
            }
            firstSimilarIndex = mid;
            end = mid - 1;
          } else {
            start = mid + 1;
          }
        }
        var cueIdx = -1;
        if (firstSimilarIndex >= 0) {
          // Assuming there are not too many similar cues
          for (var i = firstSimilarIndex; i < this.textTrackCueList.length; i++) {
            if (cue.id === this.textTrackCueList[i].id) {
              cueIdx = i;
              break;
            }
          }
        }
        return cueIdx;
      }
    }, {
      key: "checkRelativePosition",
      value: function checkRelativePosition(ref, cue) {
        var result = 0;
        if (ref.startTime != cue.startTime) {
          result = ref.startTime - cue.startTime;
        } else if (ref.endTime != cue.endTime) {
          result = ref.endTime - cue.endTime;
        }
        var relPos = "same";
        if (result > 0) {
          relPos = "before";
        } else if (result < 0) {
          relPos = "after";
        }
        return relPos;
      }
    }]);
  }();
  exports.TextTrackCueListImpl = TextTrackCueListImpl;
},"82a2a8632011dfcc1350",["3508abd8c6b891008c0d","92ad024a633394b0493f","5533cec96f6a88041c69","1f12e7e43345228dfcad","a13467c443d8b8a7e966"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VTTCue = undefined;
  // @CHECK should we move this to src/polyfills/VTTCue.ts ??
  /* [Exposed=Window,
   Constructor(double startTime, double endTime, DOMString text)]
   */
  /**
   * @hidden
   * https://www.w3.org/TR/webvtt1/#the-vttcue-interface
   */
  var VTTCue = /*#__PURE__*/function () {
    /**
     * @track is a readonly property, can not define a setter.
     * Users do not set this while constructing the VTTCue.
     */
    function VTTCue(startTime, endTime, text, track) {
      var _this = this;
      _$$_REQUIRE(_dependencyMap[0])(this, VTTCue);
      this.onenter = function (e) {
        _$$_REQUIRE(_dependencyMap[1]).LogUtil.debug(`VTTCue ${_this._id}: Default handler event : ` + (e == null ? undefined : e.type));
      };
      this.onexit = function (e) {
        _$$_REQUIRE(_dependencyMap[1]).LogUtil.debug(`VTTCue ${_this._id}: Default handler event : ` + (e == null ? undefined : e.type));
      };
      this._track = track || null;
      this._startTime = startTime;
      this._endTime = endTime;
      this._text = text;
      this._id = VTTCue.cueId.toString();
      VTTCue.cueId++;
      this._pauseOnExit = false;
      this._vertical = '';
      this._snapToLines = true;
      this._line = 'auto';
      this._lineAlign = 'start';
      this._position = 'auto';
      this._positionAlign = 'auto';
      this._size = 100;
      this._align = 'center';
      this._region = null;
      this._isActive = false;
      this.eventEmitter = new (_$$_REQUIRE(_dependencyMap[2]).MediaEventEmitterImpl)();
      _$$_REQUIRE(_dependencyMap[1]).LogUtil.debug('VTTCue constructed with ' + startTime + ' - ' + endTime + ' : ' + text);
    }
    return _$$_REQUIRE(_dependencyMap[3])(VTTCue, [{
      key: "track",
      get: function get() {
        return this._track;
      }
      /**
       * Not a usual JS setter
       * @param track
       */
    }, {
      key: "setTrack",
      value: function setTrack(track) {
        this._track = track;
      }
    }, {
      key: "id",
      get: function get() {
        return this._id;
      },
      set: function set(cId) {
        this._id = cId;
      }
    }, {
      key: "startTime",
      get: function get() {
        return this._startTime;
      },
      set: function set(cStartTime) {
        var _this$track;
        this._startTime = cStartTime;
        (_this$track = this.track) == null ? undefined : _this$track.refresh();
      }
    }, {
      key: "endTime",
      get: function get() {
        return this._endTime;
      },
      set: function set(cEndTime) {
        var _this$track2;
        this._endTime = cEndTime;
        (_this$track2 = this.track) == null ? undefined : _this$track2.refresh();
      }
    }, {
      key: "pauseOnExit",
      get: function get() {
        return this._pauseOnExit;
      },
      set: function set(aPauseOnExit) {
        _$$_REQUIRE(_dependencyMap[1]).LogUtil.warn(`VTTCue: pauseOnExit is not supported.`);
        this._pauseOnExit = aPauseOnExit;
      }
    }, {
      key: "vertical",
      get: function get() {
        return this._vertical;
      },
      set: function set(aVerticalDirection) {
        this._vertical = aVerticalDirection;
      }
    }, {
      key: "snapToLines",
      get: function get() {
        return this._snapToLines;
      },
      set: function set(aSnapToLines) {
        this._snapToLines = aSnapToLines;
      }
      /*
        attribute  align;
        attribute DOMString text;*/
      /*
       * @TODO implement
       */
      // DocumentFragment getCueAsHTML();
    }, {
      key: "line",
      get: function get() {
        return this._line;
      },
      set: function set(aLineAndPositionSetting) {
        this._line = aLineAndPositionSetting;
      }
    }, {
      key: "lineAlign",
      get: function get() {
        return this._lineAlign;
      },
      set: function set(aLineAlign) {
        this._lineAlign = aLineAlign;
      }
    }, {
      key: "position",
      get: function get() {
        return this._position;
      },
      set: function set(aPosition) {
        this._position = aPosition;
      }
    }, {
      key: "positionAlign",
      get: function get() {
        return this._positionAlign;
      },
      set: function set(aPositionAlign) {
        this._positionAlign = aPositionAlign;
      }
    }, {
      key: "size",
      get: function get() {
        return this._size;
      },
      set: function set(aSize) {
        this._size = aSize;
      }
    }, {
      key: "align",
      get: function get() {
        return this._align;
      },
      set: function set(aAlign) {
        this._align = aAlign;
      }
    }, {
      key: "text",
      get: function get() {
        return this._text;
      },
      set: function set(aText) {
        this._text = aText;
      }
    }, {
      key: "isActive",
      get: function get() {
        return this._isActive;
      },
      set: function set(aActive) {
        this._isActive = aActive;
      }
    }, {
      key: "region",
      get: function get() {
        return this._region;
      },
      set: function set(aRegion) {
        this._region = aRegion;
      }
      // EventTarget API implementation
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        _$$_REQUIRE(_dependencyMap[1]).LogUtil.debug(`VTTCue:addEventListener ${type}`);
        this.eventEmitter.addEventListener(type, listener);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        _$$_REQUIRE(_dependencyMap[1]).LogUtil.debug(`VTTCue:removeEventListener ${type}`);
        this.eventEmitter.removeEventListener(type, listener);
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        _$$_REQUIRE(_dependencyMap[1]).LogUtil.debug(`AudioTrackListImpl: emitEvent ${event.type}`);
        /**
         * If we register these as listener with the emitter, we need not do this
         * @CHECK should we schedule these using setTimeout?
         * We dispatch these asynchronously from TMOA, so it seems safe.
         **/
        if (event.type === 'enter') {
          this.onenter(event);
        } else if (event.type === 'exit') {
          this.onexit(event);
        }
        return this.eventEmitter.emit(event.type, new (_$$_REQUIRE(_dependencyMap[4]).Event)(event.type, this));
      }
    }]);
  }();
  // @TODO implement pauseOnExit
  /*
   * https://www.w3.org/TR/webvtt1/#vttregion
   */
  VTTCue.cueId = 0n;
  exports.VTTCue = VTTCue;
},"a13467c443d8b8a7e966",["3508abd8c6b891008c0d","1f12e7e43345228dfcad","92ad024a633394b0493f","5533cec96f6a88041c69","9e1e5e085598ef3ad539"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2022-2023 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TrackListEventHandler = undefined;
  var W3CMediaTurboModule_1 = __importDefault(_$$_REQUIRE(_dependencyMap[0]));
  var TrackListEventHandler = /*#__PURE__*/function () {
    function TrackListEventHandler() {
      _$$_REQUIRE(_dependencyMap[1])(this, TrackListEventHandler);
    }
    return _$$_REQUIRE(_dependencyMap[2])(TrackListEventHandler, [{
      key: "handleAudioTrackListEvent",
      value:
      /**
       * Handles audio track list event. It adds, removes or changes the video tracks in the
       * audio track list, and pases the event to audio track list so that it can emit it
       * to its listeners
       */
      function handleAudioTrackListEvent(nativeEvent, audioTrackList, mediaElement) {
        // nativeEvent.integer has change type
        var audioTrack = undefined;
        if (!nativeEvent) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`handleAudioTrackListEvent: Invalid event sent from audioTrackList`);
          return;
        }
        switch (nativeEvent.name) {
          case "change":
            {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`handleAudioTrackListEvent:CHANGE : only event will be sent`);
              audioTrack = audioTrackList.getTrackById(nativeEvent.track_id);
            }
            break;
          case "addtrack":
            {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`handleAudioTrackListEvent:ADDTRACK id ${nativeEvent.track_id}`);
              var nativeAudioTrack = W3CMediaTurboModule_1.default.getAudioTrackById(mediaElement, nativeEvent.track_id);
              if (nativeAudioTrack) {
                audioTrack = new (_$$_REQUIRE(_dependencyMap[4]).AudioTrackImpl)(nativeAudioTrack, mediaElement);
                if (audioTrack) {
                  audioTrackList.addTrack(audioTrack);
                }
              }
            }
            break;
          case "removetrack":
            {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`handleAudioTrackListEvent:REMOVETRACK id ${nativeEvent.track_id}`);
              audioTrack = audioTrackList.getTrackById(nativeEvent.track_id);
              ;
              audioTrackList.removeTrack(nativeEvent.track_id);
            }
            break;
          default:
            break;
        }
        // send callback only when valid audioTrack available
        if (audioTrack) {
          audioTrackList.emitEvent(nativeEvent.name, audioTrack);
        }
      }
      /**
       * Handles video track list event. It adds, removes or changes the video tracks in the
       * video track list, and pases the event to audio track list so that it can emit it
       * to its listeners
       */
    }, {
      key: "handleVideoTrackListEvent",
      value: function handleVideoTrackListEvent(nativeEvent, videoTrackList, mediaElement) {
        var videoTrack = undefined;
        // nativeEvent.integer has change type
        if (!nativeEvent) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`handleVideoTrackListEvent: Invalid event sent from videoTrackList`);
          return;
        }
        switch (nativeEvent.name) {
          case "change":
            {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`handleAudioTrackListEvent:CHANGE : only event will be sent`);
              videoTrack = videoTrackList.getTrackById(nativeEvent.track_id);
            }
            break;
          case "addtrack":
            {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`handleVideoTrackListEvent:ADDTRACK`);
              var nativeVideoTrack = W3CMediaTurboModule_1.default.getVideoTrackById(mediaElement, nativeEvent.track_id);
              if (nativeVideoTrack) {
                videoTrack = new (_$$_REQUIRE(_dependencyMap[5]).VideoTrackImpl)(nativeVideoTrack, mediaElement);
                if (videoTrack) {
                  videoTrackList.addTrack(videoTrack);
                }
              }
            }
            break;
          case "removetrack":
            {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`handleVideoTrackListEvent:REMOVETRACK id ${nativeEvent.track_id}`);
              videoTrack = videoTrackList.getTrackById(nativeEvent.track_id);
              videoTrackList.removeTrack(nativeEvent.track_id);
            }
            break;
          default:
            break;
        }
        // send callback only when valid videoTrack available
        if (videoTrack) {
          videoTrackList.emitEvent(nativeEvent.name, videoTrack);
        }
      }
      /**
       * Handles video track list event. It adds, removes or changes the video tracks in the
       * video track list, and pases the event to audio track list so that it can emit it
       * to its listeners
       */
    }, {
      key: "handleTextTrackListEvent",
      value: function handleTextTrackListEvent(nativeEvent, textTrackList, mediaElement) {
        var textTrack = undefined;
        // nativeEvent.integer has change type
        if (!nativeEvent) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn(`handleTextTrackListEvent: Invalid event sent from textTrackList`);
          return;
        }
        switch (nativeEvent.name) {
          case "change":
            {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`handleAudioTrackListEvent:CHANGE : only event will be sent`);
              textTrack = textTrackList.getTrackById(_$$_REQUIRE(_dependencyMap[6]).TextTrackImpl.NATIVE_TRACK_ID_PREFIX + nativeEvent.track_id);
            }
            break;
          case "addtrack":
            {
              var nativeTextTrack = W3CMediaTurboModule_1.default.getTextTrackById(mediaElement, nativeEvent.track_id);
              if (nativeTextTrack) {
                /**
                 * @CHECK This looks buggy.
                 * Why do we need to create TextTrackImpl to check,
                 * if the track with same id and kind, is already listed?
                 * Not touching it to avoid regression in OOBS case
                 * */
                textTrack = new (_$$_REQUIRE(_dependencyMap[6]).TextTrackImpl)(null, mediaElement, nativeTextTrack);
                _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`handleTextTrackListEvent:addtrack id created ${textTrack.id}`);
                if (textTrack) {
                  var track = textTrackList.getTrackById(_$$_REQUIRE(_dependencyMap[6]).TextTrackImpl.NATIVE_TRACK_ID_PREFIX + nativeEvent.track_id);
                  // This may not be required now, we can keep sending texttrack details.
                  if (track !== undefined && track !== null && track.kind === nativeTextTrack.kind) {
                    _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`handleTextTrackListEvent:addtrack text track already present in the list`);
                    // Update text track mode if track was chosen by default
                    if (nativeTextTrack.mode != track.mode && nativeTextTrack.mode === "showing") {
                      track.mode = "showing";
                    }
                    return;
                  }
                  textTrackList.addTrack(textTrack);
                }
              }
            }
            break;
          case "removetrack":
            {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`handleTextTrackListEvent:REMOVETRACK id ${nativeEvent.track_id}`);
              textTrack = textTrackList.getTrackById(_$$_REQUIRE(_dependencyMap[6]).TextTrackImpl.NATIVE_TRACK_ID_PREFIX + nativeEvent.track_id);
              textTrackList.removeTrack(_$$_REQUIRE(_dependencyMap[6]).TextTrackImpl.NATIVE_TRACK_ID_PREFIX + nativeEvent.track_id);
            }
            break;
          default:
            break;
        }
        // send callback only when valid textTrack available
        if (textTrack) {
          textTrackList.emitEvent(nativeEvent.name, textTrack);
        }
      }
    }]);
  }();
  exports.TrackListEventHandler = TrackListEventHandler;
},"3b6ed7af067745bc566f",["0814a269c2fb50034991","3508abd8c6b891008c0d","5533cec96f6a88041c69","1f12e7e43345228dfcad","548388dd03ef296f4795","126964f9fa8e80bf3661","d574e06103bb046b60b8"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AudioTrackImpl = undefined;
  var W3CMediaTurboModule_1 = __importDefault(_$$_REQUIRE(_dependencyMap[0]));
  var AudioTrackImpl = /*#__PURE__*/function () {
    function AudioTrackImpl(audioTrack, mediaElement) {
      _$$_REQUIRE(_dependencyMap[1])(this, AudioTrackImpl);
      this.audioTrack = audioTrack;
      this.mediaElement = mediaElement;
    }
    return _$$_REQUIRE(_dependencyMap[2])(AudioTrackImpl, [{
      key: "id",
      get: function get() {
        return this.audioTrack.id;
      }
    }, {
      key: "kind",
      get: function get() {
        return this.audioTrack.kind;
      }
    }, {
      key: "label",
      get: function get() {
        return this.audioTrack.label;
      }
    }, {
      key: "language",
      get: function get() {
        return this.audioTrack.language;
      }
    }, {
      key: "enabled",
      get: function get() {
        var audioTrack = W3CMediaTurboModule_1.default.getAudioTrackById(this.mediaElement, this.id);
        return audioTrack == null ? undefined : audioTrack.enabled;
      },
      set: function set(enabled) {
        if (this.enabled !== enabled) {
          if (enabled) {
            W3CMediaTurboModule_1.default.enableAudioTrack(this.mediaElement, this.id);
          } else {
            W3CMediaTurboModule_1.default.disableAudioTrack(this.mediaElement, this.id);
          }
          this.audioTrack.enabled = enabled;
        }
      }
    }]);
  }();
  exports.AudioTrackImpl = AudioTrackImpl;
},"548388dd03ef296f4795",["0814a269c2fb50034991","3508abd8c6b891008c0d","5533cec96f6a88041c69"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VideoTrackImpl = undefined;
  var W3CMediaTurboModule_1 = __importDefault(_$$_REQUIRE(_dependencyMap[0]));
  var VideoTrackImpl = /*#__PURE__*/function () {
    function VideoTrackImpl(videoTrack, mediaElement) {
      _$$_REQUIRE(_dependencyMap[1])(this, VideoTrackImpl);
      this.videoTrack = videoTrack;
      this.mediaElement = mediaElement;
    }
    return _$$_REQUIRE(_dependencyMap[2])(VideoTrackImpl, [{
      key: "id",
      get: function get() {
        return this.videoTrack.id;
      }
    }, {
      key: "kind",
      get: function get() {
        return this.videoTrack.kind;
      }
    }, {
      key: "label",
      get: function get() {
        return this.videoTrack.label;
      }
    }, {
      key: "language",
      get: function get() {
        return this.videoTrack.language;
      }
    }, {
      key: "selected",
      get: function get() {
        var videoTrack = W3CMediaTurboModule_1.default.getVideoTrackById(this.mediaElement, this.id);
        return videoTrack == null ? undefined : videoTrack.selected;
      },
      set: function set(selected) {
        if (this.selected !== selected) {
          if (selected) {
            W3CMediaTurboModule_1.default.enableVideoTrack(this.mediaElement, this.id);
          } else {
            W3CMediaTurboModule_1.default.disableVideoTrack(this.mediaElement, this.id);
          }
          this.videoTrack.selected = selected;
        }
      }
    }]);
  }();
  exports.VideoTrackImpl = VideoTrackImpl;
},"126964f9fa8e80bf3661",["0814a269c2fb50034991","3508abd8c6b891008c0d","5533cec96f6a88041c69"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MediaControlStateUtil = undefined;
  var allStateSupportedActions = [_$$_REQUIRE(_dependencyMap[0]).Action.START_OVER, _$$_REQUIRE(_dependencyMap[0]).Action.SET_AUDIO_VOLUME, _$$_REQUIRE(_dependencyMap[0]).Action.SET_REPEAT_MODE];
  var allActiveStateSupportedActions = [_$$_REQUIRE(_dependencyMap[0]).Action.STOP, _$$_REQUIRE(_dependencyMap[0]).Action.FAST_FORWARD, _$$_REQUIRE(_dependencyMap[0]).Action.REWIND, _$$_REQUIRE(_dependencyMap[0]).Action.SKIP_FORWARD, _$$_REQUIRE(_dependencyMap[0]).Action.SKIP_BACKWARD, _$$_REQUIRE(_dependencyMap[0]).Action.SEEK];
  var MediaControlStateUtil = /*#__PURE__*/function () {
    /**
     * @hidden
     * @brief constructor of MediaControlStateUtil with is attached with
     *        current instance of mediaplayer.
     */
    function MediaControlStateUtil(_mediaPlayer) {
      var _this = this;
      _$$_REQUIRE(_dependencyMap[1])(this, MediaControlStateUtil);
      this.playbackStatus = _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.NOT_PLAYING;
      this.currentPosition = 0;
      this.currentSupportedActions = [_$$_REQUIRE(_dependencyMap[0]).Action.PLAY, _$$_REQUIRE(_dependencyMap[0]).Action.PAUSE, _$$_REQUIRE(_dependencyMap[0]).Action.STOP, _$$_REQUIRE(_dependencyMap[0]).Action.FAST_FORWARD, _$$_REQUIRE(_dependencyMap[0]).Action.REWIND, _$$_REQUIRE(_dependencyMap[0]).Action.SKIP_FORWARD, _$$_REQUIRE(_dependencyMap[0]).Action.SKIP_BACKWARD, _$$_REQUIRE(_dependencyMap[0]).Action.SEEK, _$$_REQUIRE(_dependencyMap[0]).Action.TOGGLE_PLAY_PAUSE, _$$_REQUIRE(_dependencyMap[0]).Action.SET_PLAYBACK_SPEED, new (_$$_REQUIRE(_dependencyMap[0]).Action)('ENABLE_XRAY'), new (_$$_REQUIRE(_dependencyMap[0]).Action)('DISABLE_XRAY')];
      this.repeatMode = _$$_REQUIRE(_dependencyMap[0]).RepeatMode.OFF;
      this.playbackSpeed = 1.0;
      this.currentSupportedSpeeds = [-3, -2, -1, 0.5, 0.5, 1.0, 2.0, 3.0];
      this.currentSupportedRatings = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0];
      this.mSeekIntervalInSec_ = 10.0;
      this.mSessionId = {
        id: 0
      };
      this.mId = {
        contentId: 'com.foo.bar',
        catalogName: 'sample-catalog-v1'
      };
      this.xRayControlName = 'X-ray';
      this.xRayControlStateOff = 'off';
      this.xRayControlStateOn = 'on';
      this.playbackPosition = {
        updatedAtTime: {
          seconds: 1702965600,
          nanoseconds: 0
        },
        position: {
          seconds: 10,
          nanoseconds: 999999999
        }
      };
      this.forwardSkipSteps = [{
        seconds: 10,
        nanoseconds: 0
      }, {
        seconds: 20,
        nanoseconds: 0
      }, {
        seconds: 40,
        nanoseconds: 0
      }, {
        seconds: 60,
        nanoseconds: 0
      }];
      this.backwardSkipSteps = [{
        seconds: 10,
        nanoseconds: 0
      }, {
        seconds: 20,
        nanoseconds: 0
      }, {
        seconds: 40,
        nanoseconds: 0
      }, {
        seconds: 60,
        nanoseconds: 0
      }];
      /**
       * @hidden
       * @brief attach thet mediacontrolserver object with MediaControlStateUtil
       */
      this.setMediaControlServer = function (mediaControlServer) {
        var _this$mediaPlayer;
        _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`MediaControlStateUtil: setMediaControlServer ++`);
        if (mediaControlServer === null || mediaControlServer === undefined) {
          return;
        }
        _this.setEventListeners();
        _this.mediaControlServer = mediaControlServer;
        _this.setDefaultSeekIntervalInSec((_this$mediaPlayer = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer.defaultSeekIntervalInSec);
        _this.updateState(true /* force initial update */);
        _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`MediaControlStateUtil: setMediaControlServer --`);
      };
      /**
       * @hidden
       * @brief clear the mediaplayer event listner
       */
      this.clearMediaPlayer = function (mediaPlayer) {
        _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`MediaControlStateUtil: clearMediaPlayer ++`);
        if (mediaPlayer === null || mediaPlayer === undefined) {
          return;
        }
        _this.removeEventListeners(mediaPlayer);
      };
      /**
       * @hidden
       * @brief configure the default seek interval in case user does not
       *        set.
       */
      this.setDefaultSeekIntervalInSec = function (seekInterval) {
        _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlStateUtil: defualtSeekInterval ` + seekInterval);
        _this.mSeekIntervalInSec_ = seekInterval;
      };
      /**
       * @hidden
       * @brief set the player error if any.
       */
      this.setPlayerError = function (mediaError) {
        _this.mError = mediaError;
      };
      /**
       * @hidden
       * @brief reset the player error.
       */
      this.resetError = function () {
        _this.mError = new (_$$_REQUIRE(_dependencyMap[3]).MediaErrorImpl)(0, 'No Error');
      };
      /**
       * @hidden
       * @brief Implement the event listner of current mediaplayer instance
       *        based on events , session update will be done and eventually
       *        update the KMC server.
       */
      this.eventListeners = {
        loadstart: function loadstart() {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: loadstart event');
          _this.resetError();
          _this.playbackStatus = _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.BUFFERING;
          _this.updateState();
        },
        waiting: function waiting() {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: waiting event');
          _this.playbackStatus = _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.BUFFERING;
          _this.updateState();
        },
        progress: function progress() {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: progress event');
          _this.playbackStatus = _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.BUFFERING;
          _this.updateState();
        },
        stalled: function stalled() {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: stalled event');
          _this.playbackStatus = _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.NOT_PLAYING;
          _this.updateState();
        },
        suspend: function suspend() {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: suspend event');
          _this.playbackStatus = _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.NOT_PLAYING;
          _this.updateState();
        },
        abort: function abort() {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: abort event');
          _this.playbackStatus = _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.NOT_PLAYING;
          _this.updateState();
        },
        emptied: function emptied() {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: emptied event');
          _this.playbackStatus = _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.NOT_PLAYING;
          _this.updateState();
        },
        loadedmetadata: function loadedmetadata() {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: loadedmetadata event');
          _this.playbackStatus = _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.BUFFERING;
          _this.updateState();
        },
        loadeddata: function loadeddata() {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: loadeddata event');
          _this.playbackStatus = _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.BUFFERING;
          _this.updateState();
        },
        canplay: function canplay() {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: canplay event');
          _this.playbackStatus = _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.BUFFERING;
          _this.updateState();
        },
        seeked: function seeked() {
          var _this$mediaPlayer2;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: seeked event');
          _this.currentPosition = (_this$mediaPlayer2 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer2.currentTime;
          _this.updateState();
        },
        timeupdate: function timeupdate() {
          var _this$mediaPlayer3;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: timeupdate event');
          _this.playbackStatus = _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.PLAYING;
          _this.currentPosition = (_this$mediaPlayer3 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer3.currentTime;
          _this.updateState();
        },
        audiofocuspaused: function audiofocuspaused() {
          var _this$mediaPlayer4;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: audiofocuspaused event');
          _this.playbackStatus = _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.PAUSED;
          _this.currentPosition = (_this$mediaPlayer4 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer4.currentTime;
          _this.updateState();
        },
        audiofocuslost: function audiofocuslost() {
          var _this$mediaPlayer5;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: audiofocuslost event');
          _this.playbackStatus = _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.PAUSED;
          _this.currentPosition = (_this$mediaPlayer5 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer5.currentTime;
          _this.updateState();
        },
        audiofocusgranted: function audiofocusgranted() {
          var _this$mediaPlayer6;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: audiofocusgranted event');
          _this.playbackStatus = _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.PLAYING;
          _this.currentPosition = (_this$mediaPlayer6 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer6.currentTime;
          _this.updateState();
        },
        playing: function playing() {
          var _this$mediaPlayer7;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: player event');
          _this.resetError();
          _this.playbackStatus = _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.PLAYING;
          _this.currentPosition = (_this$mediaPlayer7 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer7.currentTime;
          _this.updateState();
        },
        pause: function pause() {
          var _this$mediaPlayer8;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: pause event');
          _this.playbackStatus = _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.PAUSED;
          _this.currentPosition = (_this$mediaPlayer8 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer8.currentTime;
          _this.updateState();
        },
        seeking: function seeking() {
          var _this$mediaPlayer9;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('MediaControlStateUtil: seeking event');
          _this.currentPosition = (_this$mediaPlayer9 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer9.currentTime;
          _this.updateState();
        },
        ended: function ended() {
          var _this$mediaPlayer10;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: ended event');
          _this.playbackStatus = _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.NOT_PLAYING;
          _this.currentPosition = (_this$mediaPlayer10 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer10.currentTime;
          _this.updateState();
        },
        error: function error() {
          var _this$mediaPlayer11, _this$mediaPlayer12;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: error event');
          _this.setPlayerError((_this$mediaPlayer11 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer11.error);
          _this.playbackStatus = _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.NOT_PLAYING;
          _this.currentPosition = (_this$mediaPlayer12 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer12.currentTime;
          _this.updateState();
        },
        ratechange: function ratechange() {
          var _this$mediaPlayer13, _this$mediaPlayer14;
          var playbackRate = (_this$mediaPlayer13 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer13.playbackRate;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlStateUtil: rate change event to ${playbackRate}`);
          _this.playbackSpeed = playbackRate;
          _this.currentPosition = (_this$mediaPlayer14 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer14.currentTime;
          _this.updateState();
        }
      };
      _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('MediaControlStateUtil: ++');
      this.mediaPlayer = _mediaPlayer;
      this.mSessionId = _mediaPlayer.mSessionId;
      this.mError = new (_$$_REQUIRE(_dependencyMap[3]).MediaErrorImpl)(0, 'No Error');
      _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('MediaControlStateUtil: --');
    }
    return _$$_REQUIRE(_dependencyMap[4])(MediaControlStateUtil, [{
      key: "getServerState",
      value:
      /**
       * @hidden
       * @brief papulate the current mediaplayer session state
       *        and it will be finally updated to KMC server.
       */
      function getServerState() {
        _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: getServerState ++');
        /* @TODO hard-coded values need to remove */
        /*
        const msSinceEpoch = Date.now();
        const secsSinceEpoch = Math.floor(msSinceEpoch/1000);
        const nsSinceEpoch = (msSinceEpoch - (secsSinceEpoch * 1000)) * 1000000 ;
        let updatedAtTime: ITimeValue;
        updatedAtTime.seconds = secsSinceEpoch;
        updatedAtTime.nanoseconds = nsSinceEpoch;
        const secPosition = Math.floor(this.currentPosition);
        const nsPosition = (this.currentPosition - secPosition) * 1000 * 1000 * 1000;
        let position: ITimeValue;
        position.seconds = secPosition;
        position.nanoseconds = nsPosition;
        */
        if (this.playbackState !== undefined) {
          this._playbackState = this.playbackState;
        } else {
          this._playbackState = {
            playbackStatus: this.playbackStatus,
            playbackSpeed: this.playbackSpeed,
            position: this.playbackPosition
          };
        }
        /*
        let playbackposition:IPlaybackPosition;
        playbackposition.updatedAtTime = updatedAtTime;
        playbackposition.position = position;
        this._playbackState.position = playbackposition
        */
        if (this.capabilities !== undefined) {
          this._capabilities = this.capabilities;
        } else {
          //this.setSupportedActions(this.playbackStatus);
          this._capabilities = {
            actions: this.currentSupportedActions,
            speeds: this.currentSupportedSpeeds,
            ratings: this.currentSupportedRatings,
            forwardSkipSteps: this.forwardSkipSteps,
            backwardSkipSteps: this.backwardSkipSteps
          };
        }
        /*
        this.updateSupportedActions(this.playbackStatus);
        LogUtil.info('MediaControlStateUtil:: updateSupportedActions --');
        */
        if (this.playlistState !== undefined) {
          this._playlistState = this.playlistState;
        } else {
          this._playlistState = {
            repeatMode: this.repeatMode,
            shuffle: false
          };
        }
        this.controls = [{
          name: this.xRayControlName,
          state: this.xRayControlStateOff
        }];
        this.locale = {
          identifier: 'en-US'
        };
        if (this.mediaInfo !== undefined) {
          this._mediaInfo = this.mediaInfo;
        } else {
          this._mediaInfo = {
            id: this.mId,
            hasVideo: true,
            availableAudioTracks: [{
              id: '0',
              displayName: 'English',
              language: this.locale
            }],
            availableTextTracks: [{
              id: '0',
              displayName: 'English',
              language: this.locale
            }],
            duration: {
              seconds: 600,
              nanoseconds: 999999999
            },
            startTime: {
              seconds: 946684870,
              nanoseconds: 999999999
            },
            seekRangeStart: {
              seconds: 90,
              nanoseconds: 999999999
            },
            seekRangeEnd: {
              seconds: 120,
              nanoseconds: 999999999
            }
          };
        }
        this._serverState = {
          id: this.mSessionId,
          playbackState: this._playbackState,
          mediaInfo: this._mediaInfo,
          capabilities: this._capabilities,
          playlistState: this._playlistState,
          controls: this.controls
        };
        _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlServerUtil: getServerState : ', JSON.stringify(this._serverState));
        _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlServerUtil: getServerState --');
        return this._serverState;
      }
      /**
       * @hidden
       * @brief set the supported actions based on current playback state of
       *        mediaplayer.
       */
    }, {
      key: "setSupportedActions",
      value: function setSupportedActions(playerStatus) {
        if (playerStatus == _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.NOT_PLAYING) {
          this.currentSupportedActions = allStateSupportedActions;
        } else {
          this.currentSupportedActions = allStateSupportedActions.concat(allActiveStateSupportedActions);
        }
      }
      /**
       * @hidden
       * @brief update the supported actions based on current playback state of
       *        mediaplayer.
       */
    }, {
      key: "updateSupportedActions",
      value: function updateSupportedActions(playerStatus) {
        if (playerStatus == _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.NOT_PLAYING || playerStatus == _$$_REQUIRE(_dependencyMap[0]).PlaybackStatus.PAUSED) {
          var _this$_capabilities, _this$_capabilities3;
          var indexPlay = (_this$_capabilities = this._capabilities) == null ? undefined : _this$_capabilities.actions.indexOf(_$$_REQUIRE(_dependencyMap[0]).Action.PLAY);
          if (indexPlay < 0) {
            var _this$_capabilities2;
            (_this$_capabilities2 = this._capabilities) == null ? undefined : _this$_capabilities2.actions.push(_$$_REQUIRE(_dependencyMap[0]).Action.PLAY);
          }
          var indexPause = (_this$_capabilities3 = this._capabilities) == null ? undefined : _this$_capabilities3.actions.indexOf(_$$_REQUIRE(_dependencyMap[0]).Action.PAUSE);
          if (indexPause >= 0) {
            var _this$_capabilities4;
            (_this$_capabilities4 = this._capabilities) == null ? undefined : _this$_capabilities4.actions.splice(indexPause, 1);
          }
        } else {
          var _this$_capabilities5, _this$_capabilities7;
          // Playing or Buffering
          var _indexPlay = (_this$_capabilities5 = this._capabilities) == null ? undefined : _this$_capabilities5.actions.indexOf(_$$_REQUIRE(_dependencyMap[0]).Action.PLAY);
          if (_indexPlay >= 0) {
            var _this$_capabilities6;
            (_this$_capabilities6 = this._capabilities) == null ? undefined : _this$_capabilities6.actions.splice(_indexPlay, 1);
          }
          var _indexPause = (_this$_capabilities7 = this._capabilities) == null ? undefined : _this$_capabilities7.actions.indexOf(_$$_REQUIRE(_dependencyMap[0]).Action.PAUSE);
          if (_indexPause < 0) {
            var _this$_capabilities8;
            (_this$_capabilities8 = this._capabilities) == null ? undefined : _this$_capabilities8.actions.push(_$$_REQUIRE(_dependencyMap[0]).Action.PAUSE);
          }
        }
      }
      /**
       * @hidden
       * @brief update the session state to KMC server as and when MediaPlayer send the
       *        state mapped events to listner.
       */
    }, {
      key: "updateState",
      value: function updateState() {
        var _this$_playbackState;
        var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: updateState ++');
        var playerStatusChanged = this.playbackStatus != ((_this$_playbackState = this._playbackState) == null ? undefined : _this$_playbackState.playbackStatus);
        if (playerStatusChanged || force) {
          var _this$mediaControlSer;
          var mSessionState = this.getServerState();
          (_this$mediaControlSer = this.mediaControlServer) == null ? undefined : _this$mediaControlSer.updateMediaSessionStates([mSessionState]);
        }
        _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlStateUtil: updateState --');
      }
    }, {
      key: "setEventListeners",
      value:
      /**
      * @hidden
      * @brief configure the mediaplayer event listners.
      */
      function setEventListeners() {
        _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('MediaControlStateUtil: setEventListeners ++');
        for (var listener in this.eventListeners) {
          if (this.eventListeners.hasOwnProperty(listener)) this.mediaPlayer.addEventListener(listener, this.eventListeners[listener]);
        }
      }
      /**
       * @hidden
       * @brief reset the mediaplayer event listners.
       */
    }, {
      key: "removeEventListeners",
      value: function removeEventListeners(mediaPlayer) {
        _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('MediaControlStateUtil: removeEventListeners ++');
        if (mediaPlayer === null) {
          return;
        }
        for (var listener in this.eventListeners) {
          if (this.eventListeners.hasOwnProperty(listener)) mediaPlayer.removeEventListener(listener, this.eventListeners[listener]);
        }
      }
    }]);
  }();
  exports.MediaControlStateUtil = MediaControlStateUtil;
},"82bdb147a9dfce5d0d15",["50f17b882ad6b57cfe9e","3508abd8c6b891008c0d","1f12e7e43345228dfcad","7f2298a3ae35e640412a","5533cec96f6a88041c69"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  function _callSuper(t, o, e) { return o = _$$_REQUIRE(_dependencyMap[0])(o), _$$_REQUIRE(_dependencyMap[1])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _$$_REQUIRE(_dependencyMap[0])(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.QuotaExceededError = exports.NotSupportedError = exports.InvalidStateError = exports.MediaErrorImpl = undefined;
  var MediaErrorImpl = /*#__PURE__*/function () {
    function MediaErrorImpl(code, message) {
      _$$_REQUIRE(_dependencyMap[2])(this, MediaErrorImpl);
      this.code_ = code;
      this.message_ = message;
    }
    return _$$_REQUIRE(_dependencyMap[3])(MediaErrorImpl, [{
      key: "code",
      get: function get() {
        return this.code_;
      }
    }, {
      key: "message",
      get: function get() {
        return this.message_;
      }
    }, {
      key: "MEDIA_ERR_ABORTED",
      get: function get() {
        return 1;
      }
    }, {
      key: "MEDIA_ERR_DECODE",
      get: function get() {
        return 3;
      }
    }, {
      key: "MEDIA_ERR_NETWORK",
      get: function get() {
        return 2;
      }
    }, {
      key: "MEDIA_ERR_SRC_NOT_SUPPORTED",
      get: function get() {
        return 4;
      }
    }]);
  }();
  exports.MediaErrorImpl = MediaErrorImpl;
  var InvalidStateError = /*#__PURE__*/function (_Error) {
    function InvalidStateError(message) {
      var _this;
      _$$_REQUIRE(_dependencyMap[2])(this, InvalidStateError);
      _this = _callSuper(this, InvalidStateError, [message]);
      _this.name = "InvalidStateError";
      _this.message = message;
      _this.code = 11;
      return _this;
    }
    _$$_REQUIRE(_dependencyMap[4])(InvalidStateError, _Error);
    return _$$_REQUIRE(_dependencyMap[3])(InvalidStateError);
  }(/*#__PURE__*/_$$_REQUIRE(_dependencyMap[5])(Error));
  exports.InvalidStateError = InvalidStateError;
  var NotSupportedError = /*#__PURE__*/function (_Error2) {
    function NotSupportedError(message) {
      var _this2;
      _$$_REQUIRE(_dependencyMap[2])(this, NotSupportedError);
      _this2 = _callSuper(this, NotSupportedError, [message]);
      _this2.name = "NotSupportedError";
      _this2.message = message;
      _this2.code = 9;
      return _this2;
    }
    _$$_REQUIRE(_dependencyMap[4])(NotSupportedError, _Error2);
    return _$$_REQUIRE(_dependencyMap[3])(NotSupportedError);
  }(/*#__PURE__*/_$$_REQUIRE(_dependencyMap[5])(Error));
  exports.NotSupportedError = NotSupportedError;
  var QuotaExceededError = /*#__PURE__*/function (_Error3) {
    function QuotaExceededError(message) {
      var _this3;
      _$$_REQUIRE(_dependencyMap[2])(this, QuotaExceededError);
      _this3 = _callSuper(this, QuotaExceededError, [message]);
      _this3.name = "QuotaExceededError";
      _this3.message = message;
      _this3.code = 22;
      return _this3;
    }
    _$$_REQUIRE(_dependencyMap[4])(QuotaExceededError, _Error3);
    return _$$_REQUIRE(_dependencyMap[3])(QuotaExceededError);
  }(/*#__PURE__*/_$$_REQUIRE(_dependencyMap[5])(Error));
  exports.QuotaExceededError = QuotaExceededError;
},"7f2298a3ae35e640412a",["f391b9d534c3a6bc8659","4534eb96ece5e83c089a","3508abd8c6b891008c0d","5533cec96f6a88041c69","73afcd34a88a750f6d69","c577b02e1e09b9cd815b"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  function _callSuper(t, o, e) { return o = _$$_REQUIRE(_dependencyMap[0])(o), _$$_REQUIRE(_dependencyMap[1])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _$$_REQUIRE(_dependencyMap[0])(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  function _superPropGet(t, o, e, r) { var p = _$$_REQUIRE(_dependencyMap[2])(_$$_REQUIRE(_dependencyMap[0])(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KeplerMediaControlHandler = undefined;
  var KeplerMediaControlHandler = /*#__PURE__*/function (_MediaControlHandler_) {
    function KeplerMediaControlHandler() {
      _$$_REQUIRE(_dependencyMap[3])(this, KeplerMediaControlHandler);
      return _callSuper(this, KeplerMediaControlHandler, arguments);
    }
    _$$_REQUIRE(_dependencyMap[4])(KeplerMediaControlHandler, _MediaControlHandler_);
    return _$$_REQUIRE(_dependencyMap[5])(KeplerMediaControlHandler, [{
      key: "handlePlay",
      value: (
      /**
       * @brief Callback from KMC server to execute the media control command "play" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by initiating play command to pipeline as a default mode,
       *        alternatively App client can choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       */
      function () {
        var _handlePlay = _$$_REQUIRE(_dependencyMap[6])(function* (sessionId) {
          return yield _superPropGet(KeplerMediaControlHandler, "handlePlay", this, 3)([sessionId]);
        });
        function handlePlay(_x) {
          return _handlePlay.apply(this, arguments);
        }
        return handlePlay;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "pause" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by initiating pause command to pipeline as a default mode,
       *        alternatively App client can choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       */
      )
    }, {
      key: "handlePause",
      value: (function () {
        var _handlePause = _$$_REQUIRE(_dependencyMap[6])(function* (sessionId, context) {
          return yield _superPropGet(KeplerMediaControlHandler, "handlePause", this, 3)([sessionId, context]);
        });
        function handlePause(_x2, _x3) {
          return _handlePause.apply(this, arguments);
        }
        return handlePause;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "toggleplaypause" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by initiating play/pause based on current state of pipeline as a default mode,
       *        alternatively App client can choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       */
      )
    }, {
      key: "handleTogglePlayPause",
      value: (function () {
        var _handleTogglePlayPause = _$$_REQUIRE(_dependencyMap[6])(function* (sessionId) {
          return yield _superPropGet(KeplerMediaControlHandler, "handleTogglePlayPause", this, 3)([sessionId]);
        });
        function handleTogglePlayPause(_x4) {
          return _handleTogglePlayPause.apply(this, arguments);
        }
        return handleTogglePlayPause;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "stop" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by initiating pause command to pipeline as a default mode,
       *        alternatively App client can choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       */
      )
    }, {
      key: "handleStop",
      value: (function () {
        var _handleStop = _$$_REQUIRE(_dependencyMap[6])(function* (sessionId) {
          return yield _superPropGet(KeplerMediaControlHandler, "handleStop", this, 3)([sessionId]);
        });
        function handleStop(_x5) {
          return _handleStop.apply(this, arguments);
        }
        return handleStop;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "startover" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by seek to start position and initiate the play command to pipeline as a default mode,
       *        alternatively App client can choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       */
      )
    }, {
      key: "handleStartOver",
      value: (function () {
        var _handleStartOver = _$$_REQUIRE(_dependencyMap[6])(function* (sessionId) {
          return yield _superPropGet(KeplerMediaControlHandler, "handleStartOver", this, 3)([sessionId]);
        });
        function handleStartOver(_x6) {
          return _handleStartOver.apply(this, arguments);
        }
        return handleStartOver;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "fastforward" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by seek forward command to pipeline as a default mode.
       *        alternatively App client can choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       */
      )
    }, {
      key: "handleFastForward",
      value: (function () {
        var _handleFastForward = _$$_REQUIRE(_dependencyMap[6])(function* (sessionId) {
          return yield _superPropGet(KeplerMediaControlHandler, "handleFastForward", this, 3)([sessionId]);
        });
        function handleFastForward(_x7) {
          return _handleFastForward.apply(this, arguments);
        }
        return handleFastForward;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "rewind" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by seek backward command to pipeline as a default mode.
       *        alternatively App client can choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       */
      )
    }, {
      key: "handleRewind",
      value: (function () {
        var _handleRewind = _$$_REQUIRE(_dependencyMap[6])(function* (sessionId) {
          return yield _superPropGet(KeplerMediaControlHandler, "handleRewind", this, 3)([sessionId]);
        });
        function handleRewind(_x8) {
          return _handleRewind.apply(this, arguments);
        }
        return handleRewind;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "seek" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by seek forward/backward command to pipeline as a default mode.
       *        alternatively App client can choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       */
      )
    }, {
      key: "handleSeek",
      value: (function () {
        var _handleSeek = _$$_REQUIRE(_dependencyMap[6])(function* (position, sessionId) {
          return yield _superPropGet(KeplerMediaControlHandler, "handleSeek", this, 3)([position, sessionId]);
        });
        function handleSeek(_x9, _x10) {
          return _handleSeek.apply(this, arguments);
        }
        return handleSeek;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "setplaybackspeed" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by configure the playbackspeed command to pipeline as a default mode.
       *        alternatively App client can choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       */
      )
    }, {
      key: "handleSetPlaybackSpeed",
      value: (function () {
        var _handleSetPlaybackSpeed = _$$_REQUIRE(_dependencyMap[6])(function* (speed, sessionId) {
          return yield _superPropGet(KeplerMediaControlHandler, "handleSetPlaybackSpeed", this, 3)([speed, sessionId]);
        });
        function handleSetPlaybackSpeed(_x11, _x12) {
          return _handleSetPlaybackSpeed.apply(this, arguments);
        }
        return handleSetPlaybackSpeed;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "skipforward" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by seek command with delta position to pipeline as a default mode.
       *        alternatively App client can choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       */
      )
    }, {
      key: "handleSkipForward",
      value: (function () {
        var _handleSkipForward = _$$_REQUIRE(_dependencyMap[6])(function* (delta, sessionId) {
          return yield _superPropGet(KeplerMediaControlHandler, "handleSkipForward", this, 3)([delta, sessionId]);
        });
        function handleSkipForward(_x13, _x14) {
          return _handleSkipForward.apply(this, arguments);
        }
        return handleSkipForward;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "skipbackward" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by seek command with delta position to pipeline as a default mode.
       *        alternatively App client can choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       */
      )
    }, {
      key: "handleSkipBackward",
      value: (function () {
        var _handleSkipBackward = _$$_REQUIRE(_dependencyMap[6])(function* (delta, sessionId) {
          return yield _superPropGet(KeplerMediaControlHandler, "handleSkipBackward", this, 3)([delta, sessionId]);
        });
        function handleSkipBackward(_x15, _x16) {
          return _handleSkipBackward.apply(this, arguments);
        }
        return handleSkipBackward;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "setVolume" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by initiating setvolume command as a default mode.
       *        alternatively App client can choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       */
      )
    }, {
      key: "handleSetAudioVolume",
      value: (function () {
        var _handleSetAudioVolume = _$$_REQUIRE(_dependencyMap[6])(function* (volume, sessionId) {
          return yield _superPropGet(KeplerMediaControlHandler, "handleSetAudioVolume", this, 3)([volume, sessionId]);
        });
        function handleSetAudioVolume(_x17, _x18) {
          return _handleSetAudioVolume.apply(this, arguments);
        }
        return handleSetAudioVolume;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "setAudioTrack" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by initiating setaudiotrack command as a default mode.
       *        alternatively App client can choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       *        Note: Currently this is NOP in default mode and handling will be available in future releases.
       */
      )
    }, {
      key: "handleSetAudioTrack",
      value: (function () {
        var _handleSetAudioTrack = _$$_REQUIRE(_dependencyMap[6])(function* (audioTrack, sessionId) {
          return yield _superPropGet(KeplerMediaControlHandler, "handleSetAudioTrack", this, 3)([audioTrack, sessionId]);
        });
        function handleSetAudioTrack(_x19, _x20) {
          return _handleSetAudioTrack.apply(this, arguments);
        }
        return handleSetAudioTrack;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "enableTextTrack" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by initiating enableTextTrack command as a default mode.
       *        alternatively App client can choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       *        Note: Currently this is NOP in default mode and handling will be available in future releases.
       */
      )
    }, {
      key: "handleEnableTextTrack",
      value: (function () {
        var _handleEnableTextTrack = _$$_REQUIRE(_dependencyMap[6])(function* (textTrack, sessionId) {
          return yield _superPropGet(KeplerMediaControlHandler, "handleEnableTextTrack", this, 3)([textTrack, sessionId]);
        });
        function handleEnableTextTrack(_x21, _x22) {
          return _handleEnableTextTrack.apply(this, arguments);
        }
        return handleEnableTextTrack;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "next" for
       *        current mediaplayer instance.
       *        This is NOP for w3cmedia playback handling as this is playlist management feature.
       *        App clients are requested to choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       */
      )
    }, {
      key: "handleNext",
      value: (function () {
        var _handleNext = _$$_REQUIRE(_dependencyMap[6])(function* (sessionId) {
          return yield _superPropGet(KeplerMediaControlHandler, "handleNext", this, 3)([sessionId]);
        });
        function handleNext(_x23) {
          return _handleNext.apply(this, arguments);
        }
        return handleNext;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "previous" for
       *        current mediaplayer instance.
       *        This is NOP for w3cmedia playback handling as this is playlist management feature.
       *        App clients are requested to choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       */
      )
    }, {
      key: "handlePrevious",
      value: (function () {
        var _handlePrevious = _$$_REQUIRE(_dependencyMap[6])(function* () {
          _$$_REQUIRE(_dependencyMap[7]).LogUtil.info('KeplerMediaControlHandler: handlePrevious');
          return yield _superPropGet(KeplerMediaControlHandler, "handlePrevious", this, 3)([]);
        });
        function handlePrevious() {
          return _handlePrevious.apply(this, arguments);
        }
        return handlePrevious;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "shuffle" for
       *        current mediaplayer instance.
       *        This is NOP for w3cmedia playback handling as this is playlist management feature.
       *        App clients are requested to choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       */
      )
    }, {
      key: "handleEnableShuffle",
      value: (function () {
        var _handleEnableShuffle = _$$_REQUIRE(_dependencyMap[6])(function* (enable, sessionId) {
          return yield _superPropGet(KeplerMediaControlHandler, "handleEnableShuffle", this, 3)([enable, sessionId]);
        });
        function handleEnableShuffle(_x24, _x25) {
          return _handleEnableShuffle.apply(this, arguments);
        }
        return handleEnableShuffle;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "repeate" for
       *        current mediaplayer instance.
       *        This is NOP for w3cmedia playback handling as this is playlist management feature.
       *        App clients are requested to choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       */
      )
    }, {
      key: "handleSetRepeatMode",
      value: (function () {
        var _handleSetRepeatMode = _$$_REQUIRE(_dependencyMap[6])(function* (mode, sessionId) {
          return yield _superPropGet(KeplerMediaControlHandler, "handleSetRepeatMode", this, 3)([mode, sessionId]);
        });
        function handleSetRepeatMode(_x26, _x27) {
          return _handleSetRepeatMode.apply(this, arguments);
        }
        return handleSetRepeatMode;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "setRating" for
       *        current mediaplayer instance.
       *        This is NOP for w3cmedia playback handling as this is playlist management feature.
       *        App clients are requested to choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       */
      )
    }, {
      key: "handleSetRating",
      value: (function () {
        var _handleSetRating = _$$_REQUIRE(_dependencyMap[6])(function* (id, rating, sessionId) {
          return yield _superPropGet(KeplerMediaControlHandler, "handleSetRating", this, 3)([id, rating, sessionId]);
        });
        function handleSetRating(_x28, _x29, _x30) {
          return _handleSetRating.apply(this, arguments);
        }
        return handleSetRating;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "disableTextTrack" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by initiating disableTextTrack command as a default mode.
       *        alternatively App client can choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       *        Note: Currently this is NOP in default mode and handling will be available in future releases.
       */
      )
    }, {
      key: "handleDisableTextTrack",
      value: (function () {
        var _handleDisableTextTrack = _$$_REQUIRE(_dependencyMap[6])(function* (sessionId) {
          return yield _superPropGet(KeplerMediaControlHandler, "handleDisableTextTrack", this, 3)([sessionId]);
        });
        function handleDisableTextTrack(_x31) {
          return _handleDisableTextTrack.apply(this, arguments);
        }
        return handleDisableTextTrack;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "getMetaInfo" for
       *        current mediaplayer instance.
       *        This is NOP for w3cmedia playback handling as this is playlist management feature.
       *        App clients are requested to choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       */
      )
    }, {
      key: "handleGetMetadataInfo",
      value: (function () {
        var _handleGetMetadataInfo = _$$_REQUIRE(_dependencyMap[6])(function* (id) {
          return yield _superPropGet(KeplerMediaControlHandler, "handleGetMetadataInfo", this, 3)([id]);
        });
        function handleGetMetadataInfo(_x32) {
          return _handleGetMetadataInfo.apply(this, arguments);
        }
        return handleGetMetadataInfo;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "customAction" for
       *        current mediaplayer instance.
       *        This is NOP for w3cmedia playback handling as this is playlist management feature.
       *        App clients are requested to choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       */
      )
    }, {
      key: "handleCustomAction",
      value: (function () {
        var _handleCustomAction = _$$_REQUIRE(_dependencyMap[6])(function* (action, sessionId) {
          return yield _superPropGet(KeplerMediaControlHandler, "handleCustomAction", this, 3)([action, sessionId]);
        });
        function handleCustomAction(_x33, _x34) {
          return _handleCustomAction.apply(this, arguments);
        }
        return handleCustomAction;
      }()
      /**
       * @brief Callback from KMC server to execute the media control command "getSessionState" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by updating the sessionstate as a default.
       *        alternatively App client can choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       */
      )
    }, {
      key: "handleGetSessionState",
      value: (function () {
        var _handleGetSessionState = _$$_REQUIRE(_dependencyMap[6])(function* (sessionId) {
          return yield _superPropGet(KeplerMediaControlHandler, "handleGetSessionState", this, 3)([sessionId]);
        });
        function handleGetSessionState(_x35) {
          return _handleGetSessionState.apply(this, arguments);
        }
        return handleGetSessionState;
      }())
    }]);
  }(_$$_REQUIRE(_dependencyMap[8]).MediaControlHandler);
  exports.KeplerMediaControlHandler = KeplerMediaControlHandler;
  ;
},"0b93a73a8c0720588336",["f391b9d534c3a6bc8659","4534eb96ece5e83c089a","ef4c2223f1078b78bd52","3508abd8c6b891008c0d","73afcd34a88a750f6d69","5533cec96f6a88041c69","ff7d8d645536d793bbec","1f12e7e43345228dfcad","77282e48e603d7caa4f7"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MediaControlHandler = undefined;
  var NANOSECONDS_IN_SECONDS = 1000000000;
  var MediaControlHandler = /*#__PURE__*/function () {
    function MediaControlHandler() {
      _$$_REQUIRE(_dependencyMap[0])(this, MediaControlHandler);
    }
    return _$$_REQUIRE(_dependencyMap[1])(MediaControlHandler, [{
      key: "setMediaPlayer",
      value:
      /**
       * @hidden
       * @brief Fetches video playback quality attributes.
       */
      function setMediaPlayer(mediaplayer) {
        _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('MediaControlHandler: setMediaPlayer');
        if (mediaplayer === null) {
          return;
        }
        this.mediaPlayer = mediaplayer;
      }
      /**
       * @hidden
       * @brief mapping the repeate mode to string for logging purpouse.
       */
    }, {
      key: "getRepeatModeString",
      value: function getRepeatModeString(repeatMode) {
        switch (repeatMode) {
          case _$$_REQUIRE(_dependencyMap[3]).RepeatMode.OFF:
            return 'OFF';
          case _$$_REQUIRE(_dependencyMap[3]).RepeatMode.REPEAT_PLAYLIST:
            return 'REPEAT_PLAYLIST';
          case _$$_REQUIRE(_dependencyMap[3]).RepeatMode.REPEAT_TRACK:
            return 'REPEAT_TRACK';
        }
        return 'BAD_VALUE';
      }
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "play" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by initiating play command to pipeline as a default mode.
       */
    }, {
      key: "handlePlay",
      value: (function () {
        var _handlePlay = _$$_REQUIRE(_dependencyMap[4])(function* (sessionId) {
          var _this$mediaPlayer;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('MediaControlHandler: performing play operation on Media Player');
          if (sessionId) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handlePlay: sessionID = ${sessionId.id}`);
          } else {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handlePlay: sessionID is null`);
          }
          (_this$mediaPlayer = this.mediaPlayer) == null ? undefined : _this$mediaPlayer.play();
          return Promise.resolve();
        });
        function handlePlay(_x) {
          return _handlePlay.apply(this, arguments);
        }
        return handlePlay;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "pause" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by initiating pause command to pipeline as a default mode.
       */
      )
    }, {
      key: "handlePause",
      value: (function () {
        var _handlePause = _$$_REQUIRE(_dependencyMap[4])(function* (sessionId, context) {
          var _this$mediaPlayer2;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('MediaControlHandler: performing pause operation on Media Player');
          if (sessionId) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handlePause: sessionID = ${sessionId.id}`);
          } else {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handlePause: sessionID is null`);
          }
          if (context) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handlePause: source = ${context.source}`);
          } else {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handlePause: source is null`);
          }
          // defualt implementation is to pause the playback irrespective of source
          (_this$mediaPlayer2 = this.mediaPlayer) == null ? undefined : _this$mediaPlayer2.pause();
          return Promise.resolve();
        });
        function handlePause(_x2, _x3) {
          return _handlePause.apply(this, arguments);
        }
        return handlePause;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "toggleplaypause" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by initiating play/pause based on current state of pipeline as a default mode.
       */
      )
    }, {
      key: "handleTogglePlayPause",
      value: (function () {
        var _handleTogglePlayPause = _$$_REQUIRE(_dependencyMap[4])(function* (sessionId) {
          var _this$mediaPlayer3, _this$mediaPlayer3$me;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('MediaControlHandler: performing handleTogglePlayPause on Media Player');
          if (sessionId) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleTogglePlayPause: sessionID = ${sessionId.id}`);
          } else {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleTogglePlayPause: sessionID is null`);
          }
          if (((_this$mediaPlayer3 = this.mediaPlayer) == null ? undefined : (_this$mediaPlayer3$me = _this$mediaPlayer3.mediaControlStateUtil) == null ? undefined : _this$mediaPlayer3$me.playbackStatus) === _$$_REQUIRE(_dependencyMap[3]).PlaybackStatus.PLAYING) {
            yield this.handlePause(sessionId);
          } else {
            yield this.handlePlay(sessionId);
          }
          return Promise.resolve();
        });
        function handleTogglePlayPause(_x4) {
          return _handleTogglePlayPause.apply(this, arguments);
        }
        return handleTogglePlayPause;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "stop" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by initiating pause command to pipeline as a default mode.
       */
      )
    }, {
      key: "handleStop",
      value: (function () {
        var _handleStop = _$$_REQUIRE(_dependencyMap[4])(function* (sessionId) {
          var _this$mediaPlayer4;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('MediaControlHandler: performing stop operation on Media Player');
          if (sessionId) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleStop: sessionID = ${sessionId.id}`);
          } else {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleStop: sessionID is null`);
          }
          (_this$mediaPlayer4 = this.mediaPlayer) == null ? undefined : _this$mediaPlayer4.pause();
          return Promise.resolve();
        });
        function handleStop(_x5) {
          return _handleStop.apply(this, arguments);
        }
        return handleStop;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "startover" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by seek to start position and initiate the play command to pipeline as a default mode.
       */
      )
    }, {
      key: "handleStartOver",
      value: (function () {
        var _handleStartOver = _$$_REQUIRE(_dependencyMap[4])(function* (sessionId) {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('MediaControlHandler: performing start over operation on Media Player');
          if (sessionId) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleStop: sessionID = ${sessionId.id}`);
          } else {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleStop: sessionID is null`);
          }
          this.mediaPlayer.currentTime = 0;
          this.mediaPlayer.play();
          return Promise.resolve();
        });
        function handleStartOver(_x6) {
          return _handleStartOver.apply(this, arguments);
        }
        return handleStartOver;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "fastforward" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by seek forward command to pipeline as a default mode.
       */
      )
    }, {
      key: "handleFastForward",
      value: (function () {
        var _handleFastForward = _$$_REQUIRE(_dependencyMap[4])(function* (sessionId) {
          var _this$mediaPlayer5, _this$mediaPlayer6, _this$mediaPlayer7, _this$mediaPlayer8;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('MediaControlHandler: performing fastforward operation on Media Player');
          if (sessionId) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleFastForward: sessionID = ${sessionId.id}`);
          } else {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleFastForward: sessionID is null`);
          }
          var currentTime = (_this$mediaPlayer5 = this.mediaPlayer) == null ? undefined : _this$mediaPlayer5.currentTime;
          var duration = (_this$mediaPlayer6 = this.mediaPlayer) == null ? undefined : _this$mediaPlayer6.duration;
          if (currentTime === undefined || duration === undefined) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.warn(`MediaControlHandler: Could not seek forward from currentTime=${currentTime}, duration=${duration}`);
            return Promise.resolve();
            ;
          }
          var seekIntervalSeconds = Math.floor((_this$mediaPlayer7 = this.mediaPlayer) == null ? undefined : _this$mediaPlayer7.seekIntervalInSec_);
          var seekIntervalNanoSeconds = (((_this$mediaPlayer8 = this.mediaPlayer) == null ? undefined : _this$mediaPlayer8.seekIntervalInSec_) - seekIntervalSeconds) * NANOSECONDS_IN_SECONDS;
          var deltaPositionSeconds = seekIntervalNanoSeconds / NANOSECONDS_IN_SECONDS + seekIntervalSeconds;
          var sanitizedDeltaPositionSeconds = Math.min(deltaPositionSeconds, duration - currentTime);
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: SkipForward: requested ${deltaPositionSeconds} s, applying ${sanitizedDeltaPositionSeconds} s.`);
          this.mediaPlayer.currentTime += sanitizedDeltaPositionSeconds;
          return Promise.resolve();
        });
        function handleFastForward(_x7) {
          return _handleFastForward.apply(this, arguments);
        }
        return handleFastForward;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "rewind" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by seek backward command to pipeline as a default mode.
       */
      )
    }, {
      key: "handleRewind",
      value: (function () {
        var _handleRewind = _$$_REQUIRE(_dependencyMap[4])(function* (sessionId) {
          var _this$mediaPlayer9, _this$mediaPlayer10, _this$mediaPlayer11, _this$mediaPlayer12;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('MediaControlHandler: performing rewind operation on Media Player');
          if (sessionId) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleRewind: sessionID = ${sessionId.id}`);
          } else {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleRewind: sessionID is null`);
          }
          var currentTime = (_this$mediaPlayer9 = this.mediaPlayer) == null ? undefined : _this$mediaPlayer9.currentTime;
          var duration = (_this$mediaPlayer10 = this.mediaPlayer) == null ? undefined : _this$mediaPlayer10.duration;
          if (currentTime === undefined || duration === undefined) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.warn(`MediaControlHandler: Could not seek backward from currentTime=${currentTime}, duration=${duration}`);
            return Promise.resolve();
            ;
          }
          var seekIntervalSeconds = Math.floor((_this$mediaPlayer11 = this.mediaPlayer) == null ? undefined : _this$mediaPlayer11.seekIntervalInSec_);
          var seekIntervalNanoSeconds = (((_this$mediaPlayer12 = this.mediaPlayer) == null ? undefined : _this$mediaPlayer12.seekIntervalInSec_) - seekIntervalSeconds) * NANOSECONDS_IN_SECONDS;
          var deltaPositionSeconds = seekIntervalNanoSeconds / NANOSECONDS_IN_SECONDS + seekIntervalSeconds;
          var sanitizedDeltaPositionSeconds = Math.min(currentTime, deltaPositionSeconds);
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleRewind: requested ${deltaPositionSeconds} s, applying ${sanitizedDeltaPositionSeconds} s.`);
          this.mediaPlayer.currentTime -= sanitizedDeltaPositionSeconds;
          return Promise.resolve();
        });
        function handleRewind(_x8) {
          return _handleRewind.apply(this, arguments);
        }
        return handleRewind;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "seek" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by seek forward/backward command to pipeline as a default mode.
       */
      )
    }, {
      key: "handleSeek",
      value: (function () {
        var _handleSeek = _$$_REQUIRE(_dependencyMap[4])(function* (position, sessionId) {
          var _this$mediaPlayer13;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('MediaControlHandler: performing seek operation on Media Player');
          if (sessionId) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleSeek: sessionID = ${sessionId.id}`);
          } else {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleSeek: sessionID is null`);
          }
          // check if second is not valid or not
          if (position.seconds === undefined) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.warn(`MediaControlHandler: Could not seek ${position.seconds}s.`);
            return Promise.resolve();
            ;
          }
          // reset nanosecond if this is undefined.
          if (position.nanoseconds === undefined) {
            position.nanoseconds = 0;
          }
          var duration = (_this$mediaPlayer13 = this.mediaPlayer) == null ? undefined : _this$mediaPlayer13.duration;
          if (duration === undefined) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.warn(`MediaControlHandler: Could not seek ${position.seconds} seconds.`);
            return Promise.resolve();
          }
          var seekPositionSeconds = position.nanoseconds / NANOSECONDS_IN_SECONDS + position.seconds;
          var sanitizedSeekPositionSeconds = seekPositionSeconds;
          if (seekPositionSeconds < 0) {
            sanitizedSeekPositionSeconds = 0;
          } else if (seekPositionSeconds > duration) {
            sanitizedSeekPositionSeconds = duration;
          }
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: Seek: requested ${seekPositionSeconds} s, applying ${sanitizedSeekPositionSeconds} s.`);
          this.mediaPlayer.currentTime = sanitizedSeekPositionSeconds;
          return Promise.resolve();
        });
        function handleSeek(_x9, _x10) {
          return _handleSeek.apply(this, arguments);
        }
        return handleSeek;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "setplaybackspeed" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by configure the playbackspeed command to pipeline as a default mode.
       */
      )
    }, {
      key: "handleSetPlaybackSpeed",
      value: (function () {
        var _handleSetPlaybackSpeed = _$$_REQUIRE(_dependencyMap[4])(function* (speed, sessionId) {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('MediaControlHandler: performing playback speed operation on Media Player');
          if (sessionId) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleSetPlaybackSpeed: sessionID = ${sessionId.id}`);
          } else {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleSetPlaybackSpeed: sessionID is null`);
          }
          this.mediaPlayer.playbackRate = speed;
          return Promise.resolve();
        });
        function handleSetPlaybackSpeed(_x11, _x12) {
          return _handleSetPlaybackSpeed.apply(this, arguments);
        }
        return handleSetPlaybackSpeed;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "skipforward" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by seek command with delta position to pipeline as a default mode.
       */
      )
    }, {
      key: "handleSkipForward",
      value: (function () {
        var _handleSkipForward = _$$_REQUIRE(_dependencyMap[4])(function* (delta, sessionId) {
          var _this$mediaPlayer14, _this$mediaPlayer15;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('MediaControlHandler: performing skipForward operation on Media Player');
          if (sessionId) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleSkipForward: sessionID = ${sessionId.id}`);
          } else {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleSkipForward: sessionID is null`);
          }
          // check if second is not valid or not
          if (delta.seconds === undefined) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.warn(`MediaControlHandler: Could not skipForward ${delta.seconds}s.`);
            return Promise.resolve();
            ;
          }
          // reset nanosecond if this is undefined.
          if (delta.nanoseconds === undefined) {
            delta.nanoseconds = 0;
          }
          var deltaPositionSeconds = delta.nanoseconds / NANOSECONDS_IN_SECONDS + delta.seconds;
          var currentTime = (_this$mediaPlayer14 = this.mediaPlayer) == null ? undefined : _this$mediaPlayer14.currentTime;
          var duration = (_this$mediaPlayer15 = this.mediaPlayer) == null ? undefined : _this$mediaPlayer15.duration;
          if (currentTime === undefined || duration === undefined) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.warn(`MediaControlHandler: Could not SkipForward ${deltaPositionSeconds} seconds. currentTime=${currentTime}, duration=${duration}`);
            return Promise.resolve();
          }
          var sanitizedDeltaPositionSeconds = Math.min(deltaPositionSeconds, duration - currentTime);
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: SkipForward: requested ${deltaPositionSeconds} s, applying ${sanitizedDeltaPositionSeconds} s.`);
          this.mediaPlayer.currentTime += sanitizedDeltaPositionSeconds;
          return Promise.resolve();
        });
        function handleSkipForward(_x13, _x14) {
          return _handleSkipForward.apply(this, arguments);
        }
        return handleSkipForward;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "skipbackward" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by seek command with delta position to pipeline as a default mode.
       */
      )
    }, {
      key: "handleSkipBackward",
      value: (function () {
        var _handleSkipBackward = _$$_REQUIRE(_dependencyMap[4])(function* (delta, sessionId) {
          var _this$mediaPlayer16;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('MediaControlHandler: performing skipBackword operation on Media Player');
          if (sessionId) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleSkipBackward: sessionID = ${sessionId.id}`);
          } else {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleSkipBackward: sessionID is null`);
          }
          // check if second is not valid or not
          if (delta.seconds === undefined) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.warn(`MediaControlHandler: Could not skipForward ${delta.seconds}s.`);
            return Promise.resolve();
            ;
          }
          // reset nanosecond if this is undefined.
          if (delta.nanoseconds === undefined) {
            delta.nanoseconds = 0;
          }
          var deltaPositionSeconds = delta.nanoseconds / NANOSECONDS_IN_SECONDS + delta.seconds;
          var currentTime = (_this$mediaPlayer16 = this.mediaPlayer) == null ? undefined : _this$mediaPlayer16.currentTime;
          if (currentTime === undefined) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.warn(`MediaControlHandler: Could not SkipBackward ${deltaPositionSeconds} seconds. currentTime=${currentTime}`);
            return Promise.resolve();
          }
          var sanitizedDeltaPositionSeconds = Math.min(deltaPositionSeconds, currentTime);
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleSkipBackward: requested ${deltaPositionSeconds} s, applying ${sanitizedDeltaPositionSeconds} s.`);
          this.mediaPlayer.currentTime -= sanitizedDeltaPositionSeconds;
          return Promise.resolve();
        });
        function handleSkipBackward(_x15, _x16) {
          return _handleSkipBackward.apply(this, arguments);
        }
        return handleSkipBackward;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "setVolume" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by initiating setvolume command as a default mode.
       */
      )
    }, {
      key: "handleSetAudioVolume",
      value: (function () {
        var _handleSetAudioVolume = _$$_REQUIRE(_dependencyMap[4])(function* (volume, sessionId) {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('MediaControlHandler: performing setvolume operation on Media Player');
          if (sessionId) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleSetAudioVolume: sessionID = ${sessionId.id}`);
          } else {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleSetAudioVolume: sessionID is null`);
          }
          this.mediaPlayer.volume = volume;
          return Promise.resolve();
        });
        function handleSetAudioVolume(_x17, _x18) {
          return _handleSetAudioVolume.apply(this, arguments);
        }
        return handleSetAudioVolume;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "setAudioTrack" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by initiating setaudiotrack command as a default mode.
       */
      )
    }, {
      key: "handleSetAudioTrack",
      value: (function () {
        var _handleSetAudioTrack = _$$_REQUIRE(_dependencyMap[4])(function* (audioTrack, sessionId) {
          var trackDetails = `id: ${audioTrack.id}, language: ${audioTrack.language}, displayName: ${audioTrack.displayName}`;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`MediaControlHandler: NOP: Setting audio track to ${trackDetails} , in future releases...`);
          return Promise.reject();
        });
        function handleSetAudioTrack(_x19, _x20) {
          return _handleSetAudioTrack.apply(this, arguments);
        }
        return handleSetAudioTrack;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "enableTextTrack" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by initiating enableTextTrack command as a default mode.
       */
      )
    }, {
      key: "handleEnableTextTrack",
      value: (function () {
        var _handleEnableTextTrack = _$$_REQUIRE(_dependencyMap[4])(function* (textTrack, sessionId) {
          var trackDetails = `id: ${textTrack.id}, language: ${textTrack.language}, displayName: ${textTrack.displayName}`;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`MediaControlHandler: NOP: Enabling next track, ${trackDetails}`);
          return Promise.reject();
        });
        function handleEnableTextTrack(_x21, _x22) {
          return _handleEnableTextTrack.apply(this, arguments);
        }
        return handleEnableTextTrack;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "next" for
       *        current mediaplayer instance.
       *        This is NOP for w3cmedia playback handling as this is playlist management feature.
       */
      )
    }, {
      key: "handleNext",
      value: (function () {
        var _handleNext = _$$_REQUIRE(_dependencyMap[4])(function* (sessionId) {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('MediaControlHandler: NOP: Play next...');
          return Promise.reject();
        });
        function handleNext(_x23) {
          return _handleNext.apply(this, arguments);
        }
        return handleNext;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "previous" for
       *        current mediaplayer instance.
       *        This is NOP for w3cmedia playback handling as this is playlist management feature.
       */
      )
    }, {
      key: "handlePrevious",
      value: (function () {
        var _handlePrevious = _$$_REQUIRE(_dependencyMap[4])(function* () {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('MediaControlHandler: NOP: Play previous...');
          return Promise.reject();
        });
        function handlePrevious() {
          return _handlePrevious.apply(this, arguments);
        }
        return handlePrevious;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "shuffle" for
       *        current mediaplayer instance.
       *        This is NOP for w3cmedia playback handling as this is playlist management feature.
       */
      )
    }, {
      key: "handleEnableShuffle",
      value: (function () {
        var _handleEnableShuffle = _$$_REQUIRE(_dependencyMap[4])(function* (enable, sessionId) {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`MediaControlHandler: NOP: Set shuffle to ${enable}`);
          return Promise.reject();
        });
        function handleEnableShuffle(_x24, _x25) {
          return _handleEnableShuffle.apply(this, arguments);
        }
        return handleEnableShuffle;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "previous" for
       *        current mediaplayer instance.
       *        This is NOP for w3cmedia playback handling as this is playlist management feature.
       */
      )
    }, {
      key: "handleSetRepeatMode",
      value: (function () {
        var _handleSetRepeatMode = _$$_REQUIRE(_dependencyMap[4])(function* (mode, sessionId) {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info('MediaControlHandler: performing repeatmode operation on Media Player');
          if (sessionId) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`MediaControlHandler: handleSetAudioVolume: sessionID = ${sessionId.id}`);
          } else {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`MediaControlHandler: handleSetAudioVolume: sessionID is null`);
          }
          if (mode === _$$_REQUIRE(_dependencyMap[3]).RepeatMode.REPEAT_TRACK || mode === _$$_REQUIRE(_dependencyMap[3]).RepeatMode.OFF) {
            this.mediaPlayer.loop = mode === _$$_REQUIRE(_dependencyMap[3]).RepeatMode.REPEAT_TRACK;
          } else {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.error('MediaControlHandler: handleSetRepeatMode failed');
          }
          return Promise.resolve();
        });
        function handleSetRepeatMode(_x26, _x27) {
          return _handleSetRepeatMode.apply(this, arguments);
        }
        return handleSetRepeatMode;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "setRating" for
       *        current mediaplayer instance.
       *        This is NOP for w3cmedia playback handling as this is playlist management feature.
       */
      )
    }, {
      key: "handleSetRating",
      value: (function () {
        var _handleSetRating = _$$_REQUIRE(_dependencyMap[4])(function* (id, rating, sessionId) {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`MediaControlHandler: NOP: Set rating of ${id} to ${rating}`);
          return Promise.reject();
        });
        function handleSetRating(_x28, _x29, _x30) {
          return _handleSetRating.apply(this, arguments);
        }
        return handleSetRating;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "disableTextTrack" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by initiating disableTextTrack command as a default mode.
       */
      )
    }, {
      key: "handleDisableTextTrack",
      value: (function () {
        var _handleDisableTextTrack = _$$_REQUIRE(_dependencyMap[4])(function* (sessionId) {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`MediaControlHandler: NOP: Disabling text track, future releases will have`);
          return Promise.reject();
        });
        function handleDisableTextTrack(_x31) {
          return _handleDisableTextTrack.apply(this, arguments);
        }
        return handleDisableTextTrack;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "getMetaInfo" for
       *        current mediaplayer instance.
       *        This is NOP for w3cmedia playback handling as this is playlist management feature.
       */
      )
    }, {
      key: "handleGetMetadataInfo",
      value: (function () {
        var _handleGetMetadataInfo = _$$_REQUIRE(_dependencyMap[4])(function* (id) {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`MediaControlHandler: NOP: Getting metadata for ${id}`);
          return Promise.reject();
        });
        function handleGetMetadataInfo(_x32) {
          return _handleGetMetadataInfo.apply(this, arguments);
        }
        return handleGetMetadataInfo;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "customAction" for
       *        current mediaplayer instance.
       *        This is NOP for w3cmedia playback handling as this is playlist management feature.
       */
      )
    }, {
      key: "handleCustomAction",
      value: (function () {
        var _handleCustomAction = _$$_REQUIRE(_dependencyMap[4])(function* (action, sessionId) {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`MediaControlHandler: NOP: Handle custom action ${action.name}`);
          return Promise.reject();
        });
        function handleCustomAction(_x33, _x34) {
          return _handleCustomAction.apply(this, arguments);
        }
        return handleCustomAction;
      }()
      /**
       * @hidden
       * @brief Callback from KMC server to execute the media control command "getSessionState" for
       *        current mediaplayer instance.
       *        w3cmedia will handle this internally by updating the sessionstate as a default.
       *        alternatively App client can choose to override the callback function using OverrideMediaControlHandler
       *        and implement accordingly.
       */
      )
    }, {
      key: "handleGetSessionState",
      value: (function () {
        var _handleGetSessionState = _$$_REQUIRE(_dependencyMap[4])(function* (sessionId) {
          var _this$mediaPlayer17, _this$mediaPlayer17$m;
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug('MediaControlHandler: performing getSessionState operation on Media Player');
          var sessionState;
          if (sessionId) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleGetSessionState: sessionID = ${sessionId.id}`);
          } else {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.debug(`MediaControlHandler: handleGetSessionState: sessionID is null`);
          }
          sessionState = (_this$mediaPlayer17 = this.mediaPlayer) == null ? undefined : (_this$mediaPlayer17$m = _this$mediaPlayer17.mediaControlStateUtil) == null ? undefined : _this$mediaPlayer17$m.getServerState();
          if (sessionState === undefined) {
            throw new Error('Unable to get session state');
          }
          return Promise.resolve([sessionState]);
        });
        function handleGetSessionState(_x35) {
          return _handleGetSessionState.apply(this, arguments);
        }
        return handleGetSessionState;
      }())
    }]);
  }();
  exports.MediaControlHandler = MediaControlHandler;
},"77282e48e603d7caa4f7",["3508abd8c6b891008c0d","5533cec96f6a88041c69","1f12e7e43345228dfcad","50f17b882ad6b57cfe9e","ff7d8d645536d793bbec"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PlayerSessionClient = undefined;
  var PlayerSessionClient = /*#__PURE__*/function () {
    // Media<VideoProps, VideoState> | Media<AudioProps, AudioState>;
    function PlayerSessionClient() {
      var _this = this;
      _$$_REQUIRE(_dependencyMap[0])(this, PlayerSessionClient);
      this.currentPlayerMediaOp = null;
      this.seekIntervalInSec_ = _$$_REQUIRE(_dependencyMap[1]).DEFAULT_SEEK_SECONDS;
      this.error = {
        code: _$$_REQUIRE(_dependencyMap[1]).DEFAULT_ERROR_CODE,
        codeString: _$$_REQUIRE(_dependencyMap[1]).DEFAULT_ERROR_CODE_STRING
      };
      this.callbacks = {
        onPause: function onPause() {
          if ((0, _$$_REQUIRE(_dependencyMap[2]).isPauseEnabled)(_this.playerState)) {
            var _this$mediaPlayer;
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('Player Session is performing pause operation on Media Player');
            (_this$mediaPlayer = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer.pause();
            _this.currentPlayerMediaOp = _$$_REQUIRE(_dependencyMap[4]).PlayerMediaOps.PLAYER_MEDIA_OP_PAUSE;
          } else {
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug('Pause operation by Player Session could not be performed because it is currently disabled');
          }
        },
        onPlay: function onPlay() {
          if ((0, _$$_REQUIRE(_dependencyMap[2]).isPlayEnabled)(_this.playerState)) {
            var _this$mediaPlayer2;
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('Player Session is performing play operation on Media Player');
            (_this$mediaPlayer2 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer2.play();
            _this.currentPlayerMediaOp = _$$_REQUIRE(_dependencyMap[4]).PlayerMediaOps.PLAYER_MEDIA_OP_PLAY;
          } else {
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug('Play operation by Player Session could not be performed because it is currently disabled');
          }
        },
        onStop: function onStop() {
          if ((0, _$$_REQUIRE(_dependencyMap[2]).isPauseEnabled)(_this.playerState)) {
            var _this$mediaPlayer3;
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug('Player Session is performing stop operation on Media Player');
            (_this$mediaPlayer3 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer3.pause();
            _this.currentPlayerMediaOp = _$$_REQUIRE(_dependencyMap[4]).PlayerMediaOps.PLAYER_MEDIA_OP_STOP;
          } else {
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug('Stop operation by Player Session could not be performed because it is currently disabled');
          }
        },
        onRewind: function onRewind(seconds, steps) {
          if ((0, _$$_REQUIRE(_dependencyMap[2]).isSeekEnabled)(_this.playerState)) {
            var _this$mediaPlayer4, _this$mediaPlayer5;
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug('Player Session is performing rewind operation on Media Player');
            var SECONDS = seconds !== -1 ? seconds : _this.seekIntervalInSec_;
            var STEPS = steps !== -1 ? steps : _$$_REQUIRE(_dependencyMap[1]).DEFAULT_SEEK_STEPS;
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`Rewinding ${SECONDS} seconds with ${STEPS} steps`);
            (_this$mediaPlayer4 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer4.fastSeek(((_this$mediaPlayer5 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer5.currentTime) - SECONDS * STEPS);
            _this.currentPlayerMediaOp = _$$_REQUIRE(_dependencyMap[4]).PlayerMediaOps.PLAYER_MEDIA_OP_REWIND;
          } else {
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug('Rewind operation by Player Session could not be performed because seek is currently disabled');
          }
        },
        onFastForward: function onFastForward(seconds, steps) {
          if ((0, _$$_REQUIRE(_dependencyMap[2]).isSeekEnabled)(_this.playerState)) {
            var _this$mediaPlayer6, _this$mediaPlayer7;
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug('Player Session is performing forward operation on Media Player');
            var SECONDS = seconds !== -1 ? seconds : _this.seekIntervalInSec_;
            var STEPS = steps !== -1 ? steps : _$$_REQUIRE(_dependencyMap[1]).DEFAULT_SEEK_STEPS;
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`FastForwarding ${SECONDS} seconds with ${STEPS} steps`);
            (_this$mediaPlayer6 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer6.fastSeek(((_this$mediaPlayer7 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer7.currentTime) + SECONDS * STEPS);
            _this.currentPlayerMediaOp = _$$_REQUIRE(_dependencyMap[4]).PlayerMediaOps.PLAYER_MEDIA_OP_FF;
          } else {
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug('Forward operation by Player Session could not be performed because seek is currently disabled');
          }
        },
        onUnsupportedOperation: function onUnsupportedOperation(operation) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`Player Session received an unsupported operation: ${_$$_REQUIRE(_dependencyMap[4]).PlayerMediaOps[operation]}`);
        },
        onSeekTo: function onSeekTo(deltaPositionMilliseconds, isRelative) {
          if ((0, _$$_REQUIRE(_dependencyMap[2]).isSeekEnabled)(_this.playerState)) {
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`Player Session is performing seek operation on Media Player of ${deltaPositionMilliseconds} ms`);
            if (_this.mediaPlayer === null) {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(' session is null hence returning');
              return;
            }
            var DELTA_POSITION_SECONDS = deltaPositionMilliseconds / 1000;
            if (!isRelative) {
              _this.mediaPlayer.currentTime = DELTA_POSITION_SECONDS;
            } else {
              _this.mediaPlayer.currentTime += DELTA_POSITION_SECONDS;
            }
            _this.currentPlayerMediaOp = _$$_REQUIRE(_dependencyMap[4]).PlayerMediaOps.PLAYER_MEDIA_OP_SEEK_TO;
          } else {
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug('Seek operation by Player Session could not be performed because it is currently disabled');
          }
        },
        onStartOver: function onStartOver() {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('Player Session is performing start over operation on Media Player');
          _this.mediaPlayer.currentTime = 0;
          _this.currentPlayerMediaOp = _$$_REQUIRE(_dependencyMap[4]).PlayerMediaOps.PLAYER_MEDIA_OP_START_OVER;
        },
        onSetPlaybackSpeed: function onSetPlaybackSpeed() {},
        onRequestPlayerPlaybackStateInfo: function onRequestPlayerPlaybackStateInfo() {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('Player Session is performing to send playback state of MediaPlayer');
          _this.setPlaybackState();
        }
      };
      this.eventListeners = {
        loadstart: function loadstart() {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('PlayerSessionClient: loadstart event');
          _this.playerState = _$$_REQUIRE(_dependencyMap[4]).PlayerState.PLAYER_STATE_CONNECTING;
          _this.setPlaybackState();
        },
        waiting: function waiting() {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('PlayerSessionClient: waiting event');
          _this.playerState = _$$_REQUIRE(_dependencyMap[4]).PlayerState.PLAYER_STATE_BUFFERING;
          _this.setPlaybackState();
        },
        playing: function playing() {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('PlayerSessionClient: player event');
          _this.playerState = _$$_REQUIRE(_dependencyMap[4]).PlayerState.PLAYER_STATE_PLAYING;
          _this.setPlaybackState();
        },
        pause: function pause() {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('PlayerSessionClient: pause event');
          _this.playerState = _$$_REQUIRE(_dependencyMap[4]).PlayerState.PLAYER_STATE_PAUSED;
          _this.setPlaybackState();
        },
        seeking: function seeking() {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('PlayerSessionClient: seeking event');
        },
        ended: function ended() {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('PlayerSessionClient: ended event');
          _this.playerState = _$$_REQUIRE(_dependencyMap[4]).PlayerState.PLAYER_STATE_STOPPED;
          _this.setPlaybackState();
        },
        error: function error() {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('PlayerSessionClient: error event');
          if (_this.mediaPlayer !== null) {
            var _this$mediaPlayer8;
            _this.playerState = _$$_REQUIRE(_dependencyMap[4]).PlayerState.PLAYER_STATE_ERROR;
            _this.setPlayerError((_this$mediaPlayer8 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer8.error);
          }
        },
        ratechange: function ratechange() {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('PlayerSessionClient: ratechange');
          if (_this.mediaPlayer === null) {
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('PlayerSessionClient: mediaplayer null');
            return;
          }
          var _this$mediaPlayer9 = _this.mediaPlayer,
            playbackRate = _this$mediaPlayer9.playbackRate,
            defaultPlaybackRate = _this$mediaPlayer9.defaultPlaybackRate;
          if (playbackRate === defaultPlaybackRate) {
            return;
          } else if (playbackRate > defaultPlaybackRate) {
            _this.playerState = _$$_REQUIRE(_dependencyMap[4]).PlayerState.PLAYER_STATE_FAST_FORWARDING;
          } else if (playbackRate < -1 * defaultPlaybackRate) {
            _this.playerState = _$$_REQUIRE(_dependencyMap[4]).PlayerState.PLAYER_STATE_REWINDING;
          }
          _this.setPlaybackState();
        }
      };
      this.playerSessionCreated = false;
      this.playerState = _$$_REQUIRE(_dependencyMap[4]).PlayerState.PLAYER_STATE_NONE;
      this.initialize = function () {
        try {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('Creating Player session for Media Player');
          _$$_REQUIRE(_dependencyMap[5]).PlayerSession.setPlayerSessionCallback(_this.callbacks);
          _this.playerSessionCreated = _$$_REQUIRE(_dependencyMap[5]).PlayerSession.create();
          if (_this.playerSessionCreated) {
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('Succesfully created Player session');
          } else {
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn('PlayerSession creation failed!!');
          }
        } catch (error) {
          _this.playerState = _$$_REQUIRE(_dependencyMap[4]).PlayerState.PLAYER_STATE_INVALID;
          var errorMessage = `Failed to create Player session for Media Player:\n${error}`;
          _this.setPlayerSessionError({
            code: _$$_REQUIRE(_dependencyMap[4]).ErrorCode.ERROR_APP_NONE,
            codeString: errorMessage
          });
          return;
        }
      };
      this.setMediaPlayer = function (mediaPlayer) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`setMediaPlayer `);
        if (mediaPlayer === null || mediaPlayer === undefined) {
          return;
        }
        _this.mediaPlayer = mediaPlayer;
        if (_this.playerSessionCreated && _this.mediaPlayer !== null) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('Succesfully attached MediaPlayer to PlayerSession');
          _this.setEventListeners();
        }
      };
      this.setDefaultSeekIntervalInSec = function (seekInterval) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`setDefaultSeekIntervalInSec seekInterval ` + seekInterval);
        if (_this.mediaPlayer === null || _this.mediaPlayer === undefined) {
          return;
        }
        _this.seekIntervalInSec_ = seekInterval;
      };
      this.clearMediaPlayer = function (mediaPlayer) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info(`clearMediaPlayer `);
        if (mediaPlayer === null || mediaPlayer === undefined) {
          return;
        }
        _this.removeEventListeners(mediaPlayer);
        // check if previously set media player is the one
        // that is cleared
        if (_this.mediaPlayer === mediaPlayer) {
          _this.mediaPlayer = null;
        } else {
          // maybe another media player was set before
          // clearing this one. Do nothing.
        }
      };
      this.setPlaybackState = function () {
        if (!_this.playerSessionCreated) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.error('Attempted to set playbackState before player session created');
          return;
        }
        try {
          var playbackState = _this.getPlaybackState();
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('Setting playbackState to session client \n');
          var playbackStateSent = _$$_REQUIRE(_dependencyMap[5]).PlayerSession.setPlaybackState(playbackState);
          if (playbackStateSent) _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('Setting playbackState state to session client is successful\n');else _$$_REQUIRE(_dependencyMap[3]).LogUtil.error('Failed to set playbackState as:\n');
        } catch (error) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.error('Unable to set playbackState.\n', error);
        }
      };
      this.getPlaybackState = function () {
        var _this$mediaPlayer10, _this$mediaPlayer11;
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('enumarate the session playback state');
        return {
          state: _this.playerState,
          supportedMediaOps: (0, _$$_REQUIRE(_dependencyMap[2]).getSupportedMediaOps)(_this.playerState),
          errorCode: _this.error.code,
          errorCodeString: _this.error.codeString,
          timeRangeData: {
            minSeekMs: 0,
            maxSeekMs: _this.mediaPlayer === null || _this.mediaPlayer === undefined ? -1 : (_this$mediaPlayer10 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer10.duration,
            trackPositionMs: _this.mediaPlayer === null || _this.mediaPlayer === undefined ? -1 : (_this$mediaPlayer11 = _this.mediaPlayer) == null ? undefined : _this$mediaPlayer11.currentTime
          },
          audioFocus: _$$_REQUIRE(_dependencyMap[4]).AudioFocusMode.AUDIO_FOCUS_NONE,
          currentPlaybackSpeed: 1,
          repeatMode: _$$_REQUIRE(_dependencyMap[4]).PlayerRepeatMode.PLAYER_REPEAT_MODE_NONE,
          shuffleMode: _$$_REQUIRE(_dependencyMap[4]).PlayerShuffleMode.PLAYER_SHUFFLE_MODE_NONE,
          trackRating: _$$_REQUIRE(_dependencyMap[4]).PlayerTrackRating.PLAYER_RATING_NONE,
          audioTrackAvailableLanguages: ['English'],
          captionTrackInfo: [{
            captionLanguage: 'English',
            captionMimeType: ''
          }]
        };
      };
      this.setPlayerError = function (mediaError) {
        var _mediaError$code, _mediaError$message;
        _this.error = {
          code: _this.getErrorCode((_mediaError$code = mediaError == null ? undefined : mediaError.code) != null ? _mediaError$code : -1),
          codeString: (_mediaError$message = mediaError == null ? undefined : mediaError.message) != null ? _mediaError$message : 'Error But No Message'
        };
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('setPlayerError: setPlaybackState call');
        _this.setPlaybackState();
      };
      this.getErrorCode = function (errorCode) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('getErrorCode :\n');
        switch (errorCode) {
          case 1: // MediaError.MEDIA_ERR_ABORTED
          case 2: // MediaError.MEDIA_ERR_DECODE
          case 3: // MediaError.MEDIA_ERR_NETWORK
          case 4: // MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED
          default:
            return _$$_REQUIRE(_dependencyMap[4]).ErrorCode.ERROR_APP_ERROR;
        }
      };
      this.setPlayerSessionError = function (playerSessionError) {
        _this.error = {
          code: playerSessionError.code,
          codeString: playerSessionError.codeString
        };
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('setPlayerSessionError: setPlaybackState call');
        _this.setPlaybackState();
      };
      this.resetError = function () {
        _this.error = {
          code: _$$_REQUIRE(_dependencyMap[1]).DEFAULT_ERROR_CODE,
          codeString: _$$_REQUIRE(_dependencyMap[1]).DEFAULT_ERROR_CODE_STRING
        };
      };
      this.destroy = function () {
        try {
          _this.playerState = _$$_REQUIRE(_dependencyMap[4]).PlayerState.PLAYER_STATE_SESSION_RELEASE;
          _this.setPlaybackState();
          _this.removeEventListeners(_this.mediaPlayer);
          _$$_REQUIRE(_dependencyMap[5]).PlayerSession.destroy();
        } catch (error) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.error('An exception occurred while destroying PlayerSession:\n', error);
        }
      };
    }
    return _$$_REQUIRE(_dependencyMap[6])(PlayerSessionClient, [{
      key: "setEventListeners",
      value: function setEventListeners() {
        for (var listener in this.eventListeners) {
          var _this$mediaPlayer12;
          if (this.eventListeners.hasOwnProperty(listener)) (_this$mediaPlayer12 = this.mediaPlayer) == null ? undefined : _this$mediaPlayer12.addEventListener(listener, this.eventListeners[listener]);
        }
      }
    }, {
      key: "removeEventListeners",
      value: function removeEventListeners(mediaPlayer) {
        if (mediaPlayer === null) {
          return;
        }
        for (var listener in this.eventListeners) {
          if (this.eventListeners.hasOwnProperty(listener)) mediaPlayer.removeEventListener(listener, this.eventListeners[listener]);
        }
      }
    }]);
  }();
  exports.PlayerSessionClient = PlayerSessionClient;
},"bc928d93d4283a83c808",["3508abd8c6b891008c0d","7be972a45ac7eda0538a","52d2d317ae633416b81d","1f12e7e43345228dfcad","91f63a0279037d488e06","95bf362220260f08aafe","5533cec96f6a88041c69"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isSeekEnabled = exports.isPlayEnabled = exports.isPauseEnabled = exports.getSupportedMediaOps = undefined;
  var getSupportedMediaOps = function getSupportedMediaOps(playerState) {
    var supportedMediaOps = _$$_REQUIRE(_dependencyMap[0]).PlayerMediaOps.PLAYER_MEDIA_OP_STOP | _$$_REQUIRE(_dependencyMap[0]).PlayerMediaOps.PLAYER_MEDIA_OP_START_OVER | _$$_REQUIRE(_dependencyMap[0]).PlayerMediaOps.PLAYER_MEDIA_OP_INVALID;
    if ((0, exports.isPauseEnabled)(playerState)) supportedMediaOps |= _$$_REQUIRE(_dependencyMap[0]).PlayerMediaOps.PLAYER_MEDIA_OP_PAUSE;
    if ((0, exports.isPlayEnabled)(playerState)) supportedMediaOps |= _$$_REQUIRE(_dependencyMap[0]).PlayerMediaOps.PLAYER_MEDIA_OP_PLAY | _$$_REQUIRE(_dependencyMap[0]).PlayerMediaOps.PLAYER_MEDIA_OP_PLAY_URI;
    if ((0, exports.isSeekEnabled)(playerState)) supportedMediaOps |= _$$_REQUIRE(_dependencyMap[0]).PlayerMediaOps.PLAYER_MEDIA_OP_SEEK_TO | _$$_REQUIRE(_dependencyMap[0]).PlayerMediaOps.PLAYER_MEDIA_OP_REWIND | _$$_REQUIRE(_dependencyMap[0]).PlayerMediaOps.PLAYER_MEDIA_OP_FF;
    return supportedMediaOps;
  };
  exports.getSupportedMediaOps = getSupportedMediaOps;
  var isPauseEnabled = function isPauseEnabled(playerState) {
    var pauseDisabledStates = [_$$_REQUIRE(_dependencyMap[0]).PlayerState.PLAYER_STATE_ERROR, _$$_REQUIRE(_dependencyMap[0]).PlayerState.PLAYER_STATE_STOPPED, _$$_REQUIRE(_dependencyMap[0]).PlayerState.PLAYER_STATE_PAUSED, _$$_REQUIRE(_dependencyMap[0]).PlayerState.PLAYER_STATE_STOPPED];
    return !pauseDisabledStates.includes(playerState);
  };
  exports.isPauseEnabled = isPauseEnabled;
  var isPlayEnabled = function isPlayEnabled(playerState) {
    var playDisabledStates = [_$$_REQUIRE(_dependencyMap[0]).PlayerState.PLAYER_STATE_ERROR, _$$_REQUIRE(_dependencyMap[0]).PlayerState.PLAYER_STATE_PLAYING, _$$_REQUIRE(_dependencyMap[0]).PlayerState.PLAYER_STATE_BUFFERING];
    return !playDisabledStates.includes(playerState);
  };
  exports.isPlayEnabled = isPlayEnabled;
  var isSeekEnabled = function isSeekEnabled(playerState) {
    var seekDisabledStates = [_$$_REQUIRE(_dependencyMap[0]).PlayerState.PLAYER_STATE_ERROR, _$$_REQUIRE(_dependencyMap[0]).PlayerState.PLAYER_STATE_CONNECTING];
    return !seekDisabledStates.includes(playerState);
  };
  exports.isSeekEnabled = isSeekEnabled;
},"52d2d317ae633416b81d",["91f63a0279037d488e06"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2022-2023 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MediaElementEventRouter = undefined;
  var W3CMediaTurboModule_1 = __importDefault(_$$_REQUIRE(_dependencyMap[0]));
  /**
   * NFP Turbo module sends MediaElementEvent as a callback. However,
   * W3C spec expects the events to be emitted from elements like
   * HTMLMediaElement, MediaSource and SourceBuffer.
   * This file receives the event from Turbo module and routes it
   * to registered objects (HTMLMediaElement, MediaSource and SourceBuffer)
   */
  var MediaElementEventRouter = /*#__PURE__*/function () {
    /**
     * MediaElement Event Sources
     */

    function MediaElementEventRouter(mediaElement) {
      var _this = this;
      _$$_REQUIRE(_dependencyMap[1])(this, MediaElementEventRouter);
      this.mediaElement = mediaElement;
      this.mediaPlayer = null;
      this.mediaSource = null;
      this.sourceBuffers = new Array();
      var mediaEventSource = W3CMediaTurboModule_1.default.getMediaEventSource();
      this.MEDIA_EVENT_SOURCE_ACTIVESOURCEBUFFERS = mediaEventSource.ACTIVESOURCEBUFFERS;
      this.MEDIA_EVENT_SOURCE_AUDIO_TRACKLIST = mediaEventSource.AUDIO_TRACKLIST;
      this.MEDIA_EVENT_SOURCE_HTMLMEDIAELEMENT = mediaEventSource.HTMLMEDIAELEMENT;
      this.MEDIA_EVENT_SOURCE_MEDIASOURCE = mediaEventSource.MEDIASOURCE;
      this.MEDIA_EVENT_SOURCE_SOURCEBUFFER = mediaEventSource.SOURCEBUFFER;
      this.MEDIA_EVENT_SOURCE_VIDEO_TRACKLIST = mediaEventSource.VIDEO_TRACKLIST;
      this.MEDIA_EVENT_SOURCE_TEXT_TRACKLIST = mediaEventSource.TEXT_TRACKLIST;
      this.onMediaElementEvent = this.onMediaElementEvent.bind(this);
      /**
       * Register the event callback to turbo module
       */
      W3CMediaTurboModule_1.default.setEventCallback(this.mediaElement, function (event, buffer) {
        event.buffer = buffer;
        return _this.onMediaElementEvent(event);
      });
    }
    /**
     * Register the HTMLMediaElement object  to receive events
     * @param mediaPlayer HTMLMediaElement object that will receives the event
     */
    return _$$_REQUIRE(_dependencyMap[2])(MediaElementEventRouter, [{
      key: "registerHTMLMediaElement",
      value: function registerHTMLMediaElement(mediaPlayer) {
        this.mediaPlayer = mediaPlayer;
      }
      /**
       * Register  the MediaSource object to receive events
       * @param mediaSource MediaSource object that will receives the event
       */
    }, {
      key: "registerMediaSource",
      value: function registerMediaSource(mediaSource) {
        this.mediaSource = mediaSource;
      }
      /**
       * Register  the  SourceBuffer object to receive events
       * @param sourceBuffer SourceBuffer object that will receives the event
       */
    }, {
      key: "registerSourceBuffer",
      value: function registerSourceBuffer(sourceBuffer) {
        var bufferId = sourceBuffer.getId();
        this.sourceBuffers.push(sourceBuffer);
      }
      /**
       * Deregister MediaElement, MediaSource and SourceBuffer
       */
    }, {
      key: "deregisterMediaElement",
      value: function deregisterMediaElement() {
        this.mediaPlayer = null;
        this.mediaSource = null;
        this.sourceBuffers.splice(0, this.sourceBuffers.length);
      }
      /**
       * Routes events to respective registered components.
       */
    }, {
      key: "onMediaElementEvent",
      value: function onMediaElementEvent(event) {
        var _this$mediaSource,
          _this2 = this,
          _this$mediaSource2,
          _this$mediaPlayer2;
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`MediaElementEventRouter:onMediaElementEvent: src: ${event.src}, name: ${event.name} \
                trackId: ${event.track_id}, sourceBufferId: ${event.sourcebuffer_id}`);
        switch (event.src) {
          case this.MEDIA_EVENT_SOURCE_SOURCEBUFFER:
            // route to source buffers
            this.sourceBuffers.forEach(function (sourceBuffer) {
              if (event.sourcebuffer_id === sourceBuffer.getId()) {
                sourceBuffer.handleEvent(event);
              }
            });
            break;
          case this.MEDIA_EVENT_SOURCE_ACTIVESOURCEBUFFERS:
            // route to media source
            (_this$mediaSource = this.mediaSource) == null ? undefined : _this$mediaSource.handleEvent(event.name);
            break;
          case this.MEDIA_EVENT_SOURCE_TEXT_TRACKLIST:
          case this.MEDIA_EVENT_SOURCE_AUDIO_TRACKLIST:
          case this.MEDIA_EVENT_SOURCE_VIDEO_TRACKLIST:
            // track list could be targeted to a source buffer or media element.
            // identify the target using source buffer id and route accordingly
            // currently native impl doesn't support media element target.
            // will be added when URL playback support is added.
            var eventHandled = false;
            this.sourceBuffers.forEach(function (sourceBuffer) {
              if (event.sourcebuffer_id === sourceBuffer.getId()) {
                var _this2$mediaPlayer;
                sourceBuffer.handleEvent(event);
                // also mirror this track event to HTMLMediaElement object
                // Section 4.5.7 Initialization Segment Received
                // Point: 5.1.2.9: Add new audio track to the audioTracks attribute on the HTMLMediaElement.
                (_this2$mediaPlayer = _this2.mediaPlayer) == null ? undefined : _this2$mediaPlayer.handleEvent(event);
                eventHandled = true;
              }
            });
            // if not handled by source buffers above, it means it is for HTMLMediaElement Obj
            // for URL based playback
            if (!eventHandled) {
              var _this$mediaPlayer;
              (_this$mediaPlayer = this.mediaPlayer) == null ? undefined : _this$mediaPlayer.handleEvent(event);
            }
            break;
          case this.MEDIA_EVENT_SOURCE_MEDIASOURCE:
            (_this$mediaSource2 = this.mediaSource) == null ? undefined : _this$mediaSource2.handleEvent(event.name);
            break;
          case this.MEDIA_EVENT_SOURCE_HTMLMEDIAELEMENT:
          default:
            (_this$mediaPlayer2 = this.mediaPlayer) == null ? undefined : _this$mediaPlayer2.handleEvent(event);
            break;
        }
      }
    }]);
  }();
  exports.MediaElementEventRouter = MediaElementEventRouter;
},"bce3d776a4d73e681b59",["0814a269c2fb50034991","3508abd8c6b891008c0d","5533cec96f6a88041c69","1f12e7e43345228dfcad"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2022-2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  function _callSuper(t, o, e) { return o = _$$_REQUIRE(_dependencyMap[0])(o), _$$_REQUIRE(_dependencyMap[1])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _$$_REQUIRE(_dependencyMap[0])(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MediaSource = exports.GlobalMediaSources = undefined;
  var W3CMediaTurboModule_1 = __importDefault(_$$_REQUIRE(_dependencyMap[2]));
  var DEFAULT_BUFFER_APPEND_CHUNK_SIZE = 131072;
  var DEFAULT_EVICTION_THRESHOLD = 104857600;
  var EOS_NETWORK_ERROR = "network";
  var EOS_DECODE_ERROR = "decode";
  // Size of the string "codecs=". The size of codecs value might be different.
  var SIZE_OF_CODECS_ATTRIBUTE = 7;
  /**
   * @hidden
   */
  var BlobData = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[3])(function BlobData() {
    _$$_REQUIRE(_dependencyMap[4])(this, BlobData);
    this.blobId = 0;
    this.offset = 0;
  });
  /**
   * @hidden
   */
  exports.GlobalMediaSources = new Map();
  /**
   * Implements the `MediaSource` interface. It uses `EventEmitter` to emit events.
   * Maintains a list of `SourceBuffers` object and Active Source buffers.
   */
  var MediaSource = /*#__PURE__*/function (_EventAttributes_1$Ev) {
    function MediaSource() {
      var _this;
      _$$_REQUIRE(_dependencyMap[4])(this, MediaSource);
      _$$_REQUIRE(_dependencyMap[5]).LogUtil.info("MediaSource:+constructor");
      var _eventEmitter = new (_$$_REQUIRE(_dependencyMap[6]).MediaEventEmitterImpl)();
      _this = _callSuper(this, MediaSource, [_eventEmitter]);
      _this.sourceBuffersList = new (_$$_REQUIRE(_dependencyMap[7]).SourceBufferListImpl)();
      _this.activeSourceBuffersList = new (_$$_REQUIRE(_dependencyMap[7]).SourceBufferListImpl)();
      /**
       * @hidden
       */
      _this.size = 0;
      /**
       * @hidden
       */
      _this.type = "mediasource";
      _this.eventEmitter = _eventEmitter;
      _this.canConstructInDedicatedWorker = true;
      /**
       *  When the `MediaSource` is created readyState must be set to "closed".
       *  Indicates that the source is not currently attached to a media element.
       *  For additional information, see
       *  https://www.w3.org/TR/2016/REC-media-source-20161117/#attributes
      */
      _this.readyState_ = _$$_REQUIRE(_dependencyMap[8]).ReadyState.closed;
      _this.mediaElement = null;
      _this.mediaElementEventRouter = null;
      _this.id = MediaSource.idGen++;
      _this.data = new BlobData();
      _this.data.blobId = _this.id;
      exports.GlobalMediaSources.set(_this.id, _this);
      _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaSource[${_this.id}]:-constructor: ${_this.id}`);
      return _this;
    }
    /**
     * @hidden
     */
    _$$_REQUIRE(_dependencyMap[9])(MediaSource, _EventAttributes_1$Ev);
    return _$$_REQUIRE(_dependencyMap[3])(MediaSource, [{
      key: "slice",
      value:
      /**
       * @hidden
       */

      /**
       * @hidden
       */
      function slice(start, end) {
        // @ts-ignore
        return this;
      }
      /**
       * @hidden
       */
    }, {
      key: "setMediaElementHandle",
      value: function setMediaElementHandle(mediaElement) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaSource[${this.id}]:+setMediaElementHandle `);
        this.mediaElement = mediaElement;
        W3CMediaTurboModule_1.default.createAndAttachMediaSource(this.mediaElement);
        /**
         * The source has been opened by a media element and is ready for data to be
         * appended to the SourceBuffer objects in sourceBuffers.
         *  For additional information, see
         * https://www.w3.org/TR/media-source-2/#dom-readystate-open/
         */
        if (this.mediaElement) {
          this.transitionToState(_$$_REQUIRE(_dependencyMap[8]).ReadyState.open);
        }
      }
      /**
       * @hidden
       */
    }, {
      key: "setMediaEventRouter",
      value: function setMediaEventRouter(mediaElementEventRouter) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaSource[${this.id}]:setMediaEventRouter`);
        // register media source with media element event router
        mediaElementEventRouter == null ? undefined : mediaElementEventRouter.registerMediaSource(this);
        this.mediaElementEventRouter = mediaElementEventRouter;
      }
      // EventTarget APIs
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaSource[${this.id}]:addEventListener: ${type}`);
        this.eventEmitter.addListener(type, listener);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaSource[${this.id}]:removeEventListener: ${type}`);
        this.eventEmitter.removeListener(type, listener);
      }
      /**
       * @hidden
       * Currently, addsourcebuffer and removesourcebuffer doesn't give us the
       * id of the source buffers. So when we get a add or remove source buffer event
       * on active source buffer we will re-build the list from turbo module.
       * @note: This thing needs to be re-designed as there could be synchronization problems
       * leading to mismatch in the list maintained by native or crash in app while accessing
       * activeSourceBuffers
       */
    }, {
      key: "rebuildActiveSourceBuffersList",
      value: function rebuildActiveSourceBuffersList() {
        var _this2 = this;
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaSource[${this.id}]:rebuildActiveSourceBuffersList`);
        var activeSourceBufferIds;
        if (this.mediaElement != null) {
          activeSourceBufferIds = W3CMediaTurboModule_1.default.getActiveSourceBuffers(this.mediaElement);
        }
        if (activeSourceBufferIds === undefined) {
          return;
        }
        // remove all source buffers from active source buffers list
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaSource[${this.id}]:clearing list`);
        this.activeSourceBuffersList.clear();
        // now loop through all the active source buffer ids and add them to the
        // active source buffer list. We are following the order of the source buffers
        // as maintained natively, and hoping that it matches the source buffer list.
        // As pe spec, https://www.w3.org/TR/media-source-2/#dom-mediasource-activesourcebuffers
        // "SourceBuffer objects in this list MUST appear in the same order as they appear
        // in the sourceBuffers attribute; e.g., if only sourceBuffers[0] and sourceBuffers[3]
        // are in activeSourceBuffers, then activeSourceBuffers[0] MUST equal sourceBuffers[0]
        // and activeSourceBuffers[1] MUST equal sourceBuffers[3]."
        activeSourceBufferIds.forEach(function (id) {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaSource[${_this2.id}]:finding source buffer for ${id}`);
          // find the source buffer based on id in source buffer list
          // and add it to active source buffer list
          for (var i = 0; i < _this2.sourceBuffersList.length; i++) {
            if (id === _this2.sourceBuffersList.getSourceBuffer(i).getId()) {
              // found the source buffer. now add it to the active buffers list
              _this2.activeSourceBuffersList.addSourceBuffer(_this2.sourceBuffersList.getSourceBuffer(i));
            }
          }
          ;
        });
      }
      /**
       * @hidden
       * Handle events from native turbo module
       */
    }, {
      key: "handleEvent",
      value: function handleEvent(eventName) {
        if (eventName === "sourceopen") {
          if (this.readyState_ === _$$_REQUIRE(_dependencyMap[8]).ReadyState.ended) {
            this.transitionToState(_$$_REQUIRE(_dependencyMap[8]).ReadyState.open);
          }
          return;
        } else if (eventName === "sourceended") {
          if (this.readyState_ === _$$_REQUIRE(_dependencyMap[8]).ReadyState.open) {
            this.transitionToState(_$$_REQUIRE(_dependencyMap[8]).ReadyState.ended);
          } else {
            return;
          }
        } else if (this.mediaElement != null) {
          // "addsourcebuffer" or "removesourcebuffer"
          this.rebuildActiveSourceBuffersList();
        }
        this.eventEmitter.emit(eventName, new (_$$_REQUIRE(_dependencyMap[10]).Event)(eventName, this));
      }
    }, {
      key: "sourceBuffers",
      get:
      /**
       * Gets the source buffers added to the media source.
       * For additional information, see
       * https://www.w3.org/TR/media-source-2/#dom-mediasource-sourcebuffers.
       */
      function get() {
        return this.sourceBuffersList;
      }
      /**
       * Gets the active source buffers of mediasource.
       * For additional information, see
       * https://www.w3.org/TR/media-source-2/#dom-mediasource-activesourcebuffers.
       */
    }, {
      key: "activeSourceBuffers",
      get: function get() {
        return this.activeSourceBuffersList;
      }
      /**
       * Gets the ready state of MediaSource.
       * For additional information, see
       * https://www.w3.org/TR/media-source-2/#dom-mediasource-readystate.
       */
    }, {
      key: "readyState",
      get: function get() {
        // TODO: Currently NFP doesn't support MediaSource's ready state.
        return this.readyState_;
      }
      /**
       * Gets the duraton of the content.
       * For additional information, see
       * https://www.w3.org/TR/media-source-2/#dom-mediasource-duration.
       */
    }, {
      key: "duration",
      get: function get() {
        // https://www.w3.org/TR/media-source-2/#dom-mediasource-duration
        // If the readyState attribute is "closed" then return NaN and abort these steps.
        if (!this.mediaElement || this.readyState_ === _$$_REQUIRE(_dependencyMap[8]).ReadyState.closed) {
          return NaN;
        }
        return W3CMediaTurboModule_1.default.getDuration(this.mediaElement);
      }
      /**
       * Sets the duraton of the content.
       * For additional information, see
       * https://www.w3.org/TR/media-source-2/#dom-mediasource-duration.
       */,
      set: function set(duration) {
        // https://www.w3.org/TR/media-source-2/#dom-mediasource-duration
        // If the value being set is negative or NaN then throw a TypeError exception
        // and abort these steps.
        if (duration < 0 || Number.isNaN(duration)) {
          throw new TypeError("Not applicable duration value");
        }
        // If the readyState attribute is not "open" then throw an InvalidStateError
        // exception and abort these steps.
        if (!this.mediaElement || this.readyState_ !== _$$_REQUIRE(_dependencyMap[8]).ReadyState.open) {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.error(`MediaSource::set duration mediaElement is empty or readyState is not 'open'`);
          throw new (_$$_REQUIRE(_dependencyMap[11]).InvalidStateError)("no media element attached");
        }
        // If any of the sourcebuffer 'updating' is true then
        // throw an InvalidStateError exception
        for (var i = 0; i < this.sourceBuffersList.length; i++) {
          if (this.sourceBuffersList.getSourceBuffer(i).updating) {
            throw new (_$$_REQUIRE(_dependencyMap[11]).InvalidStateError)("set duration throws an exception when updating attribute is true.");
          }
        }
        W3CMediaTurboModule_1.default.setDuration(this.mediaElement, duration);
      }
      /**
       * For additional information, see
       * https://www.w3.org/TR/media-source-2/#dom-mediasource-onsourceopen
       */
    }, {
      key: "onsourceopen",
      set: function set(listener) {
        this.addEvent(this._onsourceopen, "sourceopen", listener);
      }
      /**
       * For additional information, see
       * https://www.w3.org/TR/media-source-2/#dom-mediasource-onsourceended
       */
    }, {
      key: "onsourceended",
      set: function set(listener) {
        this.addEvent(this._onsourceended, "sourceended", listener);
      }
      /**
       * For additional information, see
       * https://www.w3.org/TR/media-source-2/#dom-mediasource-onsourceclose
       */
    }, {
      key: "onsourceclose",
      set: function set(listener) {
        this.addEvent(this._onsourceclose, "sourceclose", listener);
      }
      /**
       * Get max supported resolution based on the decoder profile.
       */
    }, {
      key: "getMaxSupportedResolution",
      value: function getMaxSupportedResolution(mimestr) {
        var resolution = {
          width: 0,
          height: 0
        };
        var mimeType = _$$_REQUIRE(_dependencyMap[12]).MimeType.parseMimeString(mimestr);
        if (!mimeType || mimeType.type !== "video") {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`Invalid mimeType or not a video mimeType`);
          return resolution;
        }
        var codecStr = mimeType.getParameter("codecs");
        var codecsArray = codecStr === undefined ? [] : codecStr.split(",");
        if (codecsArray.length == 0 && mimeType.subType) {
          var possibleCodec = mimeType.subType;
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaSource: mimeType codecStr was invalid or empty,using mimeType.subType = ${possibleCodec}`);
          codecsArray = [possibleCodec];
        }
        for (var index = 0; index < codecsArray.length; index++) {
          var codec = (0, _$$_REQUIRE(_dependencyMap[13]).removeLeadingAndTrailingHTTPWhitespace)(codecsArray[index]);
          if (!codec || !_$$_REQUIRE(_dependencyMap[14]).MimeTypeRegistry.isKnownVideoCodec(codec)) {
            continue;
          }
          var codecInfo = (0, _$$_REQUIRE(_dependencyMap[15]).parseCodecMime)(codec, "");
          if (!codecInfo) {
            continue;
          }
          var decoderConfig = new (_$$_REQUIRE(_dependencyMap[16]).VideoDecoderConfig)();
          var mediaFormat = new (_$$_REQUIRE(_dependencyMap[16]).MediaFormat)(codecInfo.codec);
          decoderConfig.mediaFormat = mediaFormat;
          var videoCaps = _$$_REQUIRE(_dependencyMap[16]).KeplerMediaDescriptor.queryMediaCapabilitiesSync(decoderConfig);
          for (var _index = 0; _index < videoCaps.length; _index++) {
            var videoCapability = videoCaps[_index];
            var resolutions = videoCapability.videoFormatCapabilities.resolutions;
            resolution.width = Math.max(resolution.width, resolutions[1].width);
            resolution.height = Math.max(resolution.height, resolutions[1].height);
          }
        }
        return resolution;
      }
      /**
       * Adds a SourceBuffer to the media source based on mime type.
       * For additional information, see
       * https://www.w3.org/TR/media-source-2/#dom-mediasource-addsourcebuffer.
       * @param type The mime type of data sent to source buffer.
       */
    }, {
      key: "addSourceBuffer",
      value: function addSourceBuffer(type) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaSource[${this.id}]::addSourceBuffer: ${type}`);
        // Spec Refence:  https://www.w3.org/TR/media-source-2/#dom-mediasource-addsourcebuffer
        // 1. If type is an empty string then throw a TypeError exception and abort these steps.
        if (typeof type !== "string") {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.error(`MediaSource::addSourceBuffer: type is not string`);
          throw new (_$$_REQUIRE(_dependencyMap[11]).NotSupportedError)("addSourcebuffer: 'type' expected to be string but got null");
        }
        if (type === "") {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.error(`MediaSource::addSourceBuffer: empty type`);
          throw new TypeError("empty type");
        }
        // 2. If type contains a MIME type that is not supported or contains a MIME type that
        //  is not supported with the types specified for the other SourceBuffer objects in sourceBuffers,
        // then throw a NotSupportedError exception and abort these steps.
        // TODO
        // "4. If the readyState attribute is not in the "open" state
        //  then throw an InvalidStateError exception and abort these steps."
        if (this.readyState_ !== _$$_REQUIRE(_dependencyMap[8]).ReadyState.open) {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.error(`MediaSource: not in ready state or no media element attched`);
          throw new (_$$_REQUIRE(_dependencyMap[11]).InvalidStateError)("not in ready state or no media element attched");
        }
        var sourceBufferWidth = 1920;
        var sourceBufferHeight = 1080;
        var resolution = this.getMaxSupportedResolution(type);
        if (resolution != null && resolution.width && resolution != null && resolution.height) {
          sourceBufferWidth = resolution.width;
          sourceBufferHeight = resolution.height;
        }
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaSource: Source Buffer Width = ${sourceBufferWidth} , Height = ${sourceBufferHeight}`);
        if (this.mediaElement != null) {
          var _this$mediaElementEve;
          var result = W3CMediaTurboModule_1.default.addSourceBuffer(this.mediaElement, DEFAULT_BUFFER_APPEND_CHUNK_SIZE, sourceBufferWidth, sourceBufferHeight, 30, DEFAULT_EVICTION_THRESHOLD, type);
          if (result.sourceBufferId === undefined) {
            _$$_REQUIRE(_dependencyMap[5]).LogUtil.error("Unable to add Source Buffer!!!");
            throw new (_$$_REQUIRE(_dependencyMap[11]).InvalidStateError)("Unable to add Source Buffer");
          }
          var sourceBufferImpl = new (_$$_REQUIRE(_dependencyMap[17]).SourceBufferImpl)(this.mediaElement, this, result.sourceBufferId, type);
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaSource[${this.id}]::addSourceBuffer:: registering source buffer ${result.sourceBufferId} to mediaElementEventRouter`);
          (_this$mediaElementEve = this.mediaElementEventRouter) == null ? undefined : _this$mediaElementEve.registerSourceBuffer(sourceBufferImpl);
          this.sourceBuffersList.addSourceBuffer(sourceBufferImpl);
          return sourceBufferImpl;
        } else {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.error(`MediaSource::addSourceBuffer: no media element attched`);
          throw new (_$$_REQUIRE(_dependencyMap[11]).InvalidStateError)("no media element attched");
        }
      }
      /**
       * Removes the source buffer from media source.
       * For additional information, see
       * https://www.w3.org/TR/media-source-2/#dom-mediasource-removesourcebuffer.
       * @param sourceBuffer source buffer instance to be removed.
       */
    }, {
      key: "removeSourceBuffer",
      value: function removeSourceBuffer(sourceBuffer) {
        var sourceBufferImpl = sourceBuffer;
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaSource[${this.id}]:removeSourceBuffer ${sourceBufferImpl.getId()}`);
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.error(`MediaSource: no media element`);
          return;
        }
        W3CMediaTurboModule_1.default.removeSourceBuffer(this.mediaElement, sourceBufferImpl.getId());
        this.sourceBuffersList.removeSourceBuffer(sourceBufferImpl.getId());
      }
      /**
       * Signals the end of stream for media source.
       * For additional information, see
       * https://www.w3.org/TR/media-source-2/#dom-mediasource-endofstream.
       * @param error (optional) EndOfStreamError
       */
    }, {
      key: "endOfStream",
      value: function endOfStream(error) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaSource[${this.id}]:endOfStream ${error}`);
        if (this.readyState_ !== _$$_REQUIRE(_dependencyMap[8]).ReadyState.open) {
          throw new (_$$_REQUIRE(_dependencyMap[11]).InvalidStateError)("Media Source is not in open state. Attach to media element");
        }
        if (!this.mediaElement) {
          throw new (_$$_REQUIRE(_dependencyMap[11]).InvalidStateError)("Null media Element");
        }
        for (var i = 0; i < this.sourceBuffersList.length; i++) {
          if (this.sourceBuffersList.getSourceBuffer(i).updating) {
            throw new (_$$_REQUIRE(_dependencyMap[11]).InvalidStateError)("endOfStream() throws an exception when updating attribute is true.");
          }
        }
        // this will trigger sourceended event callback
        if (error === undefined) {
          W3CMediaTurboModule_1.default.endOfStream(this.mediaElement, "");
        } else if (error !== EOS_NETWORK_ERROR && error !== EOS_DECODE_ERROR || error === null) {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.info("MediaSource[${this.id}]:endOfStream invalid error string or null");
          throw new TypeError("endOfStream");
        } else {
          if (this.sourceBuffers.length !== 0) {
            // TODO: need to handle this in native
            W3CMediaTurboModule_1.default.endOfStream(this.mediaElement, error == null ? undefined : error.toString());
          }
        }
        this.handleEvent("sourceended");
      }
      /**
       * Sets the start and end seek range for live.
       * For additional information, see
       * https://www.w3.org/TR/media-source-2/#dom-mediasource-setliveseekablerange.
       * @param start Start position of the seek range of a live content in seconds.
       * @param end  End position of the seek range of a live content in seconds.
       */
    }, {
      key: "setLiveSeekableRange",
      value: function setLiveSeekableRange(start, end) {
        if (!this.mediaElement || this.readyState_ !== _$$_REQUIRE(_dependencyMap[8]).ReadyState.open) {
          throw new (_$$_REQUIRE(_dependencyMap[11]).InvalidStateError)(`this.mediaElement: ${this.mediaElement}, readyState: ${this.readyState_}`);
        }
        if (start < 0 || start > end) {
          throw new TypeError(`Not applicable start: ${start} and end: ${end} value`);
        }
        W3CMediaTurboModule_1.default.setLiveSeekableRange(this.mediaElement, start, end);
      }
      /**
       * Clears the previously set live seek range.
       * For additional information, see
       * https://www.w3.org/TR/media-source-2/#dom-mediasource-clearliveseekablerange.
       */
    }, {
      key: "clearLiveSeekableRange",
      value: function clearLiveSeekableRange() {
        if (!this.mediaElement || this.readyState_ !== _$$_REQUIRE(_dependencyMap[8]).ReadyState.open) {
          throw new (_$$_REQUIRE(_dependencyMap[11]).InvalidStateError)(`this.mediaElement: ${this.mediaElement}, readyState: ${this.readyState_}`);
        }
        W3CMediaTurboModule_1.default.clearLiveSeekableRange(this.mediaElement);
      }
      /**
       * @hidden
       */
    }, {
      key: "getHandle",
      value: function getHandle() {
        return this;
      }
      /**
       * Checks whehter the mime type is supported by the Media source.
       * For additional information, see
       * https://www.w3.org/TR/media-source-2/#dom-mediasource-istypesupported.
       * @param type mime type.
       */
    }, {
      key: "transitionToState",
      value:
      /**
       * @hidden
       */
      function transitionToState(to) {
        /**
          * https://www.w3.org/TR/media-source-2/#dfn-sourceopen
          * readyState transitions from "closed" to "open" or from "ended" to "open".
          */
        if ((this.readyState_ === _$$_REQUIRE(_dependencyMap[8]).ReadyState.closed || this.readyState_ === _$$_REQUIRE(_dependencyMap[8]).ReadyState.ended) && to === _$$_REQUIRE(_dependencyMap[8]).ReadyState.open) {
          this.readyState_ = to;
          this.eventEmitter.emit("sourceopen", new (_$$_REQUIRE(_dependencyMap[10]).Event)("sourceopen", this));
        } else {
          this.readyState_ = to;
        }
      }
    }], [{
      key: "install",
      value: function install() {
        // TODO: using node in tsconfig.json fails compilation in yocto.
        // If we tried to fix it, DRM playback doesn't happen. Needs more deep dive.
        // Temporarily moving these polyfills back to app
        // (global as any).window.MediaSource = MediaSource;
        // (global as any).MediaSource = MediaSource;
        // LogUtil.info("xpoly, installing MediaSource polyfills");
      }
    }, {
      key: "isTypeSupported",
      value: function isTypeSupported(type) {
        _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaSource: isTypeSupported ${type}`);
        // 1. If type is an empty string, then return false.
        if (!type || type.length === 0) {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.error(`MediaSource: type is empty`);
          return false;
        }
        // TODO: Remove this hack after PROJXXXX-107806 is fixed.
        if (type.localeCompare(_$$_REQUIRE(_dependencyMap[14]).UNKNOWN_SHAKA_MIME) === 0) {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.info(`MediaSource: Known invalid mimetype is supported as of now`);
          return true;
        }
        var mimeType = _$$_REQUIRE(_dependencyMap[12]).MimeType.parseMimeString(type);
        // 2. If type does not contain a valid MIME type string, then return false.
        if (mimeType === null) {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.error("invalid mime ", type);
          return false;
        }
        if (mimeType.type !== "video" && mimeType.type !== "audio") {
          _$$_REQUIRE(_dependencyMap[5]).LogUtil.error("invalid mime type ", mimeType.type);
          return false;
        }
        // 3. If type contains a media type or media subtype that the MediaSource does not support, then return false.
        // 4. If type contains a codec that the MediaSource does not support, then return false.
        // 5. If the MediaSource does not support the specified combination of media type, media subtype, and codecs then return false.
        if (!_$$_REQUIRE(_dependencyMap[14]).MimeTypeRegistry.checkCodecParamForEnforcedContainers(mimeType)) return false;
        return _$$_REQUIRE(_dependencyMap[14]).MimeTypeRegistry.checkSupportedType(mimeType);
      }
    }]);
  }(_$$_REQUIRE(_dependencyMap[18]).EventAttributes);
  MediaSource.idGen = 1;
  exports.MediaSource = MediaSource;
},"559b56212f65a51c1441",["f391b9d534c3a6bc8659","4534eb96ece5e83c089a","0814a269c2fb50034991","5533cec96f6a88041c69","3508abd8c6b891008c0d","1f12e7e43345228dfcad","92ad024a633394b0493f","ad2607914fe9c1e9910e","8ee67effabd3f8c12ca2","73afcd34a88a750f6d69","9e1e5e085598ef3ad539","7f2298a3ae35e640412a","51ba9e69d25f63defe5f","7c24a30d9976d826af0f","5276f25b9cfa3ba46e9e","76e94d9cb88d077fdd92","87c1deaf4e092124fc7a","d2e0db98724a97dd6b88","51da1666f805b86ecd3d"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2022 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  function _callSuper(t, o, e) { return o = _$$_REQUIRE(_dependencyMap[0])(o), _$$_REQUIRE(_dependencyMap[1])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _$$_REQUIRE(_dependencyMap[0])(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SourceBufferListImpl = undefined;
  /**
   * Proxies to support [ ] operator on VideoTrackList
   */
  var proxyHandlers = {
    get: function get(target, key) {
      if (!(key in target)) {
        return target.sourceBuffers[key];
      } else {
        return Reflect.get(target, key);
      }
    }
  };
  /**
   * This class implements SourceBufferList and uses Proxy
   * to implement [ ] operator to access underlying soucebuffes
   * at the specified index.
   */
  var SourceBufferListImpl = /*#__PURE__*/function (_EventAttributes_1$Ev) {
    function SourceBufferListImpl() {
      var _this;
      _$$_REQUIRE(_dependencyMap[2])(this, SourceBufferListImpl);
      var _eventEmitter = new (_$$_REQUIRE(_dependencyMap[3]).MediaEventEmitterImpl)();
      _this = _callSuper(this, SourceBufferListImpl, [_eventEmitter]);
      _this.eventEmitter = _eventEmitter;
      _this.sourceBuffers = new Array();
      return _$$_REQUIRE(_dependencyMap[1])(_this, new Proxy(_this, proxyHandlers));
    }
    _$$_REQUIRE(_dependencyMap[4])(SourceBufferListImpl, _EventAttributes_1$Ev);
    return _$$_REQUIRE(_dependencyMap[5])(SourceBufferListImpl, [{
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        _$$_REQUIRE(_dependencyMap[6]).LogUtil.info(`SourceBufferListImpl:addEventListener: ${type}`);
        this.eventEmitter.addListener(type, listener);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        _$$_REQUIRE(_dependencyMap[6]).LogUtil.info(`SourceBufferListImpl:removeEventListener: ${type}`);
        this.eventEmitter.removeListener(type, listener);
      }
      /** SourceBufferList implemetation */
    }, {
      key: "length",
      get: function get() {
        if (!this.sourceBuffers) {
          return 0;
        }
        return this.sourceBuffers.length;
      }
      /**
       * @hidden
       * Handle events from native turbo module
       */
    }, {
      key: "handleEvent",
      value: function handleEvent(eventName) {
        _$$_REQUIRE(_dependencyMap[6]).LogUtil.debug(`SourceBufferListImpl:handleEvent: event name ${eventName}`);
        if (eventName === "addsourcebuffer" || eventName === "removesourcebuffer") {
          this.eventEmitter.emit(eventName, new (_$$_REQUIRE(_dependencyMap[7]).Event)(eventName, this));
        }
      }
      /**
       * For additional information, see
       * https://www.w3.org/TR/media-source-2/#dom-sourcebufferlist-onaddsourcebuffer
       */
    }, {
      key: "onaddsourcebuffer",
      set: function set(listener) {
        this.addEvent(this._onaddsourcebuffer, "addsourcebuffer", listener);
      }
      /**
       * For additional information, see
       * https://www.w3.org/TR/media-source-2/#dom-sourcebufferlist-onremovesourcebuffer
       */
    }, {
      key: "onremovesourcebuffer",
      set: function set(listener) {
        this.addEvent(this._onremovesourcebuffer, "removesourcebuffer", listener);
      }
      /** public apis */
      /**
       * Gets Source buffer at index. THis needs to be called after checking
       * for array lenght by the callee
       */
    }, {
      key: "getSourceBuffer",
      value: function getSourceBuffer(index) {
        return this.sourceBuffers[index];
      }
      /**
       * Adds a source buffer to the list
       * @param sourceBuffer: SourceBufferImpl object that will be added to the list
       */
    }, {
      key: "addSourceBuffer",
      value: function addSourceBuffer(sourceBuffer) {
        _$$_REQUIRE(_dependencyMap[6]).LogUtil.info(`SourceBufferListImpl: addSourceBuffer id ${sourceBuffer.getId()}`);
        this.sourceBuffers.push(sourceBuffer);
        this.handleEvent("addsourcebuffer");
      }
      /**
       * Removes a source buffer from the list
       * @param id Unique id of the source buffer that needs to be removed
       */
    }, {
      key: "removeSourceBuffer",
      value: function removeSourceBuffer(id) {
        _$$_REQUIRE(_dependencyMap[6]).LogUtil.info(`SourceBufferListImpl: removeTrack id ${id}`);
        // find the track
        var sourceBufferIndex = undefined;
        this.sourceBuffers.forEach(function (souceBuffer, index) {
          if (souceBuffer.getId() === id) {
            sourceBufferIndex = index;
          }
        });
        // remove track if found
        if (sourceBufferIndex !== undefined) {
          this.sourceBuffers.splice(sourceBufferIndex, 1);
          this.handleEvent("removesourcebuffer");
        } else {
          _$$_REQUIRE(_dependencyMap[6]).LogUtil.warn(`source buffer id ${id} not found`);
        }
      }
      /**
       * Removes all source buffers from the list
       */
    }, {
      key: "clear",
      value: function clear() {
        _$$_REQUIRE(_dependencyMap[6]).LogUtil.info(`SourceBufferListImpl: clear `);
        this.sourceBuffers.splice(0, this.sourceBuffers.length);
        this.handleEvent("removesourcebuffer");
      }
    }]);
  }(_$$_REQUIRE(_dependencyMap[8]).EventAttributes);
  exports.SourceBufferListImpl = SourceBufferListImpl;
},"ad2607914fe9c1e9910e",["f391b9d534c3a6bc8659","4534eb96ece5e83c089a","3508abd8c6b891008c0d","92ad024a633394b0493f","73afcd34a88a750f6d69","5533cec96f6a88041c69","1f12e7e43345228dfcad","9e1e5e085598ef3ad539","51da1666f805b86ecd3d"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.EventAttributes = undefined;
  var EventAttributes = /*#__PURE__*/function () {
    function EventAttributes(_eventEmitter) {
      _$$_REQUIRE(_dependencyMap[0])(this, EventAttributes);
      this._eventEmitter = _eventEmitter;
    }
    return _$$_REQUIRE(_dependencyMap[1])(EventAttributes, [{
      key: "addEvent",
      value: function addEvent(currentListener, eventName, listener) {
        if (currentListener) {
          this._eventEmitter.removeEventListener(eventName, currentListener);
        }
        currentListener = listener;
        if (listener !== null) {
          this._eventEmitter.addEventListener(eventName, listener);
        }
      }
    }]);
  }();
  exports.EventAttributes = EventAttributes;
},"51da1666f805b86ecd3d",["3508abd8c6b891008c0d","5533cec96f6a88041c69"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2022 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.EndOfStreamError = exports.ReadyState = exports.AppendMode = undefined;
  /**
   * For additional information, see
   * https://www.w3.org/TR/media-source-2/#dom-appendmode.
   */
  var AppendMode;
  (function (AppendMode) {
    AppendMode["segments"] = "segments";
    AppendMode["sequence"] = "sequence";
  })(AppendMode = exports.AppendMode || (exports.AppendMode = {}));
  /**
   * For additional information, see
   * https://www.w3.org/TR/media-source-2/#dom-readystate.
   */
  var ReadyState;
  (function (ReadyState) {
    ReadyState["closed"] = "closed";
    ReadyState["open"] = "open";
    ReadyState["ended"] = "ended";
  })(ReadyState = exports.ReadyState || (exports.ReadyState = {}));
  /**
   * For additional information, see
   * https://www.w3.org/TR/media-source-2/#dom-endofstreamerror.
   */
  var EndOfStreamError;
  (function (EndOfStreamError) {
    /**
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-endofstreamerror-network.
     */
    EndOfStreamError["network"] = "network";
    /**
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-endofstreamerror-decode.
     */
    EndOfStreamError["decode"] = "decode";
  })(EndOfStreamError = exports.EndOfStreamError || (exports.EndOfStreamError = {}));
},"8ee67effabd3f8c12ca2",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2024 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MimeType = undefined;
  var MimeType = /*#__PURE__*/function () {
    function MimeType(mimeStr) {
      _$$_REQUIRE(_dependencyMap[0])(this, MimeType);
      this.mMimeString = mimeStr;
      this.mParameters = new Map();
    }
    return _$$_REQUIRE(_dependencyMap[1])(MimeType, [{
      key: "type",
      get: function get() {
        return this.mType;
      }
    }, {
      key: "subType",
      get: function get() {
        return this.mSubtype;
      }
    }, {
      key: "essence",
      get: function get() {
        if (this.mEssence === undefined || this.mEssence.length === 0) {
          this.mEssence = this.mType + "/" + this.mSubtype;
        }
        return this.mEssence;
      }
    }, {
      key: "getParameter",
      value: function getParameter(key) {
        return this.mParameters.get(key);
      }
    }, {
      key: "getParameterCount",
      value: function getParameterCount() {
        return this.mParameters.size;
      }
    }, {
      key: "mimeString",
      get: function get() {
        return this.mMimeString;
      }
      /**
       * https://mimesniff.spec.whatwg.org/#parsing-a-mime-type
       *
       * @param mimeStr @type {string} the mime string from application.
       * @returns @type {MimeType} if the provided mime is valid, null otherwise.
       */
    }], [{
      key: "parseMimeString",
      value: function parseMimeString(mimeStr) {
        // 1. Remove any leading and trailing HTTP whitespace from input.
        mimeStr = (0, _$$_REQUIRE(_dependencyMap[2]).removeLeadingAndTrailingHTTPWhitespace)(mimeStr);
        // 2. Let position be a position variable for input, initially pointing at the start of input.
        var position = 0;
        // 3. Let type be the result of collecting a sequence of code points that are not
        //    U+002F (/) from input, given position.
        var type = "";
        while (position < mimeStr.length && mimeStr[position] !== "/") {
          type += mimeStr[position];
          position++;
        }
        // 4. If type is the empty string or does not solely contain HTTP
        //    token code points, then return failure.
        if (type.length === 0 || !(0, _$$_REQUIRE(_dependencyMap[2]).solelyContainsHTTPTokenCodePoints)(type)) {
          return null;
        }
        // 5. If position is past the end of input, then return failure.
        if (position >= mimeStr.length) {
          return null;
        }
        // 6. Advance position by 1. (This skips past U+002F (/).)
        position++;
        // 7. Let subtype be the result of collecting a sequence of code
        //    points that are not U+003B (;) from input, given position.
        var subtype = "";
        while (position < mimeStr.length && mimeStr[position] !== ";") {
          subtype += mimeStr[position];
          position++;
        }
        // 8. Remove any trailing HTTP whitespace from subtype.
        subtype = (0, _$$_REQUIRE(_dependencyMap[2]).removeTrailingHTTPWhitespace)(subtype);
        // 9. If subtype is the empty string or does not solely contain
        //    HTTP token code points, then return failure.
        if (subtype.length === 0 || !(0, _$$_REQUIRE(_dependencyMap[2]).solelyContainsHTTPTokenCodePoints)(subtype)) {
          return null;
        }
        // 10. Let mimeType be a new MIME type record whose type is type,
        //     in ASCII lowercase, and subtype is subtype, in ASCII lowercase.
        var mimetype = new MimeType(mimeStr);
        mimetype.mType = type.toLowerCase();
        mimetype.mSubtype = subtype.toLowerCase();
        // 11. While position is not past the end of input:
        while (position < mimeStr.length) {
          // 11.1. Advance position by 1. (This skips past U+003B (;).)
          position++;
          // 11.2 Collect a sequence of code points that are HTTP whitespace from input given position.
          while ((0, _$$_REQUIRE(_dependencyMap[2]).isHTTPWhitespaceChar)(mimeStr[position])) {
            position++;
          }
          // 11.3 Let parameterName be the result of collecting a sequence of code points that are not
          //      U+003B (;) or U+003D (=) from input, given position.
          var parameterName = "";
          while (position < mimeStr.length && mimeStr[position] !== ";" && mimeStr[position] !== "=") {
            parameterName += mimeStr[position];
            position++;
          }
          // 11.4 Set parameterName to parameterName, in ASCII lowercase.
          parameterName = parameterName.toLowerCase();
          // 11.5 If position is not past the end of input, then:
          if (position < mimeStr.length) {
            // 11.5.1 If the code point at position within input is U+003B (;), then continue.
            if (mimeStr[position] === ";") {
              continue;
            }
            // 11.5.2 Advance position by 1. (This skips past U+003D (=).)
            position++;
          }
          // 11.6 If position is past the end of input, then break.
          if (position >= mimeStr.length) {
            break;
          }
          // 11.7 Let parameterValue be null.
          var parameterValue = "";
          // 11.8 If the code point at position within input is U+0022 ("), then:
          if (mimeStr[position] === "\"") {
            // 11.8.1 Set parameterValue to the result of collecting an HTTP quoted string
            //        from input, given position and true.
            // 11.8.2 Collect a sequence of code points that are not U+003B (;) from input, given position.
            var _ref = (0, _$$_REQUIRE(_dependencyMap[2]).collectHTTPQuotedString)(mimeStr, position);
            var _ref2 = _$$_REQUIRE(_dependencyMap[3])(_ref, 2);
            parameterValue = _ref2[0];
            position = _ref2[1];
            while (position < mimeStr.length && mimeStr[position] !== ";") {
              ++position;
            }
          } else {
            // 11.9. Otherwise:
            // 11.9.1 Set parameterValue to the result of collecting a sequence of
            //     code points that are not U+003B (;) from input, given position.
            while (position < mimeStr.length && mimeStr[position] !== ";") {
              parameterValue += mimeStr[position];
              ++position;
            }
            // 11.9.2 Remove any trailing HTTP whitespace from parameterValue.
            parameterValue = (0, _$$_REQUIRE(_dependencyMap[2]).removeTrailingHTTPWhitespace)(parameterValue);
            // 11.9.3 If parameterValue is the empty string, then continue.
            if (parameterValue === "") {
              continue;
            }
          }
          // 11.10 If all of the following are true:
          // parameterName is not the empty string
          // parameterName solely contains HTTP token code points
          // parameterValue solely contains HTTP quoted-string token code points
          // mimeTypes parameters[parameterName] does not exist
          // then set mimeTypes parameters[parameterName] to parameterValue.
          if (parameterName.length > 0 && (0, _$$_REQUIRE(_dependencyMap[2]).solelyContainsHTTPTokenCodePoints)(parameterName) && (0, _$$_REQUIRE(_dependencyMap[2]).soleyContainsHTTPQuotedStringTokenCodePoints)(parameterValue) && !mimetype.mParameters.has(parameterName)) {
            mimetype.mParameters.set(parameterName, parameterValue);
          }
        }
        // 12. Return mimeType.
        return mimetype;
      }
    }]);
  }();
  exports.MimeType = MimeType;
},"51ba9e69d25f63defe5f",["3508abd8c6b891008c0d","5533cec96f6a88041c69","7c24a30d9976d826af0f","606f5f734809feae52ba"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2024 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.collectHTTPQuotedString = exports.soleyContainsHTTPQuotedStringTokenCodePoints = exports.isHTTPWhitespaceChar = exports.removeTrailingHTTPWhitespace = exports.solelyContainsHTTPTokenCodePoints = exports.removeLeadingAndTrailingHTTPWhitespace = exports.checkSupportedAudioContainers = exports.checkSupportedVideoContainers = undefined;
  var supportedVideoContainers = ["video/mp4", "video/webm", "video/ogg", "video/mpeg", "video/avi", "video/quicktime", "video/3gpp"];
  var supportedAudioContainers = ["audio/mp4", "audio/webm", "audio/ogg", "audio/mpeg", "audio/aac", "audio/ac3", "audio/x-ac3", "audio/flac", "audio/x-flac"];
  function checkSupportedVideoContainers(mimeType) {
    return supportedVideoContainers.includes(mimeType);
  }
  exports.checkSupportedVideoContainers = checkSupportedVideoContainers;
  function checkSupportedAudioContainers(mimeType) {
    return supportedAudioContainers.includes(mimeType);
  }
  exports.checkSupportedAudioContainers = checkSupportedAudioContainers;
  function removeLeadingAndTrailingHTTPWhitespace(str) {
    return str.replace(/^[\t\n\r ]+/, "").replace(/[\t\n\r ]+$/, "");
  }
  exports.removeLeadingAndTrailingHTTPWhitespace = removeLeadingAndTrailingHTTPWhitespace;
  ;
  function solelyContainsHTTPTokenCodePoints(str) {
    return /^[!#-'\*\+\x2D\.0-9A-Z\^-z\|~]*$/.test(str);
  }
  exports.solelyContainsHTTPTokenCodePoints = solelyContainsHTTPTokenCodePoints;
  function removeTrailingHTTPWhitespace(str) {
    return str.replace(/[\t\n\r ]+$/, "");
  }
  exports.removeTrailingHTTPWhitespace = removeTrailingHTTPWhitespace;
  function isHTTPWhitespaceChar(char) {
    return char === " " || char === "\t" || char === "\n" || char === "\r";
  }
  exports.isHTTPWhitespaceChar = isHTTPWhitespaceChar;
  function soleyContainsHTTPQuotedStringTokenCodePoints(str) {
    return /^[\t -~\x80-\xFF]*$/.test(str);
  }
  exports.soleyContainsHTTPQuotedStringTokenCodePoints = soleyContainsHTTPQuotedStringTokenCodePoints;
  /**
   * To collect an HTTP quoted string from a string input, given a position variable
   * position and an optional boolean extract-value (default false):
   * Note: we dont use extract-value explicitly since we need it to be true always.
   *
   * https://fetch.spec.whatwg.org/#collect-an-http-quoted-string
   *
   * @param input @type {string} from which output needs to be extracted.
   * @param position @type {number} current position during parsing the mime string.
   *                 (should be at the location of " in parameter map)
   * @returns @type {string} which is within the quotes and @type {number} which is the position of the end quote
   */
  function collectHTTPQuotedString(input, position) {
    // 1. Let positionStart be position.
    // not required.
    // 2. Let value be the empty string.
    var value = "";
    // 3. Assert: the code point at position within input is U+0022 (").
    if (input[position] != "\"") {
      // TODO: assert?
      return [input, -1];
    }
    // 4. Advance position by 1.
    position++;
    // 5. while true
    while (true) {
      // 5.1 Append the result of collecting a sequence of code points that are not U+0022 (")
      //     or U+005C (\) from input, given position, to value.
      while (position < input.length && input[position] !== "\"" && input[position] !== "\\") {
        value += input[position];
        position++;
      }
      // 5.2 If position is past the end of input, then break.
      if (position >= input.length) {
        break;
      }
      // 5.3 Let quoteOrBackslash be the code point at position within input.
      var quoteOrBackslash = input[position];
      // 5.4 Advance position by 1.
      position++;
      // 5.5 If quoteOrBackslash is U+005C (\), then:
      if (quoteOrBackslash === "\\") {
        // 5.5.1 If position is past the end of input, then append U+005C (\) to value and break.
        if (position >= input.length) {
          value += "\\";
          break;
        }
        // 5.5.2 Append the code point at position within input to value.
        value += input[position];
        // 5.5.3 Advance position by 1.
        ++position;
      } else {
        // 5.6. Otherwise:
        // 5.6.1 Assert: quoteOrBackslash is U+0022 (").
        if (quoteOrBackslash != "\"") {
          // todo: assert?
          return [input, -1];
        }
        // 5.6.2 Break.
        break;
      }
    }
    // 6. If extract-value is true, then return value.
    // note: we didnt take this and its true by default for us.
    // 7. Return the code points from positionStart to position, inclusive, within input.
    // note: this would've returned the output in "value" format, which we dont want. So return value only.
    return [value, position];
  }
  exports.collectHTTPQuotedString = collectHTTPQuotedString;
},"7c24a30d9976d826af0f",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2023-2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MimeTypeRegistry = exports.UNKNOWN_SHAKA_MIME = undefined;
  var aacCodecs = ["mp4a.66", "mp4a.67", "mp4a.68", "mp4a.40.2", "mp4a.40.02", /* AAC LC + SBR*/"mp4a.40.5", "mp4a.40.05", /* AAC LC + SBR + PS */"mp4a.40.29", /*backward compatible mpeg surround*/"mp4a.40.30", "mp4a.40.42" // Extended HE-AAC (added according to shaka mapping)
  ];
  var mp3Codecs = ["mp4a.69", "mp4a.6B", "mp4a.40.34"];
  var ac3Codecs = ["ac3", "ac-3", "mp4a.a5", "mp4a.A5"];
  var eac3Codecs = ["mp4a.a6", "mp4a.A6", "eac3", "ec-3"];
  // List of supported Codecs for each mimeType
  // vp9, vp8, av1
  var supportedVideoWebmCodecs = ["vp08", "vp09", "av01", "vp8", "vp9", "av1"];
  var supportedAudioWebmCodecs = ["vorbis", "opus"];
  // mpeg4, mvc.
  var supported3GPVideoCodecs = ["hev1", "hvc1", "avc1", "avc3", "s263", "mvc1", "mvc2", "mvc3", "mvc4", "h263"];
  var supported3GPAudioCodecs = ["samr", "sawb", "sawp"];
  // -law PCM
  var supportedOGGAudioCodecs = ["theora", "h263", "Opus", "vorbis", "fLaC", "alaw", "fpcm"];
  // TODO: mpeg 1/2 video
  //  mp2, mp1, wma lossy/lossless, ulaw pcm, IEEE pcm,
  var supportedAVIVideoCodecs = ["avc1", "avc3", "hev1", "hvc1", "h263", "vp09", "vp08", "vc-1"];
  var supportedAVIAudioCodecs = ["samr", "sawb", "sawp", "Opus", "fLaC", "alac", "lpcm", "alaw", "dts+", "dts-"].concat(mp3Codecs).concat(ac3Codecs);
  // TODO:, mpeg1/2 video
  var supportedQuickTimeVideoCodecs = ["avc1", "avc3", "hev1", "hvc1", "h263", "vc-1", "drac"];
  // TODO: ulaw pcm
  var supportedQuickTimeAudioCodecs = ["Opus", "alac", "lpcm", "alaw", "fpcm", "dtsc", "dtse", "dtsh", "dtsl"].concat(aacCodecs).concat(ac3Codecs).concat(eac3Codecs);
  // TODO: mpeg1/2 video, h263,
  var supportedVideoMp4Codecs = ["avc1", "avc3", "hev1", "hvc1", "av01", "vp08", "vp09", "mp4v"];
  // mp2, mp1, als, sls, dv audio,
  var supportedAudioMp4Codecs = ["Opus", "fLaC", "dts+", "dts-", "dtsc", "dtse", "dtsh", "dtsl", "alac", "mlpa", "lpcm", "samr", "sawb"].concat(mp3Codecs).concat(aacCodecs).concat(ac3Codecs).concat(eac3Codecs);
  // mpeg-1 video (261?), mpeg-2 video (h.262), mpeg-4 visual
  var supportedVideoMP2TCodecs = ["hvc1", "hev1", "avc1", "avc3"];
  // mp2, mp1, als, sls
  var supportedAudioMP2TCodecs = ["Opus"].concat(mp3Codecs).concat(aacCodecs);
  // TODO: JIRA-206965, introduce an IDL api to get the container support.
  // https://w3c.github.io/mse-byte-stream-format-registry/#registry
  var supportedVideoContainers = ["video/mp4", "video/webm", "video/ogg", "video/mpeg", "video/avi", "video/quicktime", "video/3gpp", "video/x-matroska", "video/mp2t"];
  var supportedAudioContainers = ["audio/mp4", "audio/webm", "audio/ogg", "audio/mpeg", "audio/aac", "audio/ac3", "audio/x-ac3", "audio/flac", "audio/x-flac", "audio/mp2t"];
  // check https://chromium.googlesource.com/chromium/src/media/+/refs/heads/main/base/mime_util_internal.cc [1] on how to parse including
  // the profile levels.
  // got these values from  https://mp4ra.org/registered-types/codecs [2] which has all the registered codec types
  var knownVideoCodecs = ["a3d1", "a3d2", "a3d3", "a3d4", "av1", "av01", "avc1", "avc2", "avc3", "avc4", "avcp", "avst", "avs3", "camm", "dav1", "drac", "dva1", "dvav", "dvh1", "dvhe", "encv", "evc1", "evm1", "evs1", "evs2", "FFV1", "hev1", "hev2", "hev3", "hvc1", "hvc2", "hvc3", "hvt1", "hvt2", "hvt3", "icpv", "j2ki", "jxsm", "lhe1", "lht1", "lhv1", "mjp2", "mjpg", "mp4v", "mvc1", "mvc2", "mvc3", "mvc4", "mvd1", "mvd2", "mvd3", "mvd4", "resv", "rv60", "s263", "svc1", "svc2", "vc-1", "vp08", "vp09", "vvcN", "vvc1", "vvi1", "vvs1", "cndm", "lvc1", "vp8", "vp9", "h263"]; // missing in [2] but mentioned in [1]
  var knownAudioCodecs = ["a3ds", "ac-3", "ac-4", "alac", "alaw", "cavs", "dra1", "dts+", "dts-", "dtsc", "dtse", "dtsh", "dtsl", "dtsx", "dtsy", "ec-3", "ec+3", "enca", "fLaC", "g719", "g726", "m4ae", "mha1", "mha2", "mhm1", "mhm2", "mlpa", "mp4a", "Opus", "raw$20", "samr", "sawb", "sawp", "sevc", "sevs", "sqcp", "ssmv", "twos", "ulaw", "iamf", "ipcm", "fpcm", "apac", "mp3", "vorbis", "theora"]; // not available in [2] but mentioned in [1]
  exports.UNKNOWN_SHAKA_MIME = "video";
  var containerMapping = new Map([["video/mp4", {
    video: supportedVideoMp4Codecs,
    audio: supportedAudioMp4Codecs
  }], ["video/webm", {
    video: supportedVideoWebmCodecs,
    audio: supportedAudioWebmCodecs
  }], ["video/ogg", {
    video: supportedOGGAudioCodecs,
    audio: supportedOGGAudioCodecs
  }], ["video/mpeg", {
    video: [],
    audio: [] // TODO
  }], ["video/avi", {
    video: supportedAVIVideoCodecs,
    audio: supportedAVIAudioCodecs
  }], ["video/quicktime", {
    video: supportedQuickTimeVideoCodecs,
    audio: supportedQuickTimeAudioCodecs
  }], ["video/3gpp", {
    video: supported3GPVideoCodecs,
    audio: supported3GPAudioCodecs
  }], ["video/mp2t", {
    video: supportedVideoMP2TCodecs,
    audio: supportedAudioMP2TCodecs
  }], ["video/x-matroska", {
    video: supportedVideoWebmCodecs,
    audio: supportedAudioWebmCodecs
  }], ["audio/mp4", {
    audio: supportedAudioMp4Codecs
  }], ["audio/webm", {
    audio: supportedAudioWebmCodecs
  }], ["audio/ogg", {
    audio: supportedOGGAudioCodecs
  }], ["audio/mpeg", {
    audio: [] // audio/mpeg is not supposed to have "codecs" parameter
  }], ["audio/aac", {
    audio: [] // audio/aac is not supposed to have "codecs" parameter
  }], ["audio/ac3", {
    audio: ac3Codecs
  }], ["audio/x-ac3", {
    audio: ac3Codecs
  }], ["audio/flac", {
    audio: ["fLaC"]
  }], ["audio/x-flac", {
    audio: ["fLaC"]
  }], ["audio/mp2t", {
    audio: supportedAudioMP2TCodecs
  }]]);
  // Enforce list is based on individual specs listed at
  // https://www.w3.org/TR/mse-byte-stream-format-registry/#registry
  // Note: specs under this only mentions isTypeSupported() and addSourceBuffer() but not changeType()
  var codecParamEnforcedContainers = ["audio/webm", "video/webm"];
  var MimeTypeRegistry = /*#__PURE__*/function () {
    function MimeTypeRegistry() {
      _$$_REQUIRE(_dependencyMap[0])(this, MimeTypeRegistry);
    }
    return _$$_REQUIRE(_dependencyMap[1])(MimeTypeRegistry, null, [{
      key: "checkSupportedVideoContainers",
      value: function checkSupportedVideoContainers(mimeType) {
        return supportedVideoContainers.includes(mimeType);
      }
    }, {
      key: "checkSupportedAudioContainers",
      value: function checkSupportedAudioContainers(mimeType) {
        return supportedAudioContainers.includes(mimeType);
      }
    }, {
      key: "checkSupportedVideoWebmCodecs",
      value: function checkSupportedVideoWebmCodecs(codecsArray) {
        for (var i = 0; i < codecsArray.length; i++) {
          var codec = codecsArray[i];
          if (!supportedVideoWebmCodecs.includes(codec)) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`MimeTypeRegistry: codec:${codec} is not supported for video/webm`);
            return false;
          }
        }
        return true;
      }
    }, {
      key: "checkSupportedVideoMp4Codecs",
      value: function checkSupportedVideoMp4Codecs(codecsArray) {
        for (var i = 0; i < codecsArray.length; i++) {
          var codec = codecsArray[i];
          if (!supportedVideoMp4Codecs.includes(codec)) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.error(`MimeTypeRegistry: codec:${codec} is not supported for video/mp4`);
            return false;
          }
        }
        return true;
      }
    }, {
      key: "checkSupportedAudioWebmCodecs",
      value: function checkSupportedAudioWebmCodecs(codecsArray) {
        for (var i = 0; i < codecsArray.length; i++) {
          var codec = codecsArray[i];
          if (!supportedAudioWebmCodecs.includes(codec)) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.error(`MimeTypeRegistry: codec:${codec} is not supported for audio/webm`);
            return false;
          }
        }
        return true;
      }
    }, {
      key: "checkSupportedAudioMp4Codecs",
      value: function checkSupportedAudioMp4Codecs(codecsArray) {
        for (var i = 0; i < codecsArray.length; i++) {
          var codec = codecsArray[i];
          if (!supportedAudioMp4Codecs.includes(codec)) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.error(`MimeTypeRegistry: codec:${codec} is not supported for audio/mp4`);
            return false;
          }
        }
        return true;
      }
    }, {
      key: "isKnownVideoCodec",
      value: function isKnownVideoCodec(codec) {
        for (var index = 0; index < knownVideoCodecs.length; index++) {
          var mime = knownVideoCodecs[index];
          if (codec.startsWith(mime)) {
            return true;
          }
        }
        return false;
      }
    }, {
      key: "isKnownAudioCodec",
      value: function isKnownAudioCodec(codec) {
        for (var index = 0; index < knownAudioCodecs.length; index++) {
          var mime = knownAudioCodecs[index];
          if (codec.startsWith(mime)) {
            return true;
          }
        }
        return false;
      }
    }, {
      key: "isCodecSupportedByPlatform",
      value: function isCodecSupportedByPlatform(isAudio, codec) {
        var config = isAudio ? new (_$$_REQUIRE(_dependencyMap[3]).AudioDecoderConfig)() : new (_$$_REQUIRE(_dependencyMap[3]).VideoDecoderConfig)();
        var profileLevel = new (_$$_REQUIRE(_dependencyMap[3]).MediaFormatProfileLevel)(codec);
        config.formatProfileLevel = profileLevel;
        var caps = _$$_REQUIRE(_dependencyMap[3]).KeplerMediaDescriptor.queryMediaCapabilitiesSync(config);
        if (caps.length <= 0) {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.error(codec, " is not supported by platform");
          return false;
        }
        return true;
      }
    }, {
      key: "checkCodecParamForEnforcedContainers",
      value: function checkCodecParamForEnforcedContainers(mimeType) {
        var supportedCodecs = containerMapping.get(mimeType.essence);
        var isContainerType = supportedCodecs != undefined;
        var codecsStr = mimeType.getParameter("codecs");
        var codecsArray = codecsStr === undefined ? [] : codecsStr.split(",");
        if (isContainerType && codecParamEnforcedContainers.includes(mimeType.essence) && codecsArray.length === 0) {
          _$$_REQUIRE(_dependencyMap[2]).LogUtil.error("The mime type doesnt imply a codec but has no parameters");
          return false;
        }
        return true;
      }
    }, {
      key: "checkSupportedType",
      value: function checkSupportedType(mimeType) {
        var supportedCodecs = containerMapping.get(mimeType.essence);
        var isContainerType = supportedCodecs != undefined;
        var isAudio = mimeType.type === "audio";
        var codecsStr = mimeType.getParameter("codecs");
        var codecsArray = codecsStr === undefined ? [] : codecsStr.split(",");
        if (!isContainerType) {
          var possibleCodec = mimeType.subType;
          if (isAudio && !(possibleCodec in knownAudioCodecs)) {
            // this is not container type and the codec in subtype is not valid
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.error("not a valid audio codec");
            return false;
          }
          if (!isAudio && !(possibleCodec in knownVideoCodecs)) {
            // this is not container type and the codec in subtype is not valid
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.error("not a valid video codec");
            return false;
          }
          if (mimeType.getParameterCount() !== 0) {
            // https://www.w3.org/TR/mse-byte-stream-format-mpeg-audio/#mime-types
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.error("The mime type implies a codec but has parameters");
            return false;
          }
          codecsArray = [possibleCodec];
        }
        // TODO: JIRA-206965, introduce an IDL api to get the container support.
        // We dont support audio/mpeg. Such info should be coming from the nfp side.
        if (mimeType.essence === "audio/aac") {
          // https://www.w3.org/TR/mse-byte-stream-format-mpeg-audio/#mime-types
          if (codecsArray.length !== 0) {
            return false;
          }
          return true;
        }
        for (var index = 0; index < codecsArray.length; index++) {
          var codec = (0, _$$_REQUIRE(_dependencyMap[4]).removeLeadingAndTrailingHTTPWhitespace)(codecsArray[index]);
          var foundCodec = false;
          // Check for audio codec support.
          for (var _index = 0; _index < supportedCodecs.audio.length; _index++) {
            var element = supportedCodecs.audio[_index];
            // Need to have exact match for audio since mp3 and aac codecs just differ in profile values
            if (codec === element) {
              foundCodec = true;
              if (!MimeTypeRegistry.isCodecSupportedByPlatform(true, codec)) {
                return false;
              }
            }
          }
          if (supportedCodecs.video == undefined) {
            if (!foundCodec) {
              _$$_REQUIRE(_dependencyMap[2]).LogUtil.error("the container only supports audio codecs. Either ", codec, " is not a supported audio codec or its a video codec. Returning false");
              return false;
            }
            continue;
          }
          // check for video codec support.
          for (var _index2 = 0; _index2 < ((_supportedCodecs$vide = supportedCodecs.video) == null ? undefined : _supportedCodecs$vide.length); _index2++) {
            var _supportedCodecs$vide;
            var _element = supportedCodecs.video[_index2];
            // we dont match the profile values here, let KMD take care of it.
            if (codec.startsWith(_element)) {
              foundCodec = true;
              if (!MimeTypeRegistry.isCodecSupportedByPlatform(false, codec)) {
                return false;
              }
            }
          }
          if (!foundCodec) {
            _$$_REQUIRE(_dependencyMap[2]).LogUtil.error("The requested combination of container", mimeType.essence, " and codec ", codec, "is not supported");
            return false;
          }
        }
        _$$_REQUIRE(_dependencyMap[2]).LogUtil.info(`${codecsArray} is supported`);
        return true;
      }
    }]);
  }();
  exports.MimeTypeRegistry = MimeTypeRegistry;
},"5276f25b9cfa3ba46e9e",["3508abd8c6b891008c0d","5533cec96f6a88041c69","1f12e7e43345228dfcad","87c1deaf4e092124fc7a","7c24a30d9976d826af0f"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.parseVp9CodecID = exports.parseAV1CodecId = exports.parseHEVCCodecId = exports.parseAVCCodecId = exports.parseCodecMime = exports.CodecInfo = undefined;
  ;
  var stringToCodecTypeMap = new Map([
  // We only allow this for WAV so it isn't ambiguous.
  ["1", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_WAV], ["mp3", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_MP3],
  // Following is the list of RFC 6381 compliant audio codec
  // strings:
  //   mp4a.66     - MPEG-2 AAC MAIN
  //   mp4a.67     - MPEG-2 AAC LC
  //   mp4a.68     - MPEG-2 AAC SSR
  //   mp4a.69     - MPEG-2 extension to MPEG-1 (MP3)
  //   mp4a.6B     - MPEG-1 audio (MP3)
  //   mp4a.40.2   - MPEG-4 AAC LC
  //   mp4a.40.02  - MPEG-4 AAC LC (leading 0 in aud-oti for
  //                 compatibility)
  //   mp4a.40.5   - MPEG-4 HE-AAC v1 (AAC LC + SBR)
  //   mp4a.40.05  - MPEG-4 HE-AAC v1 (AAC LC + SBR) (leading 0
  //                 in aud-oti for compatibility)
  //   mp4a.40.29  - MPEG-4 HE-AAC v2 (AAC LC + SBR + PS)
  ["mp4a.66", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AAC], ["mp4a.67", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AAC], ["mp4a.68", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AAC], ["mp4a.69", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_MP3], ["mp4a.6B", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_MP3], ["mp4a.40.2", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AAC], ["mp4a.40.02", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AAC],
  // PROJXXX-197156 use the right mappings once they are available.
  ["mp4a.40.5", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AAC], ["mp4a.40.05", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AAC], ["mp4a.40.29", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AAC],
  // MPEG Surround is based on a down-mix coded with AAC-LC and HE-AAC
  // PROJXXX-197156 use the right mappings once they are available.
  ["mp4a.40.30", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AAC], ["mp4a.40.42", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AUDIO_UNSPECIFIED],
  // Note: Strictly speaking only mp4a.A5 and mp4a.A6
  // codec ids are valid according to RFC 6381 section 3.3, 3.4.
  // Lower-case oti (mp4a.a5 and mp4a.a6) should be rejected. But
  // Chromium used to allow those in older versions of Chromecast
  // firmware and some apps (notably MPL) depend on those codec
  // types being supported, so they should be allowed for now
  // (crbug.com/564960).
  ["ac-3", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AC3], ["mp4a.a5", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AC3], ["mp4a.A5", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AC3], ["ec-3", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_EAC3], ["mp4a.a6", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_EAC3], ["mp4a.A6", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_EAC3], ["vorbis", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_VORBIS], ["opus", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_OPUS], ["Opus", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_OPUS], ["flac", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_FLAC], ["fLaC", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_FLAC], ["vp8", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_VP8], ["vp8.0", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_VP8], ["theora", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AUDIO_UNSPECIFIED], ["dtsc", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AUDIO_UNSPECIFIED], ["mp4a.a9", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AUDIO_UNSPECIFIED], ["mp4a.A9", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AUDIO_UNSPECIFIED],
  // PROJXXX-197156 use the right mappings once they are available.
  ["dtse", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AUDIO_UNSPECIFIED], ["mp4a.ac", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AUDIO_UNSPECIFIED], ["mp4a.AC", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AUDIO_UNSPECIFIED], ["dtsx", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AUDIO_UNSPECIFIED], ["mp4a.b2", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AUDIO_UNSPECIFIED], ["mp4a.B2", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AUDIO_UNSPECIFIED],
  // PROJXXX-197156 use the right mappings once they are available.
  ["ac-4", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AUDIO_UNSPECIFIED], ["mp4a.ae", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AUDIO_UNSPECIFIED], ["mp4a.AE", _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AUDIO_UNSPECIFIED]]);
  // TODO: get the actual values once the IDL is finalised.
  var AVCProfileUnknown = 0;
  var AVCProfileBaseline = 1;
  var AVCProfileMain = 2;
  var AVCProfileExtended = 3;
  var AVCProfileHigh = 4;
  var AVCProfileHigh10 = 5;
  var AVCProfileHigh422 = 6;
  var AVCProfileHigh444 = 7;
  var AVCProfileConstrainedBaseline = 8;
  var AVCProfileConstrainedHigh = 9;
  var AVCLevelUnknown = 0;
  var HEVCProfileUnknown = 100;
  var HEVCProfileMain = 101;
  var HEVCProfileMain10HDR10 = 104;
  var HEVCProfileMain10HDR10Plus = 105;
  var HEVCLevelUnknown = 100;
  var VP9ProfileUnknown = 300;
  var VP9Profile0 = 301;
  var VP9Profile1 = 302;
  var VP9Profile2 = 303;
  var VP9Profile3 = 304;
  var VP9Profile2HDR = 305;
  var VP9Profile3HDR = 306;
  var VP9Profile2HDR10Plus = 307;
  var VP9Profile3HDR10Plus = 308;
  var VP9LevelUnknown = 300;
  var VP9Level1 = 301;
  var VP9Level11 = 302;
  var VP9Level2 = 303;
  var VP9Level21 = 304;
  var VP9Level3 = 305;
  var VP9Level31 = 306;
  var VP9Level4 = 307;
  var VP9Level41 = 308;
  var VP9Level5 = 309;
  var VP9Level51 = 310;
  var VP9Level52 = 311;
  var VP9Level6 = 312;
  var VP9Level61 = 313;
  var VP9Level62 = 314;
  // TODO: figure this mapping with the actual profile numbers from mime type.
  var DolbyVisionProfileUnknown = 800;
  var DolbyVisionProfileDvavPer = 801;
  var DolbyVisionProfileDvavPen = 802;
  var DolbyVisionProfileDvheDer = 803;
  var DolbyVisionProfileDvheDen = 804;
  var DolbyVisionProfileDvheDtr = 805;
  var DolbyVisionProfileDvheStn = 806;
  var DolbyVisionProfileDvheDth = 807;
  var DolbyVisionProfileDvheDtb = 808;
  var DolbyVisionProfileDvheSt = 809;
  var DolbyVisionProfileDvavSe = 810;
  var DolbyVisionLevelUnknown = 800;
  // TODO: figure the correct mappings for these values
  var H264PROFILE_SCALABLEBASELINE = 7;
  var H264PROFILE_SCALABLEHIGH = 8;
  var H264PROFILE_STEREOHIGH = 9;
  var H264PROFILE_MULTIVIEWHIGH = 10;
  var HEVCPROFILE_HIGH_THROUGHPUT_SCREEN_EXTENDED = 36;
  var HEVCPROFILE_SCALABLE_REXT = 35;
  var HEVCPROFILE_SCREEN_EXTENDED = 34;
  var HEVCPROFILE_SCALABLE_MAIN = 32;
  var HEVCPROFILE_MULTIVIEW_MAIN = 31;
  var HEVCPROFILE_HIGH_THROUGHPUT = 30;
  var HEVCPROFILE_REXT = 29;
  var ColorSpace = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[1])(function ColorSpace() {
    _$$_REQUIRE(_dependencyMap[2])(this, ColorSpace);
  });
  ;
  var CodecInfo = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[1])(function CodecInfo() {
    _$$_REQUIRE(_dependencyMap[2])(this, CodecInfo);
  });
  exports.CodecInfo = CodecInfo;
  function getPrimaryID(primary) {
    if (primary < 1 || primary > 22 || primary == 3) {
      return 0;
    }
    if (primary > 12 && primary < 22) {
      return 0;
    }
    return primary;
  }
  function getTransferID(transfer) {
    if (transfer < 1 || transfer > 18 || transfer == 3) {
      return 0;
    }
    return transfer;
  }
  function getMatrixID(matrix) {
    if (matrix < 0 || matrix > 11 || matrix == 3) {
      return -1;
    }
    return matrix;
  }
  function isDolbyVisionAVCCodecId(codec_id) {
    return codec_id.startsWith("dva1.") || codec_id.startsWith("dvav.");
  }
  function isDolbyVisionHEVCCodecId(codec_id) {
    return codec_id.startsWith("dvh1.") || codec_id.startsWith("dvhe.");
  }
  function getVP9HDRProfileId(hdrmetadatatype, mimeProfile) {
    if (hdrmetadatatype === "smpteSt2086") {
      // HDR10
      switch (mimeProfile) {
        case VP9Profile2:
          return VP9Profile2HDR;
        case VP9Profile3:
          return VP9Profile3HDR;
        default:
          return VP9ProfileUnknown;
      }
    }
    if (hdrmetadatatype === "smpteSt2094-40") {
      // HDR10+
      switch (mimeProfile) {
        case VP9Profile2:
          return VP9Profile2HDR10Plus;
        case VP9Profile3:
          return VP9Profile3HDR10Plus;
        default:
          return VP9ProfileUnknown;
      }
    }
    return mimeProfile;
  }
  function parseCodecMime(codec_id) {
    var hdrMetadataType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug("parseCodecMime++: ", codec_id, " ", hdrMetadataType);
    var mimeType = stringToCodecTypeMap.get(codec_id);
    if (mimeType != undefined) {
      var _codecInfo = new CodecInfo();
      _codecInfo.codec = mimeType;
      return _codecInfo;
    }
    var profileLevel = parseAVCCodecId(codec_id);
    if (profileLevel != undefined) {
      var _codecInfo2 = new CodecInfo();
      _codecInfo2.codec = _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AVC;
      _codecInfo2.profile = profileLevel.profile;
      _codecInfo2.level = profileLevel.level;
      return _codecInfo2;
    }
    profileLevel = parseHEVCCodecId(codec_id, hdrMetadataType);
    if (profileLevel != undefined) {
      var _codecInfo3 = new CodecInfo();
      _codecInfo3.codec = _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_HEVC;
      _codecInfo3.profile = profileLevel.profile;
      _codecInfo3.level = profileLevel.level;
      return _codecInfo3;
    }
    var codecInfo = parseVp9CodecID(codec_id, hdrMetadataType);
    if (codecInfo != undefined) {
      codecInfo.codec = _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_VP9;
      return codecInfo;
    }
    profileLevel = parseDolbyVisionCodecId(codec_id);
    if (profileLevel != undefined) {
      var _codecInfo4 = new CodecInfo();
      _codecInfo4.codec = _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_DOLBY_VISION;
      _codecInfo4.profile = profileLevel.profile;
      _codecInfo4.level = profileLevel.level;
      return _codecInfo4;
    }
    profileLevel = parseAV1CodecId(codec_id, hdrMetadataType);
    if (profileLevel != undefined) {
      var _codecInfo5 = new CodecInfo();
      _codecInfo5.codec = _$$_REQUIRE(_dependencyMap[0]).CodecMimeType.MIME_AV1;
      _codecInfo5.profile = profileLevel.profile;
      _codecInfo5.level = profileLevel.level;
      return _codecInfo5;
    }
    // unknown codec
    return undefined;
  }
  exports.parseCodecMime = parseCodecMime;
  /**
   * Parses strings in the format
   * <avc1/avc3>.<profile byte><constraint byte><level byte> [avc1.xxxxxx, avc3.xxxxxx]
   * Ex:
   *  avc1.4d002a is Main Profile, Level 4.2
   *
   *
   * Refers ParseAVCCodecId in
   * https://source.chromium.org/chromium/chromium/src/+/main:media/base/video_codec_string_parsers.cc
   *
   * @param codec_id @type {string} which represents avc profile level.
   * @returns @type {ProfileLevel} corresponding to the string passed.
   */
  function parseAVCCodecId(codec_id) {
    var result = {
      profile: undefined,
      level: undefined
    };
    // Make sure we have avc1.xxxxxx or avc3.xxxxxx , where xxxxxx are hex digits
    if (!codec_id.startsWith("avc1.") && !codec_id.startsWith("avc3.")) {
      return undefined;
    }
    return result;
  }
  exports.parseAVCCodecId = parseAVCCodecId;
  function parseHEVCCodecId(codec_id, hdrMetadataType) {
    var result = {
      profile: HEVCProfileUnknown,
      level: HEVCLevelUnknown
    };
    if (!codec_id.startsWith("hev1.") && !codec_id.startsWith("hvc1.")) {
      return undefined;
    }
    if (hdrMetadataType != "smpteSt2086" && hdrMetadataType != "smpteSt2094-40") {
      // parse only if the hdr meta is what we need.
      return result;
    }
    // HEVC codec id consists of:
    var kMaxHevcCodecIdLength = 41; // up to 6 constraint bytes, bytes are dot-separated and hex-encoded.
    if (codec_id.length > kMaxHevcCodecIdLength) {
      // Codec id is too long
      return undefined;
    }
    var elem = codec_id.split(".");
    if (!(elem[0] === "hev1") && !(elem[0] === "hvc1")) {
      return undefined;
    }
    if (elem.length < 4) {
      // invalid HEVC codec id
      return undefined;
    }
    var general_profile_space = 0;
    if (elem[1].length > 0 && (elem[1][0].toUpperCase() === 'A' || elem[1][0].toUpperCase() === 'B' || elem[1][0].toUpperCase() === 'C')) {
      switch (elem[1][0]) {
        case 'A':
          general_profile_space = 1;
          break;
        case 'B':
          general_profile_space = 2;
          break;
        case 'C':
          general_profile_space = 3;
        default:
          break;
      }
      elem[1] = elem[1].substring(1);
    }
    var general_profile_idc = 0;
    general_profile_idc = Number(elem[1]);
    if (Number.isNaN(general_profile_idc) || general_profile_idc > 0x1f) {
      // invalid general_profile_idc
      return undefined;
    }
    var general_profile_compatibility_flags = Number("0x" + elem[2]);
    if (Number.isNaN(general_profile_compatibility_flags)) {
      return undefined;
    }
    var out_profile = HEVCProfileUnknown;
    // Spec A.3.3
    // NOTICE: Do not change the order of below sections
    if (general_profile_idc === 2 || general_profile_compatibility_flags & 4) {
      if (hdrMetadataType === "smpteSt2086") {
        out_profile = HEVCProfileMain10HDR10;
      }
      if (hdrMetadataType === "smpteSt2094-40") {
        out_profile = HEVCProfileMain10HDR10Plus;
      }
    }
    if (out_profile === HEVCProfileUnknown) {
      // non-hdr case, depend on the native impl to figure out profile.
      return undefined;
    }
    var general_tier_flag;
    if (elem[3].length > 0 && (elem[3][0] === 'L' || elem[3][0] === 'H')) {
      general_tier_flag = elem[3][0] === 'L' ? 0 : 1;
      elem[3] = elem[3].substring(1);
    } else {
      // invalid general_tier_flag, elem[3]
      return undefined;
    }
    var general_level_idc = Number(elem[3]);
    if (Number.isNaN(general_level_idc) || general_level_idc > 0xff) {
      // invalid general_level_idc elem[3]
      return undefined;
    }
    var constraint_flags = Array(6).fill(0);
    if (elem.length > 10) {
      // unexpected number of trailing bytes in HEVC codec_id
      return undefined;
    }
    for (var i = 4; i < elem.length; ++i) {
      var constr_byte = Number("0x" + elem[i]);
      if (Number.isNaN(constr_byte) || constr_byte > 0xFF) {
        // invalid constraint byte elem[i]
        return undefined;
      }
      constraint_flags[i - 4] = constr_byte;
    }
    // todo: map this level value to our value in IDL
    result.level = HEVCLevelUnknown;
    result.profile = out_profile;
    return result;
  }
  exports.parseHEVCCodecId = parseHEVCCodecId;
  function parseAV1CodecId(codec_id, hdrMetadataType) {
    _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug("parseAV1CodecId++ ", codec_id);
    var result = {
      profile: undefined,
      level: undefined
    };
    if ((codec_id === "av1" || codec_id === "av01") && !hdrMetadataType) {
      return result;
    }
    // The codecs parameter string for the AOM AV1 codec is as follows:
    // See https://aomediacodec.github.io/av1-isobmff/#codecsparam.
    //
    // <sample entry4CC>.<profile>.<level><tier>.<bitDepth>.<monochrome>.
    // <chromaSubsampling>.<colorPrimaries>.<transferCharacteristics>.
    // <matrixCoefficients>.<videoFullRangeFlag>
    var fields = codec_id.split(".");
    // The parameters sample entry 4CC, profile, level, tier, and bitDepth are all
    // mandatory fields. If any of these fields are empty, or not within their
    // allowed range, the processing device SHOULD treat it as an error.
    if (fields.length < 4 || fields.length > 10) {
      // " Invalid number of fields
      _$$_REQUIRE(_dependencyMap[3]).LogUtil.error("parseAV1CodecId: Invalid number of fields ", fields.length);
      return undefined;
    }
    // All the other fields (including their leading '.') are optional, mutually
    // inclusive (all or none) fields. If not specified then the values listed in
    // the table below are assumed.
    //
    // mono_chrome              0
    // chromaSubsampling        112 (4:2:0 colocated with luma (0,0))
    // colorPrimaries           1 (ITU-R BT.709)
    // transferCharacteristics  1 (ITU-R BT.709)
    // matrixCoefficients       1 (ITU-R BT.709)
    // videoFullRangeFlag       0 (studio swing representation)
    // Initialize optional fields to their defaults.
    if (fields[0] != "av01") {
      // Invalid AV1 4CC
      return undefined;
    }
    // TODO: add logic to parse HDR and other info
    _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug("parseAV1CodecId-- ", codec_id);
    return result;
  }
  exports.parseAV1CodecId = parseAV1CodecId;
  ;
  function parseVp9CodecID(codec_id, hdrmetadatatype) {
    // Initialize optional fields to their defaults.
    var cs = {
      primaries: undefined,
      transfer: undefined,
      matrix: undefined,
      range: undefined
    };
    var result = {
      bit_depth: undefined,
      color_space: cs,
      subsampling: undefined,
      profile: undefined,
      level: undefined,
      codec: undefined
    };
    if (codec_id.startsWith("vp9") || codec_id.startsWith("vp9.0")) {
      // this is legacy vp9 mime type
      result.profile = VP9ProfileUnknown;
      result.level = VP9LevelUnknown;
      return result;
    }
    var fields = codec_id.split('.');
    // First four fields are mandatory. No more than 9 fields are expected.
    if (fields.length < 4 || fields.length > 9) {
      // " Invalid number of fields
      return undefined;
    }
    if (fields[0] != "vp09") {
      // Invalid 4CC
      return undefined;
    }
    if (hdrmetadatatype === "smpteSt2094-10") {
      // vp9 dolby is not valid combo
      return undefined;
    }
    var values = [];
    for (var i = 1; i < fields.length; ++i) {
      // Missing value is not allowed.
      if (fields[i] == "") {
        // " Invalid missing field i
        return undefined;
      }
      var value = Number(fields[i]);
      if (Number.isNaN(value) || value < 0) {
        // " Invalid field value
        return undefined;
      }
      values.push(value);
    }
    var profile_idc = values[0];
    switch (profile_idc) {
      case 0:
        result.profile = VP9Profile0;
        break;
      case 1:
        result.profile = VP9Profile1;
        break;
      case 2:
        result.profile = VP9Profile2;
        break;
      case 3:
        result.profile = VP9Profile3;
        break;
      default:
        // Invalid profile
        return undefined;
    }
    result.level = values[1];
    switch (result.level) {
      case 10:
        result.level = VP9Level1;
        break;
      case 11:
        result.level = VP9Level11;
        break;
      case 20:
        result.level = VP9Level2;
        break;
      case 21:
        result.level = VP9Level21;
        break;
      case 30:
        result.level = VP9Level3;
        break;
      case 31:
        result.level = VP9Level31;
        break;
      case 40:
        result.level = VP9Level4;
        break;
      case 41:
        result.level = VP9Level41;
        break;
      case 50:
        result.level = VP9Level5;
        break;
      case 51:
        result.level = VP9Level51;
        break;
      case 52:
        result.level = VP9Level52;
        break;
      case 60:
        result.level = VP9Level6;
        break;
      case 61:
        result.level = VP9Level61;
        break;
      case 62:
        result.level = VP9Level62;
        break;
      default:
        // " Invalid level
        return undefined;
    }
    result.bit_depth = values[2];
    if (result.bit_depth != 8 && result.bit_depth != 10 && result.bit_depth != 12) {
      // Invalid bit-depth
      return undefined;
    }
    // 4:2:0 isn't supported in profiles 1, 3.
    if (profile_idc == 1 || profile_idc == 3) {
      result.subsampling = 2 /* VideoChromaSampling.k422 */;
    }
    if (values.length < 4) {
      // we only have profile, level and bitDepth
      var hdrProfile = getVP9HDRProfileId(hdrmetadatatype, result.profile);
      if (hdrProfile == VP9ProfileUnknown) {
        // the hdr meta requested and profile didnt match
        return undefined;
      }
      result.profile = hdrProfile;
      return result;
    }
    var chroma_subsampling = values[3];
    switch (chroma_subsampling) {
      case 0:
      case 1:
        result.subsampling = 1 /* VideoChromaSampling.k420 */;
        break;
      case 2:
        result.subsampling = 2 /* VideoChromaSampling.k422 */;
        break;
      case 3:
        result.subsampling = 3 /* VideoChromaSampling.k444 */;
        break;
      default:
        // Invalid chroma subsampling
        return undefined;
    }
    if (result.subsampling != 1 /* VideoChromaSampling.k420 */ && profile_idc != 1 && profile_idc != 3) {
      // 4:2:2 and 4:4:4 are only supported in profile 1, 3
      // Ideally this would be an error, but even Netflix broke when we tried...
      result.subsampling = 1 /* VideoChromaSampling.k420 */;
    }
    if (values.length < 5) {
      return undefined;
    }
    result.color_space.primaries = getPrimaryID(values[4]);
    // TODO: this 0 value is not defined in our js apis.
    if (result.color_space.primaries == 0) {
      // Invalid color primaries: values[4]
      return undefined;
    }
    if (result.color_space.primaries === _$$_REQUIRE(_dependencyMap[0]).VideoColorPrimaries.BT2020) {
      if (hdrmetadatatype === "smpteSt2086") {
        // HDR10
        switch (result.profile) {
          case VP9Profile2:
            result.profile = VP9Profile2HDR;
            break;
          case VP9Profile3:
            result.profile = VP9Profile3HDR;
            break;
          default:
            return undefined;
        }
      }
      if (hdrmetadatatype === "smpteSt2094-40") {
        // HDR10+
        switch (result.profile) {
          case VP9Profile2:
            result.profile = VP9Profile2HDR10Plus;
            break;
          case VP9Profile3:
            result.profile = VP9Profile3HDR10Plus;
            break;
          default:
            return undefined;
        }
      }
    }
    if (values.length < 6) {
      return undefined;
    }
    result.color_space.transfer = getTransferID(values[5]);
    if (result.color_space.transfer == 0) {
      // Invalid transfer function: values[5]
      return undefined;
    }
    if (values.length < 7) {
      return undefined;
    }
    result.color_space.matrix = getMatrixID(values[6]);
    if (result.color_space.matrix == -1) {
      // Invalid matrix coefficients: values[6]
      return undefined;
    }
    if (result.color_space.matrix === _$$_REQUIRE(_dependencyMap[0]).VideoColorMatrix.IDENTITY && chroma_subsampling != 3) {
      // Invalid combination of chroma_subsampling  and matrix coefficients
    }
    if (values.length < 8) {
      return undefined;
    }
    var video_full_range_flag = values[7];
    if (video_full_range_flag > 1) {
      // Invalid full range flag
      return undefined;
    }
    result.color_space.range = video_full_range_flag == 1 ? "FULL" : "LIMITED";
    return result;
  }
  exports.parseVp9CodecID = parseVp9CodecID;
  // The specification for Dolby Vision codec id strings can be found in Dolby
  // Vision streams within the MPEG-DASH format:
  // https://professional.dolby.com/siteassets/content-creation/dolby-vision-for-content-creators/dolbyvisioninmpegdashspecification_v2_0_public_20190107.pdf
  function parseDolbyVisionCodecId(codec_id) {
    if (!isDolbyVisionAVCCodecId(codec_id) && !isDolbyVisionHEVCCodecId(codec_id)) {
      return undefined;
    }
    var kMaxDvCodecIdLength = 11; // level id as 2 digit string.
    if (codec_id.length > kMaxDvCodecIdLength) {
      // Codec id is too long (" << codec_id << ")";
      return undefined;
    }
    var elem = codec_id.split(".");
    if (elem.length != 3) {
      // invalid dolby vision codec id " << codec_id;
      return undefined;
    }
    // Profile string should be two digits.
    var profile_id = Number(elem[1]);
    if (elem[1].length != 2 || Number.isNaN(profile_id) || profile_id > 9) {
      // invalid format or profile_id
      return undefined;
    }
    var result = {
      profile: DolbyVisionProfileUnknown,
      level: DolbyVisionLevelUnknown
    };
    // Only profiles 0, 4, 5, 7, 8 and 9 are valid. Profile 0 and 9 are encoded
    // based on AVC while profile 4, 5, 7 and 8 are based on HEVC.
    switch (profile_id) {
      case 0:
      case 9:
        if (!isDolbyVisionAVCCodecId(codec_id)) {
          // codec id is mismatched with profile_id
          return undefined;
        }
        if (profile_id == 0) {
          result.profile = DolbyVisionProfileDvavPer;
        } else if (profile_id == 9) {
          result.profile = DolbyVisionProfileDvavSe;
        }
        break;
      case 5:
      case 7:
      case 8:
        if (!isDolbyVisionHEVCCodecId(codec_id)) {
          // codec id is mismatched with profile_id=" << profile_id;
          return undefined;
        }
        if (profile_id == 5) {
          result.profile = DolbyVisionProfileDvheStn;
        } else if (profile_id == 7) {
          result.profile = DolbyVisionProfileDvheDtb;
        } else if (profile_id == 8) {
          result.profile = DolbyVisionProfileDvheSt;
        }
        break;
      default:
        // depecrated and not supported profile_id=" << profile_id;
        return undefined;
    }
    // Level string should be two digits.
    var level_id = Number(elem[2]);
    if (elem[2].length != 2 || Number.isNaN(level_id) || level_id > 13 || level_id < 1) {
      // invalid format level_id=" << elem[2];
      return undefined;
    }
    // TODO: map this level to ours
    result.level = level_id;
    return result;
  }
},"76e94d9cb88d077fdd92",["87c1deaf4e092124fc7a","5533cec96f6a88041c69","3508abd8c6b891008c0d","1f12e7e43345228dfcad"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2022-2023 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  function _callSuper(t, o, e) { return o = _$$_REQUIRE(_dependencyMap[0])(o), _$$_REQUIRE(_dependencyMap[1])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _$$_REQUIRE(_dependencyMap[0])(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SourceBufferImpl = undefined;
  var W3CMediaTurboModule_1 = __importDefault(_$$_REQUIRE(_dependencyMap[2]));
  /**
   * This class implements SourceBuffer interface.
   * It uses EventEmitter to emit events
   */
  var SourceBufferImpl = /*#__PURE__*/function (_EventAttributes_1$Ev) {
    function SourceBufferImpl(mediaElement, mediaSource, sourceBufferId, type) {
      var _this;
      _$$_REQUIRE(_dependencyMap[3])(this, SourceBufferImpl);
      var _eventEmitter = new (_$$_REQUIRE(_dependencyMap[4]).MediaEventEmitterImpl)();
      _this = _callSuper(this, SourceBufferImpl, [_eventEmitter]);
      _this.eventEmitter = _eventEmitter;
      _this.mediaElement = mediaElement;
      if (mediaSource) {
        _this.mediaSource = mediaSource;
      }
      _this.sourceBufferId = sourceBufferId;
      _this.mimeType = _$$_REQUIRE(_dependencyMap[5]).MimeType.parseMimeString(type);
      _this.audioTrackList = new (_$$_REQUIRE(_dependencyMap[6]).AudioTrackListImpl)();
      _this.videoTrackList = new (_$$_REQUIRE(_dependencyMap[7]).VideoTrackListImpl)();
      _this.textTrackList = new (_$$_REQUIRE(_dependencyMap[8]).TextTrackListImpl)();
      _this.trackListEventHandler = new (_$$_REQUIRE(_dependencyMap[9]).TrackListEventHandler)();
      var frameProcessorAppendMode = W3CMediaTurboModule_1.default.getFrameProcessorAppendMode();
      _this.MEDIA_SEGMENTS = frameProcessorAppendMode.SEGMENTS;
      _this.MEDIA_SEQUENCE = frameProcessorAppendMode.SEQUENCE;
      var mediaEventSource = W3CMediaTurboModule_1.default.getMediaEventSource();
      _this.MEDIA_EVENT_SOURCE_AUDIO_TRACKLIST = mediaEventSource.AUDIO_TRACKLIST;
      _this.MEDIA_EVENT_SOURCE_VIDEO_TRACKLIST = mediaEventSource.VIDEO_TRACKLIST;
      _this.MEDIA_EVENT_SOURCE_TEXT_TRACKLIST = mediaEventSource.TEXT_TRACKLIST;
      _this.handleEvent = _this.handleEvent.bind(_this);
      return _this;
    }
    /**
     * @hidden
     * Checks whether sourcebuffer Exists or not.
     */
    _$$_REQUIRE(_dependencyMap[10])(SourceBufferImpl, _EventAttributes_1$Ev);
    return _$$_REQUIRE(_dependencyMap[11])(SourceBufferImpl, [{
      key: "sourceBufferExists",
      value: function sourceBufferExists() {
        for (var i = 0; i < this.mediaSource.sourceBuffers.length; i++) {
          if (this.getId() === this.mediaSource.sourceBuffers[i].getId()) {
            return true;
          }
        }
        return false;
      }
      /**
       * @hidden
       * Throw InvlaidStateError if 'updating' is true
       */
    }, {
      key: "isUpdating",
      value: function isUpdating(errorMessage) {
        if (this.updating) {
          throw new (_$$_REQUIRE(_dependencyMap[12]).InvalidStateError)(errorMessage);
        }
      }
      // EventTarget APIs
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        _$$_REQUIRE(_dependencyMap[13]).LogUtil.info(`SourceBuffer:addEventListener: ${type}`);
        this.eventEmitter.addListener(type, listener);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        _$$_REQUIRE(_dependencyMap[13]).LogUtil.info(`SourceBuffer:removeListener: ${type}`);
        this.eventEmitter.removeListener(type, listener);
      }
      // SourceBuffer APIs
    }, {
      key: "mode",
      get: function get() {
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: get mode - No Media Element`);
          return _$$_REQUIRE(_dependencyMap[14]).AppendMode.segments;
        }
        var mode_ = W3CMediaTurboModule_1.default.sourceBuffer_GetMode(this.mediaElement, this.sourceBufferId);
        return mode_ === this.MEDIA_SEGMENTS ? _$$_REQUIRE(_dependencyMap[14]).AppendMode.segments : _$$_REQUIRE(_dependencyMap[14]).AppendMode.sequence;
      },
      set: function set(mode) {
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: set mode -No Media Element`);
          return;
        }
        _$$_REQUIRE(_dependencyMap[13]).LogUtil.info(`SourceBuffer[${this.sourceBufferId}]:mode(${mode})`);
        W3CMediaTurboModule_1.default.sourceBuffer_SetMode(this.mediaElement, this.sourceBufferId, mode === _$$_REQUIRE(_dependencyMap[14]).AppendMode.segments ? this.MEDIA_SEGMENTS : this.MEDIA_SEQUENCE);
      }
    }, {
      key: "updating",
      get: function get() {
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: get updating - No Media Element`);
          return false;
        }
        return W3CMediaTurboModule_1.default.sourceBuffer_GetUpdating(this.mediaElement, this.sourceBufferId);
      }
    }, {
      key: "buffered",
      get: function get() {
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: get buffered - No Media Element`);
          return new (_$$_REQUIRE(_dependencyMap[15]).TimeRangesImpl)(null);
        }
        return new (_$$_REQUIRE(_dependencyMap[15]).TimeRangesImpl)(W3CMediaTurboModule_1.default.sourceBuffer_GetBuffered(this.mediaElement, this.sourceBufferId));
      }
    }, {
      key: "timestampOffset",
      get: function get() {
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: get timestampOffset - No Media Element`);
          return NaN;
        }
        return W3CMediaTurboModule_1.default.sourceBuffer_GetTimestampOffset(this.mediaElement, this.sourceBufferId);
      },
      set: function set(offset) {
        var finalOffset;
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: set timestampOffset - No Media Element`);
          return;
        }
        this.isUpdating("set timestampOffset throws an exception when updating attribute is true.");
        _$$_REQUIRE(_dependencyMap[13]).LogUtil.debug(`SourceBuffer[${this.sourceBufferId}]:timestampOffset = ${this.timestampOffset})`);
        if (Number.isNaN(offset) || offset === undefined || offset === Number.POSITIVE_INFINITY || offset === Number.NEGATIVE_INFINITY) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.warn("SourceBuffer timestampOffset set to invalid value, throwing exception");
          throw new TypeError("timestampOffset");
        }
        if (offset === null) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.warn("param offset is null");
          finalOffset = 0;
        } else if (typeof offset === "boolean") {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.info("param offset is boolean");
          finalOffset = offset ? 1 : 0;
        } else if (typeof offset === "string") {
          if (offset === "") {
            _$$_REQUIRE(_dependencyMap[13]).LogUtil.warn("param offset is empty string");
            finalOffset = 0;
          } else {
            finalOffset = Number(offset);
            if (Number.isNaN(finalOffset)) {
              _$$_REQUIRE(_dependencyMap[13]).LogUtil.warn("param offset is invalid string");
              throw new TypeError("timestampOffset");
            }
            _$$_REQUIRE(_dependencyMap[13]).LogUtil.info("param offset is valid string");
          }
        } else if (typeof offset === "number") {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.info("set finalOffset to offset");
          finalOffset = offset;
        } else {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.info("Unknown param type");
        }
        if (!this.sourceBufferExists()) {
          throw new (_$$_REQUIRE(_dependencyMap[12]).InvalidStateError)("sorucebuffer doesn't exist while setting timestampOffSet value");
        }
        _$$_REQUIRE(_dependencyMap[13]).LogUtil.info(`SourceBuffer[${this.sourceBufferId}]:timestampOffset(${finalOffset})`);
        W3CMediaTurboModule_1.default.sourceBuffer_SetTimestampOffset(this.mediaElement, this.sourceBufferId, finalOffset);
        if (this.mediaSource.readyState === _$$_REQUIRE(_dependencyMap[14]).ReadyState.ended) {
          this.mediaSource.handleEvent("sourceopen");
        }
      }
    }, {
      key: "audioTracks",
      get: function get() {
        return this.audioTrackList;
      }
    }, {
      key: "videoTracks",
      get: function get() {
        return this.videoTrackList;
      }
    }, {
      key: "textTracks",
      get: function get() {
        return this.textTrackList;
      }
    }, {
      key: "appendWindowStart",
      get: function get() {
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: get appendWindowStart - No Media Element`);
          return NaN;
        }
        return W3CMediaTurboModule_1.default.sourceBuffer_GetAppendWindowStart(this.mediaElement, this.sourceBufferId);
      },
      set: function set(wndStart) {
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: set appendWindowStart - No Media Element`);
          return;
        }
        _$$_REQUIRE(_dependencyMap[13]).LogUtil.info(`SourceBuffer[${this.sourceBufferId}]:appendWindowStart(${wndStart})`);
        W3CMediaTurboModule_1.default.sourceBuffer_SetAppendWindowStart(this.mediaElement, this.sourceBufferId, wndStart);
      }
    }, {
      key: "appendWindowEnd",
      get: function get() {
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: get appendWindowEnd - No Media Element`);
          return NaN;
        }
        return W3CMediaTurboModule_1.default.sourceBuffer_GetAppendWindowEnd(this.mediaElement, this.sourceBufferId);
      },
      set: function set(wndEnd) {
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: set appendWindowEnd - No Media Element`);
          return;
        }
        _$$_REQUIRE(_dependencyMap[13]).LogUtil.info(`SourceBuffer[${this.sourceBufferId}]:appendWindowEnd(${wndEnd})`);
        W3CMediaTurboModule_1.default.sourceBuffer_SetAppendWindowEnd(this.mediaElement, this.sourceBufferId, wndEnd);
      }
      /**
       * For additional information, see
       * https://www.w3.org/TR/media-source-2/#dom-sourcebuffer-onupdatestart
       */
    }, {
      key: "onupdatestart",
      set: function set(listener) {
        this.addEvent(this._onupdatestart, "updatestart", listener);
      }
      /**
       * For additional information, see
       * https://www.w3.org/TR/media-source-2/#dom-sourcebuffer-onupdate
       */
    }, {
      key: "onupdate",
      set: function set(listener) {
        this.addEvent(this._onupdate, "update", listener);
      }
      /**
       * For additional information, see
       * https://www.w3.org/TR/media-source-2/#dom-sourcebuffer-onupdateend
       */
    }, {
      key: "onupdateend",
      set: function set(listener) {
        this.addEvent(this._onupdateend, "updateend", listener);
      }
      /**
       * For additional information, see
       * https://www.w3.org/TR/media-source-2/#dom-sourcebuffer-onerror
       */
    }, {
      key: "onerror",
      set: function set(listener) {
        this.addEvent(this._onerror, "error", listener);
      }
      /**
       * For additional information, see
       * https://www.w3.org/TR/media-source-2/#dom-sourcebuffer-onabort
       */
    }, {
      key: "onabort",
      set: function set(listener) {
        this.addEvent(this._onabort, "abort", listener);
      }
    }, {
      key: "appendBuffer",
      value: function appendBuffer(data) {
        var inputBuf;
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: appendBuffer - No Media Element`);
          return;
        }
        if (data instanceof ArrayBuffer) {
          inputBuf = data;
        } else if (data instanceof Uint8Array) {
          inputBuf = data.buffer;
        }
        _$$_REQUIRE(_dependencyMap[13]).LogUtil.info(`SourceBuffer[${this.sourceBufferId}]:appendBuffer(${inputBuf.byteLength})`);
        this.isUpdating("appendBuffer() throws an exception there is a pending append.");
        if (!this.sourceBufferExists()) {
          throw new (_$$_REQUIRE(_dependencyMap[12]).InvalidStateError)("appendBuffer() throws an exception when called after removeSourceBuffer().");
        }
        var sourceBufferResultCodes = W3CMediaTurboModule_1.default.getDemuxerAddSourceBufferResult();
        var ret = W3CMediaTurboModule_1.default.sourceBuffer_Append(this.mediaElement, this.sourceBufferId, inputBuf);
        if (ret === sourceBufferResultCodes.QUOTA_EXCEEDED) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer[${this.sourceBufferId}]:appendBuffer error(${ret})`);
          throw new (_$$_REQUIRE(_dependencyMap[12]).QuotaExceededError)("The quota has been exceeded.");
        } else if (ret === sourceBufferResultCodes.NOT_SUPPORTED) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer[${this.sourceBufferId}]:appendBuffer error(${ret})`);
          throw new (_$$_REQUIRE(_dependencyMap[12]).NotSupportedError)("The operation is not supported.");
        } else if (sourceBufferResultCodes.OK && ret !== sourceBufferResultCodes.OK) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer[${this.sourceBufferId}]:appendBuffer error(${ret})`);
          throw new (_$$_REQUIRE(_dependencyMap[12]).InvalidStateError)("The object is in an invalid state.");
        }
        this.mediaSource.handleEvent("sourceopen");
      }
    }, {
      key: "abort",
      value: function abort() {
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: abort - No Media Element`);
          return;
        }
        _$$_REQUIRE(_dependencyMap[13]).LogUtil.info(`SourceBuffer[${this.sourceBufferId}]:abort`);
        /**
         * If the readyState attribute of the parent media source is not in the "open" state
         * then throw an InvalidStateError exception and abort these steps.
         * https://www.w3.org/TR/2016/REC-media-source-20161117/#dom-sourcebuffer-abort
         */
        if (this.mediaSource.readyState !== _$$_REQUIRE(_dependencyMap[14]).ReadyState.open) {
          throw new (_$$_REQUIRE(_dependencyMap[12]).InvalidStateError)("SourceBuffer:abort readyState is not open");
        }
        if (!this.sourceBufferExists()) {
          throw new (_$$_REQUIRE(_dependencyMap[12]).InvalidStateError)("SourceBuffer:abort SourceBuffer doesn't exist");
        }
        W3CMediaTurboModule_1.default.sourceBuffer_Abort(this.mediaElement, this.sourceBufferId);
      }
    }, {
      key: "changeType",
      value: function changeType(type) {
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: changeType - No Media Element`);
          return;
        }
        _$$_REQUIRE(_dependencyMap[13]).LogUtil.info(`SourceBuffer[${this.sourceBufferId}]:changeType`);
        //https://www.w3.org/TR/media-source-2/#dom-sourcebuffer-changetype
        // 1. If type is an empty string then throw a TypeError exception and abort these steps.
        if (type === null) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer::changeType: type is null`);
          throw new (_$$_REQUIRE(_dependencyMap[12]).NotSupportedError)("changeType: 'type' is null");
        }
        if (typeof type !== "string") {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer::changeType: type is not string`);
          throw new TypeError("changeType: 'type' is not string");
        }
        if (type === "") {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer::changeType: empty type`);
          throw new TypeError("changeType: empty type");
        }
        // 2. If this object has been removed from the sourceBuffers attribute of the parent media
        //    source, then throw an InvalidStateError exception and abort these steps.
        if (!this.sourceBufferExists()) {
          throw new (_$$_REQUIRE(_dependencyMap[12]).InvalidStateError)("SourceBuffer:changeType SourceBuffer doesn't exist");
        }
        // 3. If the updating attribute equals true, then throw an InvalidStateError exception and
        //    abort these steps.
        this.isUpdating("SourceBuffer::changeType: pending append.");
        // 4. If type contains a MIME type that is not supported or contains a MIME type that is not
        //    supported with the types specified (currently or previously) of SourceBuffer objects in
        //    the sourceBuffers attribute of the parent media source, then throw a NotSupportedError
        //    exception and abort these steps.
        // check for the negative cases like changing main type from audio to video or vice versa
        // video main type can have both audio and video tracks but may need negative case handling
        var mimeType = _$$_REQUIRE(_dependencyMap[5]).MimeType.parseMimeString(type);
        if (mimeType === null) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error("invalid mime ", type);
          throw new TypeError("changeType: 'type' is invalid");
        }
        if (mimeType.type !== "video" && mimeType.type !== "audio") {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error("invalid mime ", type);
          throw new TypeError("changeType: 'type' is invalid");
        }
        if (!_$$_REQUIRE(_dependencyMap[16]).MimeTypeRegistry.checkSupportedType(mimeType)) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer::changeType: type is not supported`);
          throw new (_$$_REQUIRE(_dependencyMap[12]).NotSupportedError)("changeType: 'type' is not supported");
        }
        if (this.mimeType.type != mimeType.type) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer::changeType: type is different from initial, video -> audio or vice versa. this.mimeType is `, this.mimeType.type, ` mimeType is `, mimeType);
          throw new TypeError("changeType: 'type' is invalid");
        }
        // if the above checks passes, don't expect any error or exception from the Native expect
        // from tryQueryInterface.
        var result = W3CMediaTurboModule_1.default.sourceBuffer_ChangeType(this.mediaElement, this.sourceBufferId, type);
        if (isNaN(result)) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer::changeType: not supported`);
          throw new (_$$_REQUIRE(_dependencyMap[12]).NotSupportedError)("changeType: not supported");
        }
      }
    }, {
      key: "checkforValidNumber",
      value: function checkforValidNumber(value) {
        return !Number.isNaN(value) && typeof value === 'number';
      }
    }, {
      key: "remove",
      value: function remove(start, end) {
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: remove - No Media Element`);
          return;
        }
        if (!this.checkforValidNumber(start) || !Number.isFinite(start) || !this.checkforValidNumber(end) || start >= end || start < 0 || end === Number.NEGATIVE_INFINITY) {
          throw new TypeError(`'start' or 'end' is not a valid number`);
        }
        if (Number.isNaN(this.mediaSource.duration)) {
          throw new TypeError(`'duration is NAN'`);
        }
        if (start > this.mediaSource.duration) {
          throw new TypeError(`'start' is beyond the duration`);
        }
        if (!this.sourceBufferExists()) {
          throw new (_$$_REQUIRE(_dependencyMap[12]).InvalidStateError)("appendBuffer() throws an exception when called after removeSourceBuffer().");
        }
        this.isUpdating("Updating is true");
        W3CMediaTurboModule_1.default.sourceBuffer_Remove(this.mediaElement, this.sourceBufferId, start, end);
        if (this.mediaSource.readyState === _$$_REQUIRE(_dependencyMap[14]).ReadyState.ended) {
          this.mediaSource.handleEvent("sourceopen");
        }
      }
      // public APIs
    }, {
      key: "getId",
      value: function getId() {
        if (!this.mediaElement) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: getId - No Media Element`);
          return "";
        }
        return W3CMediaTurboModule_1.default.sourceBuffer_GetId(this.mediaElement, this.sourceBufferId);
      }
    }, {
      key: "handleEvent",
      value: function handleEvent(event) {
        // handle only valid events to avoid exception
        if (event) {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.info(`SourceBuffer[${this.sourceBufferId}]:handleEvent: with event: ${event.src}`);
          if (event.src === this.MEDIA_EVENT_SOURCE_VIDEO_TRACKLIST) {
            this.trackListEventHandler.handleVideoTrackListEvent(event, this.videoTrackList, this.mediaElement);
          } else if (event.src === this.MEDIA_EVENT_SOURCE_AUDIO_TRACKLIST) {
            this.trackListEventHandler.handleAudioTrackListEvent(event, this.audioTrackList, this.mediaElement);
          } else if (event.src === this.MEDIA_EVENT_SOURCE_TEXT_TRACKLIST) {
            this.trackListEventHandler.handleTextTrackListEvent(event, this.textTrackList, this.mediaElement);
          } else {
            // source buffer update** events
            this.eventEmitter.emit(event.name, new (_$$_REQUIRE(_dependencyMap[17]).Event)(event.name, this));
          }
        } else {
          _$$_REQUIRE(_dependencyMap[13]).LogUtil.error(`SourceBuffer[${this.sourceBufferId}]:handleEvent: invalid event received`);
        }
      }
    }]);
  }(_$$_REQUIRE(_dependencyMap[18]).EventAttributes);
  exports.SourceBufferImpl = SourceBufferImpl;
},"d2e0db98724a97dd6b88",["f391b9d534c3a6bc8659","4534eb96ece5e83c089a","0814a269c2fb50034991","3508abd8c6b891008c0d","92ad024a633394b0493f","51ba9e69d25f63defe5f","966f939aa33c9c57d996","57be0424162b51212025","c3e5f31ce01fcbdfdc92","3b6ed7af067745bc566f","73afcd34a88a750f6d69","5533cec96f6a88041c69","7f2298a3ae35e640412a","1f12e7e43345228dfcad","8ee67effabd3f8c12ca2","4251f58144b964061b21","5276f25b9cfa3ba46e9e","9e1e5e085598ef3ad539","51da1666f805b86ecd3d"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TimeRangesImpl = undefined;
  var TimeRangesImpl = /*#__PURE__*/function () {
    function TimeRangesImpl(nativeTimeRanges) {
      _$$_REQUIRE(_dependencyMap[0])(this, TimeRangesImpl);
      this.nativeTimeRanges = nativeTimeRanges;
    }
    return _$$_REQUIRE(_dependencyMap[1])(TimeRangesImpl, [{
      key: "length",
      get: function get() {
        if (this.nativeTimeRanges == null) {
          return 0;
        }
        return this.nativeTimeRanges.length;
      }
    }, {
      key: "start",
      value: function start(index) {
        if (!this.nativeTimeRanges || !this.nativeTimeRanges[index]) {
          return NaN;
        }
        return this.nativeTimeRanges[index].start;
      }
    }, {
      key: "end",
      value: function end(index) {
        if (!this.nativeTimeRanges || !this.nativeTimeRanges[index]) {
          return NaN;
        }
        return this.nativeTimeRanges[index].end;
      }
    }]);
  }();
  exports.TimeRangesImpl = TimeRangesImpl;
},"4251f58144b964061b21",["3508abd8c6b891008c0d","5533cec96f6a88041c69"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TimeMarchesOnAlgo = undefined;
  var W3CMediaTurboModule_1 = __importDefault(_$$_REQUIRE(_dependencyMap[0]));
  var TMOATask = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[1])(function TMOATask(aTime, aEvent) {
    _$$_REQUIRE(_dependencyMap[2])(this, TMOATask);
    this.time = aTime;
    this.e = aEvent;
  });
  var TimeMarchesOnAlgo = /*#__PURE__*/function () {
    function TimeMarchesOnAlgo() {
      _$$_REQUIRE(_dependencyMap[2])(this, TimeMarchesOnAlgo);
      /**
       * New ques
       * current position
       * earliest position
       **/
      this._lastCurrentPosition = 0;
      this._allCues = new Array();
    }
    return _$$_REQUIRE(_dependencyMap[1])(TimeMarchesOnAlgo, [{
      key: "getLastRunPosition",
      value: function getLastRunPosition() {
        return this._lastCurrentPosition;
      }
      /**
       * @CHECK Player will explicitly trim the TextTracks or
       * it needs to be done implicitly??
       * @param cue
       */
    }, {
      key: "removeCue",
      value: function removeCue(cue) {
        // @TODO optimise search
        var cueIndex = this._allCues.findIndex(function (vttcue) {
          return vttcue === cue || vttcue.id === cue.id;
        });
        if (cueIndex >= 0) {
          this._allCues.splice(cueIndex, 1); //remove element from array
        }
        if (cue.isActive) {
          cue.isActive = false;
          /**
           * @TODO erase it from the display or cancel it if it is
           * scheduled to be renderred
           **/
        }
      }
      /**
       * @TODO Rework on this using TextTrackCueManager
       * https://html.spec.whatwg.org/multipage/media.html#time-marches-on
       * @param currentTime : Current playback Position
       */
    }, {
      key: "run",
      value: function run(captionViewHandle, currentTime, newlyIntroducedCues) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`TMOA:+run time = ${currentTime} new cues ${newlyIntroducedCues == null ? undefined : newlyIntroducedCues.size}` + ` lastTime = ${this._lastCurrentPosition}`);
        if (Number.isNaN(currentTime) || currentTime < 0) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`TMOA:-run OUT}`);
          return;
        }
        /**
         * Step 1 to 7
         * Step 6: that is, firing the 'timeupdate' event is skipped here.
         *'timeupdate' event is fired from the native side from a dedicated,
         * playback progress minitor thread. Ideally, that should be fired from here.
         */
        var currentCues = [];
        var otherCues = [];
        var missedCues = [];
        if (this.updateCuesLists(currentTime, currentCues, otherCues, missedCues, newlyIntroducedCues)) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`TMOA:-run There is nothing to update !!`);
          this._lastCurrentPosition = currentTime;
          return;
        }
        /**
         * Step 8 : @TODO Support pause-on-exit flag ??
         */
        /**
         * Step 9, 10, 11, 12
         */
        var affectedTracks = new Array();
        var taskList = new Array();
        this.prepareTaskList(currentCues, otherCues, missedCues, taskList, affectedTracks);
        /**
         * Step 13
         */
        this.sortTaskList(taskList);
        /**
         * Step 14 : Dispatch events to their targets
         */
        this.processTaskList(taskList);
        /**
         * Step 15, 16 : Inform the affected tracks
         */
        this.informAffectedTracks(affectedTracks);
        /**
         * Step 17:
         * Update Cue Active Track
         * @CHECK do we need to submit all the active cues
         * for rendering, including from the last run?
         * Ideally, those need not be rendered again
         */
        var toBeRenderedCues = [];
        this.updateActiveCues(currentCues, otherCues, toBeRenderedCues);
        /**
         * Step 18: Render active cues from the "Showing" Tracks
         */
        this.renderActiveCues(captionViewHandle, toBeRenderedCues);
        this._lastCurrentPosition = currentTime;
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`TMOA:-run}`);
        return;
      }
    }, {
      key: "updateCuesLists",
      value: function updateCuesLists(currentTime, currentCues, otherCues, missedCues, newlyIntroducedCues) {
        var _this = this;
        // @TODO get rid of _allCues or optimise merging
        if (newlyIntroducedCues && newlyIntroducedCues.size > 0) {
          this._allCues = this._allCues.concat(Array.from(newlyIntroducedCues));
          this.sortList();
        }
        var nothingToDo = true;
        this._allCues.forEach(function (cue) {
          if (cue.startTime <= currentTime && currentTime < cue.endTime) {
            currentCues.push(cue);
            if (!cue.isActive) {
              nothingToDo = false;
            }
          } else {
            otherCues.push(cue);
            if (cue.isActive) {
              nothingToDo = false;
            }
            if (cue.startTime >= _this._lastCurrentPosition && cue.endTime <= currentTime) {
              if (!(newlyIntroducedCues != null && newlyIntroducedCues.has(cue))) {
                missedCues.push(cue);
                nothingToDo = false;
              }
            }
          }
        });
        /**
         * Step 5:
         */
        if (newlyIntroducedCues) {
          newlyIntroducedCues.clear();
        }
        return nothingToDo;
      }
    }, {
      key: "prepareTaskList",
      value: function prepareTaskList(currentCues, otherCues, missedCues, aTaskList, affectedTracks) {
        /**
         * Step 10 : Prepare 'enter' event for missed cues
         */
        missedCues.forEach(function (cue) {
          aTaskList.push(new TMOATask(cue.startTime, new (_$$_REQUIRE(_dependencyMap[4]).Event)('enter', cue)));
          /**
           * Either we can blindly push and remove duplicates later
           * OR
           * avoid pushing duplicates, in th efirst place
           * For now implement as per the specs and optimize late
           */
          /*if (affectedTracks.findIndex(
                          track => (track === cue.track || track.id === cue.track.id)
                          ) < 0) {
                          affectedTracks.push(cue.track);
                      }*/
          affectedTracks.push(cue.track);
        });
        /**
         * Step 11 : "For each text track cue in other cues that either has its
         * text track cue active flag set or is in missed cues, prepare an event
         * named exit for the TextTrackCue object with the later of the text track
         * cue end time and the text track cue start time."
         *
         * This is confusing, can cue endTime be > startTime??
         *
         * Prepare exit event for eligible-other cues and missed cues
         */
        otherCues.forEach(function (cue) {
          if (cue.isActive) {
            var time = cue.endTime > cue.startTime ? cue.endTime : cue.startTime;
            aTaskList.push(new TMOATask(time, new (_$$_REQUIRE(_dependencyMap[4]).Event)('exit', cue)));
            affectedTracks.push(cue.track);
          }
        });
        // This can be clubbed with step 10. Should we?
        missedCues.forEach(function (cue) {
          var time = cue.endTime > cue.startTime ? cue.endTime : cue.startTime;
          aTaskList.push(new TMOATask(time, new (_$$_REQUIRE(_dependencyMap[4]).Event)('exit', cue)));
          affectedTracks.push(cue.track);
        });
        /**
         * Step 12: Prepare enter event for current cues which are going to be active in this loop
         */
        currentCues.forEach(function (cue) {
          if (!cue.isActive) {
            aTaskList.push(new TMOATask(cue.startTime, new (_$$_REQUIRE(_dependencyMap[4]).Event)('enter', cue)));
            affectedTracks.push(cue.track);
          }
        });
      }
    }, {
      key: "sortTaskList",
      value: function sortTaskList(aTaskList) {
        aTaskList.sort(function (t1, t2) {
          var result = 0;
          var c1 = t1.e.target;
          var c2 = t2.e.target;
          if (t1.time !== t2.time) {
            result = t1.time - t2.time;
          } else if (c1.track.orderId !== c2.track.orderId) {
            result = c1.track.orderId - c2.track.orderId;
          } else if (c1.endTime !== c2.endTime) {
            result = c1.endTime - c2.endTime;
          } else if (t1.e.type === 'enter') {
            result = -1;
          }
          return result;
        });
      }
    }, {
      key: "processTaskList",
      value: function processTaskList(aTaskList) {
        aTaskList.forEach(function (task) {
          // Need to fire them asynchronously, as Target('s emitter) emits then synchronously.
          // FIXME : bad practice??
          setTimeout(function () {
            return task.e.target.dispatchEvent(task.e);
          }, 0);
        });
      }
    }, {
      key: "informAffectedTracks",
      value: function informAffectedTracks(affectedTracks) {
        // Step 15: Sort affected track list
        affectedTracks.sort(function (t1, t2) {
          return t1.orderId - t2.orderId;
        });
        // Step 16 : Inform the affected tracks
        affectedTracks.forEach(function (t) {
          // Need to fire them asynchronously, as Target('s emitter) emits then synchronously.
          // FIXME : bad practice??
          setTimeout(function () {
            return t.dispatchEvent(new (_$$_REQUIRE(_dependencyMap[4]).TrackEvent)('cuechange', t, t));
          });
        });
      }
    }, {
      key: "updateActiveCues",
      value: function updateActiveCues(currentCues, otherCues, toBeRenderedCues) {
        currentCues.forEach(function (cue) {
          var _cue$track, _cue$track2;
          if (!cue.isActive) {
            cue.isActive = true;
          }
          if (((_cue$track = cue.track) == null ? undefined : _cue$track.mode) === "showing" && ((_cue$track2 = cue.track) == null ? undefined : _cue$track2.kind) !== "metadata") {
            toBeRenderedCues.push(cue);
          }
        });
        otherCues.forEach(function (cue) {
          return cue.isActive = false;
        });
      }
    }, {
      key: "renderActiveCues",
      value: function renderActiveCues(captionViewHandle, toBeRenderedCues) {
        /**
         * @TODO MediaPlayer needs to create and provide a TextTrackRenderer
         * For now just log these.
         */
        var nativeVTTCueArray = [];
        toBeRenderedCues.forEach(function (cue) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.debug(`TMOA: renderActiveCues: ${cue.id} ${cue.startTime} - ${cue.endTime} ${cue.text}`);
          nativeVTTCueArray.push({
            startTime: cue.startTime,
            endTime: Number.isFinite(cue.endTime) ? cue.endTime : cue.startTime,
            region: cue.region,
            vertical: cue.vertical,
            snapToLines: cue.snapToLines,
            line: cue.line,
            lineAlign: cue.lineAlign,
            position: cue.position,
            positionAlign: cue.positionAlign,
            size: cue.size,
            align: cue.align,
            text: cue.text
          });
        });
        if (nativeVTTCueArray.length > 0) {
          _$$_REQUIRE(_dependencyMap[3]).LogUtil.warn('TMOA: renderActiveCues: Cues: ' + JSON.stringify(nativeVTTCueArray));
          W3CMediaTurboModule_1.default.renderCaptionsV2(captionViewHandle, nativeVTTCueArray);
        }
      }
      /**
       * In-order cues are not guaranteed, so sort the cues
       * https://html.spec.whatwg.org/multipage/media.html#text-track-cue-order
       * @TODO fix this is not in the required order.
       */
    }, {
      key: "sortList",
      value: function sortList() {
        var _this2 = this;
        var sortedList = this._allCues.slice().sort(function (c1, c2) {
          var result = 0;
          if (c1.startTime != c2.startTime) {
            result = c1.startTime - c2.startTime;
          } else if (c1.endTime != c2.endTime) {
            result = c1.endTime - c2.endTime;
          } else {
            if ('line' in _$$_REQUIRE(_dependencyMap[5]).VTTCue.prototype) {
              // Native VTTCue
              result = _this2._allCues.indexOf(c2) - _this2._allCues.indexOf(c1);
            } else {
              // Polyfilled VTTCue
              result = _this2._allCues.indexOf(c1) - _this2._allCues.indexOf(c2);
            }
          }
          return result;
        });
        this._allCues = sortedList;
      }
    }]);
  }();
  exports.TimeMarchesOnAlgo = TimeMarchesOnAlgo;
},"3c3fa916cfb66a71c0b6",["0814a269c2fb50034991","5533cec96f6a88041c69","3508abd8c6b891008c0d","1f12e7e43345228dfcad","9e1e5e085598ef3ad539","a13467c443d8b8a7e966"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  function _callSuper(t, o, e) { return o = _$$_REQUIRE(_dependencyMap[0])(o), _$$_REQUIRE(_dependencyMap[1])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _$$_REQUIRE(_dependencyMap[0])(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.HTMLAudioElement = exports.HTMLVideoElement = exports.HTMLMediaElement = undefined;
  /**
  * https://html.spec.whatwg.org/multipage/media.html#htmlmediaelement
  * This object also emits few custom events other than standard events
  * described in w3c specification.
  * "playbackstarted"  : event sent to the client when MediaPlayer start the playback
  * "audiofocusgranted": event sent to the client when MediaPlayer resumes the playback
  *                      internally on obtaining the audio focus.
  * "audiofocuspaused" : event sent to the client when MediaPlayer pauses the playback
  *                      internally on loosing the audio focus temporarily.
  * "audiofocuslost"   : event sent to the client when MediaPlayer pauses the playback
  *                      internally on loosing the audio focus permanantly.
  *
  */
  var HTMLMediaElement = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[2])(function HTMLMediaElement() {
    _$$_REQUIRE(_dependencyMap[3])(this, HTMLMediaElement);
  });
  /**
   * Enable or disable the UI for media controls.
   * For additional information, see
   * https://html.spec.whatwg.org/multipage/media.html#dom-media-controls.
   */
  /**
   * For additional information, see
   * https://html.spec.whatwg.org/multipage/media.html#dom-media-have_nothing.
   */
  HTMLMediaElement.HAVE_NOTHING = 0;
  /**
   * For additional information, see
   * https://html.spec.whatwg.org/multipage/media.html#dom-media-have_metadata.
   */
  HTMLMediaElement.HAVE_METADATA = 1;
  /**
   * For additional information, see
   * https://html.spec.whatwg.org/multipage/media.html#dom-media-have_current_data.
   */
  HTMLMediaElement.HAVE_CURRENT_DATA = 2;
  /**
   * For additional information, see
   * https://html.spec.whatwg.org/multipage/media.html#dom-media-have_future_data.
   */
  HTMLMediaElement.HAVE_FUTURE_DATA = 3;
  /**
   * For additional information, see
   * https://html.spec.whatwg.org/multipage/media.html#dom-media-have_enough_data.
   */
  HTMLMediaElement.HAVE_ENOUGH_DATA = 4;
  /**
   * @hidden
   * https://html.spec.whatwg.org/multipage/media.html#dom-media-network_empty.
   */
  HTMLMediaElement.NETWORK_EMPTY = 0;
  /**
   * @hidden
   * https://html.spec.whatwg.org/multipage/media.html#dom-media-network_idle.
   */
  HTMLMediaElement.NETWORK_IDLE = 1;
  /**
   * @hidden
   * https://html.spec.whatwg.org/multipage/media.html#dom-media-network_loading.
   */
  HTMLMediaElement.NETWORK_LOADING = 2;
  /**
   * @hidden
   * https://html.spec.whatwg.org/multipage/media.html#dom-media-network_no_source.
   */
  HTMLMediaElement.NETWORK_NO_SOURCE = 3;
  exports.HTMLMediaElement = HTMLMediaElement;
  var HTMLVideoElement = /*#__PURE__*/function (_HTMLMediaElement2) {
    function HTMLVideoElement() {
      _$$_REQUIRE(_dependencyMap[3])(this, HTMLVideoElement);
      return _callSuper(this, HTMLVideoElement, arguments);
    }
    _$$_REQUIRE(_dependencyMap[4])(HTMLVideoElement, _HTMLMediaElement2);
    return _$$_REQUIRE(_dependencyMap[2])(HTMLVideoElement);
  }(HTMLMediaElement);
  exports.HTMLVideoElement = HTMLVideoElement;
  var HTMLAudioElement = /*#__PURE__*/function (_HTMLMediaElement3) {
    function HTMLAudioElement() {
      _$$_REQUIRE(_dependencyMap[3])(this, HTMLAudioElement);
      return _callSuper(this, HTMLAudioElement, arguments);
    }
    _$$_REQUIRE(_dependencyMap[4])(HTMLAudioElement, _HTMLMediaElement3);
    return _$$_REQUIRE(_dependencyMap[2])(HTMLAudioElement);
  }(HTMLMediaElement);
  exports.HTMLAudioElement = HTMLAudioElement;
},"27520dc71d42ce3c8e40",["f391b9d534c3a6bc8659","4534eb96ece5e83c089a","5533cec96f6a88041c69","3508abd8c6b891008c0d","73afcd34a88a750f6d69"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  function _callSuper(t, o, e) { return o = _$$_REQUIRE(_dependencyMap[0])(o), _$$_REQUIRE(_dependencyMap[1])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _$$_REQUIRE(_dependencyMap[0])(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Media = undefined;
  /*
   * Copyright 2022-2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  var React = __importStar(_$$_REQUIRE(_dependencyMap[2]));
  /**
   * @hidden
   * https://html.spec.whatwg.org/multipage/media.html#htmlmediaelement
   */
  var Media = /*#__PURE__*/function (_React$Component) {
    function Media(props, mediaPlayer) {
      var _this;
      _$$_REQUIRE(_dependencyMap[3])(this, Media);
      _this = _callSuper(this, Media, [props]);
      _this.mediaPlayer_ = null;
      _this.controls_ = false;
      _this.captionsViewHandle_ = null;
      _$$_REQUIRE(_dependencyMap[4]).LogUtil.info(`Media:+constructor`);
      _this.mediaPlayer_ = mediaPlayer;
      // NOTE: controls is a prop. Once set cannot be changed at runtime.
      if (_this.props.controls !== undefined) {
        _this.controls = _this.props.controls;
      } else {
        _$$_REQUIRE(_dependencyMap[4]).LogUtil.warn(`Media: control props is undefined`);
      }
      if (_this.props.defaultSeekIntervalInSec && Number.isInteger(_this.props.defaultSeekIntervalInSec) && _this.props.defaultSeekIntervalInSec > 0) {
        _this.mediaPlayer_.defaultSeekIntervalInSec = _this.props.defaultSeekIntervalInSec;
      }
      _this.handleEvent = _this.handleEvent.bind(_this);
      _this.setupEventListenersFromProps();
      _this.onCaptionViewCreated = _this.onCaptionViewCreated.bind(_this);
      _$$_REQUIRE(_dependencyMap[4]).LogUtil.info(`Media:-constructor`);
      return _this;
    }
    /**
     * @hidden
     */
    _$$_REQUIRE(_dependencyMap[5])(Media, _React$Component);
    return _$$_REQUIRE(_dependencyMap[6])(Media, [{
      key: "destroyMediaPlayer",
      value: function destroyMediaPlayer() {
        var _this2 = this;
        _$$_REQUIRE(_dependencyMap[4]).LogUtil.info("Media: destroyMediaPlayer");
        this.resetEventListenersFromProps();
        return new Promise(function (resolve, reject) {
          if (_this2.mediaPlayer_) {
            _$$_REQUIRE(_dependencyMap[4]).LogUtil.info("Media: destroying media element asynchronously");
            _this2.mediaPlayer_.deinitialize().then(function () {
              _$$_REQUIRE(_dependencyMap[4]).LogUtil.info("Media: MediaElement destroyed");
              _this2.mediaPlayer_ = null;
              if (_this2.props.onComponentUnMounted) {
                _this2.props.onComponentUnMounted();
              }
              resolve();
            });
            return;
          }
          reject();
        });
      }
      /**
       * @hidden
       */
    }, {
      key: "destroyMediaPlayerSync",
      value: function destroyMediaPlayerSync(timeoutInMs) {
        this.resetEventListenersFromProps();
        if (this.mediaPlayer_) {
          var status = this.mediaPlayer_.deinitializeSync(timeoutInMs);
          //this.mediaPlayer_ = null;
          //if (this.props.onComponentUnMounted) {
          //    this.props.onComponentUnMounted();
          //}
          return status;
        }
        _$$_REQUIRE(_dependencyMap[4]).LogUtil.warn("Media: not a valid MediaElement to deinit");
        return "invalid";
      }
      /**
       * @hidden
       */
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        _$$_REQUIRE(_dependencyMap[4]).LogUtil.info("Media: componentDidMount");
      }
      /**
       * @hidden
       */
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        _$$_REQUIRE(_dependencyMap[4]).LogUtil.info("Media: componentWillUnmount");
      }
      // EventTarget APIs
      /**
       * @hidden
       * Adds a event listener
       */
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        var _this$mediaPlayer_;
        _$$_REQUIRE(_dependencyMap[4]).LogUtil.info(`Media:addEventListener: ${type}`);
        (_this$mediaPlayer_ = this.mediaPlayer_) == null ? undefined : _this$mediaPlayer_.addEventListener(type, listener);
      }
      /**
       * @hidden
       * Removes event listener
       */
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        var _this$mediaPlayer_2;
        _$$_REQUIRE(_dependencyMap[4]).LogUtil.info(`Media:removeEventListener: ${type}`);
        (_this$mediaPlayer_2 = this.mediaPlayer_) == null ? undefined : _this$mediaPlayer_2.removeEventListener(type, listener);
      }
      /**
       * @hidden
       */
    }, {
      key: "nodeName",
      get: function get() {
        return this.mediaPlayer_.nodeName;
      }
      /**
       * @hidden
       */
    }, {
      key: "src",
      get:
      /**
       * @hidden
       */
      function get() {
        return this.mediaPlayer_.src;
      }
      /**
       * @hidden
       */,
      set: function set(url) {
        this.mediaPlayer_.src = url;
      }
    }, {
      key: "defaultSeekIntervalInSec",
      get:
      /**
       * @hidden
       */
      function get() {
        return this.defaultSeekIntervalInSec;
      }
      /**
       * @hidden
       */,
      set: function set(seekInterval) {
        this.mediaPlayer_.defaultSeekIntervalInSec = seekInterval;
      }
    }, {
      key: "srcObject",
      set: function set(srcObj) {
        this.mediaPlayer_.srcObject = srcObj;
      }
      /**
       * @hidden
       */
    }, {
      key: "error",
      get: function get() {
        return this.mediaPlayer_.error;
      }
      /**
       * @hidden
       */
    }, {
      key: "currentSrc",
      get: function get() {
        return this.mediaPlayer_.currentSrc;
      }
      /**
       * @hidden
       */
    }, {
      key: "networkState",
      get: function get() {
        return this.mediaPlayer_.networkState;
      }
      /**
       * @hidden
       */
    }, {
      key: "buffered",
      get: function get() {
        return this.mediaPlayer_.buffered;
      }
      /**
       * @hidden
       */
    }, {
      key: "load",
      value: function load() {
        var _this$mediaPlayer_3;
        (_this$mediaPlayer_3 = this.mediaPlayer_) == null ? undefined : _this$mediaPlayer_3.load();
      }
      /**
       *@hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-navigator-canplaytype
       * @param type mime type
       */
    }, {
      key: "canPlayType",
      value: function canPlayType(type) {
        var _this$mediaPlayer_4;
        return (_this$mediaPlayer_4 = this.mediaPlayer_) == null ? undefined : _this$mediaPlayer_4.canPlayType(type);
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-readystate
       */
    }, {
      key: "readyState",
      get: function get() {
        return this.mediaPlayer_.readyState;
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-seeking
       */
    }, {
      key: "seeking",
      get: function get() {
        return this.mediaPlayer_.seeking;
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-fastseek
       */
    }, {
      key: "fastSeek",
      value: function fastSeek(time) {
        var _this$mediaPlayer_5;
        return (_this$mediaPlayer_5 = this.mediaPlayer_) == null ? undefined : _this$mediaPlayer_5.fastSeek(time);
      }
      /**
       * @hidden
       *  https://html.spec.whatwg.org/multipage/media.html#dom-media-duration
       */
    }, {
      key: "duration",
      get: function get() {
        return this.mediaPlayer_.duration;
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-getstartdate
       */
    }, {
      key: "getStartDate",
      value: function getStartDate() {
        var _this$mediaPlayer_6;
        return (_this$mediaPlayer_6 = this.mediaPlayer_) == null ? undefined : _this$mediaPlayer_6.getStartDate();
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-paused
       */
    }, {
      key: "paused",
      get: function get() {
        return this.mediaPlayer_.paused;
      }
      /**
       * @hidden
       *
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-played
       */
    }, {
      key: "played",
      get: function get() {
        return this.mediaPlayer_.played;
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-seekable
       */
    }, {
      key: "seekable",
      get: function get() {
        return this.mediaPlayer_.seekable;
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-ended
       */
    }, {
      key: "ended",
      get: function get() {
        return this.mediaPlayer_.ended;
      }
      /**
       * @hidden
       *  https://html.spec.whatwg.org/multipage/media.html#dom-media-play
       */
    }, {
      key: "play",
      value: function play() {
        var _this$mediaPlayer_7;
        return (_this$mediaPlayer_7 = this.mediaPlayer_) == null ? undefined : _this$mediaPlayer_7.play();
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-pause
       */
    }, {
      key: "pause",
      value: function pause() {
        var _this$mediaPlayer_8;
        return (_this$mediaPlayer_8 = this.mediaPlayer_) == null ? undefined : _this$mediaPlayer_8.pause();
      }
      /**
       * @hidden
      * https://html.spec.whatwg.org/multipage/media.html#dom-media-audiotracks
      */
    }, {
      key: "audioTracks",
      get: function get() {
        return this.mediaPlayer_.audioTracks;
      }
      /**
       * @hidden
      *  https://html.spec.whatwg.org/multipage/media.html#dom-media-videotracks
      */
    }, {
      key: "videoTracks",
      get: function get() {
        return this.mediaPlayer_.videoTracks;
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-texttracks
       */
    }, {
      key: "textTracks",
      get: function get() {
        return this.mediaPlayer_.textTracks;
      }
      /**
       * @hidden
       * @brief https://html.spec.whatwg.org/multipage/media.html#dom-media-addtexttrack
       * @param kind The kind attribute must return the text track kind of the text track that the TextTrack object represents.
       * @param label The label attribute must return the text track label of the text track that the TextTrack object represents.
       * @param language The language attribute must return the text track language of the text track that the TextTrack object represents.
       * @param uri The uri attribute must return the uri of the out of band subtitle of the text track that the TextTrack object represents.
       * This is a custom addition (not as per w3c spec). If uri is provided, this component will take care of parsing and rendering subtitles.
       * @param mimeType The mimeType attribute must return the mime type of the out of band subtitle of the text track that the TextTrack
       * object represents. This is a custom addition (not as per w3c spec).
       */
    }, {
      key: "addTextTrack",
      value: function addTextTrack(kind, label, language, uri, mimeType) {
        var _this$mediaPlayer_9;
        return (_this$mediaPlayer_9 = this.mediaPlayer_) == null ? undefined : _this$mediaPlayer_9.addTextTrack(kind, label, language, uri, mimeType);
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#attr-media-preload
       */
    }, {
      key: "preload",
      get: function get() {
        return this.mediaPlayer_.preload;
      }
      /**
       * @hidden
       */,
      set: function set(preload) {
        this.mediaPlayer_.preload = preload;
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-currenttime
       */
    }, {
      key: "currentTime",
      get: function get() {
        return this.mediaPlayer_.currentTime;
      }
      /**
       * @hidden
       */,
      set: function set(time) {
        this.mediaPlayer_.currentTime = time;
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-defaultplaybackrate
       */
    }, {
      key: "defaultPlaybackRate",
      get: function get() {
        return this.mediaPlayer_.defaultPlaybackRate;
      }
      /**
       * @hidden
       */,
      set: function set(rate) {
        this.mediaPlayer_.defaultPlaybackRate = rate;
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-playbackrate
       */
    }, {
      key: "playbackRate",
      get: function get() {
        return this.mediaPlayer_.playbackRate;
      }
      /**
       * @hidden
       */,
      set: function set(rate) {
        this.mediaPlayer_.playbackRate = rate;
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-preservespitch
       * @note Not implemented
       */
    }, {
      key: "autoplay",
      get:
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-autoplay
       */
      function get() {
        return this.mediaPlayer_.autoplay;
      }
      /**
       * @hidden
       */,
      set: function set(autoplay) {
        this.mediaPlayer_.autoplay = autoplay;
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-loop
       */
    }, {
      key: "loop",
      get: function get() {
        return this.mediaPlayer_.loop;
      }
      /**
       * @hidden
       */,
      set: function set(loop) {
        this.mediaPlayer_.loop = loop;
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-controls
       */
    }, {
      key: "controls",
      get: function get() {
        return this.controls_;
      }
      /**
       * @hidden
       */,
      set: function set(controls) {
        _$$_REQUIRE(_dependencyMap[4]).LogUtil.info(`Media: setter controls ${controls}`);
        this.controls_ = controls;
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-volume
       */
    }, {
      key: "volume",
      get: function get() {
        return this.mediaPlayer_.volume;
      }
      /**
       * @hidden
       */,
      set: function set(volume) {
        this.mediaPlayer_.volume = volume;
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-muted
       */
    }, {
      key: "muted",
      get: function get() {
        return this.mediaPlayer_.muted;
      }
      /**
       * @hidden
       */,
      set: function set(muted) {
        this.mediaPlayer_.muted = muted;
      }
      /**
       * @hidden
       * https://html.spec.whatwg.org/multipage/media.html#dom-media-defaultmuted
       */
    }, {
      key: "defaultMuted",
      get: function get() {
        return this.mediaPlayer_.defaultMuted;
      }
      /**
       * @hidden
       */,
      set: function set(defaultMuted) {
        this.mediaPlayer_.defaultMuted = defaultMuted;
      }
      /**
       * @hidden
       */
    }, {
      key: "setMediaKeys",
      value: function setMediaKeys(mediaKeys) {
        var _this$mediaPlayer_10;
        return (_this$mediaPlayer_10 = this.mediaPlayer_) == null ? undefined : _this$mediaPlayer_10.setMediaKeys(mediaKeys);
      }
      /**
       * @hidden
       * Handle all media element and audio/video track list events.
       */
    }, {
      key: "handleEvent",
      value: function handleEvent(event) {
        var _this$mediaPlayer_11;
        (_this$mediaPlayer_11 = this.mediaPlayer_) == null ? undefined : _this$mediaPlayer_11.handleEvent(event);
      }
      /**
       * @hidden
       * Sets up event listeners passed in props
       */
    }, {
      key: "setupEventListenersFromProps",
      value: function setupEventListenersFromProps() {
        if (this.props.onLoadStart !== undefined) {
          this.addEventListener("loadstart", this.props.onLoadStart);
        }
        if (this.props.onProgress !== undefined) {
          this.addEventListener("progress", this.props.onProgress);
        }
        if (this.props.onSuspend !== undefined) {
          this.addEventListener("suspend", this.props.onSuspend);
        }
        if (this.props.onAbort !== undefined) {
          this.addEventListener("abort", this.props.onAbort);
        }
        if (this.props.onError !== undefined) {
          this.addEventListener("error", this.props.onError);
        }
        if (this.props.onEmptied !== undefined) {
          this.addEventListener("emptied", this.props.onEmptied);
        }
        if (this.props.onStalled !== undefined) {
          this.addEventListener("stalled", this.props.onStalled);
        }
        if (this.props.onLoadedMetadata !== undefined) {
          this.addEventListener("loadedmetadata", this.props.onLoadedMetadata);
        }
        if (this.props.onLoadedData !== undefined) {
          this.addEventListener("loadeddata", this.props.onLoadedData);
        }
        if (this.props.onCanPlay !== undefined) {
          this.addEventListener("canplay", this.props.onCanPlay);
        }
        if (this.props.onCanPlayThrough !== undefined) {
          this.addEventListener("canplaythrough", this.props.onCanPlayThrough);
        }
        if (this.props.onPlaying !== undefined) {
          this.addEventListener("playing", this.props.onPlaying);
        }
        if (this.props.onWaiting !== undefined) {
          this.addEventListener("waiting", this.props.onWaiting);
        }
        if (this.props.onSeeking !== undefined) {
          this.addEventListener("seeking", this.props.onSeeking);
        }
        if (this.props.onSeeked !== undefined) {
          this.addEventListener("seeked", this.props.onSeeked);
        }
        if (this.props.onEnded !== undefined) {
          this.addEventListener("ended", this.props.onEnded);
        }
        if (this.props.onDurationChange !== undefined) {
          this.addEventListener("durationchange", this.props.onDurationChange);
        }
        if (this.props.onTimeUpdate !== undefined) {
          this.addEventListener("timeupdate", this.props.onTimeUpdate);
        }
        if (this.props.onPlay !== undefined) {
          this.addEventListener("play", this.props.onPlay);
        }
        if (this.props.onPause !== undefined) {
          this.addEventListener("pause", this.props.onPause);
        }
        if (this.props.onRateChange !== undefined) {
          this.addEventListener("ratechange", this.props.onRateChange);
        }
        if (this.props.onResize !== undefined) {
          this.addEventListener("resize", this.props.onResize);
        }
        if (this.props.onVolumeChange !== undefined) {
          this.addEventListener("volumechange", this.props.onVolumeChange);
        }
        if (this.props.onEncrypted !== undefined) {
          this.addEventListener("encrypted", this.props.onEncrypted);
        }
        if (this.props.onWaitingForKey !== undefined) {
          this.addEventListener("waitingforkey", this.props.onWaitingForKey);
        }
        if (this.props.onAudioFocusGranted !== undefined) {
          this.addEventListener("audiofocusgranted", this.props.onAudioFocusGranted);
        }
        if (this.props.onAudioFocusPaused !== undefined) {
          this.addEventListener("audiofocuspaused", this.props.onAudioFocusPaused);
        }
        if (this.props.onAudioFocusLost !== undefined) {
          this.addEventListener("audiofocuslost", this.props.onAudioFocusLost);
        }
      }
      /**
       * @hidden
       * Reset event listeners passed in props before destroy
       */
    }, {
      key: "resetEventListenersFromProps",
      value: function resetEventListenersFromProps() {
        if (this.props.onLoadStart !== undefined) {
          this.removeEventListener("loadstart", this.props.onLoadStart);
        }
        if (this.props.onProgress !== undefined) {
          this.removeEventListener("progress", this.props.onProgress);
        }
        if (this.props.onSuspend !== undefined) {
          this.removeEventListener("suspend", this.props.onSuspend);
        }
        if (this.props.onAbort !== undefined) {
          this.removeEventListener("abort", this.props.onAbort);
        }
        if (this.props.onError !== undefined) {
          this.removeEventListener("error", this.props.onError);
        }
        if (this.props.onEmptied !== undefined) {
          this.removeEventListener("emptied", this.props.onEmptied);
        }
        if (this.props.onStalled !== undefined) {
          this.removeEventListener("stalled", this.props.onStalled);
        }
        if (this.props.onLoadedMetadata !== undefined) {
          this.removeEventListener("loadedmetadata", this.props.onLoadedMetadata);
        }
        if (this.props.onLoadedData !== undefined) {
          this.removeEventListener("loadeddata", this.props.onLoadedData);
        }
        if (this.props.onCanPlay !== undefined) {
          this.removeEventListener("canplay", this.props.onCanPlay);
        }
        if (this.props.onCanPlayThrough !== undefined) {
          this.removeEventListener("canplaythrough", this.props.onCanPlayThrough);
        }
        if (this.props.onPlaying !== undefined) {
          this.removeEventListener("playing", this.props.onPlaying);
        }
        if (this.props.onWaiting !== undefined) {
          this.removeEventListener("waiting", this.props.onWaiting);
        }
        if (this.props.onSeeking !== undefined) {
          this.removeEventListener("seeking", this.props.onSeeking);
        }
        if (this.props.onSeeked !== undefined) {
          this.removeEventListener("seeked", this.props.onSeeked);
        }
        if (this.props.onEnded !== undefined) {
          this.removeEventListener("ended", this.props.onEnded);
        }
        if (this.props.onDurationChange !== undefined) {
          this.removeEventListener("durationchange", this.props.onDurationChange);
        }
        if (this.props.onTimeUpdate !== undefined) {
          this.removeEventListener("timeupdate", this.props.onTimeUpdate);
        }
        if (this.props.onPlay !== undefined) {
          this.removeEventListener("play", this.props.onPlay);
        }
        if (this.props.onPause !== undefined) {
          this.removeEventListener("pause", this.props.onPause);
        }
        if (this.props.onRateChange !== undefined) {
          this.removeEventListener("ratechange", this.props.onRateChange);
        }
        if (this.props.onResize !== undefined) {
          this.removeEventListener("resize", this.props.onResize);
        }
        if (this.props.onVolumeChange !== undefined) {
          this.removeEventListener("volumechange", this.props.onVolumeChange);
        }
        if (this.props.onEncrypted !== undefined) {
          this.removeEventListener("encrypted", this.props.onEncrypted);
        }
        if (this.props.onWaitingForKey !== undefined) {
          this.removeEventListener("waitingforkey", this.props.onWaitingForKey);
        }
        if (this.props.onAudioFocusGranted !== undefined) {
          this.removeEventListener("audiofocusgranted", this.props.onAudioFocusGranted);
        }
        if (this.props.onAudioFocusPaused !== undefined) {
          this.removeEventListener("audiofocuspaused", this.props.onAudioFocusPaused);
        }
        if (this.props.onAudioFocusLost !== undefined) {
          this.removeEventListener("audiofocuslost", this.props.onAudioFocusLost);
        }
      }
      /**
       * @hidden
       * uses properties to set the attributes of the class that triggers setter functions.
       * (except for control prop)
       */
    }, {
      key: "setupProps",
      value: function setupProps() {
        // set autoPlay before src as it is used in the turbo API.
        if (this.props.autoplay !== undefined) {
          this.autoplay = this.props.autoplay;
        }
        if (this.props.defaultSeekIntervalInSec !== undefined) {
          this.defaultSeekIntervalInSec = this.props.defaultSeekIntervalInSec;
        }
        if (this.props.src !== undefined) {
          this.src = this.props.src;
        }
        if (this.props.preload !== undefined) {
          this.preload = this.props.preload;
        }
        if (this.props.currentTime !== undefined) {
          this.currentTime = this.props.currentTime;
        }
        if (this.props.defaultPlaybackRate !== undefined) {
          this.defaultPlaybackRate = this.props.defaultPlaybackRate;
        }
        if (this.props.playbackRate !== undefined) {
          this.playbackRate = this.props.playbackRate;
        }
        if (this.props.defaultPlaybackRate !== undefined) {
          this.defaultPlaybackRate = this.props.defaultPlaybackRate;
          // if default rate is set, initialize the playback rate also
          this.playbackRate = this.props.defaultPlaybackRate;
        }
        if (this.props.playbackRate !== undefined) {
          this.playbackRate = this.props.playbackRate;
        }
        if (this.props.preservesPitch !== undefined) {
          this.preservesPitch = this.props.preservesPitch;
        }
        if (this.props.loop !== undefined) {
          this.loop = this.props.loop;
        }
        if (this.props.volume !== undefined) {
          this.volume = this.props.volume;
        }
        if (this.props.muted !== undefined) {
          this.muted = this.props.muted;
        }
        if (this.props.defaultMuted !== undefined) {
          this.defaultMuted = this.props.defaultMuted;
        }
      }
    }, {
      key: "onMediaPlayerInitialized",
      value: function onMediaPlayerInitialized() {
        if (this.props.onComponentDidMount) {
          this.props.onComponentDidMount();
        }
        // now setup the properties
        this.setupProps();
      }
      /**
       * @hidden
       */
    }, {
      key: "initializeMediaPlayer",
      value: function initializeMediaPlayer() {
        var _this$mediaPlayer_12;
        return (_this$mediaPlayer_12 = this.mediaPlayer_) == null ? undefined : _this$mediaPlayer_12.initialize();
      }
      /**
       * @brief setup the component instance with current mediaplayer being used and pass mediaControlHandler
       *        in case client wants to opt handling of mediacontrol commands.
       */
    }, {
      key: "setMediaControlFocus",
      value: function setMediaControlFocus(componentInstance, mediaControlHandler) {
        var _this$mediaPlayer_13;
        return (_this$mediaPlayer_13 = this.mediaPlayer_) == null ? undefined : _this$mediaPlayer_13.setMediaControlFocus(componentInstance, mediaControlHandler);
      }
      /**
       * @hidden
       */
    }, {
      key: "onCaptionViewCreated",
      value: function onCaptionViewCreated(captionViewHandle) {
        var _this$mediaPlayer_14;
        (_this$mediaPlayer_14 = this.mediaPlayer_) == null ? undefined : _this$mediaPlayer_14.setCaptionViewHandle(captionViewHandle);
        this.captionsViewHandle_ = captionViewHandle;
      }
    }]);
  }(React.Component);
  exports.Media = Media;
},"372fa0c50373b8a1a1df",["f391b9d534c3a6bc8659","4534eb96ece5e83c089a","6ed0e34da2b23bd3554f","3508abd8c6b891008c0d","1f12e7e43345228dfcad","73afcd34a88a750f6d69","5533cec96f6a88041c69"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  function _callSuper(t, o, e) { return o = _$$_REQUIRE(_dependencyMap[0])(o), _$$_REQUIRE(_dependencyMap[1])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _$$_REQUIRE(_dependencyMap[0])(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  function _superPropSet(t, e, o, r, p, f) { return _$$_REQUIRE(_dependencyMap[2])(_$$_REQUIRE(_dependencyMap[0])(f ? t.prototype : t), e, o, r, p); }
  function _superPropGet(t, o, e, r) { var p = _$$_REQUIRE(_dependencyMap[3])(_$$_REQUIRE(_dependencyMap[0])(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Video = undefined;
  /*
   * Copyright 2022-2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  var React = __importStar(_$$_REQUIRE(_dependencyMap[4]));
  var react_native_1 = _$$_REQUIRE(_dependencyMap[5]);
  var MediaControls_1 = __importDefault(_$$_REQUIRE(_dependencyMap[6]));
  /**
   * Video is a react native component that implements the `HTMLVideoElement` interface
   * that extends the `HTMLMediaElement` interface.
   */
  var Video = /*#__PURE__*/function (_Media_1$Media) {
    /**
     * @hidden
     */
    function Video(props) {
      var _this;
      _$$_REQUIRE(_dependencyMap[7])(this, Video);
      _this = _callSuper(this, Video, [props, new (_$$_REQUIRE(_dependencyMap[8]).VideoPlayer)()]);
      _this.poster_ = "";
      _this.width_ = NaN;
      _this.height_ = NaN;
      _this.surfaceHandle = null;
      _this.isMediaPlayerInitialized = false;
      _this.onSurfaceMounted = _this.onSurfaceMounted.bind(_this);
      _this.onSurfaceUnmounted = _this.onSurfaceUnmounted.bind(_this);
      _this.onSurfaceCreated = _this.onSurfaceCreated.bind(_this);
      _this.onSurfaceDestroyed = _this.onSurfaceDestroyed.bind(_this);
      if (_this.props.width !== undefined) {
        _this.width_ = _this.props.width;
      }
      if (_this.props.height !== undefined) {
        _this.height_ = _this.props.height;
      }
      if (_this.props.mediaControlFocus !== undefined) {
        _superPropGet((_this, Video), "setMediaControlFocus", _this, 3)([_this.props.mediaControlFocus, _this.props.overrideMediaControlHandler]).then(function () {
          _$$_REQUIRE(_dependencyMap[9]).LogUtil.info("Video: setMediaControlFocus is configured..");
        });
      } else {
        _$$_REQUIRE(_dependencyMap[9]).LogUtil.warn("Video: setMediaControlFocus is not configured..");
      }
      _this.initializeMediaPlayer().then(function () {
        _$$_REQUIRE(_dependencyMap[9]).LogUtil.info("Video: Media Player Initialized");
        _this.isMediaPlayerInitialized = true;
        _superPropGet((_this, Video), "onMediaPlayerInitialized", _this, 3)([]);
        // if surface was created before media player was initialized
        // pass the cached surface handle
        if (_this.surfaceHandle !== null) {
          _this.maybeSetSurface(_this.surfaceHandle);
        }
      });
      return _this;
    }
    /**
     * @hidden
     */
    _$$_REQUIRE(_dependencyMap[10])(Video, _Media_1$Media);
    return _$$_REQUIRE(_dependencyMap[11])(Video, [{
      key: "videoWidth",
      get: function get() {
        if (this.mediaPlayer_ !== null) {
          var videoPlayer = this.mediaPlayer_;
          return videoPlayer.videoWidth;
        } else {
          return NaN;
        }
      }
      /**
       * @hidden
       */
    }, {
      key: "videoHeight",
      get: function get() {
        if (this.mediaPlayer_ !== null) {
          var videoPlayer = this.mediaPlayer_;
          return videoPlayer.videoHeight;
        } else {
          return NaN;
        }
      }
      /**
       * @hidden
       */
    }, {
      key: "width",
      get:
      /**
       * @hidden
       */
      function get() {
        if (this.width_ !== undefined) {
          return this.width_;
        } else {
          return 0;
        }
      }
      /**
       * @hidden
       */,
      set: function set(w) {
        this.width_ = w;
      }
    }, {
      key: "height",
      get:
      /**
      * @hidden
      */
      function get() {
        if (this.height_ !== undefined) {
          return this.height_;
        } else {
          return 0;
        }
      }
      /**
       * @hidden
       */,
      set: function set(h) {
        this.height_ = h;
      }
    }, {
      key: "poster",
      get: function get() {
        return "emptyposter";
      }
      /**
       * @hidden
       */,
      set: function set(img) {
        this.poster_ = img;
      }
      /**
       * @hidden
       */
    }, {
      key: "playsInline",
      get: function get() {
        return true;
      }
      /**
       * @hidden
       */,
      set: function set(b) {
        // Video element is not expected to handle playsInline.
        // Main document element should handle this.
        // this.playsInline_ = b;
      }
      /**
       * @hidden
       */
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        _$$_REQUIRE(_dependencyMap[9]).LogUtil.info("Video: componentDidMount");
      }
      /**
       * @hidden
       */
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        _$$_REQUIRE(_dependencyMap[9]).LogUtil.info("Video: componentWillUnmount");
        this.destroyMediaPlayer().then(function () {
          _$$_REQUIRE(_dependencyMap[9]).LogUtil.info("Video: media player destroyed");
        });
      }
      /**
       * @hidden
       */
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        _$$_REQUIRE(_dependencyMap[9]).LogUtil.info("Video: componentDidUpdate");
        if (prevProps.src !== this.props.src) {
          if (this.props.src !== undefined) {
            _superPropSet(Video, "src", this.props.src, this, 1, 1);
          }
        }
        /* check if seek interval updated by app */
        if (prevProps.defaultSeekIntervalInSec !== this.props.defaultSeekIntervalInSec) {
          _superPropSet(Video, "defaultSeekIntervalInSec", this.props.defaultSeekIntervalInSec, this, 1, 1);
        }
      }
      /**
       * @hidden
       */
    }, {
      key: "onSurfaceMounted",
      value: function onSurfaceMounted() {
        _$$_REQUIRE(_dependencyMap[9]).LogUtil.info("Video: onSurfaceMounted");
      }
      /**
       * @hidden
       */
    }, {
      key: "onSurfaceUnmounted",
      value: function onSurfaceUnmounted() {
        _$$_REQUIRE(_dependencyMap[9]).LogUtil.info("Video: onSurfaceUnmounted");
      }
      /**
       * @hidden
       */
    }, {
      key: "maybeSetSurface",
      value: function maybeSetSurface(surfaceHandle) {
        _$$_REQUIRE(_dependencyMap[9]).LogUtil.info(`Video: maybeSetSurface: ${surfaceHandle}`);
        if (this.isMediaPlayerInitialized) {
          _$$_REQUIRE(_dependencyMap[9]).LogUtil.info(`maybeSetSurface: Media Player initialized.`);
          var videoPlayer = this.mediaPlayer_;
          videoPlayer.setSurfaceHandle(surfaceHandle);
        }
        // cache it
        this.surfaceHandle = surfaceHandle;
      }
      /**
       * @hidden
       */
    }, {
      key: "onSurfaceCreated",
      value: function onSurfaceCreated(surfaceHandle) {
        _$$_REQUIRE(_dependencyMap[9]).LogUtil.info(`Video: onSurfaceCreated: ${surfaceHandle}`);
        if (surfaceHandle.length > 0) {
          this.maybeSetSurface(surfaceHandle);
        }
      }
      /**
      * @hidden
      */
    }, {
      key: "onSurfaceDestroyed",
      value: function onSurfaceDestroyed(surfaceHandle) {
        _$$_REQUIRE(_dependencyMap[9]).LogUtil.info(`Video: onSurfaceDestroyed: ${surfaceHandle}`);
        if (this.mediaPlayer_ !== null) {
          var videoPlayer = this.mediaPlayer_;
          videoPlayer.clearSurfaceHandle(surfaceHandle);
        }
      }
      /**
       * @hidden
       */
    }, {
      key: "render",
      value: function render() {
        var _this$props$showCapti;
        _$$_REQUIRE(_dependencyMap[9]).LogUtil.info('render Video');
        return /*#__PURE__*/_$$_REQUIRE(_dependencyMap[12]).jsxs(react_native_1.View, {
          style: {
            width: this.width,
            height: this.height
          },
          children: [/*#__PURE__*/_$$_REQUIRE(_dependencyMap[12]).jsx(_$$_REQUIRE(_dependencyMap[13]).KeplerVideoSurfaceView, {
            style: {
              zIndex: 0
            },
            scalingmode: this.props.scalingmode,
            onComponentDidMount: this.onSurfaceMounted,
            onSurfaceViewCreated: this.onSurfaceCreated,
            onSurfaceViewDestroyed: this.onSurfaceDestroyed,
            onComponentWillUnmount: this.onSurfaceUnmounted
          }), /*#__PURE__*/_$$_REQUIRE(_dependencyMap[12]).jsx(_$$_REQUIRE(_dependencyMap[14]).KeplerCaptionsView, {
            onCaptionViewCreated: this.onCaptionViewCreated,
            show: (_this$props$showCapti = this.props.showCaptions) != null ? _this$props$showCapti : true,
            style: {
              width: '100%',
              height: '100%',
              top: 0,
              left: 0,
              position: 'absolute',
              backgroundColor: 'transparent',
              flexDirection: 'column',
              alignItems: 'center',
              zIndex: 2
            }
          }), this.props.controls ? /*#__PURE__*/_$$_REQUIRE(_dependencyMap[12]).jsx(MediaControls_1.default, {
            initFocus: true,
            mediaPlayer: this.mediaPlayer_,
            style: {
              zIndex: 2
            }
          }) : null]
        });
      }
      /**
       * @hidden
       */
    }, {
      key: "handleEvent",
      value: function handleEvent(event) {
        if (this.mediaPlayer_ !== null) {
          var videoPlayer = this.mediaPlayer_;
          videoPlayer.handleEvent(event);
        }
      }
      /**
       * @hidden
       * @brief Fetches video playback quality attributes.
       */
    }, {
      key: "getVideoPlaybackQuality",
      value: function getVideoPlaybackQuality() {
        if (this.mediaPlayer_ !== null) {
          var videoPlayer = this.mediaPlayer_;
          return videoPlayer.getVideoPlaybackQuality();
        }
        return new (_$$_REQUIRE(_dependencyMap[8]).VideoPlaybackQualityImpl)(Date.now(), NaN, NaN);
      }
      /**
       * @brief DeInitiailzes the player synchronously
       * @param timeoutInMs timeout threshold set by client
       * @returns MediaPlayerDeInitStatus
       */
    }, {
      key: "destroyMediaPlayerSync",
      value: function destroyMediaPlayerSync(timeoutInMs) {
        return _superPropGet(Video, "destroyMediaPlayerSync", this, 3)([timeoutInMs]);
      }
    }]);
  }(_$$_REQUIRE(_dependencyMap[15]).Media);
  exports.Video = Video;
  ;
},"9b23a320fef664e25c6c",["f391b9d534c3a6bc8659","4534eb96ece5e83c089a","0a5aa7067dba858ecaf2","ef4c2223f1078b78bd52","6ed0e34da2b23bd3554f","26ef620f86acf7f6932a","57cfca0008596c8d64b2","3508abd8c6b891008c0d","a87dff82c61137f9b60f","1f12e7e43345228dfcad","73afcd34a88a750f6d69","5533cec96f6a88041c69","048fed5a64a04bdb7fed","d280120de7a05ead75ef","0d9a17d8c6f7cb480e97","372fa0c50373b8a1a1df"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  function _callSuper(t, o, e) { return o = _$$_REQUIRE(_dependencyMap[0])(o), _$$_REQUIRE(_dependencyMap[1])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _$$_REQUIRE(_dependencyMap[0])(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  function _superPropGet(t, o, e, r) { var p = _$$_REQUIRE(_dependencyMap[2])(_$$_REQUIRE(_dependencyMap[0])(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VideoPlayer = exports.VideoPlaybackQualityImpl = undefined;
  /*
   * Copyright 2022-2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */

  var W3CMediaTurboModule_1 = __importDefault(_$$_REQUIRE(_dependencyMap[3]));
  var VideoPlaybackQualityImpl = /*#__PURE__*/function () {
    /**
     * @brief Constructor to create a video playback quality instance
     */
    function VideoPlaybackQualityImpl(creationTime, droppedVideoFrames, totalVideoFrames) {
      _$$_REQUIRE(_dependencyMap[4])(this, VideoPlaybackQualityImpl);
      this.creationTime_ = 0;
      this.droppedVideoFrames_ = 0;
      this.totalVideoFrames_ = 0;
      this.creationTime_ = creationTime;
      this.droppedVideoFrames_ = droppedVideoFrames;
      this.totalVideoFrames_ = totalVideoFrames;
    }
    return _$$_REQUIRE(_dependencyMap[5])(VideoPlaybackQualityImpl, [{
      key: "creationTime",
      get: function get() {
        return this.creationTime_;
      }
    }, {
      key: "droppedVideoFrames",
      get: function get() {
        return this.droppedVideoFrames_;
      }
    }, {
      key: "totalVideoFrames",
      get: function get() {
        return this.totalVideoFrames_;
      }
    }, {
      key: "corruptedVideoFrames",
      get: function get() {
        return NaN;
      }
    }]);
  }();
  exports.VideoPlaybackQualityImpl = VideoPlaybackQualityImpl;
  /** *
   * @brief VideoPlayer is a component that implements the `HTMLVideoElement` interface
   * that extends `HTMLMediaElement` interface.
   * @remarks This is a typescript class and not a react native component. Apps need
   * to create an instance of `VideoPlayer` and use it to start buffering the content
   * without rendering video on screen. It doesn't render video to the screen by
   *  default, nor does it render the media controls GUI. Apps are expected to build
   * their own media controls UI and control the playback experience. When the app
   * wants to show the video on screen, it must add `KeplerVideoSurfaceView` React
   * Native component to the render tree, receive `onSurfaceViewCreated` event and
   * pass the surface handle obtained in the event callback to `VideoPlayer` through
   * the `setSurfaceHandle` API.
   */
  var VideoPlayer = /*#__PURE__*/function (_MediaPlayer_1$MediaP) {
    /**
     * @brief Constructor to create a video player instance
     */
    function VideoPlayer() {
      var _this;
      _$$_REQUIRE(_dependencyMap[4])(this, VideoPlayer);
      _this = _callSuper(this, VideoPlayer, ["video", _$$_REQUIRE(_dependencyMap[6]).AudioContentType.CONTENT_TYPE_MOVIE, _$$_REQUIRE(_dependencyMap[6]).AudioUsageType.USAGE_MEDIA]);
      _this.videoWidth_ = 0;
      _this.videoHeight_ = 0;
      _this.width_ = undefined;
      _this.height_ = undefined;
      _this.poster_ = "";
      _this.playsInline_ = false;
      return _this;
    }
    /**
     * @brief Initiailzes the player.
     * Wait for the promise to be fulfilled before calling any other fucntion.
     * @returns Promise that is resolved when player is initialized..
     */
    _$$_REQUIRE(_dependencyMap[7])(VideoPlayer, _MediaPlayer_1$MediaP);
    return _$$_REQUIRE(_dependencyMap[5])(VideoPlayer, [{
      key: "initialize",
      value: function initialize() {
        return _superPropGet(VideoPlayer, "initialize", this, 3)([]);
      }
      /**
       * @brief DeInitiailzes the player.
       *
       * @returns Promise that is resolved when player is deInitialized.
       */
    }, {
      key: "deinitialize",
      value: function deinitialize() {
        return _superPropGet(VideoPlayer, "deinitialize", this, 3)([]);
      }
      /**
       * @brief DeInitiailzes the player synchronously
       * @param timeoutInMs time out threshold set by client to return the deinit control.
       * @returns MediaPlayerDeInitStatus
       */
    }, {
      key: "deinitializeSync",
      value: function deinitializeSync(timeoutInMs) {
        return _superPropGet(VideoPlayer, "deinitializeSync", this, 3)([timeoutInMs]);
      }
      /**
       * @hidden
       */
    }, {
      key: "videoWidth",
      get: function get() {
        return this.videoWidth_;
      }
      /**
       * @hidden
       */
    }, {
      key: "videoHeight",
      get: function get() {
        return this.videoHeight_;
      }
      /**
       * @hidden
       */
    }, {
      key: "width",
      get:
      /**
       * @hidden
       */
      function get() {
        if (this.width_ !== undefined) {
          return this.width_;
        } else {
          return 0;
        }
      }
      /**
       * @hidden
       */,
      set: function set(w) {
        this.width_ = w;
      }
    }, {
      key: "height",
      get:
      /**
      * @hidden
      */
      function get() {
        if (this.height_ !== undefined) {
          return this.height_;
        } else {
          return 0;
        }
      }
      /**
       * @hidden
       */,
      set: function set(h) {
        this.height_ = h;
      }
    }, {
      key: "poster",
      get: function get() {
        return this.poster_;
      }
      /**
       * @hidden
       */,
      set: function set(img) {
        this.poster_ = img;
      }
      /**
       * @hidden
       */
    }, {
      key: "playsInline",
      get: function get() {
        return this.playsInline_;
      }
      /**
       * @hidden
       */,
      set: function set(b) {
        // Video element is not expected to handle playsInline.
        // Main document element should handle this.
        this.playsInline_ = b;
      }
      /**
       * @brief setup the component instance with current mediaplayer being used and pass mediaControlHandler
       *        in case client wants to opt handling of mediacontrol commands.
       */
    }, {
      key: "setMediaControlFocus",
      value: function setMediaControlFocus(componentInstance, mediaControlHandler) {
        return _superPropGet(VideoPlayer, "setMediaControlFocus", this, 3)([componentInstance, mediaControlHandler]);
      }
      /**
       * @brief Sets the surface handle to which video is rendered.
       * @param[in] `surfaceHandle` The surface handle returned by the `onSurfaceViewCreated` event emitted
       * by `KeplerVideoSurfaceView` component.
       */
    }, {
      key: "setSurfaceHandle",
      value: function setSurfaceHandle(surfaceHandle) {
        _$$_REQUIRE(_dependencyMap[8]).LogUtil.info(`VideoPlayer: setSurfaceHandle: ${surfaceHandle}`);
        if (surfaceHandle !== null && surfaceHandle.length > 0) {
          this.surfaceHandle = surfaceHandle;
          if (this.mediaElement !== null) {
            W3CMediaTurboModule_1.default.setSurface(this.mediaElement, surfaceHandle);
          } else {
            _$$_REQUIRE(_dependencyMap[8]).LogUtil.warn(`VideoPlayer: mediaElement not available, hence only cached the surface`);
          }
        } else {
          _$$_REQUIRE(_dependencyMap[8]).LogUtil.error(`VideoPlayer: invalid surface passed to setSurfaceHandle`);
        }
      }
      /**
      * @brief Sets the surface handle to which video is rendered.
      * @param[in] `surfaceHandle` The surface handle returned by `onSurfaceViewCreated` event emitted
      * by `KeplerVideoSurfaceView` component.
      */
    }, {
      key: "clearSurfaceHandle",
      value: function clearSurfaceHandle(surfaceHandle) {
        _$$_REQUIRE(_dependencyMap[8]).LogUtil.info(`VideoPlayer: clearSurfaceHandle: ${surfaceHandle}`);
        if (this.surfaceHandle !== null && surfaceHandle === this.surfaceHandle) {
          if (this.mediaElement !== null) {
            W3CMediaTurboModule_1.default.clearSurface(this.mediaElement, this.surfaceHandle);
          } else {
            _$$_REQUIRE(_dependencyMap[8]).LogUtil.warn("MediaPlayer: media element not found...skipping reset surface");
          }
          this.surfaceHandle = null;
        }
      }
      /**
       * @hidden
       */
    }, {
      key: "handleEvent",
      value: function handleEvent(event) {
        switch (event.src) {
          case this.MEDIA_EVENT_SOURCE_HTMLMEDIAELEMENT:
            {
              // Check for resolution change.
              if ("resize" === event.name) {
                this.videoWidth_ = event.width;
                this.videoHeight_ = event.height;
              }
            }
            break;
          default:
            break;
        }
        _superPropGet(VideoPlayer, "handleEvent", this, 3)([event]);
      }
      /**
       * @brief Fetches video playback quality attributes.
       */
    }, {
      key: "getVideoPlaybackQuality",
      value: function getVideoPlaybackQuality() {
        var creationTime = NaN;
        var droppedVideoFrames = 0;
        var totalVideoFrames = 0;
        if (this.mediaElement !== null) {
          var result = W3CMediaTurboModule_1.default.getVideoPlaybackQuality(this.mediaElement);
          creationTime = Date.now();
          droppedVideoFrames = result.droppedVideoFrames;
          totalVideoFrames = result.totalVideoFrames;
        }
        return new VideoPlaybackQualityImpl(creationTime, droppedVideoFrames, totalVideoFrames);
      }
    }]);
  }(_$$_REQUIRE(_dependencyMap[9]).MediaPlayer);
  exports.VideoPlayer = VideoPlayer;
  ;
},"a87dff82c61137f9b60f",["f391b9d534c3a6bc8659","4534eb96ece5e83c089a","ef4c2223f1078b78bd52","0814a269c2fb50034991","3508abd8c6b891008c0d","5533cec96f6a88041c69","4bdd62aa245a27756882","73afcd34a88a750f6d69","1f12e7e43345228dfcad","afef45745b99fd25fb6a"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2022 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.W3CLibPolyfill = undefined;
  // polyfils
  var W3CLibPolyfill = /*#__PURE__*/function () {
    function W3CLibPolyfill() {
      _$$_REQUIRE(_dependencyMap[0])(this, W3CLibPolyfill);
    }
    return _$$_REQUIRE(_dependencyMap[1])(W3CLibPolyfill, null, [{
      key: "install",
      value: function install() {
        _$$_REQUIRE(_dependencyMap[2]).LogUtil.info("xpoly installing W3CLib poly fill {} {} ");
        // TODO: using node in tsconfig.json fails compilation in yocto. 
        // If we tried to fix it, DRM playback doesn't happen. Needs more deep dive.
        // Temporarily moving these polyfills back to app
        // (global as any).navigator.requestMediaKeySystemAccess = requestMediaKeySystemAccess;
        _$$_REQUIRE(_dependencyMap[3]).MediaSource.install();
      }
    }]);
  }();
  exports.W3CLibPolyfill = W3CLibPolyfill;
},"34a672321d3ccd75ade3",["3508abd8c6b891008c0d","5533cec96f6a88041c69","1f12e7e43345228dfcad","559b56212f65a51c1441"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2023 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.WebCrypto = undefined;
  var W3CMediaTurboModule_1 = __importDefault(_$$_REQUIRE(_dependencyMap[0]));
  var WebCrypto = /*#__PURE__*/function () {
    function WebCrypto() {
      _$$_REQUIRE(_dependencyMap[1])(this, WebCrypto);
    }
    return _$$_REQUIRE(_dependencyMap[2])(WebCrypto, null, [{
      key: "randomUUID",
      value: function randomUUID() {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info("WebCrypto::randomUUID ++");
        return W3CMediaTurboModule_1.default.randomUUID();
      }
    }]);
  }();
  WebCrypto.subtle = /*#__PURE__*/function () {
    function _class() {
      _$$_REQUIRE(_dependencyMap[1])(this, _class);
    }
    return _$$_REQUIRE(_dependencyMap[2])(_class, null, [{
      key: "importKey",
      value: function () {
        var _importKey = _$$_REQUIRE(_dependencyMap[4])(function* (format, data, algorithm, extractable, keyUsages) {
          // Only 'raw' format is implemented.
          return new Promise(function (resolve, reject) {
            var key;
            var keyData;
            // take deep copy of the Key as per WebCrypto spec
            // Refer: (Point 2.2)
            // https://www.w3.org/TR/WebCryptoAPI/#dfn-SubtleCrypto-method-importKey
            if (data instanceof ArrayBuffer) {
              keyData = new Uint8Array(data).buffer;
              key = data;
            } else if (data instanceof Uint8Array || data instanceof DataView) {
              keyData = new Uint8Array(data.buffer).buffer;
              key = data.buffer;
            } else {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.error("WebCrypto::importKey(): data type error");
              reject();
            }
            var keyObj = W3CMediaTurboModule_1.default.importKey(format, keyData, algorithm, extractable, keyUsages);
            // At present, there is no native equivalent of
            // adding Array in JSONObject, so assigning key and usages here.
            if (extractable) {
              keyObj.key = key;
            }
            keyObj.usages = keyUsages;
            keyObj.algorithm = algorithm;
            var result = keyObj;
            if (result.usages.length >= 1) {
              resolve(result);
              return;
            }
            reject();
          });
        });
        function importKey(_x, _x2, _x3, _x4, _x5) {
          return _importKey.apply(this, arguments);
        }
        return importKey;
      }()
    }, {
      key: "decrypt",
      value: function () {
        var _decrypt = _$$_REQUIRE(_dependencyMap[4])(function* (algorithm, key, data) {
          return new Promise(function (resolve, reject) {
            if (algorithm === undefined || key === undefined || algorithm.name !== "AES-CTR" && algorithm.iv === undefined && key.algorithm.iv === undefined || algorithm.name === "AES-CTR" && algorithm.counter === undefined && key.algorithm.counter === undefined || data === undefined) {
              _$$_REQUIRE(_dependencyMap[3]).LogUtil.error("WebCrypto::decrypt invalid data passed");
              reject();
            }
            var ivCounterArray;
            if (algorithm.name === "AES-CTR") {
              if (algorithm.counter instanceof ArrayBuffer) {
                ivCounterArray = algorithm.counter;
              } else {
                if (algorithm.counter.byteOffset == 0 && algorithm.counter.byteLength == algorithm.counter.buffer.byteLength) {
                  // This is a TypedArray over the whole buffer.
                  ivCounterArray = algorithm.counter.buffer;
                } else {
                  // This is a "view" on the buffer.  Create a new buffer that only contains
                  // the data.  Note that since this isn't an ArrayBuffer, the "new" call
                  // will allocate a new buffer to hold the copy.
                  ivCounterArray = new Uint8Array(algorithm.counter.buffer).buffer;
                }
              }
            } else {
              if (algorithm.iv instanceof ArrayBuffer) {
                ivCounterArray = algorithm.iv;
              } else {
                if (algorithm.iv.byteOffset == 0 && algorithm.iv.byteLength == algorithm.iv.buffer.byteLength) {
                  // This is a TypedArray over the whole buffer.
                  ivCounterArray = algorithm.iv.buffer;
                } else {
                  // This is a "view" on the buffer.  Create a new buffer that only contains
                  // the data.  Note that since this isn't an ArrayBuffer, the "new" call
                  // will allocate a new buffer to hold the copy.
                  ivCounterArray = new Uint8Array(algorithm.iv.buffer).buffer;
                }
              }
            }
            // Copy ivArray to CryptoKey
            key.algorithm.iv = ivCounterArray;
            var plainData = W3CMediaTurboModule_1.default.decrypt(key.algorithm, key, ivCounterArray, data);
            if (plainData.byteLength >= 1) {
              resolve(plainData);
              return;
            }
            _$$_REQUIRE(_dependencyMap[3]).LogUtil.error("WebCrypto::decrypt Errored out");
            reject();
          });
        });
        function decrypt(_x6, _x7, _x8) {
          return _decrypt.apply(this, arguments);
        }
        return decrypt;
      }()
    }]);
  }();
  exports.WebCrypto = WebCrypto;
},"afece82566356eb3a892",["0814a269c2fb50034991","3508abd8c6b891008c0d","5533cec96f6a88041c69","1f12e7e43345228dfcad","ff7d8d645536d793bbec"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TextDecoder = undefined;
  /*
   * Copyright 2022-2023 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  var W3CMediaTurboModule_1 = __importDefault(_$$_REQUIRE(_dependencyMap[0]));
  var TextDecoder = /*#__PURE__*/function () {
    function TextDecoder() {
      _$$_REQUIRE(_dependencyMap[1])(this, TextDecoder);
    }
    return _$$_REQUIRE(_dependencyMap[2])(TextDecoder, [{
      key: "decode",
      value: function decode(data) {
        _$$_REQUIRE(_dependencyMap[3]).LogUtil.info('Custom TextDecoder in lib');
        var textData;
        if (data instanceof ArrayBuffer) {
          textData = data;
        } else if (data instanceof Uint8Array) {
          textData = data.buffer;
        }
        return W3CMediaTurboModule_1.default.textDecode(textData);
      }
    }]);
  }();
  exports.TextDecoder = TextDecoder;
},"3b51620f399f61cbe14a",["0814a269c2fb50034991","3508abd8c6b891008c0d","5533cec96f6a88041c69","1f12e7e43345228dfcad"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2024-2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MediaCapabilitiesImpl = exports.decodingInfo = undefined;
  function decodingInfo(config) {
    _$$_REQUIRE(_dependencyMap[0]).LogUtil.debug("decodingInfo++");
    var impl = new MediaCapabilitiesImpl();
    _$$_REQUIRE(_dependencyMap[0]).LogUtil.debug("calling into w3c decodingInfo with ", config);
    var res = new Promise(function (_, reject) {
      reject(new TypeError('default reject'));
    });
    try {
      res = impl.decodingInfo(config);
    } catch (error) {
      _$$_REQUIRE(_dependencyMap[0]).LogUtil.debug("caught error ", error);
    }
    _$$_REQUIRE(_dependencyMap[0]).LogUtil.debug("decodingInfo--");
    return res;
  }
  exports.decodingInfo = decodingInfo;
  var MediaCapabilitiesImpl = /*#__PURE__*/function () {
    function MediaCapabilitiesImpl() {
      _$$_REQUIRE(_dependencyMap[1])(this, MediaCapabilitiesImpl);
    }
    return _$$_REQUIRE(_dependencyMap[2])(MediaCapabilitiesImpl, [{
      key: "decodingInfo",
      value: function () {
        var _decodingInfo = _$$_REQUIRE(_dependencyMap[3])(function* (configuration) {
          var _configuration$video, _configuration$video$;
          _$$_REQUIRE(_dependencyMap[0]).LogUtil.debug("decodingInfoImpl++");
          // allow the unknown mime types from shaka
          if ((configuration == null ? undefined : (_configuration$video = configuration.video) == null ? undefined : (_configuration$video$ = _configuration$video.contentType) == null ? undefined : _configuration$video$.localeCompare(_$$_REQUIRE(_dependencyMap[4]).UNKNOWN_SHAKA_MIME)) === 0) {
            var _result = new (_$$_REQUIRE(_dependencyMap[5]).MediaCapabilitiesDecodingInfoImpl)(configuration);
            return new Promise(function (resolve, _) {
              resolve(_result);
            });
          }
          // 1.  If configuration is not a valid MediaDecodingConfiguration, return a Promise rejected with a newly
          //     created TypeError.
          if (!this.isValidDecodingConfiguration(configuration)) {
            _$$_REQUIRE(_dependencyMap[0]).LogUtil.error("decodingInfoImpl invalid config");
            return new Promise(function (_, reject) {
              reject(new TypeError('configuration is not a valid MediaDecodingConfiguration'));
            });
          }
          // Note: Skipping the global object checks in 2.1 and 2.2
          // 3. Let p be a new promise.
          var result = yield this.createMediaCapabilitiesDecodingInfo(configuration);
          var p = new Promise(function (resolve, reject) {
            // 4. In parallel, run the Create a MediaCapabilitiesDecodingInfo algorithm with configuration and resolve
            //    p with its result.
            resolve(result);
          });
          _$$_REQUIRE(_dependencyMap[0]).LogUtil.debug("decodingInfoImpl--");
          // 5. Return p.
          return p;
        });
        function decodingInfo(_x) {
          return _decodingInfo.apply(this, arguments);
        }
        return decodingInfo;
      }()
    }, {
      key: "isValidDecodingConfiguration",
      value: function isValidDecodingConfiguration(configuration) {
        _$$_REQUIRE(_dependencyMap[0]).LogUtil.debug("isValidDecodingConfiguration++");
        // 1. It MUST be a valid MediaConfiguration.
        if (configuration === undefined) {
          _$$_REQUIRE(_dependencyMap[0]).LogUtil.error("configuration is undefined");
          return false;
        }
        if (!this.isValidMediaConfigurationForDecoding(configuration, configuration.type)) {
          _$$_REQUIRE(_dependencyMap[0]).LogUtil.error("isValidMediaConfigurationForDecoding failed");
          return false;
        }
        if (configuration.keySystemConfiguration !== undefined) {
          // 2.  If keySystemConfiguration exists:
          // 2.1  The type MUST be media-source or file.
          if (!(configuration.type === "file") && !(configuration.type === "media-source")) {
            _$$_REQUIRE(_dependencyMap[0]).LogUtil.error("config type is not valid when keySystemConfiguration exists");
            return false;
          }
          // 2.2  If keySystemConfiguration.audio exists, audio MUST also exist.
          if (configuration.keySystemConfiguration.audio !== undefined && configuration.audio === undefined) {
            _$$_REQUIRE(_dependencyMap[0]).LogUtil.error("If keySystemConfiguration.audio exists, audio MUST also exist.");
            return false;
          }
          // 2.3  If keySystemConfiguration.video exists, video MUST also exist.
          if (configuration.keySystemConfiguration.video !== undefined && configuration.video === undefined) {
            _$$_REQUIRE(_dependencyMap[0]).LogUtil.error("If keySystemConfiguration.video exists, video MUST also exist.");
            return false;
          }
        }
        _$$_REQUIRE(_dependencyMap[0]).LogUtil.debug("isValidDecodingConfiguration--");
        return true;
      }
    }, {
      key: "isValidMediaConfigurationForDecoding",
      value: function isValidMediaConfigurationForDecoding(configuration, type) {
        if (!configuration.video && !configuration.audio) {
          // 1. audio and/or video MUST exist.
          _$$_REQUIRE(_dependencyMap[0]).LogUtil.error("audio and/or video MUST exist.");
          return false;
        }
        if (configuration.video) {
          // 1. If configurations contentType is not a valid video MIME type, return false and abort these steps.
          if (!this.isValidMimeType(configuration.video.contentType, true)) {
            _$$_REQUIRE(_dependencyMap[0]).LogUtil.error("Mime type should be valid: ", configuration.video.contentType);
            return false;
          }
          // 2. If framerate is not finite or is not greater than 0, return false and abort these steps.
          if (!Number.isFinite(configuration.video.framerate) || configuration.video.framerate <= 0) {
            _$$_REQUIRE(_dependencyMap[0]).LogUtil.error("framerate should be finite");
            return false;
          }
          // 3. If an optional member is specified for a MediaDecodingType or MediaEncodingType to which its not
          //    applicable, return false and abort these steps.
          if (configuration.video.hdrMetadataType !== undefined) {
            if (!(configuration.video.hdrMetadataType === "smpteSt2086") && !(configuration.video.hdrMetadataType === "smpteSt2094-10") && !(configuration.video.hdrMetadataType === "smpteSt2094-40")) {
              _$$_REQUIRE(_dependencyMap[0]).LogUtil.error("Invalid hdrMetadataType passed ", configuration.video.hdrMetadataType);
              return false;
            }
            // hdrMetadataType is only applicable to MediaDecodingConfiguration for types media-source and file.
            if (!(type === "file") && !(type === "media-source")) {
              _$$_REQUIRE(_dependencyMap[0]).LogUtil.error("hdrMetadataType is only applicable to MediaDecodingConfiguration for types media-source and file");
              return false;
            }
          }
          if (configuration.video.colorGamut !== undefined) {
            if (!(configuration.video.colorGamut === "srgb") && !(configuration.video.colorGamut === "p3") && !(configuration.video.colorGamut === "rec2020")) {
              _$$_REQUIRE(_dependencyMap[0]).LogUtil.error("Invalid colorGamut passed ", configuration.video.colorGamut);
              return false;
            }
            // colorGamut is only applicable to MediaDecodingConfiguration for types media-source and file.
            if (!(type === "file") && !(type === "media-source")) {
              _$$_REQUIRE(_dependencyMap[0]).LogUtil.error("colorGamut is only applicable to MediaDecodingConfiguration for types media-source and file");
              return false;
            }
          }
          if (configuration.video.transferFunction !== undefined) {
            if (!(configuration.video.transferFunction === "srgb") && !(configuration.video.transferFunction === "pq") && !(configuration.video.transferFunction === "hlg")) {
              _$$_REQUIRE(_dependencyMap[0]).LogUtil.error("Invalid transferFunction passed ", configuration.video.transferFunction);
              return false;
            }
            // transferFunction is only applicable to MediaDecodingConfiguration for types media-source and file.
            if (!(type === "file") && !(type === "media-source")) {
              _$$_REQUIRE(_dependencyMap[0]).LogUtil.error("transferFunction is only applicable to MediaDecodingConfiguration for types media-source and file");
              return false;
            }
          }
          if (configuration.video.scalabilityMode !== undefined) {
            // scalabilityMode is only applicable to MediaEncodingConfiguration for type webrtc.
            _$$_REQUIRE(_dependencyMap[0]).LogUtil.error("scalabilityMode is only applicable to MediaDecodingConfiguration for types webrtc");
            return false;
          }
          if (configuration.video.spatialScalability !== undefined) {
            // spatialScalability is only applicable to MediaDecodingConfiguration for types media-source, file and webrtc.
            if (!(type === "file") && !(type === "media-source") && !(type === "webrtc")) {
              _$$_REQUIRE(_dependencyMap[0]).LogUtil.error("spatialScalability is only applicable to MediaDecodingConfiguration for types media-source, file and webrtc");
              return false;
            }
          }
        }
        if (configuration.audio) {
          //  If configurations contentType is not a valid audio MIME type, return false and abort these steps.
          if (!this.isValidMimeType(configuration.audio.contentType, false)) {
            _$$_REQUIRE(_dependencyMap[0]).LogUtil.error("invalid audio mime type ", configuration.audio.contentType);
            return false;
          }
        }
        return true;
      }
    }, {
      key: "isValidMimeType",
      value: function isValidMimeType(mime, isVideo) {
        // mime type examples:
        // 'video/mp4;codecs=avc1.640028'
        // 'video/VP8'
        // 'video/H264;level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f'
        // 'video/VP9'
        // 'video/webm;codecs=vp8'
        var mimeType = _$$_REQUIRE(_dependencyMap[6]).MimeType.parseMimeString(mime);
        if (mimeType === null) {
          return false;
        }
        // A valid video MIME type is a string that is a valid media MIME type and for which the type per [RFC9110] is either video or application.
        if (isVideo && !(mimeType.type === "application" || mimeType.type === "video")) {
          return false;
        }
        //  A valid audio MIME type is a string that is a valid media MIME type and for which the type per [RFC9110] is either audio or application.
        if (!isVideo && !(mimeType.type === "application" || mimeType.type === "audio")) {
          return false;
        }
        var container = "";
        if (isVideo && (0, _$$_REQUIRE(_dependencyMap[7]).checkSupportedVideoContainers)(mimeType.essence)) {
          container = mimeType.essence;
        }
        if (!isVideo && (0, _$$_REQUIRE(_dependencyMap[7]).checkSupportedAudioContainers)(mimeType.essence)) {
          container = mimeType.essence;
        }
        // 2.1.4.1 If the MIME type does not imply a codec, the string MUST also have one and only one parameter that is named codecs
        //         with a value describing a single media codec. Otherwise, it MUST contain no parameters.
        var codecInfo = this.parseMimeForCodecType(mimeType, container);
        if (container !== "" || mimeType.type === "application") {
          var paramLength = mimeType.getParameterCount();
          if (paramLength > 1) {
            return false;
          }
          if (paramLength === 1 && codecInfo === undefined) {
            return false;
          }
          if (isVideo && codecInfo.codec.startsWith("audio")) {
            return false;
          }
          if (!isVideo && codecInfo.codec.startsWith("video")) {
            return false;
          }
        }
        if (isVideo) {
          this.mVideoMimeType = mimeType;
          this.mVideoContainerString = container;
        } else {
          this.mAudioMimeType = mimeType;
          this.mAudioContainerString = container;
        }
        return true;
      }
    }, {
      key: "parseMimeForCodecType",
      value: function parseMimeForCodecType(mimeType, container) {
        var hdrMetadataType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
        var codecStr = mimeType.getParameter("codecs");
        if (codecStr === undefined) {
          // we dont have the codecs parameter in the mime,
          // all we can do is to get the subtype and see if its a codec.
          if (container.length > 0) {
            // this is a container type, this doesnt help us.
            _$$_REQUIRE(_dependencyMap[0]).LogUtil.error("we dont have a \"codecs\" parameter in the mime and the type is container");
            return undefined;
          }
          // TODO: now we have a "video/h264" type use case. At least for h264,
          // profile-level-id should be used for profile/level info. Add this support.
        }
        // TODO: do we want to match the container and codec combo using MimeTypeRegistry?
        codecStr = (0, _$$_REQUIRE(_dependencyMap[7]).removeLeadingAndTrailingHTTPWhitespace)(codecStr);
        var info = (0, _$$_REQUIRE(_dependencyMap[8]).parseCodecMime)(codecStr, hdrMetadataType);
        return info;
      }
    }, {
      key: "parseChannelCountStr",
      value: function parseChannelCountStr(channelCountStr) {
        _$$_REQUIRE(_dependencyMap[0]).LogUtil.debug("parseChannelCountStr++ ", channelCountStr, " type: ", typeof channelCountStr);
        // 5.1.1 should be 7
        var channelArr = channelCountStr.toString().split('.');
        var totalChannels = 0;
        for (var index = 0; index < channelArr.length; index++) {
          var num = Number(channelArr[index]);
          if (Number.isNaN(num)) {
            return undefined;
          }
          totalChannels += num;
        }
        _$$_REQUIRE(_dependencyMap[0]).LogUtil.debug("parseChannelCountStr-- ", totalChannels);
        return totalChannels;
      }
    }, {
      key: "createMediaCapabilitiesDecodingInfo",
      value: function () {
        var _createMediaCapabilitiesDecodingInfo = _$$_REQUIRE(_dependencyMap[3])(function* (configuration) {
          //  1. Let info be a new MediaCapabilitiesDecodingInfo instance. Unless stated otherwise,
          //     reading and writing apply to info for the next steps.
          // 2.  Set configuration to be a new MediaDecodingConfiguration. For every property in configuration create a new property with the same name and value in configuration.
          var info = new (_$$_REQUIRE(_dependencyMap[5]).MediaCapabilitiesDecodingInfoImpl)(configuration);
          // 3.  If configuration.keySystemConfiguration exists:
          if (configuration.keySystemConfiguration !== undefined) {
            // 3.1  Set keySystemAccess to the result of running the Check Encrypted Decoding Support algorithm with configuration.
            info.keySystemAccess = yield (0, _$$_REQUIRE(_dependencyMap[9]).checkEncryptedDecodingsupport)(configuration);
            // 3.2  If keySystemAccess is not null set supported to true. Otherwise set it to false.
            info.supported = info.keySystemAccess !== null;
          } else {
            // 4.1 Set keySystemAccess to null.
            info.keySystemAccess = null;
          }
          // 4.2  If the user agent is able to decode the media represented by configuration, set supported to true.
          // if we dont have audio config itself then default to true.
          var audioSupported = configuration.audio ? false : true;
          if (configuration.audio) {
            audioSupported = yield this.checkAudioDecodingSuport(configuration);
          }
          // if we dont have video config itself then default to true.
          var videoSupported = configuration.video ? false : true;
          // we have already set the fps before querying the TM, so all the caps returned
          // support the provided fps.
          info.smooth = videoSupported;
          if (configuration.video) {
            var caps = yield this.checkVideoDecodingSuport(configuration);
            videoSupported = caps.length > 0;
            for (var cap of caps) {
              if (cap.mediaCodecFeaturesCapabilities.hardwareBacked) {
                info.powerEfficient = true;
                break;
              }
            }
          }
          if (configuration.keySystemConfiguration === undefined) {
            // 4.3 Otherwise, set it to false.
            info.supported = audioSupported && videoSupported;
          }
          return info;
        });
        function createMediaCapabilitiesDecodingInfo(_x2) {
          return _createMediaCapabilitiesDecodingInfo.apply(this, arguments);
        }
        return createMediaCapabilitiesDecodingInfo;
      }()
    }, {
      key: "checkAudioDecodingSuport",
      value: function () {
        var _checkAudioDecodingSuport = _$$_REQUIRE(_dependencyMap[3])(function* (config) {
          var decoderConfig = new (_$$_REQUIRE(_dependencyMap[10]).AudioDecoderConfig)();
          var codecInfo = this.parseMimeForCodecType(this.mAudioMimeType, this.mAudioContainerString);
          if (codecInfo !== undefined) {
            // TODO: check the compatibility with the container?
            var mediaFormat = new (_$$_REQUIRE(_dependencyMap[10]).MediaFormat)(codecInfo.codec);
            decoderConfig.mediaFormat = mediaFormat;
          }
          var audioFormat = new (_$$_REQUIRE(_dependencyMap[10]).AudioFormat)();
          audioFormat.channelCount = this.parseChannelCountStr(config.audio.channels);
          audioFormat.sampleRate = config.audio.samplerate;
          decoderConfig.audioFormat = audioFormat;
          if (config.audio.spatialRendering) {
            // TODO: check the mime type and call into audio system for support.
            // We only have eac3-joc support for now. So the mime passed should
            // match this and audio TM should say this is supported.
          }
          _$$_REQUIRE(_dependencyMap[0]).LogUtil.debug("audio decoder config before query is ", decoderConfig);
          var caps = yield _$$_REQUIRE(_dependencyMap[10]).KeplerMediaDescriptor.queryMediaCapabilities(decoderConfig);
          return caps.length > 0;
        });
        function checkAudioDecodingSuport(_x3) {
          return _checkAudioDecodingSuport.apply(this, arguments);
        }
        return checkAudioDecodingSuport;
      }()
    }, {
      key: "checkVideoDecodingSuport",
      value: function () {
        var _checkVideoDecodingSuport = _$$_REQUIRE(_dependencyMap[3])(function* (config) {
          var _codecInfo$color_spac, _codecInfo$color_spac2, _codecInfo$color_spac3;
          var decoderConfig = new (_$$_REQUIRE(_dependencyMap[10]).VideoDecoderConfig)();
          var codecStr = this.mVideoMimeType.getParameter("codecs");
          codecStr = (0, _$$_REQUIRE(_dependencyMap[7]).removeLeadingAndTrailingHTTPWhitespace)(codecStr);
          var profileLevel = new (_$$_REQUIRE(_dependencyMap[10]).MediaFormatProfileLevel)(codecStr);
          var codecInfo = this.parseMimeForCodecType(this.mVideoMimeType, this.mVideoContainerString, config.video.hdrMetadataType ? "" : config.video.hdrMetadataType);
          if (codecInfo !== undefined) {
            // TODO: check the compatibility with the container
            var mediaFormat = new (_$$_REQUIRE(_dependencyMap[10]).MediaFormat)(codecInfo.codec);
            mediaFormat.bitrateKbps = config.video.bitrate / 1024; // decoding info bitrate is in bps.
            decoderConfig.mediaFormat = mediaFormat;
            if (codecInfo.profile !== undefined && codecInfo.level !== undefined) {
              profileLevel.profileLevel = {
                profile: codecInfo.profile,
                level: codecInfo.level
              };
            }
          }
          var videoFormat = new (_$$_REQUIRE(_dependencyMap[10]).VideoFormat)();
          videoFormat.resolution = {
            width: config.video.width,
            height: config.video.height
          };
          videoFormat.colorPrimaries = codecInfo == null ? undefined : (_codecInfo$color_spac = codecInfo.color_space) == null ? undefined : _codecInfo$color_spac.primaries;
          videoFormat.colorTransfer = codecInfo == null ? undefined : (_codecInfo$color_spac2 = codecInfo.color_space) == null ? undefined : _codecInfo$color_spac2.transfer;
          videoFormat.colorMatrix = codecInfo == null ? undefined : (_codecInfo$color_spac3 = codecInfo.color_space) == null ? undefined : _codecInfo$color_spac3.matrix;
          videoFormat.frameRate = config.video.framerate;
          if (config.video.colorGamut !== undefined) {
            if (config.video.colorGamut === "srgb") {
              // nothing to do, since all codecs and displays support this by default.
              // TODO: confirm this behavior. Also IDL doesnt have BT601, it only has 709.
            } else if (config.video.colorGamut === "p3") {
              videoFormat.colorPrimaries = _$$_REQUIRE(_dependencyMap[10]).VideoColorPrimaries.SMPTE_ST4321;
            } else if (config.video.colorGamut === "rec2020") {
              videoFormat.colorPrimaries = _$$_REQUIRE(_dependencyMap[10]).VideoColorPrimaries.BT2020;
            }
          }
          if (config.video.transferFunction !== undefined) {
            if (config.video.transferFunction === "srgb") {
              // nothing to do, since all codecs and displays support this by default.
              // TODO: confirm this behavior. If we need to do something we need to use IEC_61966_2_1 instead of 709.
            } else if (config.video.transferFunction === "hlg") {
              videoFormat.colorTransfer = _$$_REQUIRE(_dependencyMap[10]).VideoColorTransfer.HLG;
            } else if (config.video.transferFunction === "pq") {
              videoFormat.colorTransfer = _$$_REQUIRE(_dependencyMap[10]).VideoColorTransfer.SMPTE_BT2100_PQ;
            }
          }
          decoderConfig.videoFormat = videoFormat;
          decoderConfig.formatProfileLevel = profileLevel;
          _$$_REQUIRE(_dependencyMap[0]).LogUtil.debug("video decoder config before query is ", decoderConfig);
          var caps = yield _$$_REQUIRE(_dependencyMap[10]).KeplerMediaDescriptor.queryMediaCapabilities(decoderConfig);
          return caps;
        });
        function checkVideoDecodingSuport(_x4) {
          return _checkVideoDecodingSuport.apply(this, arguments);
        }
        return checkVideoDecodingSuport;
      }()
    }]);
  }();
  exports.MediaCapabilitiesImpl = MediaCapabilitiesImpl;
},"1c87679747a7f044c554",["1f12e7e43345228dfcad","3508abd8c6b891008c0d","5533cec96f6a88041c69","ff7d8d645536d793bbec","5276f25b9cfa3ba46e9e","299287bab4aa6b141a4f","51ba9e69d25f63defe5f","7c24a30d9976d826af0f","76e94d9cb88d077fdd92","f0a57f93b4cb7ac3f6cb","87c1deaf4e092124fc7a"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MediaCapabilitiesDecodingInfoImpl = undefined;
  var MediaCapabilitiesDecodingInfoImpl = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[0])(function MediaCapabilitiesDecodingInfoImpl(config) {
    _$$_REQUIRE(_dependencyMap[1])(this, MediaCapabilitiesDecodingInfoImpl);
    this.keySystemAccess = null;
    this.configuration = config;
    this.supported = false;
    this.smooth = false;
    this.powerEfficient = false;
  });
  exports.MediaCapabilitiesDecodingInfoImpl = MediaCapabilitiesDecodingInfoImpl;
},"299287bab4aa6b141a4f",["5533cec96f6a88041c69","3508abd8c6b891008c0d"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2025 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.checkEncryptedDecodingsupport = undefined;
  var knownRobustnessLevels = ["SECURE", "NON-SECURE", "HW_SECURE_ALL", "SW_SECURE_CRYPTO", "SW_SECURE_DECODE", "HW_SECURE_CRYPTO", "HW_SECURE_DECODE", "2000", "3000", "150"];
  /**
   * Given a @type {MediaDecodingConfiguration} where @type {keySystemConfiguration}
   * exists, this algorithm returns a @type {MediaKeySystemAccess} or null as appropriate.
   * @param config @type {MediaDecodingConfiguration}
   * @returns @type {MediaKeySystemAccess} or null
   */
  function checkEncryptedDecodingsupport(_x) {
    return _checkEncryptedDecodingsupport.apply(this, arguments);
  }
  function _checkEncryptedDecodingsupport() {
    _checkEncryptedDecodingsupport = _$$_REQUIRE(_dependencyMap[0])(function* (config) {
      _$$_REQUIRE(_dependencyMap[1]).LogUtil.debug("checkEncryptedDecodingsupport++");
      // https://www.w3.org/TR/media-capabilities/#check-encrypted-decoding-support
      if (!config.keySystemConfiguration) {
        _$$_REQUIRE(_dependencyMap[1]).LogUtil.error("checkEncryptedDecodingsupport: keySystemConfiguration is null");
        return null;
      }
      // 1. If the keySystem member of config.keySystemConfiguration is not one of the Key Systems
      //    supported by the user agent, return null. String comparison is case-sensitive.
      // Note: we are not checking this here, but when we call the requestMediaKeySystemAccess fn
      // 2. Let origin be the origin of the calling contexts Document.
      // TODO: should we really do this?
      // 3. Let implementation be the implementation of config.keySystemConfiguration.keySystem
      // TODO: Is this applicable for us?
      // 4. Let emeConfiguration be a new MediaKeySystemConfiguration, and initialize it as follows:
      var emeConfiguration = {};
      // 4.1 Set the initDataTypes attribute to a sequence containing config.keySystemConfiguration.initDataType.
      emeConfiguration.initDataTypes = [config.keySystemConfiguration.initDataType];
      // 4.2 Set the distinctiveIdentifier attribute to config.keySystemConfiguration.distinctiveIdentifier.
      emeConfiguration.distinctiveIdentifier = config.keySystemConfiguration.distinctiveIdentifier;
      // 4.3  Set the persistentState attribute to config.keySystemConfiguration.persistentState.
      emeConfiguration.persistentState = config.keySystemConfiguration.persistentState;
      // 4.4  Set the sessionTypes attribute to config.keySystemConfiguration.sessionTypes.
      emeConfiguration.sessionTypes = [];
      for (var index = 0; index < config.keySystemConfiguration.sessionTypes.length; index++) {
        var typeStr = config.keySystemConfiguration.sessionTypes[index];
        if (typeStr === "temporary" || typeStr === "persistent-license") {
          emeConfiguration.sessionTypes.push(typeStr);
        }
      }
      // 4.5  If audio exists in config, set the audioCapabilities attribute to a sequence containing a
      //      single MediaKeySystemMediaCapability, initialized as follows:
      if (config.audio !== undefined) {
        _$$_REQUIRE(_dependencyMap[1]).LogUtil.debug("audio is valid");
        var keyCap = {
          contentType: "",
          robustness: "NON-SECURE"
        };
        // 4.5.1  Set the contentType attribute to config.audio.contentType.
        keyCap.contentType = config.audio.contentType;
        _$$_REQUIRE(_dependencyMap[1]).LogUtil.debug("config.keySystemConfiguration.audio is ", config.keySystemConfiguration.audio);
        //  4.5.2 If config.keySystemConfiguration.audio exists:
        if (config.keySystemConfiguration.audio !== undefined) {
          // 4.5.2.1 Set the robustness attribute to config.keySystemConfiguration.audio.robustness
          var audioRobustness = config.keySystemConfiguration.audio.robustness;
          if (knownRobustnessLevels.includes(audioRobustness)) {
            keyCap.robustness = audioRobustness;
          }
          // 4.5.2.2 Set the encryptionScheme attribute to config.keySystemConfiguration.audio.encryptionScheme
          keyCap.encryptionScheme = config.keySystemConfiguration.audio.encryptionScheme;
        }
        emeConfiguration.audioCapabilities = [keyCap];
      }
      // 4.6  If video exists in config, set the videoCapabilities attribute to a sequence containing a
      //      single MediaKeySystemMediaCapability, initialized as follows:
      if (config.video !== undefined) {
        var _keyCap = {
          contentType: "",
          robustness: "NON-SECURE"
        };
        // 4.6.1  Set the contentType attribute to config.video.contentType.
        _keyCap.contentType = config.video.contentType;
        _$$_REQUIRE(_dependencyMap[1]).LogUtil.debug("config.keySystemConfiguration.video is ", config.keySystemConfiguration.video);
        // 4.6.2  If config.keySystemConfiguration.video exists:
        if (config.keySystemConfiguration.video !== undefined) {
          // 4.6.2.1  Set the robustness attribute to config.keySystemConfiguration.video.robustness.
          var videoRobustness = config.keySystemConfiguration.video.robustness;
          if (knownRobustnessLevels.includes(videoRobustness)) {
            _keyCap.robustness = videoRobustness;
          }
        }
        emeConfiguration.videoCapabilities = [_keyCap];
      }
      var keySystemAccess = null;
      try {
        keySystemAccess = yield (0, _$$_REQUIRE(_dependencyMap[2]).requestMediaKeySystemAccess)(config.keySystemConfiguration.keySystem, [emeConfiguration]);
      } catch (e) {
        _$$_REQUIRE(_dependencyMap[1]).LogUtil.error('requestMediaKeySystemAccess failed.');
      }
      _$$_REQUIRE(_dependencyMap[1]).LogUtil.debug("checkEncryptedDecodingsupport-- ");
      return keySystemAccess;
    });
    return _checkEncryptedDecodingsupport.apply(this, arguments);
  }
  exports.checkEncryptedDecodingsupport = checkEncryptedDecodingsupport;
},"f0a57f93b4cb7ac3f6cb",["ff7d8d645536d793bbec","1f12e7e43345228dfcad","7d1995a852866a3b5fa6"]);
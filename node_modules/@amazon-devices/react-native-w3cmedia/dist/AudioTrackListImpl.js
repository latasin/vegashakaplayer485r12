"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AudioTrackListImpl = void 0;
const LogUtils_1 = require("./LogUtils");
const EventTargetInterface_1 = require("./interface/EventTargetInterface");
const MediaEventEmitterImpl_1 = require("./MediaEventEmitterImpl");
/**
 * Proxies to support [ ] operator on AudioTrackList
 */
const proxyHandlers = {
    get(target, key) {
        if (!(key in target)) {
            return target.audioTracks[key];
        }
        else {
            return Reflect.get(target, key);
        }
    }
};
/**
 * Implement AudioTrackList interface
 */
class AudioTrackListImpl {
    eventEmitter;
    audioTracks = new Array();
    constructor() {
        this.eventEmitter = new MediaEventEmitterImpl_1.MediaEventEmitterImpl();
        return new Proxy(this, proxyHandlers);
    }
    // AudioTrackList interface API implementation
    get length() {
        return this.audioTracks.length;
    }
    set onchange(listener) {
        this.eventEmitter.addEventListener("change", listener);
    }
    set onaddtrack(listener) {
        this.eventEmitter.addEventListener("addtrack", listener);
    }
    set onremovetrack(listener) {
        this.eventEmitter.addEventListener("removetrack", listener);
    }
    getTrackById(id) {
        if (this.audioTracks.length === 0) {
            LogUtils_1.LogUtil.warn(`no audio tracks available`);
            return undefined;
        }
        let track = undefined;
        this.audioTracks.forEach((audioTrack) => {
            if (audioTrack.id === id) {
                track = audioTrack;
            }
        });
        return track;
    }
    // other public APIs
    /**
     * Emits the Track list related events
     * @param eventName name of the track
     * @param audioTrack track
     */
    emitEvent(eventName, audioTrack) {
        LogUtils_1.LogUtil.debug(`AudioTrackListImpl: emitEvent ${eventName}`);
        if (eventName === "change") {
            this.eventEmitter.emit(eventName, new EventTargetInterface_1.Event(eventName, this));
        }
        else {
            if (audioTrack) {
                this.eventEmitter.emit(eventName, new EventTargetInterface_1.TrackEvent(eventName, this, audioTrack));
            }
            else {
                this.eventEmitter.emit(eventName, new EventTargetInterface_1.Event(eventName, this));
            }
        }
    }
    /**
     * Adds a track to the tracks list
     */
    addTrack(track) {
        LogUtils_1.LogUtil.debug(`AudioTrackListImpl: addTrack id ${track.id}`);
        this.audioTracks.push(track);
    }
    removeTrack(id) {
        LogUtils_1.LogUtil.debug(`AudioTrackListImpl: removeTrack id ${id}`);
        // find the track
        let trackIndex = undefined;
        this.audioTracks.forEach((audioTrack, index) => {
            if (audioTrack.id === id) {
                trackIndex = index;
            }
        });
        // remove track if found
        if (trackIndex !== undefined) {
            this.audioTracks.splice(trackIndex, 1);
            LogUtils_1.LogUtil.debug(`audio track id ${id} removed`);
        }
        else {
            LogUtils_1.LogUtil.warn(`audio track id ${id} not found`);
        }
    }
    // EventTarget API implementation
    addEventListener(type, listener, options) {
        LogUtils_1.LogUtil.info(`AudioTrackListImpl:addEventListener ${type}`);
        this.eventEmitter.addEventListener(type, listener);
    }
    removeEventListener(type, listener, options) {
        LogUtils_1.LogUtil.info(`AudioTrackListImpl:removeEventListener ${type}`);
        this.eventEmitter.removeEventListener(type, listener);
    }
}
exports.AudioTrackListImpl = AudioTrackListImpl;

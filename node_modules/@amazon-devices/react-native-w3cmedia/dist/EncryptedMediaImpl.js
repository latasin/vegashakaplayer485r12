"use strict";
/*
 * Copyright 2022-2023 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.requestMediaKeySystemAccess = exports.requestMediaKeysSystemAccess = exports.MediaKeysSystemAccessImpl = exports.MediaKeysImpl = exports.MediaKeySessionImpl = exports.MediaKeyStatusMapImpl = void 0;
const base64js = __importStar(require("base64-js"));
const LogUtils_1 = require("./LogUtils");
const EncryptedMediaInterface_1 = require("./interface/EncryptedMediaInterface");
const W3CMediaTurboModule_1 = __importDefault(require("./turbo-modules/W3CMediaTurboModule"));
const WIDEVINE = "com.widevine.alpha";
const PLAYREADY = "com.microsoft.playready.recommendation";
const DEBUG_TAG = "EncryptedMediaImpl:";
class MediaKeyStatusMapImpl {
    size = 0;
    statusMap;
    constructor(size, statusMap) {
        LogUtils_1.LogUtil.info(`${DEBUG_TAG} MediaKeyStatusMapImpl::ctor ${size} ${statusMap.size}`);
        this.size = size;
        this.statusMap = statusMap;
    }
    get(keyId) {
        LogUtils_1.LogUtil.info(`${DEBUG_TAG} MediaKeyStatusMapImpl::get`);
        return this.statusMap.get(keyId);
    }
    has(keyId) {
        LogUtils_1.LogUtil.info(`${DEBUG_TAG} MediaKeyStatusMapImpl::has`);
        return this.statusMap.has(keyId);
    }
    forEach(callbackfn, thisArg) {
        this.statusMap.forEach(callbackfn, thisArg);
    }
}
exports.MediaKeyStatusMapImpl = MediaKeyStatusMapImpl;
class MediaKeySessionImpl {
    _nmks = null;
    _nmk = null;
    _sessionType = "temporary";
    sessionId = "";
    expiration = Number.NaN;
    closed = null;
    keyStatuses = null;
    onkeystatuseschange = null;
    onmessage = null;
    constructor(sessionType, nmk) {
        LogUtils_1.LogUtil.info(`${DEBUG_TAG} MediaKeySessionImpl::ctor`);
        this._nmk = nmk;
        this._sessionType = sessionType;
    }
    setnmks(nmks) {
        LogUtils_1.LogUtil.info(`${DEBUG_TAG} MediaKeySessionImpl::setnmks`);
        this._nmks = nmks;
    }
    async generateRequest(initDataType, initData) {
        LogUtils_1.LogUtil.debug(`${DEBUG_TAG} generateRequest`);
        return new Promise((resolve, reject) => {
            LogUtils_1.LogUtil.debug(`${DEBUG_TAG} generateRequest inside the promise`);
            if (initDataType === "" || initData.byteLength === 0) {
                LogUtils_1.LogUtil.error(`${DEBUG_TAG} generateRequest Invalid data passed`);
                reject(TypeError("Invalid data passed"));
            }
            if (this._nmks === null && this._nmk) {
                LogUtils_1.LogUtil.warn(`${DEBUG_TAG} generateRequest Native obj is not present`);
                this.createSession_(this._sessionType, this._nmk)
                    .then(() => {
                    const typedArrayInput = ArrayBuffer.isView(initData)
                        ? new Uint8Array(initData.buffer, initData.byteOffset, initData.byteLength)
                        : new Uint8Array(initData);
                    const base64Init = base64js.fromByteArray(typedArrayInput);
                    // TODO: Modify below as key_ids_csv should not be required.
                    if (this._nmks) {
                        W3CMediaTurboModule_1.default.cdmiSession_GenerateRequest(this._nmks, base64Init, [], (event) => {
                            if (event.result.error_code === 0) {
                                LogUtils_1.LogUtil.debug(`${DEBUG_TAG} generateRequest License request successfully submitted!`);
                                resolve();
                            }
                            else {
                                LogUtils_1.LogUtil.error(`${DEBUG_TAG} generateRequest Could not get request license request!`);
                                reject(TypeError("Failed to generate request"));
                            }
                        });
                    }
                    else {
                        LogUtils_1.LogUtil.error(`${DEBUG_TAG} generateRequest Native obj is not present`);
                        reject((0, EncryptedMediaInterface_1.InvalidStateError)("Native obj is not present"));
                    }
                })
                    .catch(() => {
                    reject((0, EncryptedMediaInterface_1.InvalidStateError)("Native obj is not present"));
                });
            }
        });
    }
    load(sessionId) {
        if (sessionId === "") {
            LogUtils_1.LogUtil.error(`${DEBUG_TAG} load Empty sessionId passed`);
            return new Promise((resolve, reject) => {
                reject(TypeError("Empty Session Id"));
            });
        }
        return new Promise((resolve, reject) => {
            if (!this._nmks) {
                reject((0, EncryptedMediaInterface_1.InvalidStateError)("Native obj is not present"));
            }
            else {
                W3CMediaTurboModule_1.default.cdmiSession_Load(this._nmks, sessionId, (event) => {
                    if (event.result.error_code === 0) {
                        LogUtils_1.LogUtil.info(`${DEBUG_TAG} load Load Session successfully submitted!`);
                        resolve(true);
                    }
                    else {
                        LogUtils_1.LogUtil.warn(`${DEBUG_TAG} load Could not load session!`);
                        reject(TypeError("Failed to load session"));
                    }
                });
            }
        });
    }
    update(response) {
        LogUtils_1.LogUtil.info(`${DEBUG_TAG} DRM: update`);
        if (!response.byteLength) {
            LogUtils_1.LogUtil.error(`${DEBUG_TAG} update Empty response passed`);
            return new Promise((resolve, reject) => {
                reject(TypeError("Empty Response"));
            });
        }
        return new Promise((resolve, reject) => {
            if (!this._nmks) {
                reject((0, EncryptedMediaInterface_1.InvalidStateError)("Native obj is not present"));
            }
            else {
                const typedResponse = ArrayBuffer.isView(response)
                    ? new Uint8Array(response.buffer, response.byteOffset, response.byteLength)
                    : new Uint8Array(response);
                const base64Resp = base64js.fromByteArray(typedResponse);
                W3CMediaTurboModule_1.default.cdmiSession_Update(this._nmks, base64Resp, (event) => {
                    if (event.result.error_code === 0) {
                        LogUtils_1.LogUtil.info(`${DEBUG_TAG} update License response successfully submitted!`);
                        resolve();
                    }
                    else {
                        LogUtils_1.LogUtil.warn(`${DEBUG_TAG} update Could not post license response!`);
                        reject(TypeError("Failed to process response"));
                    }
                });
            }
        });
    }
    close() {
        return new Promise((resolve, reject) => {
            if (!this._nmks) {
                reject((0, EncryptedMediaInterface_1.InvalidStateError)("Native obj is not present"));
            }
            else {
                W3CMediaTurboModule_1.default.cdmiSession_Close(this._nmks, (event) => {
                    if (event.result.error_code === 0) {
                        LogUtils_1.LogUtil.info(`${DEBUG_TAG} close Close Session successfully submitted!`);
                        resolve();
                    }
                    else {
                        LogUtils_1.LogUtil.warn(`${DEBUG_TAG} close Could not close session!`);
                        reject(TypeError("Failed to close session"));
                    }
                });
            }
        });
    }
    // TODO: Implement this
    remove() {
        return new Promise((resolve, reject) => {
            if (!this._nmks) {
                reject((0, EncryptedMediaInterface_1.InvalidStateError)("Native obj is not present"));
            }
            else {
                W3CMediaTurboModule_1.default.cdmiSession_Remove(this._nmks, (event) => {
                    if (event.result.error_code === 0) {
                        LogUtils_1.LogUtil.info(`${DEBUG_TAG} remove Remove Session Keys successfully submitted!`);
                        resolve();
                    }
                    else {
                        LogUtils_1.LogUtil.warn(`${DEBUG_TAG} remove Could not remove session keys!`);
                        reject(TypeError("Failed to remove session"));
                    }
                });
            }
        });
    }
    // EventTarget APIs
    /**
     * Adds a event listener
     */
    addEventListener(type, listener, options) {
        LogUtils_1.LogUtil.info(`${DEBUG_TAG} MediaKeySession:addEventListener: ${type}`);
        if (type === "message") {
            this.onmessage = listener;
        }
        else if (type === "keystatuseschange") {
            this.onkeystatuseschange = listener;
        }
        else {
            LogUtils_1.LogUtil.error(`${DEBUG_TAG} addEventListener: Unsupported listener type`);
        }
    }
    /**
     * Removes event listener
     */
    removeEventListener(type, listener, options) {
        LogUtils_1.LogUtil.info(`${DEBUG_TAG} Media:removeEventListener: ${type}`);
        if (type === "message") {
            this.onmessage = null;
        }
        else if (type === "keystatuseschange") {
            this.onkeystatuseschange = null;
        }
        else {
            LogUtils_1.LogUtil.error(`${DEBUG_TAG} removeEventListener: Unsupported listener type`);
        }
    }
    convertToMediaKeyStatus(input) {
        switch (input) {
            case 0:
                return "usable";
            case 1:
                return "expired";
            case 2:
                return "released";
            case 3:
                return "output-restricted";
            case 4:
                return "output-downscaled";
            case 6:
                return "status-pending";
            case 7:
            default:
                return "internal-error";
        }
    }
    setMap(map) {
        this.keyStatuses = map;
    }
    createSession_(sessionType, nativemk) {
        // TODO: SessionType not used in TurboModule.
        LogUtils_1.LogUtil.info(`${DEBUG_TAG} createSession with type ${sessionType}`);
        return new Promise((resolve, reject) => {
            LogUtils_1.LogUtil.info(`${DEBUG_TAG} createSession_ inside Promise`);
            W3CMediaTurboModule_1.default.cdmiMediaKeys_CreateSession(nativemk, sessionType, (event) => {
                if (event.result.error_code === 0) {
                    LogUtils_1.LogUtil.info(`${DEBUG_TAG} createSession inside CB. Got mks! Id = ${event.id}, Event = ${event.event}`);
                    LogUtils_1.LogUtil.info(`${DEBUG_TAG} createSession Got Media Key Session! ${event.session._tag} sId: ${event.integer}`);
                    this.sessionId = event.integer.toString();
                    this.setnmks(event.session);
                    resolve();
                }
                else {
                    LogUtils_1.LogUtil.error(`${DEBUG_TAG} Could not get MediaKey Session!`);
                    reject((0, EncryptedMediaInterface_1.InvalidStateError)("Failed to get MediaKeys"));
                }
            }, (onMessage, buffer) => {
                LogUtils_1.LogUtil.debug(`${DEBUG_TAG} createSession got Message in session! Id = ${onMessage.id}, Event = ${onMessage.event}`);
                LogUtils_1.LogUtil.debug(`${DEBUG_TAG} createSession Message size = ${buffer.byteLength}`);
                if (this.onmessage == null) {
                    LogUtils_1.LogUtil.error(`onMessage not set!!!`);
                }
                else {
                    LogUtils_1.LogUtil.debug(`${DEBUG_TAG} Calling onMessage!!!`);
                    const ev = { messageType: 'license-request', message: buffer, target: this };
                    this.onmessage(ev);
                }
                LogUtils_1.LogUtil.debug(`${DEBUG_TAG} createSession Message = ${buffer.toString()}`);
            }, (onKeyStatusesChanged, buffer) => {
                LogUtils_1.LogUtil.debug(`${DEBUG_TAG} createSession key statuses changed! Id = ${onKeyStatusesChanged.id}, Event = ${onKeyStatusesChanged.event}`);
                LogUtils_1.LogUtil.debug(`${DEBUG_TAG} createSession key statuses changed size = ${buffer.byteLength} ${buffer.byteLength % 20}`);
                if (buffer.byteLength > 0 && (buffer.byteLength % 20) === 0) {
                    const uint32tmp = new Uint32Array(buffer);
                    const myMap = new Map();
                    for (let i = 0; i < (buffer.byteLength / 20); i++) {
                        LogUtils_1.LogUtil.debug(`${DEBUG_TAG} Key status = ${this.convertToMediaKeyStatus(uint32tmp[(i * 5) + 4])} from val ${uint32tmp[(i * 5) + 4]}`);
                        myMap.set(buffer.slice(i * 20, i * 20 + 16), this.convertToMediaKeyStatus(uint32tmp[(i * 5) + 4]));
                    }
                    const keyStatusMap = new MediaKeyStatusMapImpl(buffer.byteLength / 20, myMap);
                    this.setMap(keyStatusMap);
                }
                if (this.onkeystatuseschange == null) {
                    LogUtils_1.LogUtil.error(`${DEBUG_TAG} onKeyStatusesChanged not set!!!`);
                }
                else {
                    LogUtils_1.LogUtil.debug(`${DEBUG_TAG} Calling onKeyStatusesChanged!!!`);
                    const ev = { target: this };
                    this.onkeystatuseschange(ev);
                }
                LogUtils_1.LogUtil.debug(`${DEBUG_TAG} createSession Usable = ${onKeyStatusesChanged.integer}`);
            }, (onCloseCallback) => {
                if (onCloseCallback.result.error_code !== 0) {
                    LogUtils_1.LogUtil.error(`${DEBUG_TAG} Could not close the DRM system. Error: ${onCloseCallback.result.error_code}, MpbError: ${onCloseCallback.result.mpb_error}`);
                }
                else {
                    LogUtils_1.LogUtil.info(`${DEBUG_TAG} Closed Media Key Session`);
                }
            });
        });
        LogUtils_1.LogUtil.debug(`${DEBUG_TAG} returning from createSession_`);
    }
}
exports.MediaKeySessionImpl = MediaKeySessionImpl;
class MediaKeysImpl {
    // TODO: NFP turbo does not allow to set the session type during session creation
    _nativemk = null;
    constructor(nmk) {
        LogUtils_1.LogUtil.info(`${DEBUG_TAG} MediaKeysImpl::ctor`);
        this._nativemk = nmk;
    }
    getnmk() {
        return this._nativemk;
    }
    createSession(sessionType) {
        let session_type = "temporary";
        if (sessionType) {
            session_type = sessionType;
        }
        if (this._nativemk) {
            const mks = new MediaKeySessionImpl(session_type, this._nativemk);
            return mks;
        }
        else {
            LogUtils_1.LogUtil.error(`${DEBUG_TAG} No Native MediaKeys present. Returning empty shell`);
            const mks = new MediaKeySessionImpl(session_type, null);
            return mks;
        }
    }
    setServerCertificate(serverCertificate) {
        return new Promise((resolve, reject) => {
            LogUtils_1.LogUtil.debug(`${DEBUG_TAG} setServerCertificate inside Promise`);
            if (!serverCertificate.byteLength) {
                LogUtils_1.LogUtil.error(`${DEBUG_TAG} setServerCertificate Empty serverCertificate passed`);
                reject(TypeError("Empty Server Certificate"));
            }
            if (!this._nativemk) {
                LogUtils_1.LogUtil.error(`${DEBUG_TAG} setServerCertificate Native obj not present`);
                reject((0, EncryptedMediaInterface_1.InvalidStateError)("Native obj is not present"));
            }
            else {
                const typedCert = ArrayBuffer.isView(serverCertificate)
                    ? new Uint8Array(serverCertificate.buffer, serverCertificate.byteOffset, serverCertificate.byteLength)
                    : new Uint8Array(serverCertificate);
                const base64Cert = base64js.fromByteArray(typedCert);
                W3CMediaTurboModule_1.default.cdmiMediaKeys_SetServerCertificate(this._nativemk, base64Cert, (event) => {
                    if (event.result.error_code === 0) {
                        LogUtils_1.LogUtil.debug(`${DEBUG_TAG} setServerCertificate successfully submitted!`);
                        resolve(true);
                    }
                    else {
                        LogUtils_1.LogUtil.debug(`${DEBUG_TAG} setServerCertificate Could not set server certificate!`);
                        reject(TypeError("Failed to set server certificate"));
                    }
                });
            }
        });
    }
    getStatusForPolicy(policy) {
        return new Promise((resolve, reject) => {
            LogUtils_1.LogUtil.debug(`${DEBUG_TAG} getStatusForPolicy inside Promise`);
            if (!policy || policy.minHdcpVersion === "") {
                LogUtils_1.LogUtil.error(`${DEBUG_TAG} getStatusForPolicy empty policy/minHdcpVersion passed`);
                reject(TypeError("Empty policy/minHdcpVersion"));
            }
            if (!this._nativemk) {
                LogUtils_1.LogUtil.error(`${DEBUG_TAG} getStatusForPolicy Native obj not present`);
                reject((0, EncryptedMediaInterface_1.InvalidStateError)("Native obj is not present"));
            }
            else {
                const nativePolicy = {
                    minHdcpVersion: policy.minHdcpVersion
                };
                W3CMediaTurboModule_1.default.cdmiMediaKeys_GetStatusForPolicy(this._nativemk, nativePolicy, (event) => {
                    if (event.result.error_code === 0) {
                        LogUtils_1.LogUtil.debug(`${DEBUG_TAG} getStatusForPolicy succeeded: native status=${event.integer}`);
                        const nativeMediaKeyStatuses = W3CMediaTurboModule_1.default.getCdmMediaKeyStatus();
                        if (event.integer === nativeMediaKeyStatuses.USABLE ||
                            event.integer === nativeMediaKeyStatuses.OUTPUT_RESTRICTED) {
                            const status = event.integer === nativeMediaKeyStatuses.USABLE ? "usable" : "output-restricted";
                            resolve(status);
                        }
                        else {
                            LogUtils_1.LogUtil.warn(`${DEBUG_TAG} getStatusForPolicy unexpected status!`);
                            reject(TypeError("Unexpected status for policy"));
                        }
                    }
                    else {
                        LogUtils_1.LogUtil.warn(`${DEBUG_TAG} getStatusForPolicy Could not get status for policy`);
                        reject(TypeError("Failed to get status for policy"));
                    }
                });
            }
        });
    }
}
exports.MediaKeysImpl = MediaKeysImpl;
class MediaKeysSystemAccessImpl {
    _configuration = null;
    _nativemksa = null;
    _nativecfg = null;
    keySystem = "";
    constructor(keysystem, nativemksa) {
        LogUtils_1.LogUtil.info(`${DEBUG_TAG} MediaKeysSystemAccessImpl::ctor key system = ${keysystem}`);
        this._nativemksa = nativemksa;
        this.keySystem = keysystem;
        LogUtils_1.LogUtil.info(`${DEBUG_TAG} MediaKeysSystemAccessImpl::ctor native config = ${this._nativecfg}`);
    }
    // Helper method for deep cloning
    static deepClone(obj) {
        if (obj === null || typeof obj !== 'object') {
            return obj;
        }
        if (obj instanceof Date) {
            return new Date(obj.getTime());
        }
        if (Array.isArray(obj)) {
            return obj.map(item => MediaKeysSystemAccessImpl.deepClone(item));
        }
        if (obj instanceof Object) {
            const copy = {};
            Object.keys(obj).forEach((key) => {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    copy[key] = MediaKeysSystemAccessImpl.deepClone(obj[key]);
                }
            });
            return copy;
        }
        throw new Error(`Unable to copy obj! Its type isn't supported.`);
    }
    clone() {
        const cloned = new MediaKeysSystemAccessImpl(this.keySystem, this._nativemksa ? MediaKeysSystemAccessImpl.deepClone(this._nativemksa) : null);
        cloned._configuration = this._configuration
            ? MediaKeysSystemAccessImpl.deepClone(this._configuration)
            : null;
        cloned._nativecfg = this._nativecfg
            ? MediaKeysSystemAccessImpl.deepClone(this._nativecfg)
            : null;
        return cloned;
    }
    getConfiguration() {
        if (this._configuration === null) {
            if (this._nativecfg === null) {
                this._nativecfg = W3CMediaTurboModule_1.default.cdmiAccess_GetConfiguration(this._nativemksa);
                LogUtils_1.LogUtil.info(`${DEBUG_TAG} getConfiguration _nativecfg = ${this._nativecfg}`);
            }
            if (this._nativecfg !== null) {
                LogUtils_1.LogUtil.debug(`${DEBUG_TAG} getConfiguration label = ${this._nativecfg.label}`);
                const nativeInitDataTypes = W3CMediaTurboModule_1.default.getCdmInitDataType();
                const initDataTypes = new Array();
                for (let i = 0; i < this._nativecfg.init_data_types.length; i++) {
                    const initDataType = this._nativecfg.init_data_types[i];
                    LogUtils_1.LogUtil.debug(`${DEBUG_TAG} getConfiguration init_data_types[{i}] = ${initDataType}`);
                    if (initDataType === nativeInitDataTypes.CENC) {
                        initDataTypes[i] = "cenc";
                    }
                    else if (initDataType === nativeInitDataTypes.KEYIDS) {
                        initDataTypes[i] = "keyids";
                    }
                    else if (initDataType === nativeInitDataTypes.WEBM) {
                        initDataTypes[i] = "webm";
                    }
                }
                const nativeMediaRobustness = W3CMediaTurboModule_1.default.getCdmMediaRobustness();
                const audioCapabilities = new Array();
                for (let i = 0; i < this._nativecfg.audio_capabilities.length; i++) {
                    const cap = this._nativecfg.audio_capabilities[i];
                    LogUtils_1.LogUtil.debug(`${DEBUG_TAG} getConfiguration audio_capabilities[{i}]: mime=${cap.mime} robustness=${cap.robustness}`);
                    audioCapabilities.push({
                        contentType: cap.mime,
                        robustness: (nativeMediaRobustness.SECURE === cap.robustness) ? "SECURE" : "NON-SECURE"
                    });
                }
                const videoCapabilities = new Array();
                for (let i = 0; i < this._nativecfg.video_capabilities.length; i++) {
                    const cap = this._nativecfg.video_capabilities[i];
                    LogUtils_1.LogUtil.debug(`${DEBUG_TAG} getConfiguration video_capabilities[{i}]: mime=${cap.mime} robustness=${cap.robustness}`);
                    videoCapabilities.push({
                        contentType: cap.mime,
                        robustness: (nativeMediaRobustness.SECURE === cap.robustness) ? "SECURE" : "NON-SECURE"
                    });
                }
                const nativeMediaKeyRequirement = W3CMediaTurboModule_1.default.getCdmMediaKeyRequirement();
                const distinctiveId = (nativeMediaKeyRequirement.REQUIRED === this._nativecfg.distinctive_identifier) ?
                    "required" : (nativeMediaKeyRequirement.NOT_ALLOWED === this._nativecfg.distinctive_identifier) ?
                    "not-allowed" : "optional";
                LogUtils_1.LogUtil.debug(`${DEBUG_TAG} getConfiguration distinctive_identifier = ${this._nativecfg.distinctive_identifier} => ${distinctiveId}`);
                const persistentState = (nativeMediaKeyRequirement.REQUIRED === this._nativecfg.persistent_state) ?
                    "required" : (nativeMediaKeyRequirement.NOT_ALLOWED === this._nativecfg.persistent_state) ?
                    "not-allowed" : "optional";
                LogUtils_1.LogUtil.debug(`${DEBUG_TAG} getConfiguration persistent_state = ${this._nativecfg.persistent_state} => ${persistentState}`);
                const nativeSessionType = W3CMediaTurboModule_1.default.getCdmSessionType();
                const sessionTypes = new Array();
                for (let i = 0; i < this._nativecfg.session_types.length; i++) {
                    const st = (nativeSessionType.PERSISTENT === this._nativecfg.session_types[i]) ?
                        "persistent-license" : "temporary";
                    LogUtils_1.LogUtil.debug(`${DEBUG_TAG} getConfiguration session_types[{i}] = ${this._nativecfg.session_types[i]} => ${st}`);
                    sessionTypes.push(st);
                }
                this._configuration = {
                    label: this._nativecfg.label,
                    initDataTypes: initDataTypes,
                    audioCapabilities: audioCapabilities,
                    videoCapabilities: videoCapabilities,
                    distinctiveIdentifier: distinctiveId,
                    persistentState: persistentState,
                    sessionTypes: sessionTypes
                };
            }
        }
        if (this._configuration !== null && this._configuration.videoCapabilities !== undefined && this._configuration.videoCapabilities.length > 0) {
            const tmp_cap = this._configuration.videoCapabilities[0];
            LogUtils_1.LogUtil.debug(`${DEBUG_TAG} getConfiguration where number of config = ${this._configuration.videoCapabilities.length}`);
            LogUtils_1.LogUtil.debug(`${DEBUG_TAG} getConfiguration where contentType = ${tmp_cap.contentType}`);
            LogUtils_1.LogUtil.debug(`${DEBUG_TAG} getConfiguration where robustness = ${tmp_cap.robustness}`);
            LogUtils_1.LogUtil.debug(`${DEBUG_TAG} getConfiguration where config label = ${this._configuration?.label}`);
        }
        return this._configuration;
    }
    createMediaKeys() {
        LogUtils_1.LogUtil.info(`${DEBUG_TAG} MediaKeysSystemAccessImpl::createMediaKeys`);
        return new Promise((resolve, reject) => {
            LogUtils_1.LogUtil.debug(`${DEBUG_TAG} createMediaKeys Inside the promise`);
            if (this._nativemksa == null) {
                LogUtils_1.LogUtil.debug(`${DEBUG_TAG} Something is wrong with mksa. Rejecting`);
                reject((0, EncryptedMediaInterface_1.InvalidStateError)("Native obj is not present"));
            }
            else {
                W3CMediaTurboModule_1.default.cdmiAccess_CreateMediaKeys(this._nativemksa, (event) => {
                    LogUtils_1.LogUtil.debug(`${DEBUG_TAG} createMediaKeys Inside the CB`);
                    if (event.result.error_code === 0) {
                        const cdmiKeysResult = new MediaKeysImpl(event.media_keys);
                        LogUtils_1.LogUtil.debug(`${DEBUG_TAG} createMediaKeys Got MediaKeys!`);
                        resolve(cdmiKeysResult);
                    }
                    else {
                        LogUtils_1.LogUtil.error(`${DEBUG_TAG} createMediaKeys Could not get MediaKeys!`);
                        reject((0, EncryptedMediaInterface_1.InvalidStateError)("Failed to get MediaKeys"));
                    }
                });
            }
        });
    }
}
exports.MediaKeysSystemAccessImpl = MediaKeysSystemAccessImpl;
/**
 * TODO: Deprectate the 'requestMediaKeysSystemAccess' in future release (after MR32).
 * PROJXXXX-139032
 */
function requestMediaKeysSystemAccess(keySystem, supportedConfigurations) {
    LogUtils_1.LogUtil.debug(`${DEBUG_TAG} requestMediaKeysSystemAccess ${keySystem}`);
    return requestMediaKeySystemAccess(keySystem, supportedConfigurations);
}
exports.requestMediaKeysSystemAccess = requestMediaKeysSystemAccess;
/**
 * https://www.w3.org/TR/encrypted-media/#dom-navigator-requestmediakeysystemaccess
 * @param keySystem
 * @param supportedConfigurations
 * @returns
 */
function requestMediaKeySystemAccess(keySystem, supportedConfigurations) {
    LogUtils_1.LogUtil.debug(`${DEBUG_TAG} requestMediaKeySystemAccess ${keySystem}`);
    if (!keySystem.length) {
        LogUtils_1.LogUtil.error(`${DEBUG_TAG} requestMediaKeySystemAccess Invalid inputs`);
        return new Promise((_resolve, reject) => {
            reject(TypeError("Empty Key System"));
        });
    }
    // TODO: move to its own function
    const init_types = W3CMediaTurboModule_1.default.getCdmInitDataType();
    const session_types = W3CMediaTurboModule_1.default.getCdmSessionType();
    const media_robustness = W3CMediaTurboModule_1.default.getCdmMediaRobustness();
    const media_requirement = W3CMediaTurboModule_1.default.getCdmMediaKeyRequirement();
    const tmp_supported_configurations = new Array();
    if (supportedConfigurations && supportedConfigurations.length === 0) {
        LogUtils_1.LogUtil.debug(`${DEBUG_TAG} Creating default CDM Configuration. Temporary non-secure`);
        tmp_supported_configurations.push({
            label: "Default Kepler Configuration",
            init_data_types: [init_types.CENC],
            audio_capabilities: [{ mime: "audio", robustness: media_robustness.NOT_SECURE }],
            video_capabilities: [{ mime: "video", robustness: media_robustness.NOT_SECURE }],
            distinctive_identifier: media_requirement.NOT_ALLOWED,
            persistent_state: media_requirement.NOT_ALLOWED,
            session_types: [session_types.TEMPORARY]
        });
    }
    else {
        LogUtils_1.LogUtil.debug(`${DEBUG_TAG} Supported Configs size = ${supportedConfigurations.length}`);
        for (let j = 0; j < supportedConfigurations.length; j++) {
            const tmp_init_types = new Array();
            const tmp_audio_caps = new Array();
            const tmp_video_caps = new Array();
            const tmp_session_types = new Array();
            let tmp_distinctive_identifier = media_requirement.NOT_ALLOWED;
            let tmp_persistent_storage = media_requirement.NOT_ALLOWED;
            LogUtils_1.LogUtil.debug(`${DEBUG_TAG} Init Types: ${supportedConfigurations[j].initDataTypes}`);
            if (supportedConfigurations[j].initDataTypes !== undefined) {
                const curr_init_types = supportedConfigurations[j].initDataTypes;
                if (curr_init_types.length > 0) {
                    for (let i = 0; i < curr_init_types.length; i++) {
                        const init_t = curr_init_types[i];
                        if (init_t === "cenc") {
                            tmp_init_types[i] = init_types.CENC;
                        }
                        else if (init_t === "keyids") {
                            tmp_init_types[i] = init_types.KEYIDS;
                        }
                        else if (init_t === "webm") {
                            tmp_init_types[i] = init_types.WEBM;
                        }
                        else {
                            tmp_init_types[i] = init_types.CENC;
                        }
                    }
                }
                else {
                    tmp_init_types[0] = init_types.CENC;
                }
            }
            else {
                tmp_init_types[0] = init_types.CENC;
            }
            LogUtils_1.LogUtil.debug(`${DEBUG_TAG} Audio caps count: ${supportedConfigurations[j].audioCapabilities?.length}`);
            if (supportedConfigurations[j].audioCapabilities !== undefined) {
                const curr_audio_caps = supportedConfigurations[j].audioCapabilities;
                if (curr_audio_caps.length > 0) {
                    for (let i = 0; i < curr_audio_caps.length; i++) {
                        const tmp_aud_cap = {
                            mime: "audio",
                            robustness: media_robustness.NOT_SECURE,
                            encryptionScheme: null
                        };
                        LogUtils_1.LogUtil.debug(`Cap [${i}]: ${curr_audio_caps[i].contentType} : ${curr_audio_caps[i].robustness}`);
                        tmp_aud_cap.mime = curr_audio_caps[i].contentType;
                        const robustness = curr_audio_caps[i].robustness;
                        if (robustness === "SECURE") {
                            tmp_aud_cap.robustness = media_robustness.SECURE;
                        }
                        else {
                            LogUtils_1.LogUtil.debug(`Cap [${i}]: setting non-secure`);
                            tmp_aud_cap.robustness = media_robustness.NOT_SECURE;
                        }
                        if (curr_audio_caps[i].encryptionScheme != null) {
                            if (curr_audio_caps[i].encryptionScheme !== "cenc" ||
                                curr_audio_caps[i].encryptionScheme !== "cbcs" ||
                                curr_audio_caps[i].encryptionScheme !== "cbcs-1-9") {
                                LogUtils_1.LogUtil.warn(`${DEBUG_TAG} requestMediaKeySystemAccess. Unsupported encryptionScheme passed: ${curr_audio_caps[i].encryptionScheme}. skipping`);
                                continue;
                            }
                        }
                        else if (curr_audio_caps[i].encryptionScheme !== undefined) {
                            LogUtils_1.LogUtil.warn(`${DEBUG_TAG} requestMediaKeySystemAccess. Empty encryptionScheme passed for Audio. Skipping`);
                            continue;
                        }
                        LogUtils_1.LogUtil.debug(`${DEBUG_TAG} Cap [${i}]: ${tmp_aud_cap.mime} : ${tmp_aud_cap.robustness} : ${tmp_aud_cap.encryptionScheme}`);
                        tmp_audio_caps.push(tmp_aud_cap);
                    }
                }
                else {
                    const tmp_aud_cap = {
                        mime: "audio",
                        robustness: media_robustness.NOT_SECURE,
                        encryptionScheme: null
                    };
                    tmp_audio_caps.push(tmp_aud_cap);
                }
            }
            else {
                const tmp_aud_cap = {
                    mime: "audio",
                    robustness: media_robustness.NOT_SECURE,
                    encryptionScheme: null
                };
                tmp_audio_caps.push(tmp_aud_cap);
            }
            LogUtils_1.LogUtil.debug(`${DEBUG_TAG} Video caps count:  ${supportedConfigurations[j].videoCapabilities?.length}`);
            if (supportedConfigurations[j].videoCapabilities !== undefined) {
                const curr_video_caps = supportedConfigurations[j].videoCapabilities;
                if (curr_video_caps.length > 0) {
                    for (let i = 0; i < curr_video_caps.length; i++) {
                        const tmp_vid_cap = {
                            mime: "video",
                            robustness: media_robustness.NOT_SECURE,
                            encryptionScheme: null
                        };
                        LogUtils_1.LogUtil.debug(`${DEBUG_TAG} Cap [${i}]: ${curr_video_caps[i].contentType} : ${curr_video_caps[i].robustness}`);
                        tmp_vid_cap.mime = curr_video_caps[i].contentType;
                        const robustness = curr_video_caps[i].robustness;
                        LogUtils_1.LogUtil.debug(`${DEBUG_TAG} Cap [${i}] : ${robustness}`);
                        if (robustness === "SECURE" || robustness === "HW_SECURE_ALL" || robustness === "3000" || robustness === "2000") {
                            tmp_vid_cap.robustness = media_robustness.SECURE;
                        }
                        else {
                            tmp_vid_cap.robustness = media_robustness.NOT_SECURE;
                        }
                        if (curr_video_caps[i].encryptionScheme != null) {
                            if (curr_video_caps[i].encryptionScheme !== "cenc" ||
                                curr_video_caps[i].encryptionScheme !== "cbcs" ||
                                curr_video_caps[i].encryptionScheme !== "cbcs-1-9") {
                                LogUtils_1.LogUtil.warn(`${DEBUG_TAG} requestMediaKeySystemAccess. Unsupported encryptionScheme passed: ${curr_video_caps[i].encryptionScheme}. Skipping`);
                                continue;
                            }
                        }
                        else if (curr_video_caps[i].encryptionScheme !== undefined) {
                            LogUtils_1.LogUtil.warn(`${DEBUG_TAG} requestMediaKeySystemAccess. Empty encryptionScheme passed for Video. Skipping`);
                            continue;
                        }
                        LogUtils_1.LogUtil.debug(`${DEBUG_TAG} Cap [${i}]: ${tmp_vid_cap.mime} : ${tmp_vid_cap.robustness} : ${tmp_vid_cap.encryptionScheme}`);
                        tmp_video_caps.push(tmp_vid_cap);
                    }
                }
                else {
                    const tmp_vid_cap = {
                        mime: "video",
                        robustness: media_robustness.NOT_SECURE,
                        encryptionScheme: null
                    };
                    tmp_video_caps.push(tmp_vid_cap);
                }
            }
            else {
                const tmp_vid_cap = {
                    mime: "video",
                    robustness: media_robustness.NOT_SECURE,
                    encryptionScheme: null
                };
                tmp_video_caps.push(tmp_vid_cap);
            }
            LogUtils_1.LogUtil.debug(`${DEBUG_TAG} Distinctive ID: ${supportedConfigurations[j].distinctiveIdentifier}`);
            if (supportedConfigurations[j].distinctiveIdentifier !== undefined) {
                if (supportedConfigurations[j].distinctiveIdentifier === "required") {
                    tmp_distinctive_identifier = media_requirement.REQUIRED;
                }
                else if (supportedConfigurations[j].distinctiveIdentifier === "optional") {
                    tmp_distinctive_identifier = media_requirement.OPTIONAL;
                }
            }
            LogUtils_1.LogUtil.debug(`${DEBUG_TAG} Persistent Storage: ${supportedConfigurations[j].persistentState}`);
            if (supportedConfigurations[j].persistentState !== undefined) {
                if (supportedConfigurations[j].persistentState === "required") {
                    tmp_persistent_storage = media_requirement.REQUIRED;
                }
                else if (supportedConfigurations[j].persistentState === "optional") {
                    tmp_persistent_storage = media_requirement.OPTIONAL;
                }
            }
            LogUtils_1.LogUtil.debug(`${DEBUG_TAG} Session Types: ${supportedConfigurations[j].sessionTypes}`);
            if (supportedConfigurations[j].sessionTypes !== undefined) {
                const curr_session_types = supportedConfigurations[j].sessionTypes;
                if (curr_session_types.length > 0) {
                    for (let i = 0; i < curr_session_types.length; i++) {
                        const session_t = curr_session_types[i];
                        if (session_t === "persistent-license") {
                            tmp_session_types[i] = session_types.PERSISTENT;
                        }
                        else if (session_t === "temporary") {
                            tmp_session_types[i] = session_types.TEMPORARY;
                        }
                    }
                }
                else {
                    tmp_session_types[0] = session_types.TEMPORARY;
                }
            }
            else {
                tmp_session_types[0] = session_types.TEMPORARY;
            }
            LogUtils_1.LogUtil.debug(`${DEBUG_TAG} Label ${supportedConfigurations[j].label}`);
            let tmp_label = "Kepler SDK";
            if (typeof supportedConfigurations[j].label !== 'undefined' && supportedConfigurations[j].label?.length !== 0) {
                tmp_label = supportedConfigurations[j].label;
            }
            LogUtils_1.LogUtil.debug(`${DEBUG_TAG} Getting Native CDM Configuration`);
            tmp_supported_configurations.push({ label: tmp_label,
                init_data_types: tmp_init_types,
                audio_capabilities: tmp_audio_caps,
                video_capabilities: tmp_video_caps,
                distinctive_identifier: tmp_distinctive_identifier,
                persistent_state: tmp_persistent_storage,
                session_types: tmp_session_types });
        }
    }
    return new Promise((resolve, reject) => {
        LogUtils_1.LogUtil.debug(`${DEBUG_TAG} requestMediaKeySystemAccess Inside the promise`);
        W3CMediaTurboModule_1.default.cdmiAccess_New(keySystem, tmp_supported_configurations, (event) => {
            LogUtils_1.LogUtil.debug(`${DEBUG_TAG} requestMediaKeySystemAccess Inside the CB`);
            if (event.result.error_code === 0) {
                const cdmiAccessResult = new MediaKeysSystemAccessImpl(keySystem, event.access);
                LogUtils_1.LogUtil.debug(`${DEBUG_TAG} requestMediaKeySystemAccess Got SystemAcccess with name = ${cdmiAccessResult.keySystem}`);
                resolve(cdmiAccessResult);
            }
            else {
                LogUtils_1.LogUtil.error(`${DEBUG_TAG} requestMediaKeySystemAccess Could not get SystemAcccess!`);
                reject(TypeError("Failed to get the MediaKeySystemAccess"));
            }
        }, (onCloseCallback) => {
            LogUtils_1.LogUtil.debug(`${DEBUG_TAG} requestMediaKeySystemAccess Inside the OC`);
            if (onCloseCallback.result.error_code !== 0) {
                LogUtils_1.LogUtil.error(`${DEBUG_TAG} requestMediaKeySystemAccess Could not close the DRM system. Error: ${onCloseCallback.result.error_code}, MpbError: ${onCloseCallback.result.mpb_error}`);
            }
            else {
                LogUtils_1.LogUtil.debug(`${DEBUG_TAG} requestMediaKeySystemAccess Closed system Access`);
            }
        });
        LogUtils_1.LogUtil.debug(`${DEBUG_TAG} requestMediaKeySystemAccess After cdmiAccess_New`);
    });
}
exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess;

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Media = void 0;
/*
 * Copyright 2022-2025 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
const React = __importStar(require("react"));
const LogUtils_1 = require("./LogUtils");
/**
 * @hidden
 * https://html.spec.whatwg.org/multipage/media.html#htmlmediaelement
 */
class Media extends React.Component {
    mediaPlayer_ = null;
    controls_ = false;
    captionsViewHandle_ = null;
    constructor(props, mediaPlayer) {
        super(props);
        LogUtils_1.LogUtil.info(`Media:+constructor`);
        this.mediaPlayer_ = mediaPlayer;
        // NOTE: controls is a prop. Once set cannot be changed at runtime.
        if (this.props.controls !== undefined) {
            this.controls = this.props.controls;
        }
        else {
            LogUtils_1.LogUtil.warn(`Media: control props is undefined`);
        }
        if (this.props.defaultSeekIntervalInSec &&
            Number.isInteger(this.props.defaultSeekIntervalInSec) &&
            this.props.defaultSeekIntervalInSec > 0) {
            this.mediaPlayer_.defaultSeekIntervalInSec = this.props.defaultSeekIntervalInSec;
        }
        this.handleEvent = this.handleEvent.bind(this);
        this.setupEventListenersFromProps();
        this.onCaptionViewCreated = this.onCaptionViewCreated.bind(this);
        LogUtils_1.LogUtil.info(`Media:-constructor`);
    }
    /**
     * @hidden
     */
    destroyMediaPlayer() {
        LogUtils_1.LogUtil.info("Media: destroyMediaPlayer");
        this.resetEventListenersFromProps();
        return new Promise((resolve, reject) => {
            if (this.mediaPlayer_) {
                LogUtils_1.LogUtil.info("Media: destroying media element asynchronously");
                this.mediaPlayer_.deinitialize().then(() => {
                    LogUtils_1.LogUtil.info("Media: MediaElement destroyed");
                    this.mediaPlayer_ = null;
                    if (this.props.onComponentUnMounted) {
                        this.props.onComponentUnMounted();
                    }
                    resolve();
                });
                return;
            }
            reject();
        });
    }
    /**
     * @hidden
     */
    destroyMediaPlayerSync(timeoutInMs) {
        this.resetEventListenersFromProps();
        if (this.mediaPlayer_) {
            const status = this.mediaPlayer_.deinitializeSync(timeoutInMs);
            //this.mediaPlayer_ = null;
            //if (this.props.onComponentUnMounted) {
            //    this.props.onComponentUnMounted();
            //}
            return status;
        }
        LogUtils_1.LogUtil.warn("Media: not a valid MediaElement to deinit");
        return "invalid";
    }
    /**
     * @hidden
     */
    componentDidMount() {
        LogUtils_1.LogUtil.info("Media: componentDidMount");
    }
    /**
     * @hidden
     */
    componentWillUnmount() {
        LogUtils_1.LogUtil.info("Media: componentWillUnmount");
    }
    // EventTarget APIs
    /**
     * @hidden
     * Adds a event listener
     */
    addEventListener(type, listener, options) {
        LogUtils_1.LogUtil.info(`Media:addEventListener: ${type}`);
        this.mediaPlayer_?.addEventListener(type, listener);
    }
    /**
     * @hidden
     * Removes event listener
     */
    removeEventListener(type, listener, options) {
        LogUtils_1.LogUtil.info(`Media:removeEventListener: ${type}`);
        this.mediaPlayer_?.removeEventListener(type, listener);
    }
    /**
     * @hidden
     */
    get nodeName() {
        return this.mediaPlayer_.nodeName;
    }
    /**
     * @hidden
     */
    set src(url) {
        this.mediaPlayer_.src = url;
    }
    /**
     * @hidden
     */
    get src() {
        return this.mediaPlayer_.src;
    }
    /**
     * @hidden
     */
    set defaultSeekIntervalInSec(seekInterval) {
        this.mediaPlayer_.defaultSeekIntervalInSec = seekInterval;
    }
    /**
     * @hidden
     */
    get defaultSeekIntervalInSec() {
        return this.defaultSeekIntervalInSec;
    }
    /**
     * @hidden
     */
    set srcObject(srcObj) {
        this.mediaPlayer_.srcObject = srcObj;
    }
    /**
     * @hidden
     */
    get error() {
        return this.mediaPlayer_.error;
    }
    /**
     * @hidden
     */
    get currentSrc() {
        return this.mediaPlayer_.currentSrc;
    }
    /**
     * @hidden
     */
    get networkState() {
        return this.mediaPlayer_.networkState;
    }
    /**
     * @hidden
     */
    get buffered() {
        return this.mediaPlayer_.buffered;
    }
    /**
     * @hidden
     */
    load() {
        this.mediaPlayer_?.load();
    }
    /**
     *@hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-navigator-canplaytype
     * @param type mime type
     */
    canPlayType(type) {
        return this.mediaPlayer_?.canPlayType(type);
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-readystate
     */
    get readyState() {
        return this.mediaPlayer_.readyState;
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-seeking
     */
    get seeking() {
        return this.mediaPlayer_.seeking;
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-fastseek
     */
    fastSeek(time) {
        return this.mediaPlayer_?.fastSeek(time);
    }
    /**
     * @hidden
     *  https://html.spec.whatwg.org/multipage/media.html#dom-media-duration
     */
    get duration() {
        return this.mediaPlayer_.duration;
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-getstartdate
     */
    getStartDate() {
        return this.mediaPlayer_?.getStartDate();
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-paused
     */
    get paused() {
        return this.mediaPlayer_.paused;
    }
    /**
     * @hidden
     *
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-played
     */
    get played() {
        return this.mediaPlayer_.played;
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-seekable
     */
    get seekable() {
        return this.mediaPlayer_.seekable;
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-ended
     */
    get ended() {
        return this.mediaPlayer_.ended;
    }
    /**
     * @hidden
     *  https://html.spec.whatwg.org/multipage/media.html#dom-media-play
     */
    play() {
        return this.mediaPlayer_?.play();
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-pause
     */
    pause() {
        return this.mediaPlayer_?.pause();
    }
    /**
     * @hidden
    * https://html.spec.whatwg.org/multipage/media.html#dom-media-audiotracks
    */
    get audioTracks() {
        return this.mediaPlayer_.audioTracks;
    }
    /**
     * @hidden
    *  https://html.spec.whatwg.org/multipage/media.html#dom-media-videotracks
    */
    get videoTracks() {
        return this.mediaPlayer_.videoTracks;
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-texttracks
     */
    get textTracks() {
        return this.mediaPlayer_.textTracks;
    }
    /**
     * @hidden
     * @brief https://html.spec.whatwg.org/multipage/media.html#dom-media-addtexttrack
     * @param kind The kind attribute must return the text track kind of the text track that the TextTrack object represents.
     * @param label The label attribute must return the text track label of the text track that the TextTrack object represents.
     * @param language The language attribute must return the text track language of the text track that the TextTrack object represents.
     * @param uri The uri attribute must return the uri of the out of band subtitle of the text track that the TextTrack object represents.
     * This is a custom addition (not as per w3c spec). If uri is provided, this component will take care of parsing and rendering subtitles.
     * @param mimeType The mimeType attribute must return the mime type of the out of band subtitle of the text track that the TextTrack
     * object represents. This is a custom addition (not as per w3c spec).
     */
    addTextTrack(kind, label, language, uri, mimeType) {
        return this.mediaPlayer_?.addTextTrack(kind, label, language, uri, mimeType);
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#attr-media-preload
     */
    get preload() {
        return this.mediaPlayer_.preload;
    }
    /**
     * @hidden
     */
    set preload(preload) {
        this.mediaPlayer_.preload = preload;
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-currenttime
     */
    get currentTime() {
        return this.mediaPlayer_.currentTime;
    }
    /**
     * @hidden
     */
    set currentTime(time) {
        this.mediaPlayer_.currentTime = time;
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-defaultplaybackrate
     */
    get defaultPlaybackRate() {
        return this.mediaPlayer_.defaultPlaybackRate;
    }
    /**
     * @hidden
     */
    set defaultPlaybackRate(rate) {
        this.mediaPlayer_.defaultPlaybackRate = rate;
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-playbackrate
     */
    get playbackRate() {
        return this.mediaPlayer_.playbackRate;
    }
    /**
     * @hidden
     */
    set playbackRate(rate) {
        this.mediaPlayer_.playbackRate = rate;
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-preservespitch
     * @note Not implemented
     */
    preservesPitch;
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-autoplay
     */
    get autoplay() {
        return this.mediaPlayer_.autoplay;
    }
    /**
     * @hidden
     */
    set autoplay(autoplay) {
        this.mediaPlayer_.autoplay = autoplay;
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-loop
     */
    get loop() {
        return this.mediaPlayer_.loop;
    }
    /**
     * @hidden
     */
    set loop(loop) {
        this.mediaPlayer_.loop = loop;
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-controls
     */
    get controls() {
        return this.controls_;
    }
    /**
     * @hidden
     */
    set controls(controls) {
        LogUtils_1.LogUtil.info(`Media: setter controls ${controls}`);
        this.controls_ = controls;
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-volume
     */
    get volume() {
        return this.mediaPlayer_.volume;
    }
    /**
     * @hidden
     */
    set volume(volume) {
        this.mediaPlayer_.volume = volume;
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-muted
     */
    get muted() {
        return this.mediaPlayer_.muted;
    }
    /**
     * @hidden
     */
    set muted(muted) {
        this.mediaPlayer_.muted = muted;
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-defaultmuted
     */
    get defaultMuted() {
        return this.mediaPlayer_.defaultMuted;
    }
    /**
     * @hidden
     */
    set defaultMuted(defaultMuted) {
        this.mediaPlayer_.defaultMuted = defaultMuted;
    }
    /**
     * @hidden
     */
    setMediaKeys(mediaKeys) {
        return this.mediaPlayer_?.setMediaKeys(mediaKeys);
    }
    /**
     * @hidden
     * Handle all media element and audio/video track list events.
     */
    handleEvent(event) {
        this.mediaPlayer_?.handleEvent(event);
    }
    /**
     * @hidden
     * Sets up event listeners passed in props
     */
    setupEventListenersFromProps() {
        if (this.props.onLoadStart !== undefined) {
            this.addEventListener("loadstart", this.props.onLoadStart);
        }
        if (this.props.onProgress !== undefined) {
            this.addEventListener("progress", this.props.onProgress);
        }
        if (this.props.onSuspend !== undefined) {
            this.addEventListener("suspend", this.props.onSuspend);
        }
        if (this.props.onAbort !== undefined) {
            this.addEventListener("abort", this.props.onAbort);
        }
        if (this.props.onError !== undefined) {
            this.addEventListener("error", this.props.onError);
        }
        if (this.props.onEmptied !== undefined) {
            this.addEventListener("emptied", this.props.onEmptied);
        }
        if (this.props.onStalled !== undefined) {
            this.addEventListener("stalled", this.props.onStalled);
        }
        if (this.props.onLoadedMetadata !== undefined) {
            this.addEventListener("loadedmetadata", this.props.onLoadedMetadata);
        }
        if (this.props.onLoadedData !== undefined) {
            this.addEventListener("loadeddata", this.props.onLoadedData);
        }
        if (this.props.onCanPlay !== undefined) {
            this.addEventListener("canplay", this.props.onCanPlay);
        }
        if (this.props.onCanPlayThrough !== undefined) {
            this.addEventListener("canplaythrough", this.props.onCanPlayThrough);
        }
        if (this.props.onPlaying !== undefined) {
            this.addEventListener("playing", this.props.onPlaying);
        }
        if (this.props.onWaiting !== undefined) {
            this.addEventListener("waiting", this.props.onWaiting);
        }
        if (this.props.onSeeking !== undefined) {
            this.addEventListener("seeking", this.props.onSeeking);
        }
        if (this.props.onSeeked !== undefined) {
            this.addEventListener("seeked", this.props.onSeeked);
        }
        if (this.props.onEnded !== undefined) {
            this.addEventListener("ended", this.props.onEnded);
        }
        if (this.props.onDurationChange !== undefined) {
            this.addEventListener("durationchange", this.props.onDurationChange);
        }
        if (this.props.onTimeUpdate !== undefined) {
            this.addEventListener("timeupdate", this.props.onTimeUpdate);
        }
        if (this.props.onPlay !== undefined) {
            this.addEventListener("play", this.props.onPlay);
        }
        if (this.props.onPause !== undefined) {
            this.addEventListener("pause", this.props.onPause);
        }
        if (this.props.onRateChange !== undefined) {
            this.addEventListener("ratechange", this.props.onRateChange);
        }
        if (this.props.onResize !== undefined) {
            this.addEventListener("resize", this.props.onResize);
        }
        if (this.props.onVolumeChange !== undefined) {
            this.addEventListener("volumechange", this.props.onVolumeChange);
        }
        if (this.props.onEncrypted !== undefined) {
            this.addEventListener("encrypted", this.props.onEncrypted);
        }
        if (this.props.onWaitingForKey !== undefined) {
            this.addEventListener("waitingforkey", this.props.onWaitingForKey);
        }
        if (this.props.onAudioFocusGranted !== undefined) {
            this.addEventListener("audiofocusgranted", this.props.onAudioFocusGranted);
        }
        if (this.props.onAudioFocusPaused !== undefined) {
            this.addEventListener("audiofocuspaused", this.props.onAudioFocusPaused);
        }
        if (this.props.onAudioFocusLost !== undefined) {
            this.addEventListener("audiofocuslost", this.props.onAudioFocusLost);
        }
    }
    /**
     * @hidden
     * Reset event listeners passed in props before destroy
     */
    resetEventListenersFromProps() {
        if (this.props.onLoadStart !== undefined) {
            this.removeEventListener("loadstart", this.props.onLoadStart);
        }
        if (this.props.onProgress !== undefined) {
            this.removeEventListener("progress", this.props.onProgress);
        }
        if (this.props.onSuspend !== undefined) {
            this.removeEventListener("suspend", this.props.onSuspend);
        }
        if (this.props.onAbort !== undefined) {
            this.removeEventListener("abort", this.props.onAbort);
        }
        if (this.props.onError !== undefined) {
            this.removeEventListener("error", this.props.onError);
        }
        if (this.props.onEmptied !== undefined) {
            this.removeEventListener("emptied", this.props.onEmptied);
        }
        if (this.props.onStalled !== undefined) {
            this.removeEventListener("stalled", this.props.onStalled);
        }
        if (this.props.onLoadedMetadata !== undefined) {
            this.removeEventListener("loadedmetadata", this.props.onLoadedMetadata);
        }
        if (this.props.onLoadedData !== undefined) {
            this.removeEventListener("loadeddata", this.props.onLoadedData);
        }
        if (this.props.onCanPlay !== undefined) {
            this.removeEventListener("canplay", this.props.onCanPlay);
        }
        if (this.props.onCanPlayThrough !== undefined) {
            this.removeEventListener("canplaythrough", this.props.onCanPlayThrough);
        }
        if (this.props.onPlaying !== undefined) {
            this.removeEventListener("playing", this.props.onPlaying);
        }
        if (this.props.onWaiting !== undefined) {
            this.removeEventListener("waiting", this.props.onWaiting);
        }
        if (this.props.onSeeking !== undefined) {
            this.removeEventListener("seeking", this.props.onSeeking);
        }
        if (this.props.onSeeked !== undefined) {
            this.removeEventListener("seeked", this.props.onSeeked);
        }
        if (this.props.onEnded !== undefined) {
            this.removeEventListener("ended", this.props.onEnded);
        }
        if (this.props.onDurationChange !== undefined) {
            this.removeEventListener("durationchange", this.props.onDurationChange);
        }
        if (this.props.onTimeUpdate !== undefined) {
            this.removeEventListener("timeupdate", this.props.onTimeUpdate);
        }
        if (this.props.onPlay !== undefined) {
            this.removeEventListener("play", this.props.onPlay);
        }
        if (this.props.onPause !== undefined) {
            this.removeEventListener("pause", this.props.onPause);
        }
        if (this.props.onRateChange !== undefined) {
            this.removeEventListener("ratechange", this.props.onRateChange);
        }
        if (this.props.onResize !== undefined) {
            this.removeEventListener("resize", this.props.onResize);
        }
        if (this.props.onVolumeChange !== undefined) {
            this.removeEventListener("volumechange", this.props.onVolumeChange);
        }
        if (this.props.onEncrypted !== undefined) {
            this.removeEventListener("encrypted", this.props.onEncrypted);
        }
        if (this.props.onWaitingForKey !== undefined) {
            this.removeEventListener("waitingforkey", this.props.onWaitingForKey);
        }
        if (this.props.onAudioFocusGranted !== undefined) {
            this.removeEventListener("audiofocusgranted", this.props.onAudioFocusGranted);
        }
        if (this.props.onAudioFocusPaused !== undefined) {
            this.removeEventListener("audiofocuspaused", this.props.onAudioFocusPaused);
        }
        if (this.props.onAudioFocusLost !== undefined) {
            this.removeEventListener("audiofocuslost", this.props.onAudioFocusLost);
        }
    }
    /**
     * @hidden
     * uses properties to set the attributes of the class that triggers setter functions.
     * (except for control prop)
     */
    setupProps() {
        // set autoPlay before src as it is used in the turbo API.
        if (this.props.autoplay !== undefined) {
            this.autoplay = this.props.autoplay;
        }
        if (this.props.defaultSeekIntervalInSec !== undefined) {
            this.defaultSeekIntervalInSec = this.props.defaultSeekIntervalInSec;
        }
        if (this.props.src !== undefined) {
            this.src = this.props.src;
        }
        if (this.props.preload !== undefined) {
            this.preload = this.props.preload;
        }
        if (this.props.currentTime !== undefined) {
            this.currentTime = this.props.currentTime;
        }
        if (this.props.defaultPlaybackRate !== undefined) {
            this.defaultPlaybackRate = this.props.defaultPlaybackRate;
        }
        if (this.props.playbackRate !== undefined) {
            this.playbackRate = this.props.playbackRate;
        }
        if (this.props.defaultPlaybackRate !== undefined) {
            this.defaultPlaybackRate = this.props.defaultPlaybackRate;
            // if default rate is set, initialize the playback rate also
            this.playbackRate = this.props.defaultPlaybackRate;
        }
        if (this.props.playbackRate !== undefined) {
            this.playbackRate = this.props.playbackRate;
        }
        if (this.props.preservesPitch !== undefined) {
            this.preservesPitch = this.props.preservesPitch;
        }
        if (this.props.loop !== undefined) {
            this.loop = this.props.loop;
        }
        if (this.props.volume !== undefined) {
            this.volume = this.props.volume;
        }
        if (this.props.muted !== undefined) {
            this.muted = this.props.muted;
        }
        if (this.props.defaultMuted !== undefined) {
            this.defaultMuted = this.props.defaultMuted;
        }
    }
    onMediaPlayerInitialized() {
        if (this.props.onComponentDidMount) {
            this.props.onComponentDidMount();
        }
        // now setup the properties
        this.setupProps();
    }
    /**
     * @hidden
     */
    initializeMediaPlayer() {
        return this.mediaPlayer_?.initialize();
    }
    /**
     * @brief setup the component instance with current mediaplayer being used and pass mediaControlHandler
     *        in case client wants to opt handling of mediacontrol commands.
     */
    setMediaControlFocus(componentInstance, mediaControlHandler) {
        return this.mediaPlayer_?.setMediaControlFocus(componentInstance, mediaControlHandler);
    }
    /**
     * @hidden
     */
    onCaptionViewCreated(captionViewHandle) {
        this.mediaPlayer_?.setCaptionViewHandle(captionViewHandle);
        this.captionsViewHandle_ = captionViewHandle;
    }
    ;
}
exports.Media = Media;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextTrackCueListImpl = void 0;
const LogUtils_1 = require("./LogUtils");
const VTTCue_1 = require("./VTTCue");
const MediaEventEmitterImpl_1 = require("./MediaEventEmitterImpl");
/**
 * Proxies to support [ ] operator on VideoTrackList
 * @TODO get rid of this proxy, instead extend an Array
 */
const proxyHandlers = {
    get(target, key) {
        if (!(key in target)) {
            return target.textTrackCueList[key];
        }
        else {
            return Reflect.get(target, key);
        }
    },
};
/**
 * Implement TextTrackCueList interface
 */
class TextTrackCueListImpl {
    eventEmitter;
    textTrackCueList = new Array();
    // Map has an advantage over Set, when we need getCueById(id)
    cueMap = new Map();
    constructor() {
        this.eventEmitter = new MediaEventEmitterImpl_1.MediaEventEmitterImpl();
        return new Proxy(this, proxyHandlers);
    }
    // TextTrackCueList interface API implementation
    get length() {
        return this.textTrackCueList.length;
    }
    getCueById(id) {
        if (this.isEmpty()) {
            LogUtils_1.LogUtil.warn(`TextTrackCueListImpl: no cues available`);
            return undefined;
        }
        return this.cueMap.get(id);
    }
    /**
     * Adds a cue to the TTCue list
     */
    addCue(cue) {
        if (cue instanceof VTTCue_1.VTTCue) {
            /**
             * Step 3 : "If the given cue is in a text track list of cues, then remove
             * cue from that text track list of cues."
             * @TODO Do we need to remove the cue??
             * Specs says if the same cue exists, then remove it.
             * Cues are passed by reference, if it is duplicate should it be ignored??
             */
            this.removeCue(cue);
            LogUtils_1.LogUtil.debug(`TextTrackCueListImpl: addCue id ${cue.id} with text ${cue.text}`);
            if (!this.checkAndAppend(cue)) {
                this.textTrackCueList.splice(this.findInsertionIdx(cue), 0, cue);
            }
            this.cueMap.set(cue.id, cue);
        }
        else {
            LogUtils_1.LogUtil.error('addCue failed, only VTTCue is supported');
        }
    }
    /**
     * removes a cue from the TTCue list
     */
    removeCue(cue) {
        if (this.isEmpty()) {
            LogUtils_1.LogUtil.warn(`TextTrackCueListImpl::removeCue no cues in the list`);
            return;
        }
        if (this.cueMap.has(cue.id)) {
            this.cueMap.delete(cue.id);
            let cueIndex = this.findCueIndex(cue);
            if (cueIndex === -1) {
                // This may happen when a user modifies the cue timing and adds it
                // back. The older entry gets modified in place.
                // Binary search will fail. Try brute force to be sure.
                cueIndex = this.textTrackCueList.findIndex(vttcue => vttcue === cue || vttcue.id === cue.id);
            }
            if (cueIndex >= 0) {
                LogUtils_1.LogUtil.debug('TextTrackCueListImpl::removeCue @index : ' + cueIndex);
                this.textTrackCueList.splice(cueIndex, 1); //remove element from array
            }
            else {
                LogUtils_1.LogUtil.warn('TextTrackCueListImpl::removeCue cue list seems to be corrupt');
            }
        }
    }
    removeAllCues() {
        this.textTrackCueList.length = 0;
        this.cueMap.clear();
    }
    isEmpty() {
        return this.textTrackCueList.length === 0;
    }
    checkAndAppend(cue) {
        let appended = false;
        const num = this.textTrackCueList.length;
        if ((num === 0) ||
            (this.checkRelativePosition(this.textTrackCueList[num - 1], cue) !== "before")) {
            this.textTrackCueList[num] = cue;
            appended = true;
        }
        return appended;
    }
    /**
     * In-order cues are not guaranteed, so find the insertion index
     * https://html.spec.whatwg.org/multipage/media.html#text-track-cue-order
     * If multiple cues have the same start and end timestamps, then
     * insert this cue after the last matching cue.
     */
    findInsertionIdx(cue) {
        if (this.textTrackCueList.length === 0) {
            return 0;
        }
        let start = 0;
        let end = this.textTrackCueList.length;
        while (start < end) {
            let mid = start + ((end - start) >> 1);
            if (this.checkRelativePosition(this.textTrackCueList[mid], cue)
                === "before") {
                end = mid;
            }
            else {
                start = mid + 1;
            }
        }
        return start;
    }
    findCueIndex(cue) {
        let start = 0;
        let end = this.textTrackCueList.length;
        let firstSimilarIndex = -1;
        // There may be multiple cues with same start/end time
        while (start <= end) {
            let mid = start + ((end - start) >> 1);
            let pos = this.checkRelativePosition(this.textTrackCueList[mid], cue);
            if (pos === "before") {
                end = mid - 1;
            }
            else if (pos === "same") {
                if (cue.id === this.textTrackCueList[mid].id) {
                    // cue is found
                    return mid;
                }
                firstSimilarIndex = mid;
                end = mid - 1;
            }
            else {
                start = mid + 1;
            }
        }
        let cueIdx = -1;
        if (firstSimilarIndex >= 0) {
            // Assuming there are not too many similar cues
            for (let i = firstSimilarIndex; i < this.textTrackCueList.length; i++) {
                if (cue.id === this.textTrackCueList[i].id) {
                    cueIdx = i;
                    break;
                }
            }
        }
        return cueIdx;
    }
    checkRelativePosition(ref, cue) {
        let result = 0;
        if (ref.startTime != cue.startTime) {
            result = ref.startTime - cue.startTime;
        }
        else if (ref.endTime != cue.endTime) {
            result = ref.endTime - cue.endTime;
        }
        let relPos = "same";
        if (result > 0) {
            relPos = "before";
        }
        else if (result < 0) {
            relPos = "after";
        }
        return relPos;
    }
}
exports.TextTrackCueListImpl = TextTrackCueListImpl;

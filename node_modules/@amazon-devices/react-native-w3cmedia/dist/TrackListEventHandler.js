"use strict";
/*
 * Copyright 2022-2023 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TrackListEventHandler = void 0;
const AudioTrackImpl_1 = require("./AudioTrackImpl");
const LogUtils_1 = require("./LogUtils");
const TextTrackImpl_1 = require("./TextTrackImpl");
const W3CMediaTurboModule_1 = __importDefault(require("./turbo-modules/W3CMediaTurboModule"));
const VideoTrackImpl_1 = require("./VideoTrackImpl");
class TrackListEventHandler {
    /**
     * Handles audio track list event. It adds, removes or changes the video tracks in the
     * audio track list, and pases the event to audio track list so that it can emit it
     * to its listeners
     */
    handleAudioTrackListEvent(nativeEvent, audioTrackList, mediaElement) {
        // nativeEvent.integer has change type
        let audioTrack = undefined;
        if (!nativeEvent) {
            LogUtils_1.LogUtil.warn(`handleAudioTrackListEvent: Invalid event sent from audioTrackList`);
            return;
        }
        switch (nativeEvent.name) {
            case "change":
                {
                    LogUtils_1.LogUtil.debug(`handleAudioTrackListEvent:CHANGE : only event will be sent`);
                    audioTrack = audioTrackList.getTrackById(nativeEvent.track_id);
                }
                break;
            case "addtrack":
                {
                    LogUtils_1.LogUtil.debug(`handleAudioTrackListEvent:ADDTRACK id ${nativeEvent.track_id}`);
                    let nativeAudioTrack = W3CMediaTurboModule_1.default.getAudioTrackById(mediaElement, nativeEvent.track_id);
                    if (nativeAudioTrack) {
                        audioTrack = new AudioTrackImpl_1.AudioTrackImpl(nativeAudioTrack, mediaElement);
                        if (audioTrack) {
                            audioTrackList.addTrack(audioTrack);
                        }
                    }
                }
                break;
            case "removetrack":
                {
                    LogUtils_1.LogUtil.debug(`handleAudioTrackListEvent:REMOVETRACK id ${nativeEvent.track_id}`);
                    audioTrack = audioTrackList.getTrackById(nativeEvent.track_id);
                    ;
                    audioTrackList.removeTrack(nativeEvent.track_id);
                }
                break;
            default:
                break;
        }
        // send callback only when valid audioTrack available
        if (audioTrack) {
            audioTrackList.emitEvent(nativeEvent.name, audioTrack);
        }
    }
    /**
     * Handles video track list event. It adds, removes or changes the video tracks in the
     * video track list, and pases the event to audio track list so that it can emit it
     * to its listeners
     */
    handleVideoTrackListEvent(nativeEvent, videoTrackList, mediaElement) {
        let videoTrack = undefined;
        // nativeEvent.integer has change type
        if (!nativeEvent) {
            LogUtils_1.LogUtil.warn(`handleVideoTrackListEvent: Invalid event sent from videoTrackList`);
            return;
        }
        switch (nativeEvent.name) {
            case "change":
                {
                    LogUtils_1.LogUtil.debug(`handleAudioTrackListEvent:CHANGE : only event will be sent`);
                    videoTrack = videoTrackList.getTrackById(nativeEvent.track_id);
                }
                break;
            case "addtrack":
                {
                    LogUtils_1.LogUtil.debug(`handleVideoTrackListEvent:ADDTRACK`);
                    let nativeVideoTrack = W3CMediaTurboModule_1.default.getVideoTrackById(mediaElement, nativeEvent.track_id);
                    if (nativeVideoTrack) {
                        videoTrack = new VideoTrackImpl_1.VideoTrackImpl(nativeVideoTrack, mediaElement);
                        if (videoTrack) {
                            videoTrackList.addTrack(videoTrack);
                        }
                    }
                }
                break;
            case "removetrack":
                {
                    LogUtils_1.LogUtil.debug(`handleVideoTrackListEvent:REMOVETRACK id ${nativeEvent.track_id}`);
                    videoTrack = videoTrackList.getTrackById(nativeEvent.track_id);
                    videoTrackList.removeTrack(nativeEvent.track_id);
                }
                break;
            default:
                break;
        }
        // send callback only when valid videoTrack available
        if (videoTrack) {
            videoTrackList.emitEvent(nativeEvent.name, videoTrack);
        }
    }
    /**
     * Handles video track list event. It adds, removes or changes the video tracks in the
     * video track list, and pases the event to audio track list so that it can emit it
     * to its listeners
     */
    handleTextTrackListEvent(nativeEvent, textTrackList, mediaElement) {
        let textTrack = undefined;
        // nativeEvent.integer has change type
        if (!nativeEvent) {
            LogUtils_1.LogUtil.warn(`handleTextTrackListEvent: Invalid event sent from textTrackList`);
            return;
        }
        switch (nativeEvent.name) {
            case "change":
                {
                    LogUtils_1.LogUtil.debug(`handleAudioTrackListEvent:CHANGE : only event will be sent`);
                    textTrack = textTrackList.getTrackById(TextTrackImpl_1.TextTrackImpl.NATIVE_TRACK_ID_PREFIX + nativeEvent.track_id);
                }
                break;
            case "addtrack":
                {
                    let nativeTextTrack = W3CMediaTurboModule_1.default.getTextTrackById(mediaElement, nativeEvent.track_id);
                    if (nativeTextTrack) {
                        /**
                         * @CHECK This looks buggy.
                         * Why do we need to create TextTrackImpl to check,
                         * if the track with same id and kind, is already listed?
                         * Not touching it to avoid regression in OOBS case
                         * */
                        textTrack = new TextTrackImpl_1.TextTrackImpl(null, mediaElement, nativeTextTrack);
                        LogUtils_1.LogUtil.debug(`handleTextTrackListEvent:addtrack id created ${textTrack.id}`);
                        if (textTrack) {
                            const track = textTrackList.getTrackById(TextTrackImpl_1.TextTrackImpl.NATIVE_TRACK_ID_PREFIX + nativeEvent.track_id);
                            // This may not be required now, we can keep sending texttrack details.
                            if (track !== undefined && track !== null && track.kind === nativeTextTrack.kind) {
                                LogUtils_1.LogUtil.debug(`handleTextTrackListEvent:addtrack text track already present in the list`);
                                // Update text track mode if track was chosen by default
                                if (nativeTextTrack.mode != track.mode && nativeTextTrack.mode === "showing") {
                                    track.mode = "showing";
                                }
                                return;
                            }
                            textTrackList.addTrack(textTrack);
                        }
                    }
                }
                break;
            case "removetrack":
                {
                    LogUtils_1.LogUtil.debug(`handleTextTrackListEvent:REMOVETRACK id ${nativeEvent.track_id}`);
                    textTrack = textTrackList.getTrackById(TextTrackImpl_1.TextTrackImpl.NATIVE_TRACK_ID_PREFIX + nativeEvent.track_id);
                    textTrackList.removeTrack(TextTrackImpl_1.TextTrackImpl.NATIVE_TRACK_ID_PREFIX + nativeEvent.track_id);
                }
                break;
            default:
                break;
        }
        // send callback only when valid textTrack available
        if (textTrack) {
            textTrackList.emitEvent(nativeEvent.name, textTrack);
        }
    }
}
exports.TrackListEventHandler = TrackListEventHandler;

"use strict";
/*
 * Copyright (c) 2024 Amazon.com, Inc. or its affiliates.  All rights reserved.
 *
 * PROPRIETARY/CONFIDENTIAL.  USE IS SUBJECT TO LICENSE TERMS.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
//Referenced {SeekBar,ProgressBar} folder from  - https://tiny.amazon.com/10ftogofw/KeplerComponentLibrary
const react_1 = __importStar(require("react"));
const react_native_1 = require("react-native");
const react_native_kepler_1 = require("@amazon-devices/react-native-kepler");
const ProgressBar_1 = __importDefault(require("../ProgressBar/ProgressBar"));
const tokenResolver_slider_1 = require("./tokenResolver.slider");
/**
 * Renders a Slider component specific to the SeekBar, that allows users to
 * track and control the Slider value by interacting with the Slider's thumb.
 *
 * @returns Slider component
 */
const Slider = ({ disabled = false, currentValue, totalValue, onValueChange, onSlidingStart, onSlidingEnd, onRewindPress, onFastForwardPress, onFocus, onBlur, onPress, step, markers, displayAboveThumb, displayBelowThumb, thumbIcon, barStyle, barTrackColor, currentValueIndicatorColor, currentValueIndicatorStyle, timeShiftIndicatorStyle: timeShiftIndicatorStyleOverride, longPressIntervalDuration }) => {
    const thumbContainerStyle = (0, tokenResolver_slider_1.resolveThumbContainerTokens)();
    const timeShiftIndicatorStyle = (0, tokenResolver_slider_1.resolveTimeShiftIndicatorTokens)();
    const centeredNodeStyle = (0, tokenResolver_slider_1.resolveCenteredNodeTokens)();
    const barContainerStyle = (0, tokenResolver_slider_1.resolveBarContainerTokens)();
    const markerStyle = (0, tokenResolver_slider_1.resolveMarkerTokens)();
    const progressBarStyle = (0, tokenResolver_slider_1.resolveProgressBarTokens)();
    const keyPressTimeout = (0, react_1.useRef)(0);
    const longPressInterval = (0, react_1.useRef)(0);
    const [thumbValue, setThumbValue] = (0, react_1.useState)(currentValue);
    const [barWidth, setBarWidth] = (0, react_1.useState)(0);
    const [barHeight, setBarHeight] = (0, react_1.useState)(0);
    const [focused, setFocused] = (0, react_1.useState)(false);
    const translateXVal = (0, react_1.useRef)(new react_native_1.Animated.Value(0));
    const DEFAULT_LONG_PRESS_INITIAL_DELAY = 1500;
    const DEFAULT_LONG_PRESS_INTERVAL_DURATION = 300;
    const DEFAULT_STEP = 10000;
    const stepValue = (0, react_1.useRef)(step === 0 ? 0 : step || DEFAULT_STEP);
    const keyIsHeld = react_1.default.useRef(false);
    const onPressHandler = () => {
        resetKeyPressDependencies();
        onPress?.(thumbValue);
    };
    const handleKeyPress = (key) => {
        if (stepValue.current === 0) {
            return;
        }
        const adjustedStep = key === 'left' ? -stepValue.current : stepValue.current;
        setThumbValue((previousThumbValue) => {
            let thumbValue = previousThumbValue;
            if (previousThumbValue + adjustedStep < 0) {
                thumbValue = 0;
            }
            else if (previousThumbValue + adjustedStep > totalValue) {
                thumbValue = totalValue;
            }
            else {
                thumbValue = previousThumbValue + adjustedStep;
            }
            translateXVal.current = new react_native_1.Animated.Value(normalizeToXPosition(thumbValue, totalValue, barWidth));
            return thumbValue;
        });
    };
    const handleLongPress = (key) => {
        clearInterval(longPressInterval.current);
        // @ts-ignore
        longPressInterval.current = setInterval(() => {
            handleKeyPress(key);
        }, longPressIntervalDuration || DEFAULT_LONG_PRESS_INTERVAL_DURATION);
    };
    const resetKeyPressDependencies = () => {
        clearInterval(longPressInterval.current);
        clearTimeout(keyPressTimeout.current);
    };
    (0, react_native_kepler_1.useTVEventHandler)(({ eventType, eventKeyAction }) => {
        if (disabled) {
            resetKeyPressDependencies();
            return;
        }
        if (eventKeyAction === 1) {
            keyIsHeld.current = false;
        }
        if (focused && (eventType === "left" || eventType === "right")) {
            if (eventKeyAction === 1) {
                onSlidingEnd?.();
                resetKeyPressDependencies();
                return;
            }
            if (eventKeyAction !== 0 || keyIsHeld.current)
                return;
            resetKeyPressDependencies();
            onSlidingStart?.();
            handleKeyPress(eventType);
            // @ts-ignore
            keyPressTimeout.current = setTimeout(() => {
                handleLongPress(eventType);
            }, DEFAULT_LONG_PRESS_INITIAL_DELAY);
            keyIsHeld.current = true;
        }
    });
    (0, react_1.useEffect)(() => {
        if (step === 0) {
            stepValue.current = 0;
        }
        else {
            stepValue.current = step || DEFAULT_STEP;
        }
    }, [step]);
    (0, react_1.useEffect)(() => {
        onValueChange?.(thumbValue);
    }, [thumbValue]);
    (0, react_1.useEffect)(() => {
        if (currentValue !== undefined) {
            setThumbValue(currentValue);
            translateXVal.current = new react_native_1.Animated.Value(normalizeToXPosition(currentValue, totalValue, barWidth));
        }
    }, [currentValue]);
    (0, react_1.useEffect)(() => {
        return () => {
            resetKeyPressDependencies();
            keyIsHeld.current = false;
        };
    }, []);
    return (<react_native_1.Pressable onFocus={() => {
            onFocus?.();
            setFocused(true);
        }} onBlur={() => {
            onBlur?.();
            setFocused(false);
        }} onPress={onPressHandler} disabled={disabled}>
        <react_native_1.Animated.View style={[
            centeredNodeStyle,
            {
                opacity: barWidth !== 0 ? 1 : 0,
                transform: [{ translateX: translateXVal.current }]
            }
        ]}>
          {displayAboveThumb}
        </react_native_1.Animated.View>
        <react_native_1.View style={barContainerStyle}>
          <react_native_1.View onLayout={({ nativeEvent }) => {
            const { width, height } = nativeEvent.layout;
            setBarWidth(width);
            setBarHeight(height);
            translateXVal.current = new react_native_1.Animated.Value(normalizeToXPosition(currentValue, totalValue, width));
        }} style={progressBarStyle}>
            <ProgressBar_1.default barStyle={[{ width: 1850 }, barStyle]} progress={(currentValue / totalValue) * 100} animationDuration={0} indicatorStyle={currentValueIndicatorStyle} indicatorColor={currentValueIndicatorColor} trackColor={barTrackColor}/>
            <react_native_1.Animated.View style={[
            timeShiftIndicatorStyle,
            timeShiftIndicatorStyleOverride,
            {
                height: barHeight,
                width: Math.abs(normalizeToXPosition(thumbValue, totalValue, barWidth) -
                    normalizeToXPosition(currentValue, totalValue, barWidth))
            },
            {
                transform: [
                    {
                        translateX: thumbValue >= currentValue
                            ? normalizeToXPosition(currentValue, totalValue, barWidth)
                            : normalizeToXPosition(thumbValue, totalValue, barWidth)
                    }
                ]
            }
        ]}/>
          </react_native_1.View>
          {barWidth !== 0 &&
            markers !== undefined &&
            markers.map((marker) => (<react_native_1.View key={marker.position} style={[
                    markerStyle,
                    {
                        height: barHeight,
                        transform: [
                            { translateX: (marker.position / totalValue) * barWidth }
                        ]
                    }
                ]}>
                {marker.node}
              </react_native_1.View>))}
          {focused ? <react_native_1.Animated.View style={[
                centeredNodeStyle,
                thumbContainerStyle,
                {
                    opacity: barWidth === 0 ? 0 : 1,
                    transform: [
                        {
                            translateX: translateXVal.current
                        }
                    ]
                }
            ]}>
            {thumbIcon !== undefined ? thumbIcon : <DefaultThumbIcon />}
          </react_native_1.Animated.View> : null}
        </react_native_1.View>
        <react_native_1.Animated.View style={[
            centeredNodeStyle,
            {
                opacity: barWidth !== 0 ? 1 : 0,
                transform: [{ translateX: translateXVal.current }]
            }
        ]}>
          {displayBelowThumb}
        </react_native_1.Animated.View>
      </react_native_1.Pressable>);
};
const DefaultThumbIcon = () => {
    const thumbDotStyle = (0, tokenResolver_slider_1.resolveThumbDotTokens)();
    return <react_native_1.View style={thumbDotStyle}/>;
};
const normalizeToXPosition = (value, totalValue, barWidth) => {
    return (value / totalValue) * barWidth;
};
exports.default = Slider;

"use strict";
/*
 * Copyright 2023-2025 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MimeTypeRegistry = exports.UNKNOWN_SHAKA_MIME = void 0;
const keplermediadescriptor_1 = require("@amazon-devices/keplermediadescriptor");
const LogUtils_1 = require("../LogUtils");
const MimeUtils_1 = require("../mimeparser/MimeUtils");
const aacCodecs = ["mp4a.66", "mp4a.67", "mp4a.68", "mp4a.40.2", "mp4a.40.02",
    /* AAC LC + SBR*/ "mp4a.40.5", "mp4a.40.05", /* AAC LC + SBR + PS */ "mp4a.40.29",
    /*backward compatible mpeg surround*/ "mp4a.40.30",
    "mp4a.40.42", // Extended HE-AAC (added according to shaka mapping)
];
const mp3Codecs = ["mp4a.69", "mp4a.6B", "mp4a.40.34"];
const ac3Codecs = ["ac3", "ac-3", "mp4a.a5", "mp4a.A5"];
const eac3Codecs = ["mp4a.a6", "mp4a.A6", "eac3", "ec-3"];
// List of supported Codecs for each mimeType
// vp9, vp8, av1
const supportedVideoWebmCodecs = ["vp08", "vp09", "av01", "vp8", "vp9", "av1"];
const supportedAudioWebmCodecs = ["vorbis", "opus"];
// mpeg4, mvc.
const supported3GPVideoCodecs = ["hev1", "hvc1", "avc1", "avc3", "s263", "mvc1", "mvc2", "mvc3", "mvc4", "h263"];
const supported3GPAudioCodecs = ["samr", "sawb", "sawp"];
// Î¼-law PCM
const supportedOGGAudioCodecs = ["theora", "h263", "Opus", "vorbis", "fLaC", "alaw", "fpcm"];
// TODO: mpeg 1/2 video
//  mp2, mp1, wma lossy/lossless, ulaw pcm, IEEE pcm,
const supportedAVIVideoCodecs = ["avc1", "avc3", "hev1", "hvc1", "h263", "vp09", "vp08", "vc-1"];
const supportedAVIAudioCodecs = ["samr", "sawb", "sawp", "Opus", "fLaC", "alac", "lpcm", "alaw", "dts+", "dts-"].concat(mp3Codecs).concat(ac3Codecs);
// TODO:, mpeg1/2 video
const supportedQuickTimeVideoCodecs = ["avc1", "avc3", "hev1", "hvc1", "h263", "vc-1", "drac"];
// TODO: ulaw pcm
const supportedQuickTimeAudioCodecs = ["Opus", "alac", "lpcm", "alaw", "fpcm", "dtsc", "dtse", "dtsh", "dtsl"].concat(aacCodecs).concat(ac3Codecs).concat(eac3Codecs);
// TODO: mpeg1/2 video, h263,
const supportedVideoMp4Codecs = ["avc1", "avc3", "hev1", "hvc1", "av01", "vp08", "vp09", "mp4v"];
// mp2, mp1, als, sls, dv audio,
const supportedAudioMp4Codecs = ["Opus", "fLaC", "dts+", "dts-", "dtsc", "dtse", "dtsh", "dtsl", "alac", "mlpa", "lpcm", "samr", "sawb"].concat(mp3Codecs).concat(aacCodecs).concat(ac3Codecs).concat(eac3Codecs);
// mpeg-1 video (261?), mpeg-2 video (h.262), mpeg-4 visual
const supportedVideoMP2TCodecs = ["hvc1", "hev1", "avc1", "avc3"];
// mp2, mp1, als, sls
const supportedAudioMP2TCodecs = ["Opus"].concat(mp3Codecs).concat(aacCodecs);
// TODO: JIRA-206965, introduce an IDL api to get the container support.
// https://w3c.github.io/mse-byte-stream-format-registry/#registry
const supportedVideoContainers = ["video/mp4", "video/webm", "video/ogg", "video/mpeg", "video/avi", "video/quicktime", "video/3gpp", "video/x-matroska", "video/mp2t"];
const supportedAudioContainers = ["audio/mp4", "audio/webm", "audio/ogg", "audio/mpeg", "audio/aac",
    "audio/ac3", "audio/x-ac3", "audio/flac", "audio/x-flac", "audio/mp2t"];
// check https://chromium.googlesource.com/chromium/src/media/+/refs/heads/main/base/mime_util_internal.cc [1] on how to parse including
// the profile levels.
// got these values from  https://mp4ra.org/registered-types/codecs [2] which has all the registered codec types
const knownVideoCodecs = ["a3d1", "a3d2", "a3d3", "a3d4", "av1", "av01", "avc1", "avc2", "avc3", "avc4",
    "avcp", "avst", "avs3", "camm", "dav1", "drac", "dva1", "dvav", "dvh1",
    "dvhe", "encv", "evc1", "evm1", "evs1", "evs2", "FFV1", "hev1", "hev2",
    "hev3", "hvc1", "hvc2", "hvc3", "hvt1", "hvt2", "hvt3", "icpv", "j2ki",
    "jxsm", "lhe1", "lht1", "lhv1", "mjp2", "mjpg", "mp4v", "mvc1", "mvc2",
    "mvc3", "mvc4", "mvd1", "mvd2", "mvd3", "mvd4", "resv", "rv60", "s263",
    "svc1", "svc2", "vc-1", "vp08", "vp09", "vvcN", "vvc1", "vvi1", "vvs1",
    "cndm", "lvc1",
    "vp8", "vp9", "h263"]; // missing in [2] but mentioned in [1]
const knownAudioCodecs = ["a3ds", "ac-3", "ac-4", "alac", "alaw", "cavs", "dra1", "dts+", "dts-",
    "dtsc", "dtse", "dtsh", "dtsl", "dtsx", "dtsy", "ec-3", "ec+3", "enca",
    "fLaC", "g719", "g726", "m4ae", "mha1", "mha2", "mhm1", "mhm2", "mlpa",
    "mp4a", "Opus", "raw$20", "samr", "sawb", "sawp", "sevc", "sevs", "sqcp",
    "ssmv", "twos", "ulaw", "iamf", "ipcm", "fpcm", "apac",
    "mp3", "vorbis", "theora"]; // not available in [2] but mentioned in [1]
exports.UNKNOWN_SHAKA_MIME = "video";
const containerMapping = new Map([
    ["video/mp4", {
            video: supportedVideoMp4Codecs,
            audio: supportedAudioMp4Codecs
        }],
    ["video/webm", {
            video: supportedVideoWebmCodecs,
            audio: supportedAudioWebmCodecs,
        }],
    ["video/ogg", {
            video: supportedOGGAudioCodecs,
            audio: supportedOGGAudioCodecs,
        }],
    ["video/mpeg", {
            video: [],
            audio: [] // TODO
        }],
    ["video/avi", {
            video: supportedAVIVideoCodecs,
            audio: supportedAVIAudioCodecs,
        }],
    ["video/quicktime", {
            video: supportedQuickTimeVideoCodecs,
            audio: supportedQuickTimeAudioCodecs,
        }],
    ["video/3gpp", {
            video: supported3GPVideoCodecs,
            audio: supported3GPAudioCodecs
        }],
    ["video/mp2t", {
            video: supportedVideoMP2TCodecs,
            audio: supportedAudioMP2TCodecs
        }],
    ["video/x-matroska", {
            video: supportedVideoWebmCodecs,
            audio: supportedAudioWebmCodecs
        }],
    ["audio/mp4", {
            audio: supportedAudioMp4Codecs,
        }],
    ["audio/webm", {
            audio: supportedAudioWebmCodecs,
        }],
    ["audio/ogg", {
            audio: supportedOGGAudioCodecs,
        }],
    ["audio/mpeg", {
            audio: [], // audio/mpeg is not supposed to have "codecs" parameter
        }],
    ["audio/aac", {
            audio: [], // audio/aac is not supposed to have "codecs" parameter
        }],
    ["audio/ac3", {
            audio: ac3Codecs,
        }],
    ["audio/x-ac3", {
            audio: ac3Codecs,
        }],
    ["audio/flac", {
            audio: ["fLaC"],
        }],
    ["audio/x-flac", {
            audio: ["fLaC"],
        }],
    ["audio/mp2t", {
            audio: supportedAudioMP2TCodecs,
        }],
]);
// Enforce list is based on individual specs listed at
// https://www.w3.org/TR/mse-byte-stream-format-registry/#registry
// Note: specs under this only mentions isTypeSupported() and addSourceBuffer() but not changeType()
const codecParamEnforcedContainers = ["audio/webm", "video/webm"];
class MimeTypeRegistry {
    static checkSupportedVideoContainers(mimeType) {
        return supportedVideoContainers.includes(mimeType);
    }
    static checkSupportedAudioContainers(mimeType) {
        return supportedAudioContainers.includes(mimeType);
    }
    static checkSupportedVideoWebmCodecs(codecsArray) {
        for (let i = 0; i < codecsArray.length; i++) {
            const codec = codecsArray[i];
            if (!supportedVideoWebmCodecs.includes(codec)) {
                LogUtils_1.LogUtil.info(`MimeTypeRegistry: codec:${codec} is not supported for video/webm`);
                return false;
            }
        }
        return true;
    }
    static checkSupportedVideoMp4Codecs(codecsArray) {
        for (let i = 0; i < codecsArray.length; i++) {
            const codec = codecsArray[i];
            if (!supportedVideoMp4Codecs.includes(codec)) {
                LogUtils_1.LogUtil.error(`MimeTypeRegistry: codec:${codec} is not supported for video/mp4`);
                return false;
            }
        }
        return true;
    }
    static checkSupportedAudioWebmCodecs(codecsArray) {
        for (let i = 0; i < codecsArray.length; i++) {
            const codec = codecsArray[i];
            if (!supportedAudioWebmCodecs.includes(codec)) {
                LogUtils_1.LogUtil.error(`MimeTypeRegistry: codec:${codec} is not supported for audio/webm`);
                return false;
            }
        }
        return true;
    }
    static checkSupportedAudioMp4Codecs(codecsArray) {
        for (let i = 0; i < codecsArray.length; i++) {
            const codec = codecsArray[i];
            if (!supportedAudioMp4Codecs.includes(codec)) {
                LogUtils_1.LogUtil.error(`MimeTypeRegistry: codec:${codec} is not supported for audio/mp4`);
                return false;
            }
        }
        return true;
    }
    static isKnownVideoCodec(codec) {
        for (let index = 0; index < knownVideoCodecs.length; index++) {
            const mime = knownVideoCodecs[index];
            if (codec.startsWith(mime)) {
                return true;
            }
        }
        return false;
    }
    static isKnownAudioCodec(codec) {
        for (let index = 0; index < knownAudioCodecs.length; index++) {
            const mime = knownAudioCodecs[index];
            if (codec.startsWith(mime)) {
                return true;
            }
        }
        return false;
    }
    static isCodecSupportedByPlatform(isAudio, codec) {
        let config = isAudio ? new keplermediadescriptor_1.AudioDecoderConfig() : new keplermediadescriptor_1.VideoDecoderConfig();
        let profileLevel = new keplermediadescriptor_1.MediaFormatProfileLevel(codec);
        config.formatProfileLevel = profileLevel;
        let caps = keplermediadescriptor_1.KeplerMediaDescriptor.queryMediaCapabilitiesSync(config);
        if (caps.length <= 0) {
            LogUtils_1.LogUtil.error(codec, " is not supported by platform");
            return false;
        }
        return true;
    }
    static checkCodecParamForEnforcedContainers(mimeType) {
        let supportedCodecs = containerMapping.get(mimeType.essence);
        let isContainerType = supportedCodecs != undefined;
        let codecsStr = mimeType.getParameter("codecs");
        let codecsArray = codecsStr === undefined ? [] : codecsStr.split(",");
        if (isContainerType && codecParamEnforcedContainers.includes(mimeType.essence) &&
            codecsArray.length === 0) {
            LogUtils_1.LogUtil.error("The mime type doesnt imply a codec but has no parameters");
            return false;
        }
        return true;
    }
    static checkSupportedType(mimeType) {
        let supportedCodecs = containerMapping.get(mimeType.essence);
        let isContainerType = supportedCodecs != undefined;
        let isAudio = mimeType.type === "audio";
        let codecsStr = mimeType.getParameter("codecs");
        let codecsArray = codecsStr === undefined ? [] : codecsStr.split(",");
        if (!isContainerType) {
            let possibleCodec = mimeType.subType;
            if (isAudio && !(possibleCodec in knownAudioCodecs)) {
                // this is not container type and the codec in subtype is not valid
                LogUtils_1.LogUtil.error("not a valid audio codec");
                return false;
            }
            if (!isAudio && !(possibleCodec in knownVideoCodecs)) {
                // this is not container type and the codec in subtype is not valid
                LogUtils_1.LogUtil.error("not a valid video codec");
                return false;
            }
            if (mimeType.getParameterCount() !== 0) {
                // https://www.w3.org/TR/mse-byte-stream-format-mpeg-audio/#mime-types
                LogUtils_1.LogUtil.error("The mime type implies a codec but has parameters");
                return false;
            }
            codecsArray = [possibleCodec];
        }
        // TODO: JIRA-206965, introduce an IDL api to get the container support.
        // We dont support audio/mpeg. Such info should be coming from the nfp side.
        if (mimeType.essence === "audio/aac") {
            // https://www.w3.org/TR/mse-byte-stream-format-mpeg-audio/#mime-types
            if (codecsArray.length !== 0) {
                return false;
            }
            return true;
        }
        for (let index = 0; index < codecsArray.length; index++) {
            const codec = (0, MimeUtils_1.removeLeadingAndTrailingHTTPWhitespace)(codecsArray[index]);
            let foundCodec = false;
            // Check for audio codec support.
            for (let index = 0; index < supportedCodecs.audio.length; index++) {
                const element = supportedCodecs.audio[index];
                // Need to have exact match for audio since mp3 and aac codecs just differ in profile values
                if (codec === element) {
                    foundCodec = true;
                    if (!MimeTypeRegistry.isCodecSupportedByPlatform(true, codec)) {
                        return false;
                    }
                }
            }
            if (supportedCodecs.video == undefined) {
                if (!foundCodec) {
                    LogUtils_1.LogUtil.error("the container only supports audio codecs. Either ", codec, " is not a supported audio codec or its a video codec. Returning false");
                    return false;
                }
                continue;
            }
            // check for video codec support.
            for (let index = 0; index < supportedCodecs.video?.length; index++) {
                const element = supportedCodecs.video[index];
                // we dont match the profile values here, let KMD take care of it.
                if (codec.startsWith(element)) {
                    foundCodec = true;
                    if (!MimeTypeRegistry.isCodecSupportedByPlatform(false, codec)) {
                        return false;
                    }
                }
            }
            if (!foundCodec) {
                LogUtils_1.LogUtil.error("The requested combination of container", mimeType.essence, " and codec ", codec, "is not supported");
                return false;
            }
        }
        LogUtils_1.LogUtil.info(`${codecsArray} is supported`);
        return true;
    }
}
exports.MimeTypeRegistry = MimeTypeRegistry;

"use strict";
/*
 * Copyright 2022-2025 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaSource = exports.GlobalMediaSources = void 0;
const LogUtils_1 = require("../LogUtils");
const MediaEventEmitterImpl_1 = require("../MediaEventEmitterImpl");
const SourceBufferImpl_1 = require("../SourceBufferImpl");
const SourceBufferListImpl_1 = require("../SourceBufferListImpl");
const W3CMediaTurboModule_1 = __importDefault(require("../turbo-modules/W3CMediaTurboModule"));
const EventTargetInterface_1 = require("./EventTargetInterface");
const keplermediadescriptor_1 = require("@amazon-devices/keplermediadescriptor");
const MediaSourceInterface_1 = require("./MediaSourceInterface");
const MediaErrorImpl_1 = require("../MediaErrorImpl");
const MimeTypeRegistry_1 = require("../constants/MimeTypeRegistry");
const EventAttributes_1 = require("../EventAttributes");
const MimeType_1 = require("../mimeparser/MimeType");
const MimeUtils_1 = require("../mimeparser/MimeUtils");
const CodecProfileLevelParser_1 = require("../mimeparser/CodecProfileLevelParser");
const DEFAULT_BUFFER_APPEND_CHUNK_SIZE = 128 * 1024;
const DEFAULT_EVICTION_THRESHOLD = 100 * 1024 * 1024;
const EOS_NETWORK_ERROR = "network";
const EOS_DECODE_ERROR = "decode";
// Size of the string "codecs=". The size of codecs value might be different.
const SIZE_OF_CODECS_ATTRIBUTE = 7;
/**
 * @hidden
 */
class BlobData {
    blobId = 0;
    offset = 0;
}
/**
 * @hidden
 */
exports.GlobalMediaSources = new Map();
/**
 * Implements the `MediaSource` interface. It uses `EventEmitter` to emit events.
 * Maintains a list of `SourceBuffers` object and Active Source buffers.
 */
class MediaSource extends EventAttributes_1.EventAttributes {
    eventEmitter;
    mediaElement;
    readyState_;
    mediaElementEventRouter;
    sourceBuffersList = new SourceBufferListImpl_1.SourceBufferListImpl();
    activeSourceBuffersList = new SourceBufferListImpl_1.SourceBufferListImpl();
    static idGen = 1;
    id;
    _onsourceopen;
    _onsourceended;
    _onsourceclose;
    constructor() {
        LogUtils_1.LogUtil.info("MediaSource:+constructor");
        const _eventEmitter = new MediaEventEmitterImpl_1.MediaEventEmitterImpl();
        super(_eventEmitter);
        this.eventEmitter = _eventEmitter;
        this.canConstructInDedicatedWorker = true;
        /**
         *  When the `MediaSource` is created readyState must be set to "closed".
         *  Indicates that the source is not currently attached to a media element.
         *  For additional information, see
         *  https://www.w3.org/TR/2016/REC-media-source-20161117/#attributes
        */
        this.readyState_ = MediaSourceInterface_1.ReadyState.closed;
        this.mediaElement = null;
        this.mediaElementEventRouter = null;
        this.id = MediaSource.idGen++;
        this.data = new BlobData();
        this.data.blobId = this.id;
        exports.GlobalMediaSources.set(this.id, this);
        LogUtils_1.LogUtil.info(`MediaSource[${this.id}]:-constructor: ${this.id}`);
    }
    /**
     * @hidden
     */
    static install() {
        // TODO: using node in tsconfig.json fails compilation in yocto.
        // If we tried to fix it, DRM playback doesn't happen. Needs more deep dive.
        // Temporarily moving these polyfills back to app
        // (global as any).window.MediaSource = MediaSource;
        // (global as any).MediaSource = MediaSource;
        // LogUtil.info("xpoly, installing MediaSource polyfills");
    }
    /**
     * @hidden
     */
    size = 0;
    /**
     * @hidden
     */
    type = "mediasource";
    /**
     * @hidden
     */
    data;
    /**
     * @hidden
     */
    slice(start, end) {
        // @ts-ignore
        return this;
    }
    /**
     * @hidden
     */
    setMediaElementHandle(mediaElement) {
        LogUtils_1.LogUtil.info(`MediaSource[${this.id}]:+setMediaElementHandle `);
        this.mediaElement = mediaElement;
        W3CMediaTurboModule_1.default.createAndAttachMediaSource(this.mediaElement);
        /**
         * The source has been opened by a media element and is ready for data to be
         * appended to the SourceBuffer objects in sourceBuffers.
         *  For additional information, see
         * https://www.w3.org/TR/media-source-2/#dom-readystate-open/
         */
        if (this.mediaElement) {
            this.transitionToState(MediaSourceInterface_1.ReadyState.open);
        }
    }
    /**
     * @hidden
     */
    setMediaEventRouter(mediaElementEventRouter) {
        LogUtils_1.LogUtil.info(`MediaSource[${this.id}]:setMediaEventRouter`);
        // register media source with media element event router
        mediaElementEventRouter?.registerMediaSource(this);
        this.mediaElementEventRouter = mediaElementEventRouter;
    }
    // EventTarget APIs
    addEventListener(type, listener, options) {
        LogUtils_1.LogUtil.info(`MediaSource[${this.id}]:addEventListener: ${type}`);
        this.eventEmitter.addListener(type, listener);
    }
    removeEventListener(type, listener, options) {
        LogUtils_1.LogUtil.info(`MediaSource[${this.id}]:removeEventListener: ${type}`);
        this.eventEmitter.removeListener(type, listener);
    }
    /**
     * @hidden
     * Currently, addsourcebuffer and removesourcebuffer doesn't give us the
     * id of the source buffers. So when we get a add or remove source buffer event
     * on active source buffer we will re-build the list from turbo module.
     * @note: This thing needs to be re-designed as there could be synchronization problems
     * leading to mismatch in the list maintained by native or crash in app while accessing
     * activeSourceBuffers
     */
    rebuildActiveSourceBuffersList() {
        LogUtils_1.LogUtil.info(`MediaSource[${this.id}]:rebuildActiveSourceBuffersList`);
        let activeSourceBufferIds;
        if (this.mediaElement != null) {
            activeSourceBufferIds = W3CMediaTurboModule_1.default.getActiveSourceBuffers(this.mediaElement);
        }
        if (activeSourceBufferIds === undefined) {
            return;
        }
        // remove all source buffers from active source buffers list
        LogUtils_1.LogUtil.info(`MediaSource[${this.id}]:clearing list`);
        this.activeSourceBuffersList.clear();
        // now loop through all the active source buffer ids and add them to the
        // active source buffer list. We are following the order of the source buffers
        // as maintained natively, and hoping that it matches the source buffer list.
        // As pe spec, https://www.w3.org/TR/media-source-2/#dom-mediasource-activesourcebuffers
        // "SourceBuffer objects in this list MUST appear in the same order as they appear
        // in the sourceBuffers attribute; e.g., if only sourceBuffers[0] and sourceBuffers[3]
        // are in activeSourceBuffers, then activeSourceBuffers[0] MUST equal sourceBuffers[0]
        // and activeSourceBuffers[1] MUST equal sourceBuffers[3]."
        activeSourceBufferIds.forEach((id) => {
            LogUtils_1.LogUtil.info(`MediaSource[${this.id}]:finding source buffer for ${id}`);
            // find the source buffer based on id in source buffer list
            // and add it to active source buffer list
            for (let i = 0; i < this.sourceBuffersList.length; i++) {
                if (id === this.sourceBuffersList.getSourceBuffer(i).getId()) {
                    // found the source buffer. now add it to the active buffers list
                    this.activeSourceBuffersList.addSourceBuffer(this.sourceBuffersList.getSourceBuffer(i));
                }
            }
            ;
        });
    }
    /**
     * @hidden
     * Handle events from native turbo module
     */
    handleEvent(eventName) {
        if (eventName === "sourceopen") {
            if (this.readyState_ === MediaSourceInterface_1.ReadyState.ended) {
                this.transitionToState(MediaSourceInterface_1.ReadyState.open);
            }
            return;
        }
        else if (eventName === "sourceended") {
            if (this.readyState_ === MediaSourceInterface_1.ReadyState.open) {
                this.transitionToState(MediaSourceInterface_1.ReadyState.ended);
            }
            else {
                return;
            }
        }
        else if (this.mediaElement != null) { // "addsourcebuffer" or "removesourcebuffer"
            this.rebuildActiveSourceBuffersList();
        }
        this.eventEmitter.emit(eventName, new EventTargetInterface_1.Event(eventName, this));
    }
    canConstructInDedicatedWorker;
    /**
     * Gets the source buffers added to the media source.
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-mediasource-sourcebuffers.
     */
    get sourceBuffers() {
        return this.sourceBuffersList;
    }
    /**
     * Gets the active source buffers of mediasource.
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-mediasource-activesourcebuffers.
     */
    get activeSourceBuffers() {
        return this.activeSourceBuffersList;
    }
    /**
     * Gets the ready state of MediaSource.
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-mediasource-readystate.
     */
    get readyState() {
        // TODO: Currently NFP doesn't support MediaSource's ready state.
        return this.readyState_;
    }
    /**
     * Gets the duraton of the content.
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-mediasource-duration.
     */
    get duration() {
        // https://www.w3.org/TR/media-source-2/#dom-mediasource-duration
        // If the readyState attribute is "closed" then return NaN and abort these steps.
        if (!this.mediaElement || this.readyState_ === MediaSourceInterface_1.ReadyState.closed) {
            return NaN;
        }
        return W3CMediaTurboModule_1.default.getDuration(this.mediaElement);
    }
    /**
     * Sets the duraton of the content.
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-mediasource-duration.
     */
    set duration(duration) {
        // https://www.w3.org/TR/media-source-2/#dom-mediasource-duration
        // If the value being set is negative or NaN then throw a TypeError exception
        // and abort these steps.
        if (duration < 0 || Number.isNaN(duration)) {
            throw new TypeError("Not applicable duration value");
        }
        // If the readyState attribute is not "open" then throw an InvalidStateError
        // exception and abort these steps.
        if (!this.mediaElement || this.readyState_ !== MediaSourceInterface_1.ReadyState.open) {
            LogUtils_1.LogUtil.error(`MediaSource::set duration mediaElement is empty or readyState is not 'open'`);
            throw new MediaErrorImpl_1.InvalidStateError("no media element attached");
        }
        // If any of the sourcebuffer 'updating' is true then
        // throw an InvalidStateError exception
        for (let i = 0; i < this.sourceBuffersList.length; i++) {
            if (this.sourceBuffersList.getSourceBuffer(i).updating) {
                throw new MediaErrorImpl_1.InvalidStateError("set duration throws an exception when updating attribute is true.");
            }
        }
        W3CMediaTurboModule_1.default.setDuration(this.mediaElement, duration);
    }
    /**
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-mediasource-onsourceopen
     */
    set onsourceopen(listener) {
        this.addEvent(this._onsourceopen, "sourceopen", listener);
    }
    /**
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-mediasource-onsourceended
     */
    set onsourceended(listener) {
        this.addEvent(this._onsourceended, "sourceended", listener);
    }
    /**
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-mediasource-onsourceclose
     */
    set onsourceclose(listener) {
        this.addEvent(this._onsourceclose, "sourceclose", listener);
    }
    /**
     * Get max supported resolution based on the decoder profile.
     */
    getMaxSupportedResolution(mimestr) {
        let resolution = { width: 0, height: 0 };
        let mimeType = MimeType_1.MimeType.parseMimeString(mimestr);
        if (!mimeType || mimeType.type !== "video") {
            LogUtils_1.LogUtil.info(`Invalid mimeType or not a video mimeType`);
            return resolution;
        }
        let codecStr = mimeType.getParameter("codecs");
        let codecsArray = codecStr === undefined ? [] : codecStr.split(",");
        if (codecsArray.length == 0 && mimeType.subType) {
            let possibleCodec = mimeType.subType;
            LogUtils_1.LogUtil.info(`MediaSource: mimeType codecStr was invalid or empty,using mimeType.subType = ${possibleCodec}`);
            codecsArray = [possibleCodec];
        }
        for (let index = 0; index < codecsArray.length; index++) {
            let codec = (0, MimeUtils_1.removeLeadingAndTrailingHTTPWhitespace)(codecsArray[index]);
            if (!codec || !MimeTypeRegistry_1.MimeTypeRegistry.isKnownVideoCodec(codec)) {
                continue;
            }
            let codecInfo = (0, CodecProfileLevelParser_1.parseCodecMime)(codec, "");
            if (!codecInfo) {
                continue;
            }
            const decoderConfig = new keplermediadescriptor_1.VideoDecoderConfig();
            let mediaFormat = new keplermediadescriptor_1.MediaFormat(codecInfo.codec);
            decoderConfig.mediaFormat = mediaFormat;
            let videoCaps = keplermediadescriptor_1.KeplerMediaDescriptor.queryMediaCapabilitiesSync(decoderConfig);
            for (let index = 0; index < videoCaps.length; index++) {
                let videoCapability = videoCaps[index];
                let resolutions = videoCapability.videoFormatCapabilities.resolutions;
                resolution.width = Math.max(resolution.width, resolutions[1].width);
                resolution.height = Math.max(resolution.height, resolutions[1].height);
            }
        }
        return resolution;
    }
    /**
     * Adds a SourceBuffer to the media source based on mime type.
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-mediasource-addsourcebuffer.
     * @param type The mime type of data sent to source buffer.
     */
    addSourceBuffer(type) {
        LogUtils_1.LogUtil.info(`MediaSource[${this.id}]::addSourceBuffer: ${type}`);
        // Spec Refence:  https://www.w3.org/TR/media-source-2/#dom-mediasource-addsourcebuffer
        // 1. If type is an empty string then throw a TypeError exception and abort these steps.
        if (typeof type !== "string") {
            LogUtils_1.LogUtil.error(`MediaSource::addSourceBuffer: type is not string`);
            throw new MediaErrorImpl_1.NotSupportedError("addSourcebuffer: 'type' expected to be string but got null");
        }
        if (type === "") {
            LogUtils_1.LogUtil.error(`MediaSource::addSourceBuffer: empty type`);
            throw new TypeError("empty type");
        }
        // 2. If type contains a MIME type that is not supported or contains a MIME type that
        //  is not supported with the types specified for the other SourceBuffer objects in sourceBuffers,
        // then throw a NotSupportedError exception and abort these steps.
        // TODO
        // "4. If the readyState attribute is not in the "open" state
        //  then throw an InvalidStateError exception and abort these steps."
        if (this.readyState_ !== MediaSourceInterface_1.ReadyState.open) {
            LogUtils_1.LogUtil.error(`MediaSource: not in ready state or no media element attched`);
            throw new MediaErrorImpl_1.InvalidStateError("not in ready state or no media element attched");
        }
        let sourceBufferWidth = 1920;
        let sourceBufferHeight = 1080;
        let resolution = this.getMaxSupportedResolution(type);
        if (resolution?.width && resolution?.height) {
            sourceBufferWidth = resolution.width;
            sourceBufferHeight = resolution.height;
        }
        LogUtils_1.LogUtil.info(`MediaSource: Source Buffer Width = ${sourceBufferWidth} , Height = ${sourceBufferHeight}`);
        if (this.mediaElement != null) {
            const result = W3CMediaTurboModule_1.default.addSourceBuffer(this.mediaElement, DEFAULT_BUFFER_APPEND_CHUNK_SIZE, sourceBufferWidth, sourceBufferHeight, 30, DEFAULT_EVICTION_THRESHOLD, type);
            if (result.sourceBufferId === undefined) {
                LogUtils_1.LogUtil.error("Unable to add Source Buffer!!!");
                throw new MediaErrorImpl_1.InvalidStateError("Unable to add Source Buffer");
            }
            const sourceBufferImpl = new SourceBufferImpl_1.SourceBufferImpl(this.mediaElement, this, result.sourceBufferId, type);
            LogUtils_1.LogUtil.info(`MediaSource[${this.id}]::addSourceBuffer:: registering source buffer ${result.sourceBufferId} to mediaElementEventRouter`);
            this.mediaElementEventRouter?.registerSourceBuffer(sourceBufferImpl);
            this.sourceBuffersList.addSourceBuffer(sourceBufferImpl);
            return sourceBufferImpl;
        }
        else {
            LogUtils_1.LogUtil.error(`MediaSource::addSourceBuffer: no media element attched`);
            throw new MediaErrorImpl_1.InvalidStateError("no media element attched");
        }
    }
    /**
     * Removes the source buffer from media source.
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-mediasource-removesourcebuffer.
     * @param sourceBuffer source buffer instance to be removed.
     */
    removeSourceBuffer(sourceBuffer) {
        const sourceBufferImpl = sourceBuffer;
        LogUtils_1.LogUtil.info(`MediaSource[${this.id}]:removeSourceBuffer ${sourceBufferImpl.getId()}`);
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.error(`MediaSource: no media element`);
            return;
        }
        W3CMediaTurboModule_1.default.removeSourceBuffer(this.mediaElement, sourceBufferImpl.getId());
        this.sourceBuffersList.removeSourceBuffer(sourceBufferImpl.getId());
    }
    /**
     * Signals the end of stream for media source.
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-mediasource-endofstream.
     * @param error (optional) EndOfStreamError
     */
    endOfStream(error) {
        LogUtils_1.LogUtil.info(`MediaSource[${this.id}]:endOfStream ${error}`);
        if (this.readyState_ !== MediaSourceInterface_1.ReadyState.open) {
            throw new MediaErrorImpl_1.InvalidStateError("Media Source is not in open state. Attach to media element");
        }
        if (!this.mediaElement) {
            throw new MediaErrorImpl_1.InvalidStateError("Null media Element");
        }
        for (let i = 0; i < this.sourceBuffersList.length; i++) {
            if (this.sourceBuffersList.getSourceBuffer(i).updating) {
                throw new MediaErrorImpl_1.InvalidStateError("endOfStream() throws an exception when updating attribute is true.");
            }
        }
        // this will trigger sourceended event callback
        if (error === undefined) {
            W3CMediaTurboModule_1.default.endOfStream(this.mediaElement, "");
        }
        else if ((error !== EOS_NETWORK_ERROR && error !== EOS_DECODE_ERROR) ||
            error === null) {
            LogUtils_1.LogUtil.info("MediaSource[${this.id}]:endOfStream invalid error string or null");
            throw new TypeError("endOfStream");
        }
        else {
            if (this.sourceBuffers.length !== 0) { // TODO: need to handle this in native
                W3CMediaTurboModule_1.default.endOfStream(this.mediaElement, error?.toString());
            }
        }
        this.handleEvent("sourceended");
    }
    /**
     * Sets the start and end seek range for live.
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-mediasource-setliveseekablerange.
     * @param start Start position of the seek range of a live content in seconds.
     * @param end  End position of the seek range of a live content in seconds.
     */
    setLiveSeekableRange(start, end) {
        if (!this.mediaElement || this.readyState_ !== MediaSourceInterface_1.ReadyState.open) {
            throw new MediaErrorImpl_1.InvalidStateError(`this.mediaElement: ${this.mediaElement}, readyState: ${this.readyState_}`);
        }
        if (start < 0 || start > end) {
            throw new TypeError(`Not applicable start: ${start} and end: ${end} value`);
        }
        W3CMediaTurboModule_1.default.setLiveSeekableRange(this.mediaElement, start, end);
    }
    /**
     * Clears the previously set live seek range.
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-mediasource-clearliveseekablerange.
     */
    clearLiveSeekableRange() {
        if (!this.mediaElement || this.readyState_ !== MediaSourceInterface_1.ReadyState.open) {
            throw new MediaErrorImpl_1.InvalidStateError(`this.mediaElement: ${this.mediaElement}, readyState: ${this.readyState_}`);
        }
        W3CMediaTurboModule_1.default.clearLiveSeekableRange(this.mediaElement);
    }
    /**
     * @hidden
     */
    getHandle() {
        return this;
    }
    /**
     * Checks whehter the mime type is supported by the Media source.
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-mediasource-istypesupported.
     * @param type mime type.
     */
    static isTypeSupported(type) {
        LogUtils_1.LogUtil.info(`MediaSource: isTypeSupported ${type}`);
        // 1. If type is an empty string, then return false.
        if (!type || type.length === 0) {
            LogUtils_1.LogUtil.error(`MediaSource: type is empty`);
            return false;
        }
        // TODO: Remove this hack after PROJXXXX-107806 is fixed.
        if (type.localeCompare(MimeTypeRegistry_1.UNKNOWN_SHAKA_MIME) === 0) {
            LogUtils_1.LogUtil.info(`MediaSource: Known invalid mimetype is supported as of now`);
            return true;
        }
        let mimeType = MimeType_1.MimeType.parseMimeString(type);
        // 2. If type does not contain a valid MIME type string, then return false.
        if (mimeType === null) {
            LogUtils_1.LogUtil.error("invalid mime ", type);
            return false;
        }
        if (mimeType.type !== "video" && mimeType.type !== "audio") {
            LogUtils_1.LogUtil.error("invalid mime type ", mimeType.type);
            return false;
        }
        // 3. If type contains a media type or media subtype that the MediaSource does not support, then return false.
        // 4. If type contains a codec that the MediaSource does not support, then return false.
        // 5. If the MediaSource does not support the specified combination of media type, media subtype, and codecs then return false.
        if (!MimeTypeRegistry_1.MimeTypeRegistry.checkCodecParamForEnforcedContainers(mimeType))
            return false;
        return MimeTypeRegistry_1.MimeTypeRegistry.checkSupportedType(mimeType);
    }
    /**
     * @hidden
     */
    transitionToState(to) {
        /**
          * https://www.w3.org/TR/media-source-2/#dfn-sourceopen
          * readyState transitions from "closed" to "open" or from "ended" to "open".
          */
        if ((this.readyState_ === MediaSourceInterface_1.ReadyState.closed || this.readyState_ === MediaSourceInterface_1.ReadyState.ended) &&
            to === MediaSourceInterface_1.ReadyState.open) {
            this.readyState_ = to;
            this.eventEmitter.emit("sourceopen", new EventTargetInterface_1.Event("sourceopen", this));
        }
        else {
            this.readyState_ = to;
        }
    }
}
exports.MediaSource = MediaSource;

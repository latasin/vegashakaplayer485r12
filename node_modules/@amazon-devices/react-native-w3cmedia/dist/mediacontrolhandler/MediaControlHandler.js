"use strict";
/*
 * Copyright 2025 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaControlHandler = void 0;
const kepler_media_controls_1 = require("@amazon-devices/kepler-media-controls");
const LogUtils_1 = require("../LogUtils");
const NANOSECONDS_IN_SECONDS = (1000 * 1000 * 1000);
class MediaControlHandler {
    mediaPlayer;
    /**
     * @hidden
     * @brief Fetches video playback quality attributes.
     */
    setMediaPlayer(mediaplayer) {
        LogUtils_1.LogUtil.info('MediaControlHandler: setMediaPlayer');
        if (mediaplayer === null) {
            return;
        }
        this.mediaPlayer = mediaplayer;
    }
    /**
     * @hidden
     * @brief mapping the repeate mode to string for logging purpouse.
     */
    getRepeatModeString(repeatMode) {
        switch (repeatMode) {
            case kepler_media_controls_1.RepeatMode.OFF:
                return 'OFF';
            case kepler_media_controls_1.RepeatMode.REPEAT_PLAYLIST:
                return 'REPEAT_PLAYLIST';
            case kepler_media_controls_1.RepeatMode.REPEAT_TRACK:
                return 'REPEAT_TRACK';
        }
        return 'BAD_VALUE';
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "play" for
     *        current mediaplayer instance.
     *        w3cmedia will handle this internally by initiating play command to pipeline as a default mode.
     */
    async handlePlay(sessionId) {
        LogUtils_1.LogUtil.info('MediaControlHandler: performing play operation on Media Player');
        if (sessionId) {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handlePlay: sessionID = ${sessionId.id}`);
        }
        else {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handlePlay: sessionID is null`);
        }
        this.mediaPlayer?.play();
        return Promise.resolve();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "pause" for
     *        current mediaplayer instance.
     *        w3cmedia will handle this internally by initiating pause command to pipeline as a default mode.
     */
    async handlePause(sessionId, context) {
        LogUtils_1.LogUtil.info('MediaControlHandler: performing pause operation on Media Player');
        if (sessionId) {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handlePause: sessionID = ${sessionId.id}`);
        }
        else {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handlePause: sessionID is null`);
        }
        if (context) {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handlePause: source = ${context.source}`);
        }
        else {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handlePause: source is null`);
        }
        // defualt implementation is to pause the playback irrespective of source
        this.mediaPlayer?.pause();
        return Promise.resolve();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "toggleplaypause" for
     *        current mediaplayer instance.
     *        w3cmedia will handle this internally by initiating play/pause based on current state of pipeline as a default mode.
     */
    async handleTogglePlayPause(sessionId) {
        LogUtils_1.LogUtil.info('MediaControlHandler: performing handleTogglePlayPause on Media Player');
        if (sessionId) {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleTogglePlayPause: sessionID = ${sessionId.id}`);
        }
        else {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleTogglePlayPause: sessionID is null`);
        }
        if (this.mediaPlayer?.mediaControlStateUtil?.playbackStatus === kepler_media_controls_1.PlaybackStatus.PLAYING) {
            await this.handlePause(sessionId);
        }
        else {
            await this.handlePlay(sessionId);
        }
        return Promise.resolve();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "stop" for
     *        current mediaplayer instance.
     *        w3cmedia will handle this internally by initiating pause command to pipeline as a default mode.
     */
    async handleStop(sessionId) {
        LogUtils_1.LogUtil.info('MediaControlHandler: performing stop operation on Media Player');
        if (sessionId) {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleStop: sessionID = ${sessionId.id}`);
        }
        else {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleStop: sessionID is null`);
        }
        this.mediaPlayer?.pause();
        return Promise.resolve();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "startover" for
     *        current mediaplayer instance.
     *        w3cmedia will handle this internally by seek to start position and initiate the play command to pipeline as a default mode.
     */
    async handleStartOver(sessionId) {
        LogUtils_1.LogUtil.info('MediaControlHandler: performing start over operation on Media Player');
        if (sessionId) {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleStop: sessionID = ${sessionId.id}`);
        }
        else {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleStop: sessionID is null`);
        }
        this.mediaPlayer.currentTime = 0;
        this.mediaPlayer.play();
        return Promise.resolve();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "fastforward" for
     *        current mediaplayer instance.
     *        w3cmedia will handle this internally by seek forward command to pipeline as a default mode.
     */
    async handleFastForward(sessionId) {
        LogUtils_1.LogUtil.info('MediaControlHandler: performing fastforward operation on Media Player');
        if (sessionId) {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleFastForward: sessionID = ${sessionId.id}`);
        }
        else {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleFastForward: sessionID is null`);
        }
        const currentTime = this.mediaPlayer?.currentTime;
        const duration = this.mediaPlayer?.duration;
        if (currentTime === undefined || duration === undefined) {
            LogUtils_1.LogUtil.warn(`MediaControlHandler: Could not seek forward from currentTime=${currentTime}, duration=${duration}`);
            return Promise.resolve();
            ;
        }
        const seekIntervalSeconds = Math.floor(this.mediaPlayer?.seekIntervalInSec_);
        const seekIntervalNanoSeconds = (this.mediaPlayer?.seekIntervalInSec_ - seekIntervalSeconds) * NANOSECONDS_IN_SECONDS;
        const deltaPositionSeconds = seekIntervalNanoSeconds / NANOSECONDS_IN_SECONDS + seekIntervalSeconds;
        const sanitizedDeltaPositionSeconds = Math.min(deltaPositionSeconds, (duration - currentTime));
        LogUtils_1.LogUtil.debug(`MediaControlHandler: SkipForward: requested ${deltaPositionSeconds} s, applying ${sanitizedDeltaPositionSeconds} s.`);
        this.mediaPlayer.currentTime += sanitizedDeltaPositionSeconds;
        return Promise.resolve();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "rewind" for
     *        current mediaplayer instance.
     *        w3cmedia will handle this internally by seek backward command to pipeline as a default mode.
     */
    async handleRewind(sessionId) {
        LogUtils_1.LogUtil.info('MediaControlHandler: performing rewind operation on Media Player');
        if (sessionId) {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleRewind: sessionID = ${sessionId.id}`);
        }
        else {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleRewind: sessionID is null`);
        }
        const currentTime = this.mediaPlayer?.currentTime;
        const duration = this.mediaPlayer?.duration;
        if (currentTime === undefined || duration === undefined) {
            LogUtils_1.LogUtil.warn(`MediaControlHandler: Could not seek backward from currentTime=${currentTime}, duration=${duration}`);
            return Promise.resolve();
            ;
        }
        const seekIntervalSeconds = Math.floor(this.mediaPlayer?.seekIntervalInSec_);
        const seekIntervalNanoSeconds = (this.mediaPlayer?.seekIntervalInSec_ - seekIntervalSeconds) * NANOSECONDS_IN_SECONDS;
        const deltaPositionSeconds = seekIntervalNanoSeconds / NANOSECONDS_IN_SECONDS + seekIntervalSeconds;
        const sanitizedDeltaPositionSeconds = Math.min(currentTime, deltaPositionSeconds);
        LogUtils_1.LogUtil.debug(`MediaControlHandler: handleRewind: requested ${deltaPositionSeconds} s, applying ${sanitizedDeltaPositionSeconds} s.`);
        this.mediaPlayer.currentTime -= sanitizedDeltaPositionSeconds;
        return Promise.resolve();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "seek" for
     *        current mediaplayer instance.
     *        w3cmedia will handle this internally by seek forward/backward command to pipeline as a default mode.
     */
    async handleSeek(position, sessionId) {
        LogUtils_1.LogUtil.info('MediaControlHandler: performing seek operation on Media Player');
        if (sessionId) {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleSeek: sessionID = ${sessionId.id}`);
        }
        else {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleSeek: sessionID is null`);
        }
        // check if second is not valid or not
        if (position.seconds === undefined) {
            LogUtils_1.LogUtil.warn(`MediaControlHandler: Could not seek ${position.seconds}s.`);
            return Promise.resolve();
            ;
        }
        // reset nanosecond if this is undefined.
        if (position.nanoseconds === undefined) {
            position.nanoseconds = 0;
        }
        const duration = this.mediaPlayer?.duration;
        if (duration === undefined) {
            LogUtils_1.LogUtil.warn(`MediaControlHandler: Could not seek ${position.seconds} seconds.`);
            return Promise.resolve();
        }
        const seekPositionSeconds = position.nanoseconds / NANOSECONDS_IN_SECONDS + position.seconds;
        let sanitizedSeekPositionSeconds = seekPositionSeconds;
        if (seekPositionSeconds < 0) {
            sanitizedSeekPositionSeconds = 0;
        }
        else if (seekPositionSeconds > duration) {
            sanitizedSeekPositionSeconds = duration;
        }
        LogUtils_1.LogUtil.debug(`MediaControlHandler: Seek: requested ${seekPositionSeconds} s, applying ${sanitizedSeekPositionSeconds} s.`);
        this.mediaPlayer.currentTime = sanitizedSeekPositionSeconds;
        return Promise.resolve();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "setplaybackspeed" for
     *        current mediaplayer instance.
     *        w3cmedia will handle this internally by configure the playbackspeed command to pipeline as a default mode.
     */
    async handleSetPlaybackSpeed(speed, sessionId) {
        LogUtils_1.LogUtil.info('MediaControlHandler: performing playback speed operation on Media Player');
        if (sessionId) {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleSetPlaybackSpeed: sessionID = ${sessionId.id}`);
        }
        else {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleSetPlaybackSpeed: sessionID is null`);
        }
        this.mediaPlayer.playbackRate = speed;
        return Promise.resolve();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "skipforward" for
     *        current mediaplayer instance.
     *        w3cmedia will handle this internally by seek command with delta position to pipeline as a default mode.
     */
    async handleSkipForward(delta, sessionId) {
        LogUtils_1.LogUtil.info('MediaControlHandler: performing skipForward operation on Media Player');
        if (sessionId) {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleSkipForward: sessionID = ${sessionId.id}`);
        }
        else {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleSkipForward: sessionID is null`);
        }
        // check if second is not valid or not
        if (delta.seconds === undefined) {
            LogUtils_1.LogUtil.warn(`MediaControlHandler: Could not skipForward ${delta.seconds}s.`);
            return Promise.resolve();
            ;
        }
        // reset nanosecond if this is undefined.
        if (delta.nanoseconds === undefined) {
            delta.nanoseconds = 0;
        }
        const deltaPositionSeconds = delta.nanoseconds / NANOSECONDS_IN_SECONDS + delta.seconds;
        const currentTime = this.mediaPlayer?.currentTime;
        const duration = this.mediaPlayer?.duration;
        if (currentTime === undefined || duration === undefined) {
            LogUtils_1.LogUtil.warn(`MediaControlHandler: Could not SkipForward ${deltaPositionSeconds} seconds. currentTime=${currentTime}, duration=${duration}`);
            return Promise.resolve();
        }
        const sanitizedDeltaPositionSeconds = Math.min(deltaPositionSeconds, (duration - currentTime));
        LogUtils_1.LogUtil.debug(`MediaControlHandler: SkipForward: requested ${deltaPositionSeconds} s, applying ${sanitizedDeltaPositionSeconds} s.`);
        this.mediaPlayer.currentTime += sanitizedDeltaPositionSeconds;
        return Promise.resolve();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "skipbackward" for
     *        current mediaplayer instance.
     *        w3cmedia will handle this internally by seek command with delta position to pipeline as a default mode.
     */
    async handleSkipBackward(delta, sessionId) {
        LogUtils_1.LogUtil.info('MediaControlHandler: performing skipBackword operation on Media Player');
        if (sessionId) {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleSkipBackward: sessionID = ${sessionId.id}`);
        }
        else {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleSkipBackward: sessionID is null`);
        }
        // check if second is not valid or not
        if (delta.seconds === undefined) {
            LogUtils_1.LogUtil.warn(`MediaControlHandler: Could not skipForward ${delta.seconds}s.`);
            return Promise.resolve();
            ;
        }
        // reset nanosecond if this is undefined.
        if (delta.nanoseconds === undefined) {
            delta.nanoseconds = 0;
        }
        const deltaPositionSeconds = delta.nanoseconds / NANOSECONDS_IN_SECONDS + delta.seconds;
        const currentTime = this.mediaPlayer?.currentTime;
        if (currentTime === undefined) {
            LogUtils_1.LogUtil.warn(`MediaControlHandler: Could not SkipBackward ${deltaPositionSeconds} seconds. currentTime=${currentTime}`);
            return Promise.resolve();
        }
        const sanitizedDeltaPositionSeconds = Math.min(deltaPositionSeconds, currentTime);
        LogUtils_1.LogUtil.debug(`MediaControlHandler: handleSkipBackward: requested ${deltaPositionSeconds} s, applying ${sanitizedDeltaPositionSeconds} s.`);
        this.mediaPlayer.currentTime -= sanitizedDeltaPositionSeconds;
        return Promise.resolve();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "setVolume" for
     *        current mediaplayer instance.
     *        w3cmedia will handle this internally by initiating setvolume command as a default mode.
     */
    async handleSetAudioVolume(volume, sessionId) {
        LogUtils_1.LogUtil.info('MediaControlHandler: performing setvolume operation on Media Player');
        if (sessionId) {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleSetAudioVolume: sessionID = ${sessionId.id}`);
        }
        else {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleSetAudioVolume: sessionID is null`);
        }
        this.mediaPlayer.volume = volume;
        return Promise.resolve();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "setAudioTrack" for
     *        current mediaplayer instance.
     *        w3cmedia will handle this internally by initiating setaudiotrack command as a default mode.
     */
    async handleSetAudioTrack(audioTrack, sessionId) {
        const trackDetails = `id: ${audioTrack.id}, language: ${audioTrack.language}, displayName: ${audioTrack.displayName}`;
        LogUtils_1.LogUtil.info(`MediaControlHandler: NOP: Setting audio track to ${trackDetails} , in future releases...`);
        return Promise.reject();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "enableTextTrack" for
     *        current mediaplayer instance.
     *        w3cmedia will handle this internally by initiating enableTextTrack command as a default mode.
     */
    async handleEnableTextTrack(textTrack, sessionId) {
        const trackDetails = `id: ${textTrack.id}, language: ${textTrack.language}, displayName: ${textTrack.displayName}`;
        LogUtils_1.LogUtil.info(`MediaControlHandler: NOP: Enabling next track, ${trackDetails}`);
        return Promise.reject();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "next" for
     *        current mediaplayer instance.
     *        This is NOP for w3cmedia playback handling as this is playlist management feature.
     */
    async handleNext(sessionId) {
        LogUtils_1.LogUtil.info('MediaControlHandler: NOP: Play next...');
        return Promise.reject();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "previous" for
     *        current mediaplayer instance.
     *        This is NOP for w3cmedia playback handling as this is playlist management feature.
     */
    async handlePrevious() {
        LogUtils_1.LogUtil.info('MediaControlHandler: NOP: Play previous...');
        return Promise.reject();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "shuffle" for
     *        current mediaplayer instance.
     *        This is NOP for w3cmedia playback handling as this is playlist management feature.
     */
    async handleEnableShuffle(enable, sessionId) {
        LogUtils_1.LogUtil.info(`MediaControlHandler: NOP: Set shuffle to ${enable}`);
        return Promise.reject();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "previous" for
     *        current mediaplayer instance.
     *        This is NOP for w3cmedia playback handling as this is playlist management feature.
     */
    async handleSetRepeatMode(mode, sessionId) {
        LogUtils_1.LogUtil.info('MediaControlHandler: performing repeatmode operation on Media Player');
        if (sessionId) {
            LogUtils_1.LogUtil.info(`MediaControlHandler: handleSetAudioVolume: sessionID = ${sessionId.id}`);
        }
        else {
            LogUtils_1.LogUtil.info(`MediaControlHandler: handleSetAudioVolume: sessionID is null`);
        }
        if ((mode === kepler_media_controls_1.RepeatMode.REPEAT_TRACK || mode === kepler_media_controls_1.RepeatMode.OFF)) {
            this.mediaPlayer.loop = (mode === kepler_media_controls_1.RepeatMode.REPEAT_TRACK);
        }
        else {
            LogUtils_1.LogUtil.error('MediaControlHandler: handleSetRepeatMode failed');
        }
        return Promise.resolve();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "setRating" for
     *        current mediaplayer instance.
     *        This is NOP for w3cmedia playback handling as this is playlist management feature.
     */
    async handleSetRating(id, rating, sessionId) {
        LogUtils_1.LogUtil.info(`MediaControlHandler: NOP: Set rating of ${id} to ${rating}`);
        return Promise.reject();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "disableTextTrack" for
     *        current mediaplayer instance.
     *        w3cmedia will handle this internally by initiating disableTextTrack command as a default mode.
     */
    async handleDisableTextTrack(sessionId) {
        LogUtils_1.LogUtil.info(`MediaControlHandler: NOP: Disabling text track, future releases will have`);
        return Promise.reject();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "getMetaInfo" for
     *        current mediaplayer instance.
     *        This is NOP for w3cmedia playback handling as this is playlist management feature.
     */
    async handleGetMetadataInfo(id) {
        LogUtils_1.LogUtil.info(`MediaControlHandler: NOP: Getting metadata for ${id}`);
        return Promise.reject();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "customAction" for
     *        current mediaplayer instance.
     *        This is NOP for w3cmedia playback handling as this is playlist management feature.
     */
    async handleCustomAction(action, sessionId) {
        LogUtils_1.LogUtil.info(`MediaControlHandler: NOP: Handle custom action ${action.name}`);
        return Promise.reject();
    }
    /**
     * @hidden
     * @brief Callback from KMC server to execute the media control command "getSessionState" for
     *        current mediaplayer instance.
     *        w3cmedia will handle this internally by updating the sessionstate as a default.
     *        alternatively App client can choose to override the callback function using OverrideMediaControlHandler
     *        and implement accordingly.
     */
    async handleGetSessionState(sessionId) {
        LogUtils_1.LogUtil.debug('MediaControlHandler: performing getSessionState operation on Media Player');
        var sessionState;
        if (sessionId) {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleGetSessionState: sessionID = ${sessionId.id}`);
        }
        else {
            LogUtils_1.LogUtil.debug(`MediaControlHandler: handleGetSessionState: sessionID is null`);
        }
        sessionState = this.mediaPlayer?.mediaControlStateUtil?.getServerState();
        if (sessionState === undefined) {
            throw new Error('Unable to get session state');
        }
        return Promise.resolve([sessionState]);
    }
}
exports.MediaControlHandler = MediaControlHandler;

"use strict";
/*
 * Copyright 2025 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaControlStateUtil = void 0;
const kepler_media_controls_1 = require("@amazon-devices/kepler-media-controls");
const MediaErrorImpl_1 = require("../MediaErrorImpl");
const LogUtils_1 = require("../LogUtils");
const allStateSupportedActions = [
    kepler_media_controls_1.Action.START_OVER,
    kepler_media_controls_1.Action.SET_AUDIO_VOLUME,
    kepler_media_controls_1.Action.SET_REPEAT_MODE,
];
const allActiveStateSupportedActions = [
    kepler_media_controls_1.Action.STOP,
    kepler_media_controls_1.Action.FAST_FORWARD,
    kepler_media_controls_1.Action.REWIND,
    kepler_media_controls_1.Action.SKIP_FORWARD,
    kepler_media_controls_1.Action.SKIP_BACKWARD,
    kepler_media_controls_1.Action.SEEK,
];
class MediaControlStateUtil {
    mediaPlayer;
    playbackStatus = kepler_media_controls_1.PlaybackStatus.NOT_PLAYING;
    currentPosition = 0;
    currentSupportedActions = [
        kepler_media_controls_1.Action.PLAY,
        kepler_media_controls_1.Action.PAUSE,
        kepler_media_controls_1.Action.STOP,
        kepler_media_controls_1.Action.FAST_FORWARD,
        kepler_media_controls_1.Action.REWIND,
        kepler_media_controls_1.Action.SKIP_FORWARD,
        kepler_media_controls_1.Action.SKIP_BACKWARD,
        kepler_media_controls_1.Action.SEEK,
        kepler_media_controls_1.Action.TOGGLE_PLAY_PAUSE,
        kepler_media_controls_1.Action.SET_PLAYBACK_SPEED,
        new kepler_media_controls_1.Action('ENABLE_XRAY'),
        new kepler_media_controls_1.Action('DISABLE_XRAY'),
    ];
    repeatMode = kepler_media_controls_1.RepeatMode.OFF;
    playbackSpeed = 1.0;
    currentSupportedSpeeds = [-3.0, -2.0, -1.0, 0.5, 0.5, 1.0, 2.0, 3.0];
    currentSupportedRatings = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0];
    mediaControlServer;
    mSeekIntervalInSec_ = 10.0;
    mError;
    mediaInfo;
    capabilities;
    playlistState;
    playbackState;
    controls;
    locale;
    // default configurations
    _serverState;
    _playbackState;
    _capabilities;
    _playlistState;
    _mediaInfo;
    mSessionId = { id: 0 };
    mId = { contentId: 'com.foo.bar', catalogName: 'sample-catalog-v1' };
    xRayControlName = 'X-ray';
    xRayControlStateOff = 'off';
    xRayControlStateOn = 'on';
    playbackPosition = {
        updatedAtTime: { seconds: 1702965600, nanoseconds: 0 },
        position: { seconds: 10, nanoseconds: 999999999 },
    };
    forwardSkipSteps = [
        { seconds: 10, nanoseconds: 0 },
        { seconds: 20, nanoseconds: 0 },
        { seconds: 40, nanoseconds: 0 },
        { seconds: 60, nanoseconds: 0 },
    ];
    backwardSkipSteps = [
        { seconds: 10, nanoseconds: 0 },
        { seconds: 20, nanoseconds: 0 },
        { seconds: 40, nanoseconds: 0 },
        { seconds: 60, nanoseconds: 0 },
    ];
    /**
     * @hidden
     * @brief constructor of MediaControlStateUtil with is attached with
     *        current instance of mediaplayer.
     */
    constructor(mediaPlayer) {
        LogUtils_1.LogUtil.info('MediaControlStateUtil: ++');
        this.mediaPlayer = mediaPlayer;
        this.mSessionId = mediaPlayer.mSessionId;
        this.mError = new MediaErrorImpl_1.MediaErrorImpl(0, 'No Error');
        LogUtils_1.LogUtil.info('MediaControlStateUtil: --');
    }
    /**
     * @hidden
     * @brief attach thet mediacontrolserver object with MediaControlStateUtil
     */
    setMediaControlServer = (mediaControlServer) => {
        LogUtils_1.LogUtil.info(`MediaControlStateUtil: setMediaControlServer ++`);
        if (mediaControlServer === null || mediaControlServer === undefined) {
            return;
        }
        this.setEventListeners();
        this.mediaControlServer = mediaControlServer;
        this.setDefaultSeekIntervalInSec(this.mediaPlayer?.defaultSeekIntervalInSec);
        this.updateState(true /* force initial update */);
        LogUtils_1.LogUtil.info(`MediaControlStateUtil: setMediaControlServer --`);
    };
    /**
     * @hidden
     * @brief clear the mediaplayer event listner
     */
    clearMediaPlayer = (mediaPlayer) => {
        LogUtils_1.LogUtil.info(`MediaControlStateUtil: clearMediaPlayer ++`);
        if (mediaPlayer === null || mediaPlayer === undefined) {
            return;
        }
        this.removeEventListeners(mediaPlayer);
    };
    /**
     * @hidden
     * @brief papulate the current mediaplayer session state
     *        and it will be finally updated to KMC server.
     */
    getServerState() {
        LogUtils_1.LogUtil.debug('MediaControlStateUtil: getServerState ++');
        /* @TODO hard-coded values need to remove */
        /*
        const msSinceEpoch = Date.now();
        const secsSinceEpoch = Math.floor(msSinceEpoch/1000);
        const nsSinceEpoch = (msSinceEpoch - (secsSinceEpoch * 1000)) * 1000000 ;
        let updatedAtTime: ITimeValue;
        updatedAtTime.seconds = secsSinceEpoch;
        updatedAtTime.nanoseconds = nsSinceEpoch;
        const secPosition = Math.floor(this.currentPosition);
        const nsPosition = (this.currentPosition - secPosition) * 1000 * 1000 * 1000;
        let position: ITimeValue;
        position.seconds = secPosition;
        position.nanoseconds = nsPosition;
        */
        if (this.playbackState !== undefined) {
            this._playbackState = this.playbackState;
        }
        else {
            this._playbackState = {
                playbackStatus: this.playbackStatus,
                playbackSpeed: this.playbackSpeed,
                position: this.playbackPosition,
            };
        }
        /*
        let playbackposition:IPlaybackPosition;
        playbackposition.updatedAtTime = updatedAtTime;
        playbackposition.position = position;
        this._playbackState.position = playbackposition
        */
        if (this.capabilities !== undefined) {
            this._capabilities = this.capabilities;
        }
        else {
            //this.setSupportedActions(this.playbackStatus);
            this._capabilities = {
                actions: this.currentSupportedActions,
                speeds: this.currentSupportedSpeeds,
                ratings: this.currentSupportedRatings,
                forwardSkipSteps: this.forwardSkipSteps,
                backwardSkipSteps: this.backwardSkipSteps,
            };
        }
        /*
        this.updateSupportedActions(this.playbackStatus);
        LogUtil.info('MediaControlStateUtil:: updateSupportedActions --');
        */
        if (this.playlistState !== undefined) {
            this._playlistState = this.playlistState;
        }
        else {
            this._playlistState = {
                repeatMode: this.repeatMode,
                shuffle: false
            };
        }
        this.controls = [{ name: this.xRayControlName, state: this.xRayControlStateOff },];
        this.locale = { identifier: 'en-US', };
        if (this.mediaInfo !== undefined) {
            this._mediaInfo = this.mediaInfo;
        }
        else {
            this._mediaInfo = {
                id: this.mId,
                hasVideo: true,
                availableAudioTracks: [
                    { id: '0', displayName: 'English', language: this.locale },
                ],
                availableTextTracks: [
                    { id: '0', displayName: 'English', language: this.locale },
                ],
                duration: { seconds: 600, nanoseconds: 999999999 },
                startTime: { seconds: 946684870, nanoseconds: 999999999 },
                seekRangeStart: { seconds: 90, nanoseconds: 999999999 },
                seekRangeEnd: { seconds: 120, nanoseconds: 999999999 },
            };
        }
        this._serverState = {
            id: this.mSessionId,
            playbackState: this._playbackState,
            mediaInfo: this._mediaInfo,
            capabilities: this._capabilities,
            playlistState: this._playlistState,
            controls: this.controls,
        };
        LogUtils_1.LogUtil.debug('MediaControlServerUtil: getServerState : ', JSON.stringify(this._serverState));
        LogUtils_1.LogUtil.debug('MediaControlServerUtil: getServerState --');
        return this._serverState;
    }
    /**
     * @hidden
     * @brief set the supported actions based on current playback state of
     *        mediaplayer.
     */
    setSupportedActions(playerStatus) {
        if (playerStatus == kepler_media_controls_1.PlaybackStatus.NOT_PLAYING) {
            this.currentSupportedActions = allStateSupportedActions;
        }
        else {
            this.currentSupportedActions = allStateSupportedActions.concat(allActiveStateSupportedActions);
        }
    }
    /**
     * @hidden
     * @brief update the supported actions based on current playback state of
     *        mediaplayer.
     */
    updateSupportedActions(playerStatus) {
        if (playerStatus == kepler_media_controls_1.PlaybackStatus.NOT_PLAYING || playerStatus == kepler_media_controls_1.PlaybackStatus.PAUSED) {
            const indexPlay = this._capabilities?.actions.indexOf(kepler_media_controls_1.Action.PLAY);
            if (indexPlay < 0) {
                this._capabilities?.actions.push(kepler_media_controls_1.Action.PLAY);
            }
            const indexPause = this._capabilities?.actions.indexOf(kepler_media_controls_1.Action.PAUSE);
            if (indexPause >= 0) {
                this._capabilities?.actions.splice(indexPause, 1);
            }
        }
        else { // Playing or Buffering
            const indexPlay = this._capabilities?.actions.indexOf(kepler_media_controls_1.Action.PLAY);
            if (indexPlay >= 0) {
                this._capabilities?.actions.splice(indexPlay, 1);
            }
            const indexPause = this._capabilities?.actions.indexOf(kepler_media_controls_1.Action.PAUSE);
            if (indexPause < 0) {
                this._capabilities?.actions.push(kepler_media_controls_1.Action.PAUSE);
            }
        }
    }
    /**
     * @hidden
     * @brief update the session state to KMC server as and when MediaPlayer send the
     *        state mapped events to listner.
     */
    updateState(force = false) {
        LogUtils_1.LogUtil.debug('MediaControlStateUtil: updateState ++');
        const playerStatusChanged = (this.playbackStatus != this._playbackState?.playbackStatus);
        if (playerStatusChanged || force) {
            const mSessionState = this.getServerState();
            this.mediaControlServer?.updateMediaSessionStates([mSessionState]);
        }
        LogUtils_1.LogUtil.debug('MediaControlStateUtil: updateState --');
    }
    /**
     * @hidden
     * @brief configure the default seek interval in case user does not
     *        set.
     */
    setDefaultSeekIntervalInSec = (seekInterval) => {
        LogUtils_1.LogUtil.debug(`MediaControlStateUtil: defualtSeekInterval ` + seekInterval);
        this.mSeekIntervalInSec_ = seekInterval;
    };
    /**
     * @hidden
     * @brief set the player error if any.
     */
    setPlayerError = (mediaError) => {
        this.mError = mediaError;
    };
    /**
     * @hidden
     * @brief reset the player error.
     */
    resetError = () => {
        this.mError = new MediaErrorImpl_1.MediaErrorImpl(0, 'No Error');
    };
    /**
     * @hidden
     * @brief Implement the event listner of current mediaplayer instance
     *        based on events , session update will be done and eventually
     *        update the KMC server.
     */
    eventListeners = {
        loadstart: () => {
            LogUtils_1.LogUtil.debug('MediaControlStateUtil: loadstart event');
            this.resetError();
            this.playbackStatus = kepler_media_controls_1.PlaybackStatus.BUFFERING;
            this.updateState();
        },
        waiting: () => {
            LogUtils_1.LogUtil.debug('MediaControlStateUtil: waiting event');
            this.playbackStatus = kepler_media_controls_1.PlaybackStatus.BUFFERING;
            this.updateState();
        },
        progress: () => {
            LogUtils_1.LogUtil.debug('MediaControlStateUtil: progress event');
            this.playbackStatus = kepler_media_controls_1.PlaybackStatus.BUFFERING;
            this.updateState();
        },
        stalled: () => {
            LogUtils_1.LogUtil.debug('MediaControlStateUtil: stalled event');
            this.playbackStatus = kepler_media_controls_1.PlaybackStatus.NOT_PLAYING;
            this.updateState();
        },
        suspend: () => {
            LogUtils_1.LogUtil.debug('MediaControlStateUtil: suspend event');
            this.playbackStatus = kepler_media_controls_1.PlaybackStatus.NOT_PLAYING;
            this.updateState();
        },
        abort: () => {
            LogUtils_1.LogUtil.debug('MediaControlStateUtil: abort event');
            this.playbackStatus = kepler_media_controls_1.PlaybackStatus.NOT_PLAYING;
            this.updateState();
        },
        emptied: () => {
            LogUtils_1.LogUtil.debug('MediaControlStateUtil: emptied event');
            this.playbackStatus = kepler_media_controls_1.PlaybackStatus.NOT_PLAYING;
            this.updateState();
        },
        loadedmetadata: () => {
            LogUtils_1.LogUtil.debug('MediaControlStateUtil: loadedmetadata event');
            this.playbackStatus = kepler_media_controls_1.PlaybackStatus.BUFFERING;
            this.updateState();
        },
        loadeddata: () => {
            LogUtils_1.LogUtil.debug('MediaControlStateUtil: loadeddata event');
            this.playbackStatus = kepler_media_controls_1.PlaybackStatus.BUFFERING;
            this.updateState();
        },
        canplay: () => {
            LogUtils_1.LogUtil.debug('MediaControlStateUtil: canplay event');
            this.playbackStatus = kepler_media_controls_1.PlaybackStatus.BUFFERING;
            this.updateState();
        },
        seeked: () => {
            LogUtils_1.LogUtil.debug('MediaControlStateUtil: seeked event');
            this.currentPosition = this.mediaPlayer?.currentTime;
            this.updateState();
        },
        timeupdate: () => {
            LogUtils_1.LogUtil.debug('MediaControlStateUtil: timeupdate event');
            this.playbackStatus = kepler_media_controls_1.PlaybackStatus.PLAYING;
            this.currentPosition = this.mediaPlayer?.currentTime;
            this.updateState();
        },
        audiofocuspaused: () => {
            LogUtils_1.LogUtil.debug('MediaControlStateUtil: audiofocuspaused event');
            this.playbackStatus = kepler_media_controls_1.PlaybackStatus.PAUSED;
            this.currentPosition = this.mediaPlayer?.currentTime;
            this.updateState();
        },
        audiofocuslost: () => {
            LogUtils_1.LogUtil.debug('MediaControlStateUtil: audiofocuslost event');
            this.playbackStatus = kepler_media_controls_1.PlaybackStatus.PAUSED;
            this.currentPosition = this.mediaPlayer?.currentTime;
            this.updateState();
        },
        audiofocusgranted: () => {
            LogUtils_1.LogUtil.debug('MediaControlStateUtil: audiofocusgranted event');
            this.playbackStatus = kepler_media_controls_1.PlaybackStatus.PLAYING;
            this.currentPosition = this.mediaPlayer?.currentTime;
            this.updateState();
        },
        playing: () => {
            LogUtils_1.LogUtil.debug('MediaControlStateUtil: player event');
            this.resetError();
            this.playbackStatus = kepler_media_controls_1.PlaybackStatus.PLAYING;
            this.currentPosition = this.mediaPlayer?.currentTime;
            this.updateState();
        },
        pause: () => {
            LogUtils_1.LogUtil.debug('MediaControlStateUtil: pause event');
            this.playbackStatus = kepler_media_controls_1.PlaybackStatus.PAUSED;
            this.currentPosition = this.mediaPlayer?.currentTime;
            this.updateState();
        },
        seeking: () => {
            LogUtils_1.LogUtil.info('MediaControlStateUtil: seeking event');
            this.currentPosition = this.mediaPlayer?.currentTime;
            this.updateState();
        },
        ended: () => {
            LogUtils_1.LogUtil.debug('MediaControlStateUtil: ended event');
            this.playbackStatus = kepler_media_controls_1.PlaybackStatus.NOT_PLAYING;
            this.currentPosition = this.mediaPlayer?.currentTime;
            this.updateState();
        },
        error: () => {
            LogUtils_1.LogUtil.debug('MediaControlStateUtil: error event');
            this.setPlayerError(this.mediaPlayer?.error);
            this.playbackStatus = kepler_media_controls_1.PlaybackStatus.NOT_PLAYING;
            this.currentPosition = this.mediaPlayer?.currentTime;
            this.updateState();
        },
        ratechange: () => {
            const playbackRate = this.mediaPlayer?.playbackRate;
            LogUtils_1.LogUtil.debug(`MediaControlStateUtil: rate change event to ${playbackRate}`);
            this.playbackSpeed = playbackRate;
            this.currentPosition = this.mediaPlayer?.currentTime;
            this.updateState();
        }
    };
    /**
    * @hidden
    * @brief configure the mediaplayer event listners.
    */
    setEventListeners() {
        LogUtils_1.LogUtil.info('MediaControlStateUtil: setEventListeners ++');
        for (const listener in this.eventListeners) {
            if (this.eventListeners.hasOwnProperty(listener))
                this.mediaPlayer.addEventListener(listener, this.eventListeners[listener]);
        }
    }
    /**
     * @hidden
     * @brief reset the mediaplayer event listners.
     */
    removeEventListeners(mediaPlayer) {
        LogUtils_1.LogUtil.info('MediaControlStateUtil: removeEventListeners ++');
        if (mediaPlayer === null) {
            return;
        }
        for (const listener in this.eventListeners) {
            if (this.eventListeners.hasOwnProperty(listener))
                mediaPlayer.removeEventListener(listener, this.eventListeners[listener]);
        }
    }
}
exports.MediaControlStateUtil = MediaControlStateUtil;

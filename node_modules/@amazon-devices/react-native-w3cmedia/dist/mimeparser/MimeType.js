"use strict";
/*
 * Copyright 2024 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MimeType = void 0;
const MimeUtils_1 = require("./MimeUtils");
class MimeType {
    mType;
    mSubtype;
    mEssence;
    mParameters;
    mMimeString;
    constructor(mimeStr) {
        this.mMimeString = mimeStr;
        this.mParameters = new Map();
    }
    get type() {
        return this.mType;
    }
    get subType() {
        return this.mSubtype;
    }
    get essence() {
        if (this.mEssence === undefined || this.mEssence.length === 0) {
            this.mEssence = this.mType + "/" + this.mSubtype;
        }
        return this.mEssence;
    }
    getParameter(key) {
        return this.mParameters.get(key);
    }
    getParameterCount() {
        return this.mParameters.size;
    }
    get mimeString() {
        return this.mMimeString;
    }
    /**
     * https://mimesniff.spec.whatwg.org/#parsing-a-mime-type
     *
     * @param mimeStr @type {string} the mime string from application.
     * @returns @type {MimeType} if the provided mime is valid, null otherwise.
     */
    static parseMimeString(mimeStr) {
        // 1. Remove any leading and trailing HTTP whitespace from input.
        mimeStr = (0, MimeUtils_1.removeLeadingAndTrailingHTTPWhitespace)(mimeStr);
        // 2. Let position be a position variable for input, initially pointing at the start of input.
        let position = 0;
        // 3. Let type be the result of collecting a sequence of code points that are not
        //    U+002F (/) from input, given position.
        let type = "";
        while (position < mimeStr.length && mimeStr[position] !== "/") {
            type += mimeStr[position];
            position++;
        }
        // 4. If type is the empty string or does not solely contain HTTP
        //    token code points, then return failure.
        if (type.length === 0 || !(0, MimeUtils_1.solelyContainsHTTPTokenCodePoints)(type)) {
            return null;
        }
        // 5. If position is past the end of input, then return failure.
        if (position >= mimeStr.length) {
            return null;
        }
        // 6. Advance position by 1. (This skips past U+002F (/).)
        position++;
        // 7. Let subtype be the result of collecting a sequence of code
        //    points that are not U+003B (;) from input, given position.
        let subtype = "";
        while (position < mimeStr.length && mimeStr[position] !== ";") {
            subtype += mimeStr[position];
            position++;
        }
        // 8. Remove any trailing HTTP whitespace from subtype.
        subtype = (0, MimeUtils_1.removeTrailingHTTPWhitespace)(subtype);
        // 9. If subtype is the empty string or does not solely contain
        //    HTTP token code points, then return failure.
        if (subtype.length === 0 || !(0, MimeUtils_1.solelyContainsHTTPTokenCodePoints)(subtype)) {
            return null;
        }
        // 10. Let mimeType be a new MIME type record whose type is type,
        //     in ASCII lowercase, and subtype is subtype, in ASCII lowercase.
        let mimetype = new MimeType(mimeStr);
        mimetype.mType = type.toLowerCase();
        mimetype.mSubtype = subtype.toLowerCase();
        // 11. While position is not past the end of input:
        while (position < mimeStr.length) {
            // 11.1. Advance position by 1. (This skips past U+003B (;).)
            position++;
            // 11.2 Collect a sequence of code points that are HTTP whitespace from input given position.
            while ((0, MimeUtils_1.isHTTPWhitespaceChar)(mimeStr[position])) {
                position++;
            }
            // 11.3 Let parameterName be the result of collecting a sequence of code points that are not
            //      U+003B (;) or U+003D (=) from input, given position.
            let parameterName = "";
            while (position < mimeStr.length && mimeStr[position] !== ";" && mimeStr[position] !== "=") {
                parameterName += mimeStr[position];
                position++;
            }
            // 11.4 Set parameterName to parameterName, in ASCII lowercase.
            parameterName = parameterName.toLowerCase();
            // 11.5 If position is not past the end of input, then:
            if (position < mimeStr.length) {
                // 11.5.1 If the code point at position within input is U+003B (;), then continue.
                if (mimeStr[position] === ";") {
                    continue;
                }
                // 11.5.2 Advance position by 1. (This skips past U+003D (=).)
                position++;
            }
            // 11.6 If position is past the end of input, then break.
            if (position >= mimeStr.length) {
                break;
            }
            // 11.7 Let parameterValue be null.
            let parameterValue = "";
            // 11.8 If the code point at position within input is U+0022 ("), then:
            if (mimeStr[position] === "\"") {
                // 11.8.1 Set parameterValue to the result of collecting an HTTP quoted string
                //        from input, given position and true.
                [parameterValue, position] = (0, MimeUtils_1.collectHTTPQuotedString)(mimeStr, position);
                // 11.8.2 Collect a sequence of code points that are not U+003B (;) from input, given position.
                while (position < mimeStr.length && mimeStr[position] !== ";") {
                    ++position;
                }
            }
            else {
                // 11.9. Otherwise:
                // 11.9.1 Set parameterValue to the result of collecting a sequence of
                //     code points that are not U+003B (;) from input, given position.
                while (position < mimeStr.length && mimeStr[position] !== ";") {
                    parameterValue += mimeStr[position];
                    ++position;
                }
                // 11.9.2 Remove any trailing HTTP whitespace from parameterValue.
                parameterValue = (0, MimeUtils_1.removeTrailingHTTPWhitespace)(parameterValue);
                // 11.9.3 If parameterValue is the empty string, then continue.
                if (parameterValue === "") {
                    continue;
                }
            }
            // 11.10 If all of the following are true:
            // parameterName is not the empty string
            // parameterName solely contains HTTP token code points
            // parameterValue solely contains HTTP quoted-string token code points
            // mimeType’s parameters[parameterName] does not exist
            // then set mimeType’s parameters[parameterName] to parameterValue.
            if (parameterName.length > 0 &&
                (0, MimeUtils_1.solelyContainsHTTPTokenCodePoints)(parameterName) &&
                (0, MimeUtils_1.soleyContainsHTTPQuotedStringTokenCodePoints)(parameterValue) &&
                !mimetype.mParameters.has(parameterName)) {
                mimetype.mParameters.set(parameterName, parameterValue);
            }
        }
        // 12. Return mimeType.
        return mimetype;
    }
}
exports.MimeType = MimeType;

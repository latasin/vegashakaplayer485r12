"use strict";
/*
 * Copyright 2023 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebCrypto = void 0;
const LogUtils_1 = require("../LogUtils");
const W3CMediaTurboModule_1 = __importDefault(require("../turbo-modules/W3CMediaTurboModule"));
class WebCrypto {
    static randomUUID() {
        LogUtils_1.LogUtil.info("WebCrypto::randomUUID ++");
        return W3CMediaTurboModule_1.default.randomUUID();
    }
    static subtle = class {
        static async importKey(format, data, algorithm, extractable, keyUsages) {
            // Only 'raw' format is implemented.
            return new Promise((resolve, reject) => {
                let key;
                let keyData;
                // take deep copy of the Key as per WebCrypto spec
                // Refer: (Point 2.2)
                // https://www.w3.org/TR/WebCryptoAPI/#dfn-SubtleCrypto-method-importKey
                if (data instanceof ArrayBuffer) {
                    keyData = new Uint8Array(data).buffer;
                    key = data;
                }
                else if (data instanceof Uint8Array || data instanceof DataView) {
                    keyData = new Uint8Array(data.buffer).buffer;
                    key = data.buffer;
                }
                else {
                    LogUtils_1.LogUtil.error("WebCrypto::importKey(): data type error");
                    reject();
                }
                let keyObj = W3CMediaTurboModule_1.default.importKey(format, keyData, algorithm, extractable, keyUsages);
                // At present, there is no native equivalent of
                // adding Array in JSONObject, so assigning key and usages here.
                if (extractable) {
                    keyObj.key = key;
                }
                keyObj.usages = keyUsages;
                keyObj.algorithm = algorithm;
                let result = keyObj;
                if (result.usages.length >= 1) {
                    resolve(result);
                    return;
                }
                reject();
            });
        }
        static async decrypt(algorithm, key, data) {
            return new Promise((resolve, reject) => {
                if (algorithm === undefined || key === undefined ||
                    (algorithm.name !== "AES-CTR" && algorithm.iv === undefined && key.algorithm.iv === undefined) ||
                    (algorithm.name === "AES-CTR" && algorithm.counter === undefined && key.algorithm.counter === undefined) ||
                    data === undefined) {
                    LogUtils_1.LogUtil.error("WebCrypto::decrypt invalid data passed");
                    reject();
                }
                let ivCounterArray;
                if (algorithm.name === "AES-CTR") {
                    if (algorithm.counter instanceof ArrayBuffer) {
                        ivCounterArray = algorithm.counter;
                    }
                    else {
                        if (algorithm.counter.byteOffset == 0 && algorithm.counter.byteLength == algorithm.counter.buffer.byteLength) {
                            // This is a TypedArray over the whole buffer.
                            ivCounterArray = algorithm.counter.buffer;
                        }
                        else {
                            // This is a "view" on the buffer.  Create a new buffer that only contains
                            // the data.  Note that since this isn't an ArrayBuffer, the "new" call
                            // will allocate a new buffer to hold the copy.
                            ivCounterArray = new Uint8Array(algorithm.counter.buffer).buffer;
                        }
                    }
                }
                else {
                    if (algorithm.iv instanceof ArrayBuffer) {
                        ivCounterArray = algorithm.iv;
                    }
                    else {
                        if (algorithm.iv.byteOffset == 0 && algorithm.iv.byteLength == algorithm.iv.buffer.byteLength) {
                            // This is a TypedArray over the whole buffer.
                            ivCounterArray = algorithm.iv.buffer;
                        }
                        else {
                            // This is a "view" on the buffer.  Create a new buffer that only contains
                            // the data.  Note that since this isn't an ArrayBuffer, the "new" call
                            // will allocate a new buffer to hold the copy.
                            ivCounterArray = new Uint8Array(algorithm.iv.buffer).buffer;
                        }
                    }
                }
                // Copy ivArray to CryptoKey
                key.algorithm.iv = ivCounterArray;
                let plainData = W3CMediaTurboModule_1.default.decrypt(key.algorithm, key, ivCounterArray, data);
                if (plainData.byteLength >= 1) {
                    resolve(plainData);
                    return;
                }
                LogUtils_1.LogUtil.error("WebCrypto::decrypt Errored out");
                reject();
            });
        }
    };
}
exports.WebCrypto = WebCrypto;

import { IComponentInstance } from '@amzn/react-native-kepler';
import { MediaId } from '@amzn/kepler-media-types';
/**
 * Specifies the playback status.
 */
export declare enum PlaybackStatus {
    PLAYING = "PLAYING",
    PAUSED = "PAUSED",
    NOT_PLAYING = "NOT_PLAYING",
    BUFFERING = "BUFFERING"
}
/**
 * Represents the actions that you can invoke using the media control client.
 */
export declare class Action {
    name: string;
    constructor(name: string);
    static readonly PLAY: Action;
    static readonly PAUSE: Action;
    static readonly TOGGLE_PLAY_PAUSE: Action;
    static readonly STOP: Action;
    static readonly START_OVER: Action;
    static readonly FAST_FORWARD: Action;
    static readonly REWIND: Action;
    static readonly SET_PLAYBACK_SPEED: Action;
    static readonly SKIP_FORWARD: Action;
    static readonly SKIP_BACKWARD: Action;
    static readonly SEEK: Action;
    static readonly SET_AUDIO_VOLUME: Action;
    static readonly SET_AUDIO_TRACK: Action;
    static readonly ENABLE_TEXT_TRACK: Action;
    static readonly DISBLE_TEXT_TRACK: Action;
    static readonly NEXT: Action;
    static readonly PREVIOUS: Action;
    static readonly ENABLE_SHUFFLE: Action;
    static readonly SET_REPEAT_MODE: Action;
    static readonly SET_RATING: Action;
    static readonly GET_META_DATA: Action;
}
/**
 * Specifies the repeat mode for the media player.
 */
export declare enum RepeatMode {
    OFF = 0,
    REPEAT_TRACK = 1,
    REPEAT_PLAYLIST = 2
}
/**
 * Specifies the radio band for the media player.
 */
export declare enum RadioBand {
    NONE = "NONE",
    UNKNOWN = "UNKNOWN",
    AM = "AM",
    FM = "FM",
    DAB = "DAB"
}
/**
 * Specifies the source of the media command.
 */
export declare enum CommandSource {
    SYSTEM_DISPLAY_OFF = "SYSTEM_DISPLAY_OFF",
    USER = "USER",
    OTHER = "OTHER"
}
/**
 * Error occurs when a request cannot be processed due to being in the
 * wrong state to process it.
 */
export declare class InvalidStateError extends Error {
    constructor(message: string);
}
/**
 * Error occurs when a request cannot be handled.
 */
export declare class NotAllowedError extends Error {
    constructor(message: string);
}
/**
 * Error occurs when the requested playback speed is not supported.
 */
export declare class SpeedOutOfRangeError extends Error {
    constructor(message: string);
}
/**
 * Error occurs when the requested seek position is out of the advertised range.
 */
export declare class SeekOutOfRangeError extends Error {
    constructor(message: string);
}
/**
 * Error occurs when requested data is not available.
 */
export declare class NotAvailableError extends Error {
    constructor(message: string);
}
/**
 * interface for TimeValue, used to represent a time value structure.
 * @property seconds @type {number} A postive number representing seconds.
 * @property nanoseconds @type {number} A positive number representing nanoseconds. Maximum value can be 999999999.
 */
export interface ITimeValue {
    seconds: number;
    nanoseconds: number;
}
/**
 * Represents the playback position of the track.
 * @property updatedAtTime @type {ITimeValue} The time at which the playback position was recorded.
 * @property position @type {ITimeValue} The recorded position of the media during playback.
 */
export interface IPlaybackPosition {
    updatedAtTime: ITimeValue;
    position: ITimeValue;
}
/**
 * Represents the playback state of the track.
 * @property playbackStatus @type {PlaybackStatus} The status of the media track.
 * @property playbackSpeed @type {number} The speed of the media track.
 * @property position @type {IPlaybackPosition} The position of the media track.
 */
export interface IPlaybackState {
    playbackStatus: PlaybackStatus;
    playbackSpeed: number;
    position?: IPlaybackPosition;
}
/**
 * interface representing the locale of the track.
 * @property identifier @type {string} The locale of the track.
 */
export interface ILocale {
    identifier: string;
}
/**
 * Represents a track information.
 * @property id @type {string} The identifier for the track.
 * @property language @type {string} The language of the track.
 * @property displayName @type {string} The display name of the track.
 */
export interface ITrack {
    id: string;
    language: ILocale;
    displayName?: string;
}
/**
 * Represents the capabilities of a media endpoint.
 * @property actions @type {Action[]} An array of actions.
 * @property speeds @type {number[]} An array of supported speeds.
 * @property ratings @type {number[]} An array of ratings.
 * @property forwardSkipSteps @type {ITimeValue[]} An array of forward skip steps.
 * @property backwardSkipSteps @type {ITimeValue[]} An array of backward skip steps.
 */
export interface ICapabilities {
    actions: Action[];
    speeds: number[];
    ratings: number[];
    forwardSkipSteps: ITimeValue[];
    backwardSkipSteps: ITimeValue[];
}
/**
 * Represents the state of a playlist.
 * @property repeatMode @type {RepeatMode} the repeat mode of the playlist.
 * @property shuffle @type {boolean} if the playlist should be shuffled.
 */
export interface IPlaylistState {
    repeatMode: RepeatMode;
    shuffle: boolean;
}
/**
 * Represents the artwork expected by objects.
 * @property url @type {string} URL of the artwork.
 * @property sizeTag @type {string} Optional. Size tag of artwork.
 * @property id @type {string} Optional. ID of artwork.
 * @property tag @type {string} Optional. Tag of artwork.
 */
export interface IArtwork {
    url: string;
    sizeTag?: string;
    id?: string;
    tag?: string;
}
/**
 * Represents information about a radio station.
 * @property stationName @type {string} Optional. The Name of the radio station.
 * @property stationCode @type {string} Optional.  The code of the radio station.
 * @property stationLogo @type {} An array of logos supported by the radio station.
 * @property frequency @type {string} Optional. The frequency of the radio station.
 * @property band @type {string} Optional. The broadcast band of the radio station.
 * @property subChannels @type {string} Optional. An array of strings speicifying the sub channels of the radio station.
 * @property serviceFollowing @type {RadioBand} The service following of the radio station.
 * @property activeSubchannel @type {string} Optional. The active subchannel of the radio station.
 * @property radioText @type {string} Optional. The radio text of the radio station.
 * @property isMuted @type {boolean} Optional. If the radio station is muted.
 * @property isDigital @type {boolean} Optional. If the radio station is digital.
 * @property isStereo @type {boolean} Optional. If the radio station is stereo.
 * @property isDigitalAudio @type {boolean} Optional. If the radio station is digital audio.
 * @property isLiveAudio @type {boolean} Optional. If the radio station is live audio.
 * @property isAcquiring @type {boolean} Optional. If the radio station is acquiring.
 */
export interface IRadioStationInfo {
    stationName?: string;
    stationCode?: string;
    stationLogo: IArtwork[];
    frequency?: string;
    band?: string;
    subChannels: string[];
    serviceFollowing: RadioBand;
    activeSubchannel?: string;
    radioText?: string;
    isMuted: boolean;
    isDigital: boolean;
    isStereo: boolean;
    isDigitalAudio: boolean;
    isLiveAudio: boolean;
    isAcquiring: boolean;
}
/**
 * Represents information about the media provider.
 * @property name  @type {string} The name of media provider.
 * @property logo  @type {IArtwork} An array of logo supported by the media provider.
 */
export interface IMediaProviderInfo {
    name: string;
    logo: IArtwork[];
}
/**
 * Represents information about an artist.
 * @property name  @type {string} The name of the artist.
 * @property id  @type {string} The ID of the artist.
 */
export interface IArtist {
    name: string;
    id: string;
}
/**
 * Represents infomation about an audio book.
 * @property chapterTitle @type {string} Optional. The title of a chapter.
 * @property narrator @type {IArtist} Optional. An array that contains the narrators of the audio book.
 */
export interface IAudioBookInfo {
    chapterTitle?: string;
    narrator: IArtist[];
}
/**
 * Represent the playback source.
 * @property source @type {string}  The source of playback.
 * @property id @type {string} Optional. The ID of the playback source.
 */
export interface IPlaybackSource {
    source: string;
    id?: string;
}
/**
 * interface expected by object returning metadata.
 * @property mediaId @type {MediaId | string} The ID of the media.
 * @property title @type {string} Optional. The title of the media.
 * @property date @type {string}  Optional. The date of the media.
 * @property authors @type {IArtist[]}  Optional. An array that contains the authors of the media.
 * @property artists @type {IArtist[]}  Optional. An array that contains the artists of the media.
 * @property composers @type {IArtist[]}  Optional. An array that contains the composers of the media.
 * @property genre @type {string} Optional. The genre of the media.
 * @property description @type {string} Optional. The description of the media
 * @property album @type {string} Optional. The album that contains the media.
 * @property artwork @type {IArtwork[]} An artwork of media.
 * @property radioStationInfo @type {IRadioStationInfo} Optional. Information about the radio station that is playing the media.
 * @property mediaProviderInfo @type {IMediaProviderInfo} Optional. Information about the media provider that is playing the media.
 * @property audioBookInfo @type {IAudioBookInfo} Optional. Information about the audio book that is playing the media.
 * @property playbackSource @type {IPlaybackSource} Optional. Information about the playback source.
 * @property mediaType @type {string} Optional. The type of media.
 */
export interface IMediaMetadata {
    mediaId: MediaId | string;
    title?: string;
    date?: string;
    authors?: IArtist[];
    artists?: IArtist[];
    composers?: IArtist[];
    genre?: string;
    description?: string;
    album?: string;
    artwork: IArtwork[];
    radioStationInfo?: IRadioStationInfo;
    mediaProviderInfo?: IMediaProviderInfo;
    audioBookInfo?: IAudioBookInfo;
    playbackSource?: IPlaybackSource;
    mediaType?: string;
}
/**
 * Optional context passed to a media command.
 * @property source @type {CommandSource} The initiator of the command, e.g., remote control or display turned off.
 */
export interface ICommandContext {
    source: CommandSource;
}
/**
 * Repesents a generic error that might be thrown.
 * @property type @type {string} The type of error.
 * @property message @type {string} The message describing the error.
 */
export interface KeplerMediaControlsError {
    type: string;
    message: string;
}
/**
 * Represents a subscription that can be used to subsribe to various things.
 * like media endpoint listener, media state changes etc.
 */
export interface ISubscription {
    /**
     * Removes the subscription.
     */
    unsubscribe: () => void;
}
/**
 * When implemented, handles media control state changes.
 */
export interface IMediaControlListener {
    /**
     * Invoked when a media control endpoint session changes state.
     * @param updatedStates @type {MediaSessionState[]} array of updated states.
     */
    onStateChanged: (updatedStates: MediaSessionState[]) => void;
}
/**
 * Represents a media session ID.
 * @property id @type {number} The ID of the session.
 */
export interface IMediaSessionId {
    id: number;
}
/**
 * Represents information about the media.
 * @property id @type {MediaId} The ID of the media.
 * @property hasVideo @type {boolean} When set to `true` the media has a video component; otherwise `false`.
 * @property availableAudioTracks @type {ITrack[]} An array of the available audio tracks.
 * @property availableTextTracks @type {ITrack[]} An array of the available text tracks.
 * @property duration @type {ITimeValue} The duration of the media.
 * @property startTime @type {ITimeValue} The start time of the media.
 * @property seekRangeStart @type {ITimeValue} The start of the seek range.
 * @property seekRangeEnd @type {ITimeValue} The end of the seek range.
 * @property activeAudioTrack @type {ITrack} The active audio track.
 * @property activeTextTrack @type {ITrack} the active text track.
 * @property currentRating @type {number} The current rating.
 */
export interface IMediaInfo {
    id: MediaId;
    hasVideo: boolean;
    availableAudioTracks: ITrack[];
    availableTextTracks: ITrack[];
    duration?: ITimeValue;
    startTime?: ITimeValue;
    seekRangeStart?: ITimeValue;
    seekRangeEnd?: ITimeValue;
    activeAudioTrack?: ITrack;
    activeTextTrack?: ITrack;
    currentRating?: number;
}
/**
 * Represents a control.
 * @property name @type {string} The name of the control.
 * @property state @type {string} The state of the control.
 */
export interface IControl {
    name: string;
    state: string;
}
/**
 * Represents the media session state.
 * @property id @type {IMediaSessionId} The ID of the session.
 * @property playbackState @type {IPlaybackState} The playback state.
 * @property mediaInfo @type {IMediaInfo} The information about the media.
 * @property capabilities @type {ICapabilities} The capabilities supported by the media.
 * @property playlistState @type {IPlaylistState} The state of the playlist.
 * @property controls @type {IControl[]} An array of controls for supported by the media player.
 */
export interface MediaSessionState {
    id: IMediaSessionId;
    playbackState: IPlaybackState;
    mediaInfo?: IMediaInfo;
    capabilities: ICapabilities;
    playlistState?: IPlaylistState;
    controls: IControl[];
}
/**
 * Represeents the package ID of an app.
 * @property id @type {string} The ID of the package.
 */
export interface IPackageId {
    id: string;
}
/**
 * When implemented, handles media control callbacks.
 */
export interface IMediaControlHandlerAsync {
    /**
     * Handles a play request initiated through a media control.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with the request.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the play request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handlePlay: (sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Handles a pause request initiated through a media control.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with the request.
     * @param context @type {ICommandContext} Optional. Additional command context.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the pause request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handlePause: (sessionId?: IMediaSessionId, context?: ICommandContext) => Promise<void>;
    /**
     * Handles a toggle play pause request initiated through a media control.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with the request.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the toggle play pause request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handleTogglePlayPause: (sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Handles a stop request initiated through a media control.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with the request.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the stop request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handleStop: (sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Handles a start over request initiated through a media control.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with the request.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the start over request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handleStartOver: (sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Handles a fast forward request initiated through a media control.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with the request.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the fast forward request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handleFastForward: (sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Handles a rewind request initiated through a media control.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with the request.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the rewind request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handleRewind: (sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Handles a set playback speed request initiated through a media control.
     * @param speed @type {number} speed to set.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with the request.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the set playback speed request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handleSetPlaybackSpeed: (speed: number, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Handles a skip forward request initiated through a media control.
     * @param delta @type {ITimeValue} delta to skip forward.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with the request.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the skip forward request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handleSkipForward: (delta: ITimeValue, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Handles a skip backward request initiated through a media control.
     * @param delta @type {ITimeValue} delta to skip backward.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with the request.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the skip backward request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handleSkipBackward: (delta: ITimeValue, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Handles a seek request initiated through a media control.
     * @param position @type {ITimeValue} position to seek to.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with the request.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the seek request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handleSeek: (position: ITimeValue, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Handles a set audio volume request initiated through a media control.
     * @param volume @type {number} volume to set.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with the request.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the set audio volume request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handleSetAudioVolume: (volume: number, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Handles a set audio track request initiated through a media control.
     * @param @type {ITrack} audioTrack track to set.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with the request.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the set audio track request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handleSetAudioTrack: (audioTrack: ITrack, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Handles an enable text track request initiated through a media control.
     * @param @type {ITrack} textTrack track to enable.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with the request.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the enable text track request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handleEnableTextTrack: (textTrack: ITrack, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Handles a disable text track request initiated through a media control.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with the request.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the disable text track request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handleDisableTextTrack: (sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Handles a next request initiated through a media control.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with the request.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the next request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handleNext: (sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Handles a previous request initiated through a media control.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with the request.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the previous request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handlePrevious: (sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Handles an enable shuffle request initiated through a media control.
     * @param enable @type {boolean} enable shuffle.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with the request.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the enable shuffle request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handleEnableShuffle: (enable: boolean, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Handles a set repeat mode request initiated through a media control.
     * @param mode @type {RepeatMode} repeat mode.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with the request.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the pause set repeat mode is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handleSetRepeatMode: (mode: RepeatMode, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Handles a set rating request.
     * @param id @type {MediaId} The ID of the media.
     * @param rating @type {number} The value to set for the rating.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with the request.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the set rating request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handleSetRating: (id: MediaId, rating: number, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Handles a request for the metadata of the specified media item.
     * @param id @type {MediaId} The ID of the media.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handleGetMetadataInfo: (id: MediaId) => Promise<IMediaMetadata>;
    /**
     * Handles a request for a custom action.
     * @param action @type {Action} The action to perform.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with the request.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handleCustomAction: (action: Action, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Handles a request for the session state.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID of the session whose state is to be fetched.
     * If not provided, treat as a request for data on all sessions.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    handleGetSessionState: (sessionId?: IMediaSessionId) => Promise<MediaSessionState[]>;
}
/**
 * interface for media control clients
 */
export interface IMediaControlClientAsync {
    /**
     * Sends a play request on the media control endpoint.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    play: (sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Sends a pause requst on the media control endpoint.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    pause: (sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Sends a togglePlayPause request on the media control endpoint.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    togglePlayPause: (sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Sends a stop request on the media control endpoint.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    stop: (sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Sends a startOver request on the media control endpoint.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    startOver: (sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Sends a fastForward request on the media control endpoint.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    fastForward: (sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Sends a rewind request on the media control endpoint.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    rewind: (sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Sends a setPlaybackSpeed request on the media control endpoint.
     * @param speed @type {number} speed to set.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    setPlaybackSpeed: (speed: number, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Sends a skipForward request on the media control endpoint.
     * @param delta @type {ITimeValue} The time delta to skip forward.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    skipForward: (delta: ITimeValue, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Sends a skipBackward request on the media control endpoint.
     * @param delta @type {ITimeValue} The time delta to skip backward.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    skipBackward: (delta: ITimeValue, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Sends a seek request on the media control endpoint.
     * @param position @type {ITimeValue} The time position to seek to.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    seek: (position: ITimeValue, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Sends a set audio volume request on the media control endpoint.
     * @param volume @type {number} The volume level to set. <are there constraints on this?>
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    setAudioVolume: (volume: number, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Sends a setAudioTrack requst on the media control endpoint.
     * @param track @type {ITrack} The track to set.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    setAudioTrack: (track: ITrack, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Sends a enableTextTrack request on the media control endpoint.
     * @param track @type {ITrack} The track to enable.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    enableTextTrack: (track: ITrack, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Sends a disableTextTrack request on the media control endpoint.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    disableTextTrack: (sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Sends a next request on the media control endpoint.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    next: (sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Sends a previous request on the media control endpoint.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    previous: (sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Sends a enableShuffle request on the media control endpoint.
     * @param enable @type {boolean} When set to `true` shuffle is enabled; otherwise `false`.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    enableShuffle: (enable: boolean, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Sends a setRepeatMode request on the media control endpoint.
     * @param mode @type {RepeatMode} The mode to set.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    setRepeatMode: (mode: RepeatMode, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Sends a setRating request on the media control endpoint.
     * @param id @type {MediaId} The ID of the media.
     * @param rating @type {number} The rating to set. <Are there contraints on this?>
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    setRating: (id: MediaId, rating: number, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Sends a getMetadata request on the media control endpoint.
     * @param id @type {MediaId} The ID of the media.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    getMetadata: (id: MediaId) => Promise<IMediaMetadata>;
    /**
     * Sends a sendCustomAction request on the media control endpoint.
     * @param action @type {Action} The action to send.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the session to target is decided by the endpoint.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    sendCustomAction: (action: Action, sessionId?: IMediaSessionId) => Promise<void>;
    /**
     * Sends a getSessionState request on the media control endpoint.
     * @param sessionId @type  {IMediaSessionId} Optional. The session ID to target with
     * the request. If not provided, the request is interpretted to be for all available
     * sessions.
     * @returns @type {Promise} of @type {void} A Promise that resolves when the request is successfully handled,
     *                                          or rejects with an error if the request fails.
     */
    getSessionState: (sessionId?: IMediaSessionId) => Promise<MediaSessionState[]>;
    /**
     * Gets the package ID of this endpoint.
     * @returns @type {IPackageId} The package ID.
     */
    getEndpointPackageId: () => IPackageId;
    /**
     * Subscribes a listener to monitor changes in the media session state.
     * @param listener @type {IMediaControlListener} The listener to add.
     * @returns @type {Promise} of @type {ISubscription} A Promise that resolves with an ISubscription object. This object can be used
   *          to unsubscribe the listener when it's no longer needed.
     */
    addListener: (listener: IMediaControlListener) => Promise<ISubscription>;
    /**
     * Destroys the media control client asynchronously.
     */
    destroy: () => void;
}
/**
 * Represents a listener to add to monitor changes to the available media control endpoints.
 */
export interface IMediaControlEndpointLocatorListener {
    /**
     * Called when the list of endpoints changes.
     * @param controllers @type {IMediaControlClientAsync[]} An array of media control client endpoints
     * that are available. The returned list is ordered with the first media control having active focus.
     */
    onEndpointsChanged: (controllers: IMediaControlClientAsync[]) => void;
}
/**
 * Interface for asynchronously locating and interacting with media control endpoints.
 */
export interface IMediaControlEndpointLocatorAsync {
    /**
     * Call to obtain a list of media control clients.
     * @returns @type {Promise} of @type {MediaControlTypes.IMediaControlClientAsync[]} containing
     * an ordered list of media control endpoints. The returned list is ordered with the first
     * media control having active focus.
     */
    getMediaControlEndpoints: () => Promise<IMediaControlClientAsync[]>;
    /**
     * Subscribes a listener to monitor changes in the list of control endpoints.
     * @param listener @type {MediaControlTypes.IMediaControlEndpointLocatorListener}
     * @returns @type {Promise} of @type {MediaControlTypes.ISubscription} A Promise that
     * resolves to an ISubscription object. The resolved ISubscription object provides
     * a method to unsubscribe the listener when it's no longer need.
     */
    addChangeListener: (listener: IMediaControlEndpointLocatorListener) => Promise<ISubscription>;
}
/**
 * Represent media control server operations.
 * This interface provides methods for managing media control handlers and updating
 * media session states.
 *
 */
export interface IMediaControlServerAsync {
    /**
     * Assigns a handler to process requests for media control actions for a given
     * component.
     *
     * @param handler @type {IMediaConrolHandlerAsync} An instance of the `IMediaControlHandlerAsync` interface that
     *                manages media control actions.
     * @param instance @type {IComponentInstance} An instance of the `IComponentInstance` interface representing
     *                 the component for which the handler is being set.
     *
     * @remarks
     * Assigning a handler is essential for processing media control requests and
     * implementing custom media control logic.
     *
     * There is only one active handler at a time. The active handler is the one set by
     * the most recent invocation of setHandler.
     */
    setHandlerForComponent: (handler: IMediaControlHandlerAsync, instance: IComponentInstance) => void;
    /**
     * Updates the state of the media sessions.
     *
     * @param states @type {MediaSessionState[]} Array of MediaSessionStates containing
     * updated session states.
     *
     * @remarks
     * Updating the session states is crucial for reflecting changes in media playback
     * status, available media streams, and other related information.
     *
     * State changes can also be an action taken by a media control server application
     * upon acting on an media control action received through the installed
     * `IMediaControlHandlerAsync` instance.
     */
    updateMediaSessionStates: (states: MediaSessionState[]) => void;
}

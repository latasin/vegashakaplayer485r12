var __BUNDLE_START_TIME__=this.nativePerformanceNow?nativePerformanceNow():Date.now(),__DEV__=false,process=this.process||{},__METRO_GLOBAL_PREFIX__='';process.env=process.env||{};process.env.NODE_ENV=process.env.NODE_ENV||"production";
(function (global) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @polyfill
   * @nolint
   * @format
   */

  /* eslint-disable no-shadow, eqeqeq, curly, no-unused-vars, no-void, no-control-regex  */

  /**
   * This pipes all of our console logging functions to native logging so that
   * JavaScript errors in required modules show up in Xcode via NSLog.
   */
  var inspect = function () {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    //
    // https://github.com/joyent/node/blob/master/lib/util.js

    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        formatValueCalls: 0,
        stylize: stylizeNoColor
      };
      return formatValue(ctx, obj, opts.depth);
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function (val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      ctx.formatValueCalls++;
      if (ctx.formatValueCalls > 200) {
        return `[TOO BIG formatValueCalls ${ctx.formatValueCalls} exceeded limit of 200]`;
      }

      // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }

      // Look up the keys of the object.
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      // IE doesn't make error fields non-enumerable
      // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }

      // Some type of object without properties can be shortcutted.
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = '',
        array = false,
        braces = ['{', '}'];

      // Make Array say that they are Array
      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }

      // Make functions say that they are functions
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }

      // Make RegExps say that they are RegExps
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }

      // Make dates with properties first say the date
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }

      // Make error with message first say the error
      if (isError(value)) {
        base = ' ' + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function (key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value)) return ctx.stylize('' + value, 'number');
      if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
      // For some reason typeof null is "object", so special case here.
      if (isNull(value)) return ctx.stylize('null', 'null');
    }
    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
      };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function (line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function (line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }
      return name + ': ' + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function (prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }
      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.
    function isArray(ar) {
      return Array.isArray(ar);
    }
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    function isNull(arg) {
      return arg === null;
    }
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    function isString(arg) {
      return typeof arg === 'string';
    }
    function isUndefined(arg) {
      return arg === undefined;
    }
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    return inspect;
  }();
  var OBJECT_COLUMN_NAME = '(index)';
  var LOG_LEVELS = {
    trace: 0,
    info: 1,
    warn: 2,
    error: 3
  };
  var INSPECTOR_LEVELS = [];
  INSPECTOR_LEVELS[LOG_LEVELS.trace] = 'debug';
  INSPECTOR_LEVELS[LOG_LEVELS.info] = 'log';
  INSPECTOR_LEVELS[LOG_LEVELS.warn] = 'warning';
  INSPECTOR_LEVELS[LOG_LEVELS.error] = 'error';

  // Strip the inner function in getNativeLogFunction(), if in dev also
  // strip method printing to originalConsole.
  var INSPECTOR_FRAMES_TO_SKIP = 1;
  function getNativeLogFunction(level) {
    return function () {
      var str;
      if (arguments.length === 1 && typeof arguments[0] === 'string') {
        str = arguments[0];
      } else {
        str = Array.prototype.map.call(arguments, function (arg) {
          return inspect(arg, {
            depth: 10
          });
        }).join(', ');
      }

      // TRICKY
      // If more than one argument is provided, the code above collapses them all
      // into a single formatted string. This transform wraps string arguments in
      // single quotes (e.g. "foo" -> "'foo'") which then breaks the "Warning:"
      // check below. So it's important that we look at the first argument, rather
      // than the formatted argument string.
      var firstArg = arguments[0];
      var logLevel = level;
      if (typeof firstArg === 'string' && firstArg.slice(0, 9) === 'Warning: ' && logLevel >= LOG_LEVELS.error) {
        // React warnings use console.error so that a stack trace is shown,
        // but we don't (currently) want these to show a redbox
        // (Note: Logic duplicated in ExceptionsManager.js.)
        logLevel = LOG_LEVELS.warn;
      }
      if (global.__inspectorLog) {
        global.__inspectorLog(INSPECTOR_LEVELS[logLevel], str, [].slice.call(arguments), INSPECTOR_FRAMES_TO_SKIP);
      }
      if (groupStack.length) {
        str = groupFormat('', str);
      }
      global.nativeLoggingHook(str, logLevel);
    };
  }
  function repeat(element, n) {
    return Array.apply(null, Array(n)).map(function () {
      return element;
    });
  }
  function consoleTablePolyfill(rows) {
    // convert object -> array
    if (!Array.isArray(rows)) {
      var data = rows;
      rows = [];
      for (var key in data) {
        if (data.hasOwnProperty(key)) {
          var row = data[key];
          row[OBJECT_COLUMN_NAME] = key;
          rows.push(row);
        }
      }
    }
    if (rows.length === 0) {
      global.nativeLoggingHook('', LOG_LEVELS.info);
      return;
    }
    var columns = Object.keys(rows[0]).sort();
    var stringRows = [];
    var columnWidths = [];

    // Convert each cell to a string. Also
    // figure out max cell width for each column
    columns.forEach(function (k, i) {
      columnWidths[i] = k.length;
      for (var j = 0; j < rows.length; j++) {
        var cellStr = (rows[j][k] || '?').toString();
        stringRows[j] = stringRows[j] || [];
        stringRows[j][i] = cellStr;
        columnWidths[i] = Math.max(columnWidths[i], cellStr.length);
      }
    });

    // Join all elements in the row into a single string with | separators
    // (appends extra spaces to each cell to make separators  | aligned)
    function joinRow(row, space) {
      var cells = row.map(function (cell, i) {
        var extraSpaces = repeat(' ', columnWidths[i] - cell.length).join('');
        return cell + extraSpaces;
      });
      space = space || ' ';
      return cells.join(space + '|' + space);
    }
    var separators = columnWidths.map(function (columnWidth) {
      return repeat('-', columnWidth).join('');
    });
    var separatorRow = joinRow(separators, '-');
    var header = joinRow(columns);
    var table = [header, separatorRow];
    for (var i = 0; i < rows.length; i++) {
      table.push(joinRow(stringRows[i]));
    }

    // Notice extra empty line at the beginning.
    // Native logging hook adds "RCTLog >" at the front of every
    // logged string, which would shift the header and screw up
    // the table
    global.nativeLoggingHook('\n' + table.join('\n'), LOG_LEVELS.info);
  }
  var GROUP_PAD = "\u2502"; // Box light vertical
  var GROUP_OPEN = "\u2510"; // Box light down+left
  var GROUP_CLOSE = "\u2518"; // Box light up+left

  var groupStack = [];
  function groupFormat(prefix, msg) {
    // Insert group formatting before the console message
    return groupStack.join('') + prefix + ' ' + (msg || '');
  }
  function consoleGroupPolyfill(label) {
    global.nativeLoggingHook(groupFormat(GROUP_OPEN, label), LOG_LEVELS.info);
    groupStack.push(GROUP_PAD);
  }
  function consoleGroupCollapsedPolyfill(label) {
    global.nativeLoggingHook(groupFormat(GROUP_CLOSE, label), LOG_LEVELS.info);
    groupStack.push(GROUP_PAD);
  }
  function consoleGroupEndPolyfill() {
    groupStack.pop();
    global.nativeLoggingHook(groupFormat(GROUP_CLOSE), LOG_LEVELS.info);
  }
  function consoleAssertPolyfill(expression, label) {
    if (!expression) {
      global.nativeLoggingHook('Assertion failed: ' + label, LOG_LEVELS.error);
    }
  }
  if (global.nativeLoggingHook) {
    var originalConsole = global.console;
    // Preserve the original `console` as `originalConsole`

    global.console = {
      error: getNativeLogFunction(LOG_LEVELS.error),
      info: getNativeLogFunction(LOG_LEVELS.info),
      log: getNativeLogFunction(LOG_LEVELS.info),
      warn: getNativeLogFunction(LOG_LEVELS.warn),
      trace: getNativeLogFunction(LOG_LEVELS.trace),
      debug: getNativeLogFunction(LOG_LEVELS.trace),
      table: consoleTablePolyfill,
      group: consoleGroupPolyfill,
      groupEnd: consoleGroupEndPolyfill,
      groupCollapsed: consoleGroupCollapsedPolyfill,
      assert: consoleAssertPolyfill
    };
    Object.defineProperty(console, '_isPolyfilled', {
      value: true,
      enumerable: false
    });

    // If available, also call the original `console` method since that is
    // sometimes useful. Ex: on OS X, this will let you see rich output in
    // the Safari Web Inspector console.
  } else if (!global.console) {
    var stub = function stub() {};
    var log = global.print || stub;
    global.console = {
      debug: log,
      error: log,
      info: log,
      log: log,
      trace: log,
      warn: log,
      assert: function assert(expression, label) {
        if (!expression) {
          log('Assertion failed: ' + label);
        }
      },
      clear: stub,
      dir: stub,
      dirxml: stub,
      group: stub,
      groupCollapsed: stub,
      groupEnd: stub,
      profile: stub,
      profileEnd: stub,
      table: stub
    };
    Object.defineProperty(console, '_isPolyfilled', {
      value: true,
      enumerable: false
    });
  }
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   * @polyfill
   */

  var _inGuard = 0;
  /**
   * This is the error handler that is called when we encounter an exception
   * when loading a module. This will report any errors encountered before
   * ExceptionsManager is configured.
   */
  var _globalHandler = function onError(e, isFatal) {
    throw e;
  };

  /**
   * The particular require runtime that we are using looks for a global
   * `ErrorUtils` object and if it exists, then it requires modules with the
   * error handler specified via ErrorUtils.setGlobalHandler by calling the
   * require function with applyWithGuard. Since the require module is loaded
   * before any of the modules, this ErrorUtils must be defined (and the handler
   * set) globally before requiring anything.
   */
  var ErrorUtils = {
    setGlobalHandler: function setGlobalHandler(fun) {
      _globalHandler = fun;
    },
    getGlobalHandler: function getGlobalHandler() {
      return _globalHandler;
    },
    reportError: function reportError(error) {
      _globalHandler && _globalHandler(error, false);
    },
    reportFatalError: function reportFatalError(error) {
      // NOTE: This has an untyped call site in Metro.
      _globalHandler && _globalHandler(error, true);
    },
    applyWithGuard: function applyWithGuard(fun, context, args,
    // Unused, but some code synced from www sets it to null.
    unused_onError,
    // Some callers pass a name here, which we ignore.
    unused_name) {
      try {
        _inGuard++;
        /* $FlowFixMe[incompatible-call] : TODO T48204745 (1) apply(context,
         * null) is fine. (2) array -> rest array should work */
        /* $FlowFixMe[incompatible-type] : TODO T48204745 (1) apply(context,
         * null) is fine. (2) array -> rest array should work */
        return fun.apply(context, args);
      } catch (e) {
        ErrorUtils.reportError(e);
      } finally {
        _inGuard--;
      }
      return null;
    },
    applyWithGuardIfNeeded: function applyWithGuardIfNeeded(fun, context, args) {
      if (ErrorUtils.inGuard()) {
        /* $FlowFixMe[incompatible-call] : TODO T48204745 (1) apply(context,
         * null) is fine. (2) array -> rest array should work */
        /* $FlowFixMe[incompatible-type] : TODO T48204745 (1) apply(context,
         * null) is fine. (2) array -> rest array should work */
        return fun.apply(context, args);
      } else {
        ErrorUtils.applyWithGuard(fun, context, args);
      }
      return null;
    },
    inGuard: function inGuard() {
      return !!_inGuard;
    },
    guard: function guard(fun, name, context) {
      var _ref;
      // TODO: (moti) T48204753 Make sure this warning is never hit and remove it - types
      // should be sufficient.
      if (typeof fun !== 'function') {
        console.warn('A function must be passed to ErrorUtils.guard, got ', fun);
        return null;
      }
      var guardName = (_ref = name != null ? name : fun.name) != null ? _ref : '<generated guard>';
      /* $FlowFixMe[missing-this-annot] The 'this' type annotation(s) required by
       * Flow's LTI update could not be added via codemod */
      function guarded() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return ErrorUtils.applyWithGuard(fun, context != null ? context : this, args, null, guardName);
      }
      return guarded;
    }
  };
  global.ErrorUtils = ErrorUtils;
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * @polyfill
   * @nolint
   */

  (function () {
    'use strict';

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    /**
     * Returns an array of the given object's own enumerable entries.
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries
     */
    if (typeof Object.entries !== 'function') {
      Object.entries = function (object) {
        // `null` and `undefined` values are not allowed.
        if (object == null) {
          throw new TypeError('Object.entries called on non-object');
        }
        var entries = [];
        for (var key in object) {
          if (hasOwnProperty.call(object, key)) {
            entries.push([key, object[key]]);
          }
        }
        return entries;
      };
    }

    /**
     * Returns an array of the given object's own enumerable entries.
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values
     */
    if (typeof Object.values !== 'function') {
      Object.values = function (object) {
        // `null` and `undefined` values are not allowed.
        if (object == null) {
          throw new TypeError('Object.values called on non-object');
        }
        var values = [];
        for (var key in object) {
          if (hasOwnProperty.call(object, key)) {
            values.push(object[key]);
          }
        }
        return values;
      };
    }
  })();
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright (c) 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.
   *
   * PROPRIETARY/CONFIDENTIAL
   *
   * Use is subject to license terms.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KeplerMediaDescriptor = exports.VideoFormat = exports.VideoDecoderConfig = exports.VideoColorTransfer = exports.VideoColorPrimaries = exports.VideoColorMatrix = exports.MediaFormatProfileLevel = exports.MediaFormat = exports.MediaCodecFeatures = exports.DecoderFeatures = exports.CodecMimeType = exports.AudioSampleFormat = exports.AudioFormat = exports.AudioDecoderConfig = undefined;
  Object.defineProperty(exports, "KeplerMediaDescriptor", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[0]).KeplerMediaDescriptor;
    }
  });
  Object.defineProperty(exports, "AudioDecoderConfig", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1]).AudioDecoderConfig;
    }
  });
  Object.defineProperty(exports, "AudioFormat", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1]).AudioFormat;
    }
  });
  Object.defineProperty(exports, "AudioSampleFormat", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1]).AudioSampleFormat;
    }
  });
  Object.defineProperty(exports, "CodecMimeType", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1]).CodecMimeType;
    }
  });
  Object.defineProperty(exports, "DecoderFeatures", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1]).DecoderFeatures;
    }
  });
  Object.defineProperty(exports, "MediaCodecFeatures", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1]).MediaCodecFeatures;
    }
  });
  Object.defineProperty(exports, "MediaFormat", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1]).MediaFormat;
    }
  });
  Object.defineProperty(exports, "MediaFormatProfileLevel", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1]).MediaFormatProfileLevel;
    }
  });
  Object.defineProperty(exports, "VideoColorMatrix", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1]).VideoColorMatrix;
    }
  });
  Object.defineProperty(exports, "VideoColorPrimaries", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1]).VideoColorPrimaries;
    }
  });
  Object.defineProperty(exports, "VideoColorTransfer", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1]).VideoColorTransfer;
    }
  });
  Object.defineProperty(exports, "VideoDecoderConfig", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1]).VideoDecoderConfig;
    }
  });
  Object.defineProperty(exports, "VideoFormat", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1]).VideoFormat;
    }
  });
},"87c1deaf4e092124fc7a",["c3af3ddac05c2d00578b","5af0ab6c9217f3564784"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2024 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KeplerMediaDescriptor = undefined;
  // rs_out
  // @ts-nocheck

  var KeplerMediaDescriptorTurboModule_1 = __importDefault(_$$_REQUIRE(_dependencyMap[0]));
  /**
   * The entry point for KMD apis. This class provides apis to query the media capabilities of
   * the device.
   */
  var KeplerMediaDescriptor = /*#__PURE__*/function () {
    function KeplerMediaDescriptor() {
      _$$_REQUIRE(_dependencyMap[1])(this, KeplerMediaDescriptor);
    }
    /**
     * Query the Media capabilities asynchronously.
     *
     * @param config @type {MediaConfig} which encapsulates all the attributes to be queried
     * querying capabilities.
     *
     * @returns @type {Promise} of @type {MediaCapabilities} containing all the capabilities returned
     * according to the @param config. Empty array if there is an error (input or internal) while querying the device
     * or the device doesn't support the requested  attributes.
     */
    return _$$_REQUIRE(_dependencyMap[2])(KeplerMediaDescriptor, null, [{
      key: "queryMediaCapabilities",
      value: (function () {
        var _queryMediaCapabilities = _$$_REQUIRE(_dependencyMap[3])(function* (config) {
          var _jsonObjs;
          var jsonObjs;
          var isVideo;
          var displayResolution;
          var result = [];
          if (config instanceof _$$_REQUIRE(_dependencyMap[4]).VideoDecoderConfig) {
            jsonObjs = KeplerMediaDescriptorTurboModule_1.default.queryVideoDecoderCapabilities(config);
            isVideo = true;
          } else if (config instanceof _$$_REQUIRE(_dependencyMap[4]).AudioDecoderConfig) {
            jsonObjs = KeplerMediaDescriptorTurboModule_1.default.queryAudioDecoderCapabilities(config);
            isVideo = false;
          } else {
            console.error('unknown config type, return empty');
            return new Promise(function (_, reject) {
              reject(new TypeError("unknown config type"));
            });
          }
          console.debug('js queryMediaCapabilities: ', jsonObjs);
          (_jsonObjs = jsonObjs) == null ? undefined : _jsonObjs.forEach(function (obj) {
            var mediaCaps;
            if (isVideo) {
              mediaCaps = new (_$$_REQUIRE(_dependencyMap[5]).VideoDecoderCapabilitiesImpl)(obj);
            } else {
              mediaCaps = new (_$$_REQUIRE(_dependencyMap[5]).AudioDecoderCapabilitiesImpl)(obj);
            }
            result.push(mediaCaps);
          });
          console.debug('result length: ', result.length);
          return new Promise(function (resolve, _) {
            resolve(result);
          });
        });
        function queryMediaCapabilities(_x) {
          return _queryMediaCapabilities.apply(this, arguments);
        }
        return queryMediaCapabilities;
      }())
    }, {
      key: "queryMediaCapabilitiesSync",
      value: function queryMediaCapabilitiesSync(config) {
        var _jsonObjs2;
        var jsonObjs;
        var isVideo;
        var result = [];
        if (config instanceof _$$_REQUIRE(_dependencyMap[4]).VideoDecoderConfig) {
          jsonObjs = KeplerMediaDescriptorTurboModule_1.default.queryVideoDecoderCapabilities(config);
          isVideo = true;
        } else if (config instanceof _$$_REQUIRE(_dependencyMap[4]).AudioDecoderConfig) {
          jsonObjs = KeplerMediaDescriptorTurboModule_1.default.queryAudioDecoderCapabilities(config);
          isVideo = false;
        } else {
          console.error('unknown config type, return empty');
          return result;
        }
        console.debug('js queryMediaCapabilities: ', jsonObjs);
        (_jsonObjs2 = jsonObjs) == null ? undefined : _jsonObjs2.forEach(function (obj) {
          var mediaCaps;
          if (isVideo) {
            mediaCaps = new (_$$_REQUIRE(_dependencyMap[5]).VideoDecoderCapabilitiesImpl)(obj);
          } else {
            mediaCaps = new (_$$_REQUIRE(_dependencyMap[5]).AudioDecoderCapabilitiesImpl)(obj);
          }
          result.push(mediaCaps);
        });
        console.debug('result length: ', result.length);
        return result;
      }
    }]);
  }();
  exports.KeplerMediaDescriptor = KeplerMediaDescriptor;
},"c3af3ddac05c2d00578b",["af1bcd3f248e77fadb2e","3508abd8c6b891008c0d","5533cec96f6a88041c69","ff7d8d645536d793bbec","5af0ab6c9217f3564784","9d9845d625957629df79"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  //@ts-ignore

  // prettier-ignore
  exports.default = _$$_REQUIRE(_dependencyMap[0]).TurboModuleRegistry.getEnforcing('KeplerMediaDescriptorTurboModule');
},"af1bcd3f248e77fadb2e",["8a35a86b7946c72e0207"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Copyright (c) 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.
   *
   * PROPRIETARY/CONFIDENTIAL
   *
   * Use is subject to license terms.
   *
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TurboModuleRegistry = undefined;
  exports.TurboModuleRegistry = _$$_REQUIRE(_dependencyMap[0]);
},"8a35a86b7946c72e0207",["33d6b98d6e39f6b0a8f9"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * Portions of this file are copyright (c) 2023 Amazon.com, Inc. or its
   * affiliates.  All rights reserved.
   *
   * PORTIONS OF THIS FILE ARE AMAZON PROPRIETARY/CONFIDENTIAL.  USE IS SUBJECT TO
   * LICENSE TERMS.
   *
   * Amazon modifications are indicated by [amznmod_* comments].
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getEnforcing = exports.get = undefined;
  var turboModuleProxy = global.__turboModuleProxy;
  function requireModule(name) {
    if (turboModuleProxy != null) {
      return turboModuleProxy(name);
    }
    return null;
  }
  function get(name) {
    return requireModule(name);
  }
  exports.get = get;
  function getEnforcing(name) {
    var module = requireModule(name);
    (0, _$$_REQUIRE(_dependencyMap[0]).default)(module != null, `TurboModuleRegistry.getEnforcing(...): '${name}' could not be found. ` + 'Verify that a module by this name is registered in the native binary.');
    return module;
  }
  exports.getEnforcing = getEnforcing;
},"33d6b98d6e39f6b0a8f9",["8d9475a2cb77b53e450d"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * Portions of this file are copyright (c) 2023 Amazon.com, Inc. or its
   * affiliates.  All rights reserved.
   *
   * PORTIONS OF THIS FILE ARE AMAZON PROPRIETARY/CONFIDENTIAL.  USE IS SUBJECT TO
   * LICENSE TERMS.
   *
   * Amazon modifications are indicated by [amznmod_* comments].
   */
  /**
   * amznmod_tmapi: Migrated to typescript
   */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * Use invariant() to assert state which your program assumes to be true.
   *
   * Provide sprintf-style format (only %s is supported) and arguments
   * to provide information about what broke and what you were
   * expecting.
   *
   * The invariant message will be stripped in production, but the invariant
   * will remain to ensure logic does not differ in production.
   */
  var NODE_ENV = "production";
  var invariant = function invariant(condition, format) {
    for (var _len = arguments.length, extraArgs = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      extraArgs[_key - 2] = arguments[_key];
    }
    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      } else {
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return extraArgs[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }
      // @ts-ignore `framesToPop` is not part of Error type but something Meta (and maybe RN) uses.
      error.framesToPop = 1; // we don't care about invariant's own frame
      throw error;
    }
  };
  exports.default = invariant;
},"8d9475a2cb77b53e450d",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
  }
  module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"3508abd8c6b891008c0d",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _defineProperties(e, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _$$_REQUIRE(_dependencyMap[0])(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
      writable: false
    }), e;
  }
  module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"5533cec96f6a88041c69",["a8c8780df4560174ada7"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function toPropertyKey(t) {
    var i = _$$_REQUIRE(_dependencyMap[0])(t, "string");
    return "symbol" == _$$_REQUIRE(_dependencyMap[1])["default"](i) ? i : i + "";
  }
  module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"a8c8780df4560174ada7",["ffc6df13d33bb305555d","d8362e1f4a4e80eaa9d4"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function toPrimitive(t, r) {
    if ("object" != _$$_REQUIRE(_dependencyMap[0])["default"](t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (undefined !== e) {
      var i = e.call(t, r || "default");
      if ("object" != _$$_REQUIRE(_dependencyMap[0])["default"](i)) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"ffc6df13d33bb305555d",["d8362e1f4a4e80eaa9d4"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _typeof(o) {
    "@babel/helpers - typeof";

    return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
  }
  module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"d8362e1f4a4e80eaa9d4",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function asyncGeneratorStep(n, t, e, r, o, a, c) {
    try {
      var i = n[a](c),
        u = i.value;
    } catch (n) {
      return void e(n);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
  }
  function _asyncToGenerator(n) {
    return function () {
      var t = this,
        e = arguments;
      return new Promise(function (r, o) {
        var a = n.apply(t, e);
        function _next(n) {
          asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
        }
        function _throw(n) {
          asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
        }
        _next(undefined);
      });
    };
  }
  module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"ff7d8d645536d793bbec",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2024 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VideoFormat = exports.VideoDecoderConfig = exports.VideoColorTransfer = exports.VideoColorPrimaries = exports.VideoColorMatrix = exports.MediaFormatProfileLevel = exports.MediaFormat = exports.MediaCodecFeatures = exports.DecoderFeatures = exports.CodecMimeType = exports.AudioSampleFormat = exports.AudioFormat = exports.AudioDecoderConfig = undefined;
  /**
   * The VideoDecoderConfig defines all the attributes required for Video
   * decode use case.
   *
   * Applications should create this class to query the video decoders
   * supported on the device.
   */
  var VideoDecoderConfig = /*#__PURE__*/function () {
    function VideoDecoderConfig() {
      _$$_REQUIRE(_dependencyMap[0])(this, VideoDecoderConfig);
    }
    return _$$_REQUIRE(_dependencyMap[1])(VideoDecoderConfig, [{
      key: "mediaFormat",
      get:
      /**
       * @returns {MediaFormat} set using the setter.
       */
      function get() {
        return this.mMediaFormat;
      }
      /**
       * Sets the MediaFormatProfileLevel.
       *
       * This can be used to query on the profile levels
       * supported.
       *
       * @see MediaFormatProfileLevel for further details
       */,
      set:
      /**
       * Sets the MediaFormat.
       *
       * This can be used to query on the format of the media supported by the device.
       *
       * @see MediaFormat for further details.
       */
      function set(format) {
        this.mMediaFormat = format;
      }
    }, {
      key: "formatProfileLevel",
      get:
      /**
       * @returns {MediaFormatProfileLevel} set using the setter.
       */
      function get() {
        return this.mFormatProfileLevel;
      }
      /**
       * Sets the MediaCodecFeatures.
       *
       * This can be used to query on media codec features supported
       * by the device.
       *
       * @see MediaCodecFeatures for more details.
       */,
      set: function set(profileLevel) {
        this.mFormatProfileLevel = profileLevel;
      }
    }, {
      key: "mediaCodecFeatures",
      get:
      /**
       * @returns {MediaCodecFeatures} set using setter.
       */
      function get() {
        return this.mMediaCodecFeatures;
      }
      /**
       * Sets the VideoFormat.
       *
       * This can be used to query on different properties supported
       * by the video codecs on the device.
       *
       * @see VideoFormat for further details.
       */,
      set: function set(features) {
        this.mMediaCodecFeatures = features;
      }
    }, {
      key: "videoFormat",
      get:
      /**
       * @returns {VideoFormat} set using the setter.
       */
      function get() {
        return this.mVideoFormat;
      }
      /**
       * Sets the DecoderFeatures.
       *
       * This can be used to query on decoder features like decryption.
       *
       * @see DecoderFeatures for further details.
       */,
      set: function set(format) {
        this.mVideoFormat = format;
      }
    }, {
      key: "decoderFeatures",
      get:
      /**
       * @returns {DecoderFeatures} set using the setter.
       */
      function get() {
        return this.mCodecFeatures;
      },
      set: function set(features) {
        this.mCodecFeatures = features;
      }
    }]);
  }();
  exports.VideoDecoderConfig = VideoDecoderConfig;
  /**
   * The AudioDecoderConfig defines all the attributes required for audio
   * decode use case.
   *
   * Applications should create this class to query the audio decoders
   * supported on the device.
   */
  var AudioDecoderConfig = /*#__PURE__*/function () {
    function AudioDecoderConfig() {
      _$$_REQUIRE(_dependencyMap[0])(this, AudioDecoderConfig);
    }
    return _$$_REQUIRE(_dependencyMap[1])(AudioDecoderConfig, [{
      key: "mediaFormat",
      get:
      /**
       * @returns {MediaFormat} set using the setter.
       */
      function get() {
        return this.mMediaFormat;
      }
      /**
       * Sets the MediaFormatProfileLevel.
       *
       * This can be used to query on the profile levels
       * supported.
       *
       * @see MediaFormatProfileLevel for further details
       */,
      set:
      /**
       * Sets the MediaFormat.
       *
       * This can be used to query on the format of the media supported by the device.
       *
       * @see MediaFormat for further details.
       */
      function set(format) {
        this.mMediaFormat = format;
      }
    }, {
      key: "formatProfileLevel",
      get:
      /**
       * @returns {MediaFormatProfileLevel} set using the setter.
       */
      function get() {
        return this.mFormatProfileLevel;
      }
      /**
       * Sets the MediaCodecFeatures.
       *
       * This can be used to query on media codec features supported
       * by the device.
       *
       * @see MediaCodecFeatures for more details.
       */,
      set: function set(profileLevel) {
        this.mFormatProfileLevel = profileLevel;
      }
    }, {
      key: "mediaCodecFeatures",
      get:
      /**
       * @returns {MediaCodecFeatures} set using setter.
       */
      function get() {
        return this.mMediaCodecFeatures;
      }
      /**
       * Sets the AudioFormat.
       *
       * This can be used to query on different properties supported
       * by the audio codecs on the device.
       *
       * @see AudioFormat for further details
       */,
      set: function set(features) {
        this.mMediaCodecFeatures = features;
      }
    }, {
      key: "audioFormat",
      get:
      /**
       * @returns {AudioFormat} set using the setter.
       */
      function get() {
        return this.mAudioFormat;
      }
      /**
       * Sets the DecoderFeatures.
       *
       * This can be used to query on decoder features like decryption.
       *
       * @see DecoderFeatures for further details.
       */,
      set: function set(format) {
        this.mAudioFormat = format;
      }
    }, {
      key: "codecFeatures",
      get:
      /**
       * @returns {DecoderFeatures} set by the setter.
       */
      function get() {
        return this.mDecoderFeatures;
      },
      set: function set(features) {
        this.mDecoderFeatures = features;
      }
    }]);
  }();
  exports.AudioDecoderConfig = AudioDecoderConfig;
  /**
   * Represents the format of the media.
   */
  var MediaFormat = /*#__PURE__*/function () {
    /**
     * constructs a MediaFormat object.
     *
     * Refer to
     * https://datatracker.ietf.org/doc/html/rfc6381
     *
     * MIME is the ability to identify the specific codec.
     *
     * @see {CodecMimeType} for Video/Audio codec mimetypes defined.
     *
     * @param mimeType @type {CodecMimeType} to be queried for.
     */
    function MediaFormat(mimeType) {
      _$$_REQUIRE(_dependencyMap[0])(this, MediaFormat);
      this.mMime = mimeType;
    }
    /**
     *
     * @returns {CodecMimeType} associated with this object.
     */
    return _$$_REQUIRE(_dependencyMap[1])(MediaFormat, [{
      key: "mimeType",
      get: function get() {
        return this.mMime;
      }
      /**
       * Sets the target bitrate in kbps.
       *
       * This can also be used for dynamic configuration.
       */
    }, {
      key: "bitrateKbps",
      get:
      /**
       * @returns {number} the bitrate set by the setter.
       */
      function get() {
        return this.mBitRate;
      },
      set: function set(bitrate) {
        this.mBitRate = bitrate;
      }
    }]);
  }();
  exports.MediaFormat = MediaFormat;
  /**
   * Class to set the codec profile and level.
   */
  var MediaFormatProfileLevel = /*#__PURE__*/function () {
    /**
     * constructs a MediaFormatProfileLevel object.
     *
     * Refer to
     * https://datatracker.ietf.org/doc/html/rfc6381
     *
     * Codec Parameters represent the codec  major capabilities needed to decode
     * like codec/codec subtype and profiles/levels.
     *
     * For example string "avc1.640028" represents H264:-
     *     -- stream-format avc1
     *     -- profile 4.0 which is derived from 2 bytes bytes(base16) in the
     * sequence "640028"
     *     -- profile_idc identified by "64" which indicates "High Profile".
     *     -- level_idc which is "28" and 40 in decimal which means 4.0.
     *
     * @param params The codecs @type {string} for audio or video codec.
     */
    function MediaFormatProfileLevel(params) {
      _$$_REQUIRE(_dependencyMap[0])(this, MediaFormatProfileLevel);
      this.mCodecParams = params;
    }
    /**
     * @returns {string} set by the setter.
     */
    return _$$_REQUIRE(_dependencyMap[1])(MediaFormatProfileLevel, [{
      key: "codecParams",
      get: function get() {
        return this.mCodecParams;
      }
      /**
       * Sets the Profile and Level.
       *
       * For example codec parameters string
       * For video, "codecs=avc1.640028" has profile ID "0x64" which means high
       * profile for H264 and has level Id "0x28" which means level 4.0.
       *
       * For audio, "codecs=mp4a.40.02" has profile ID "0x02" which means low
       * complexity for AAC.
       *
       * This method can also be called for dynamic configuration.
       *
       * @param level @type {ProfileLevel} The desired profile and level to be used.
       *
       */
    }, {
      key: "profileLevel",
      get:
      /**
       * @returns {ProfileLevel} set using the setter.
       */
      function get() {
        return this.mProfileLevel;
      },
      set: function set(level) {
        this.mProfileLevel = level;
      }
    }]);
  }();
  exports.MediaFormatProfileLevel = MediaFormatProfileLevel;
  /**
   * @name {AudioFormat} provides setters to set different properties
   * which can be used to query for a specific audio codec which satisfies all
   * the properties set.
   */
  var AudioFormat = /*#__PURE__*/function () {
    function AudioFormat() {
      _$$_REQUIRE(_dependencyMap[0])(this, AudioFormat);
    }
    return _$$_REQUIRE(_dependencyMap[1])(AudioFormat, [{
      key: "channelCount",
      get:
      /**
       * @returns Channel count as @type {number} set by the setter
       */
      function get() {
        return this.mChannelCount;
      }
      /**
       * The number of audio samples taken per second (in Hz).
       */,
      set:
      /**
       * The number of channels in the audio signal.
       *
       * Example: 1(mono), 2(stereo), 3(2.1), 5(4.1), 6(5.1), 8(7.1) etc.
       */
      function set(count) {
        this.mChannelCount = count;
      }
    }, {
      key: "sampleRate",
      get:
      /**
       * @returns Sample rate in Hz as
       * @type {number}.
       */
      function get() {
        return this.mSampleRate;
      }
      /**
       * Sets the raw sample format, the supported values are
       * defined in @see AudioSampleFormat
       */,
      set: function set(rate) {
        this.mSampleRate = rate;
      }
    }, {
      key: "sampleFormat",
      get:
      /**
       * @returns {AudioSampleFormat} set by setter.
       */
      function get() {
        return this.mSampleFormat;
      },
      set: function set(format) {
        this.mSampleFormat = format;
      }
    }]);
  }();
  exports.AudioFormat = AudioFormat;
  /**
   * @name VideoFormat provides setters to set different properties
   * which can be used to query for a specific video codec which satisfies all
   * the properties set.
   */
  var VideoFormat = /*#__PURE__*/function () {
    function VideoFormat() {
      _$$_REQUIRE(_dependencyMap[0])(this, VideoFormat);
    }
    return _$$_REQUIRE(_dependencyMap[1])(VideoFormat, [{
      key: "resolution",
      get:
      /**
       * @returns {Resolution} set by setter.
       */
      function get() {
        return this.mResolution;
      }
      /**
       * Sets the color format.
       *
       * This color format is associated with the raw buffers which is applicable
       * for decoders output or encoders input. Codec support standard and/or
       * proprietary color formats, where application has to choose based on the
       * usecase.
       *
       * For example, if the video decoder supports
       * "FLEX_YCbCr_420_888/FLEX_YCbCr_420_101010" which means proprietary
       * color format, is best choice for video decoding when
       * application will not read the buffer and its needed just for rendering on
       * display.
       *
       * @param format: @type {BufferPixelFormat} the color format value.
       */,
      set:
      /**
       * Sets the resolution.
       *
       * Recomended to provide the max resolution during transform initialization
       * and required resolution for any dynamic resolution switching during
       * encoding in running state.
       *
       * This method can also be called for dynamic configuration.
       *
       * @param resolution: @type {Resolution} width and height in no of pixels
       */
      function set(resolution) {
        this.mResolution = resolution;
      }
    }, {
      key: "colorFormat",
      get:
      /**
       * @returns {BufferPixelFormat} set by setter.
       */
      function get() {
        return this.mColorFormat;
      }
      /**
       * Sets the color primaries.
       *
       * Color Primaries represent three points(RGB primaries) of the triangle on
       * the CIE 1931 chromaticity diagram, and the space inside the triangle is
       * the gamut.
       *
       * Applicable for decoders input or encoders output.
       *
       * @param primaries: @type {VideoColorPrimaries} The color primaries value.
       */,
      set: function set(format) {
        this.mColorFormat = format;
      }
    }, {
      key: "colorPrimaries",
      get:
      /**
       * @returns {VideoColorPrimaries} set by setter.
       */
      function get() {
        return this.mColorPrimaries;
      }
      /**
       * Sets the color transfer.
       *
       * Color Transfer characteristics map the color gamut to the screen signal
       *
       * Applicable for decoders input or encoders output.
       *
       * @param transferFn: @type {VideoColorTransfer} the color transfer value.
       */,
      set: function set(primaries) {
        this.mColorPrimaries = primaries;
      }
    }, {
      key: "colorTransfer",
      get:
      /**
       * @returns {VideoColorTransfer} set by the setter.
       */
      function get() {
        return this.mColorTransfer;
      }
      /**
       * Sets the color matrix.
       *
       * Values are taken from Table 4 of ISO/IEC 23001-8:2016
       *
       * Applicable for decoders input or encoders output.
       *
       * @param matrix: @type {VideoColorMatrix} the color matrix value.
       */,
      set: function set(transferFn) {
        this.mColorTransfer = transferFn;
      }
    }, {
      key: "colorMatrix",
      get:
      /**
       * @returns {VideoColorMatrix} set by the setter
       */
      function get() {
        return this.mColorMatrix;
      }
      /**
       * Sets the frameRate.
       *
       * This can also be called for dynamic configuration.
       *
       * @param rate: @type {number} framerate value in no of frames/sec.
       */,
      set: function set(matrix) {
        this.mColorMatrix = matrix;
      }
    }, {
      key: "frameRate",
      get:
      /**
       * @returns {number}, the frame rate value set using setter.
       */
      function get() {
        return this.mFrameRate;
      },
      set: function set(rate) {
        this.mFrameRate = rate;
      }
    }]);
  }();
  exports.VideoFormat = VideoFormat;
  /**
   * @name MediaCodecFeatures provides setters for different codec features.
   */
  var MediaCodecFeatures = /*#__PURE__*/function () {
    function MediaCodecFeatures() {
      _$$_REQUIRE(_dependencyMap[0])(this, MediaCodecFeatures);
    }
    return _$$_REQUIRE(_dependencyMap[1])(MediaCodecFeatures, [{
      key: "requiresHardwareBacked",
      get:
      /**
       * @returns {boolean} set by the setter.
       */
      function get() {
        return this.mRequiresHardwareBacked;
      },
      set:
      /**
       * Set true to request the hardware backed codec.
       *
       * @param hardWareBacked: @type {boolean}, if true a hw backed codec will be queried.
       * If False or not set, this value is no-op and the returned codecs
       * may or may not have hardware backed feature.
       */
      function set(hardWareBacked) {
        this.mRequiresHardwareBacked = hardWareBacked;
      }
    }]);
  }();
  exports.MediaCodecFeatures = MediaCodecFeatures;
  /**
   * @name DecoderFeatures provides setters for different decoder features.
   */
  var DecoderFeatures = /*#__PURE__*/function () {
    function DecoderFeatures() {
      _$$_REQUIRE(_dependencyMap[0])(this, DecoderFeatures);
    }
    return _$$_REQUIRE(_dependencyMap[1])(DecoderFeatures, [{
      key: "requiresDecryption",
      get:
      /**
       * @returns {boolean}, the value set by setters.
       */
      function get() {
        return this.mRequiresDecryption;
      },
      set:
      /**
       * Request support for content decryption.
       *
       * AES-128 is the typical encryption standard used for DRM content.
       * The ISO/IEC 23001-7 standard has defined four Common Encryption schemes:
       * 1. CENC (AES CTR full-sample encryption)
       * 2. CENS(AES CTR patterned subsample encryption)
       * 3. CBC1 (AES CBC full-sample encryption)
       * 4. CBCS (AES CBC patterned subsample encryption)
       *
       * Refer to the DRM capabilities APIs to check which decrption scheme is
       * supported by the CDM
       *
       * @param decrypt: @type {boolean}, if true content decryption support is queried.
       * If false or not set, this value is no-op and the returned codecs
       * may or may not have decryption support.
       */
      function set(decrypt) {
        this.mRequiresDecryption = decrypt;
      }
    }]);
  }();
  exports.DecoderFeatures = DecoderFeatures;
  /**
   * Audio Raw Sample Format
   */
  var AudioSampleFormat;
  (function (AudioSampleFormat) {
    // PCM signed 8-bit
    AudioSampleFormat["PCM_S8"] = "PCM_S8";
    // PCM unsigned 8-bit
    AudioSampleFormat["PCM_U8"] = "PCM_U8";
    // PCM signed 16-bit little-endian
    AudioSampleFormat["PCM_S16LE"] = "PCM_S16LE";
    // PCM signed 16-bit big-endian
    AudioSampleFormat["PCM_S16BE"] = "PCM_S16BE";
    // PCM unsigned 16-bit little-endian
    AudioSampleFormat["PCM_U16LE"] = "PCM_U16LE";
    // PCM unsigned 16-bit big-endian
    AudioSampleFormat["PCM_U16BE"] = "PCM_U16BE";
    // PCM signed 24-bit little-endian
    AudioSampleFormat["PCM_S24LE"] = "PCM_S24LE";
    // PCM signed 24-bit big-endian
    AudioSampleFormat["PCM_S24BE"] = "PCM_S24BE";
    // PCM unsigned 24-bit little-endian
    AudioSampleFormat["PCM_U24LE"] = "PCM_U24LE";
    // PCM unsigned 24-bit big-endian
    AudioSampleFormat["PCM_U24BE"] = "PCM_U24BE";
    // PCM signed 32-bit little-endian
    AudioSampleFormat["PCM_S32LE"] = "PCM_S32LE";
    // PCM signed 32-bit big-endian
    AudioSampleFormat["PCM_S32BE"] = "PCM_S32BE";
    // PCM unsigned 32-bit little-endian
    AudioSampleFormat["PCM_U32LE"] = "PCM_U32LE";
    // PCM unsigned 32-bit big-endian
    AudioSampleFormat["PCM_U32BE"] = "PCM_U32BE";
    // PCM 32-bit floating-point little-endian
    AudioSampleFormat["PCM_F32LE"] = "PCM_F32LE";
    // PCM 32-bit floating-point big-endian
    AudioSampleFormat["PCM_F32BE"] = "PCM_F32BE";
  })(AudioSampleFormat || (AudioSampleFormat = {}));
  exports.AudioSampleFormat = AudioSampleFormat;
  /**
   * Codec Mime Types
   */
  var CodecMimeType;
  (function (CodecMimeType) {
    /* Video  Codec Mime Types*/
    // Raw format
    CodecMimeType["MIME_VIDEO_RAW"] = "video/raw";
    // Video Processor 8
    CodecMimeType["MIME_VP8"] = "video/vp8";
    // Video Processor 9
    CodecMimeType["MIME_VP9"] = "video/vp9";
    // AOMedia Video 1
    CodecMimeType["MIME_AV1"] = "video/av01";
    // High Efficiency Video Coding
    CodecMimeType["MIME_HEVC"] = "video/hevc";
    // Advanced Video Coding (alias video/h264)
    CodecMimeType["MIME_AVC"] = "video/avc";
    // Advanced Video Coding H264
    CodecMimeType["MIME_H264"] = "video/h264";
    // H.263 Video (alias video/3gpp)
    CodecMimeType["MIME_H263"] = "video/h263";
    // H.263 Video 3gpp
    CodecMimeType["MIME_3GPP"] = "video/3gpp";
    // MPEG-4 Video Elemental Stream (alias video/mp4v-es)
    CodecMimeType["MIME_MPEG4"] = "video/mpeg4";
    // MPEG-4 Video Elemental Stream mp4v-es
    CodecMimeType["MIME_MP4VES"] = "video/mp4v-es";
    // MPEG-2 Part 2 Visual
    CodecMimeType["MIME_MPEG2"] = "video/mpeg2";
    // MPEG-1 Part 2 Visual
    CodecMimeType["MIME_MPEG1"] = "video/mpeg1";
    // Dolby Vision
    CodecMimeType["MIME_DOLBY_VISION"] = "video/dolby-vision";
    // Video Unspecified
    CodecMimeType["MIME_VIDEO_UNSPECIFIED"] = "video/*";
    /* Audio  Codec Mime Types*/
    // Raw format
    CodecMimeType["MIME_AUDIO_RAW"] = "audio/raw";
    // MPEG-1 Audio Layer III
    CodecMimeType["MIME_MP3"] = "audio/mpeg";
    // MPEG-1 Audio Layer I
    CodecMimeType["MIME_MPEG_LAYER_I"] = "audio/mpeg-L1";
    // MPEG-1 Audio Layer II
    CodecMimeType["MIME_MPEG_LAYER_II"] = "audio/mpeg-L2";
    // Advanced Audio Coding (alias audio/aac)
    CodecMimeType["MIME_AAC_LATM"] = "audio/mp4a-latm";
    // Advanced Audio Coding - Mpeg Version II
    CodecMimeType["MIME_AAC"] = "audio/aac";
    // Advanced Audio Coding - Mpeg Version IV, RAW
    CodecMimeType["MIME_AAC_RAW"] = "audio/aac-raw";
    // Advanced Audio Coding - Mpeg Version IV, Audio Data Transport Stream
    CodecMimeType["MIME_AAC_ADTS"] = "audio/aac-adts";
    // Advanced Audio Coding - Mpeg Version IV, Audio Data Interchange Format
    CodecMimeType["MIME_AAC_ADIF"] = "audio/aac-adif";
    // Advanced Audio Coding - Mpeg Version IV, Low Overhead Audio Stream
    CodecMimeType["MIME_AAC_LOAS"] = "audio/aac-loas";
    // Vorbis
    CodecMimeType["MIME_VORBIS"] = "audio/vorbis";
    // Opus
    CodecMimeType["MIME_OPUS"] = "audio/opus";
    // Free Lossless Audio Codec
    CodecMimeType["MIME_FLAC"] = "audio/flac";
    // Waveform Audio File Format
    CodecMimeType["MIME_WAV"] = "audio/wav";
    // Adaptive Multi-Rate Narrow Band (alias audio/3gpp)
    CodecMimeType["MIME_AMR_NB"] = "audio/amr";
    // Adaptive Multi-Rate Narrow Band 3gpp
    CodecMimeType["MIME_AMR_NB_3GPP"] = "audio/3gpp";
    // Adaptive Multi-Rate Wide Band
    CodecMimeType["MIME_AMR_WB"] = "audio/amr-wb";
    // Pulse Code Modulation A-law
    CodecMimeType["MIME_G711_ALAW"] = "audio/g711-alaw";
    // Pulse Code Modulation -law
    CodecMimeType["MIME_G711_MLAW"] = "audio/g711-mlaw";
    // Dolby Digital
    CodecMimeType["MIME_AC3"] = "audio/ac3";
    // Dolby Digital Plus
    CodecMimeType["MIME_EAC3"] = "audio/eac3";
    // Audio Unspecified
    CodecMimeType["MIME_AUDIO_UNSPECIFIED"] = "audio/*";
  })(CodecMimeType || (CodecMimeType = {}));
  exports.CodecMimeType = CodecMimeType;
  /**
   * Video Color Primaries
   *
   * Color Primaries represent three points(RGB primaries) of the triangle on the
   * CIE 1931 chromaticity diagram, and the space inside the triangle is the
   * gamut.
   *
   * Color gamut describes a set of colors in which the content is intended to be
   * displayed.
   *
   * HDR content requires a wider color gamut than SDR content. Most of devices
   * support the sRGB color gamut but P3 or Rec. 2020 are color gamut that would
   * usually be expected for HDR content
   *
   * If the attached output device also supports the specified color, the device
   * needs to be able to cause the output device to render the appropriate color,
   * or something close enough. If the attached output device does not support the
   * specified color, the device needs to be capable of mapping the specified
   * color to a color supported by the output device.
   *
   * Values are taken from Table 2  Interpretation of colour primaries
   * (ColourPrimaries) of ISO/IEC 23001-8:2016
   */
  var VideoColorPrimaries;
  (function (VideoColorPrimaries) {
    /* Rec. ITU-R BT.709*/
    VideoColorPrimaries[VideoColorPrimaries["BT709"] = 1] = "BT709";
    /* Rec. ITU-R BT.2020*/
    VideoColorPrimaries[VideoColorPrimaries["BT2020"] = 9] = "BT2020";
    /* Society of Motion Picture and Television Engineers EG 432-1 (2010), P3*/
    VideoColorPrimaries[VideoColorPrimaries["SMPTE_ST4321"] = 12] = "SMPTE_ST4321";
  })(VideoColorPrimaries || (VideoColorPrimaries = {}));
  exports.VideoColorPrimaries = VideoColorPrimaries;
  /**
   * Video Color Transfer
   *
   * Color Transfer characteristics map the color gamut to the screen signal
   *
   * Transfer function describes the electro-optical algorithm supported by the
   * rendering capabilities of a device, independent of the display, to map
   * the source colors in the decoded media into the colors to be displayed.
   *
   * Values 1-15 are taken from Table 3 of ISO/IEC 23001-8:2016
   * Values 16-18 are proposed to extend the standard values
   * https://matroska.org/technical/elements.html
   */
  var VideoColorTransfer;
  (function (VideoColorTransfer) {
    /* Rec. ITU-R BT.709*/
    VideoColorTransfer[VideoColorTransfer["BT_709"] = 1] = "BT_709";
    /* IEC 61966-2-1 sRGB*/
    VideoColorTransfer[VideoColorTransfer["IEC_61966_2_1"] = 13] = "IEC_61966_2_1";
    // This is used by HDR10, HDR10+ and Dolby Vision
    /* SMPTE ST 2084 (2014) for 10-, 12-,14- and 16-bit systems*/
    VideoColorTransfer[VideoColorTransfer["SMPTE_BT2100_PQ"] = 16] = "SMPTE_BT2100_PQ";
    /* Rec. ITU-R BT.2100-2 hybrid loggamma (HLG) system*/
    VideoColorTransfer[VideoColorTransfer["HLG"] = 18] = "HLG";
  })(VideoColorTransfer || (VideoColorTransfer = {}));
  exports.VideoColorTransfer = VideoColorTransfer;
  /**
   * Video Color Matrix
   * Values are taken from Table 4 of ISO/IEC 23001-8:2016
   */
  var VideoColorMatrix;
  (function (VideoColorMatrix) {
    VideoColorMatrix[VideoColorMatrix["IDENTITY"] = 0] = "IDENTITY";
    VideoColorMatrix[VideoColorMatrix["BT709"] = 1] = "BT709";
    VideoColorMatrix[VideoColorMatrix["UNSPECIFIED"] = 2] = "UNSPECIFIED";
    VideoColorMatrix[VideoColorMatrix["RESERVED_3"] = 3] = "RESERVED_3";
    VideoColorMatrix[VideoColorMatrix["FCC_73682"] = 4] = "FCC_73682";
    VideoColorMatrix[VideoColorMatrix["ITU_R_BT470BG"] = 5] = "ITU_R_BT470BG";
    VideoColorMatrix[VideoColorMatrix["SMPTE_170M"] = 6] = "SMPTE_170M";
    VideoColorMatrix[VideoColorMatrix["SMPTE_240M"] = 7] = "SMPTE_240M";
    VideoColorMatrix[VideoColorMatrix["Y_CO_CG"] = 8] = "Y_CO_CG";
    VideoColorMatrix[VideoColorMatrix["BT2020_NON_CONSTANT_LUMINANCE"] = 9] = "BT2020_NON_CONSTANT_LUMINANCE";
    VideoColorMatrix[VideoColorMatrix["BT2020_CONSTANT_LUMINANCE"] = 10] = "BT2020_CONSTANT_LUMINANCE";
    VideoColorMatrix[VideoColorMatrix["SMPTE_ST_2085"] = 11] = "SMPTE_ST_2085";
    VideoColorMatrix[VideoColorMatrix["CHROMA_DERIVED_NON_CONSTANT_LUMINANCE"] = 12] = "CHROMA_DERIVED_NON_CONSTANT_LUMINANCE";
    VideoColorMatrix[VideoColorMatrix["CHROMA_DERIVED_CONSTANT_LUMINANCE"] = 13] = "CHROMA_DERIVED_CONSTANT_LUMINANCE";
    VideoColorMatrix[VideoColorMatrix["ITU_R_BT2100"] = 14] = "ITU_R_BT2100";
  })(VideoColorMatrix || (VideoColorMatrix = {}));
  exports.VideoColorMatrix = VideoColorMatrix;
},"5af0ab6c9217f3564784",["3508abd8c6b891008c0d","5533cec96f6a88041c69"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /*
   * Copyright 2024 Amazon.com, Inc. or its affiliates. All rights reserved.
   *
   * AMAZON PROPRIETARY/CONFIDENTIAL
   *
   * You may not use this file except in compliance with the terms and
   * conditions set forth in the accompanying LICENSE.TXT file.
   *
   * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
   * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
   * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
   */
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VideoDecoderCapabilitiesImpl = exports.AudioDecoderCapabilitiesImpl = undefined;
  var KeplerMediaDescriptorTurboModule_1 = __importDefault(_$$_REQUIRE(_dependencyMap[0]));
  /**
   * @hidden
   *
   * This impl is internal to the TM. When the application calls @name KeplerMediaDescriptor.queryMediaCapabilities,
   * The returned json object should be converted to a valid ts object. These implementations would help in the same.
   */
  var AudioDecoderCapabilitiesImpl = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[1])(function AudioDecoderCapabilitiesImpl(jsonObject) {
    _$$_REQUIRE(_dependencyMap[2])(this, AudioDecoderCapabilitiesImpl);
    this.mediaCodecFeaturesCapabilities = jsonObject.mediaCodecFeaturesCapabilities;
    this.decoderFeaturesCapabilities = jsonObject.decodeCapabilities;
    this.mediaFormatProfileLevelCapabilities = jsonObject.mediaFormatProfileLevelCapabilities;
  });
  exports.AudioDecoderCapabilitiesImpl = AudioDecoderCapabilitiesImpl;
  var VideoDecoderCapabilitiesImpl = /*#__PURE__*/_$$_REQUIRE(_dependencyMap[1])(function VideoDecoderCapabilitiesImpl(jsonObject) {
    _$$_REQUIRE(_dependencyMap[2])(this, VideoDecoderCapabilitiesImpl);
    this.mediaCodecFeaturesCapabilities = jsonObject.mediaCodecFeaturesCapabilities;
    this.mediaFormatProfileLevelCapabilities = jsonObject.mediaFormatProfileLevelCapabilities;
    this.decoderFeaturesCapabilities = jsonObject.decoderFeaturesCapabilities;
    this.videoFormatCapabilities = new VideoFormatCapabilitiesImpl(jsonObject.videoFormatCapabilities);
  });
  exports.VideoDecoderCapabilitiesImpl = VideoDecoderCapabilitiesImpl;
  var VideoFormatCapabilitiesImpl = /*#__PURE__*/function () {
    function VideoFormatCapabilitiesImpl(jsonObject) {
      _$$_REQUIRE(_dependencyMap[2])(this, VideoFormatCapabilitiesImpl);
      this.mID = jsonObject.mID;
      this.resolutions = jsonObject.resolutions;
      this.colorFormats = jsonObject.colorFormats;
    }
    return _$$_REQUIRE(_dependencyMap[1])(VideoFormatCapabilitiesImpl, [{
      key: "getMaxFrameRate",
      value: function getMaxFrameRate(resolution) {
        return KeplerMediaDescriptorTurboModule_1.default.getMaxFrameRate(this, resolution);
      }
    }]);
  }();
},"9d9845d625957629df79",["af1bcd3f248e77fadb2e","5533cec96f6a88041c69","3508abd8c6b891008c0d"]);
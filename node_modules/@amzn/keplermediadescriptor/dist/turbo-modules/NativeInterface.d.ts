/**
 * @internal
 */
export declare type BufferPixelFormat = string;
/**
 * Interface to get features supported by media codecs.
 */
interface MediaCodecFeaturesCapabilities {
    /**
     * Check whether the codec underlying stack is using hardware accelerators.
     */
    readonly hardwareBacked: boolean;
}
/**
 * Interface to get video format capabilities
 * of a video codec.
 */
interface VideoFormatCapabilities {
    /**
     * The supported resolutions.
     *
     * The supported resolution range for codec or runtime get the
     * resolution associated with buffers. The array size is always two,
     * where the min resolution is at 0 index and max resolution at 1 index.
     *
     */
    readonly resolutions: Array<Resolution>;
    /**
     * The supported color formats.
     *
     * The supported color formats(for decoders output or encoders input)
     * for codec or runtime gets the color format of buffers. An array size of one
     * and more than one is supported.
     */
    readonly colorFormats: Array<BufferPixelFormat>;
    /**
     * Gets the maximum FrameRate for particular width and height.
     *
     * Platform internally uses some existing measurement points in idle
     * condition to extrapolate framerate for particular width/heigh which should
     * be treated as hint and may not be feasible in all the system conditions.
     *
     * @return {number} maximum supported framerate per second
     */
    getMaxFrameRate(resolution: Resolution): number;
}
/**
 * Interface to get capabilities about the features supported
 * by the decoder.
 */
interface DecoderFeaturesCapabilities {
    /**
     * Provides info whether codec supports decryption.
     *
     * AES-128 is the typical encryption standard used for DRM content.
     * The ISO/IEC 23001-7 standard has defined four Common Encryption schemes:
     * 1. CENC (AES CTR full-sample encryption)
     * 2. CENS(AES CTR patterned subsample encryption)
     * 3. CBC1 (AES CBC full-sample encryption)
     * 4. CBCS (AES CBC patterned subsample encryption)
     *
     * Refer to the DRM capabilities APIs to check which decrption scheme is
     * supported by the CDM
     *
     * true if Decrypt supported.
     */
    readonly decryptionSupported: boolean;
}
/**
 * Interface to get the Profile level and codec param capabilities
 */
interface MediaFormatProfileLevelCapabilities {
    /**
     * Gets the list of codec parameters string supported by codec.
     *
     * Refer to
     * https://datatracker.ietf.org/doc/html/rfc6381
     *
     */
    readonly codecParams: Array<string>;
    /**
     * Gets the list of Profile and Levels supported by the codec.
     *
     * For H264 refer to https://www.itu.int/rec/T-REC-H.264-201906-S/en Section
     A.2 and
     * Section A.3.4 for Profiles and Levels
     *
     * Profile is linked to the features used during the Encoding
     * Level is directly linked to Macro Blocks Processing Rate per sec, as
     defined
     * in the codec specification, which means maximum supported bitrate,
     framerate and resolution.
     *
     */
    readonly profileLevels: Array<ProfileLevel>;
}
/**
 * Interface to get the capabilities of the audio codec queried for decode use case.
 */
interface AudioDecoderCapabilities {
    /**
     * Provides the information on the profile levels and codec parameters
     * supported for a give condec on the device.
     */
    readonly mediaFormatProfileLevelCapabilities: MediaFormatProfileLevelCapabilities;
    /**
     * Provides the information on features supported by media codecs.
     *
     * @see MediaCodecFeaturesCapabilities for further details.
     */
    readonly mediaCodecFeaturesCapabilities: MediaCodecFeaturesCapabilities;
    /**
     * Interface to get capabilities about the features supported
     * by the decoder.
     *
     * @see DecoderFeaturesCapabilities for further information.
     */
    readonly decoderFeaturesCapabilities: DecoderFeaturesCapabilities;
}
/**
 * Interface to get the capabilities of the video codec queried for decode use case.
 */
interface VideoDecoderCapabilities {
    /**
     * Provides the information on the profile levels and codec parameters
     * supported for a give condec on the device.
     */
    readonly mediaFormatProfileLevelCapabilities: MediaFormatProfileLevelCapabilities;
    /**
     * Provides the information on features supported by media codecs.
     *
     * @see MediaCodecFeaturesCapabilities for further details.
     */
    readonly mediaCodecFeaturesCapabilities: MediaCodecFeaturesCapabilities;
    /**
     * Provides the information on properties like resolution, color format etc.
     * supported by the video codec on the device.
     *
     * @see VideoFormatCapabilities for further details.
     */
    readonly videoFormatCapabilities: VideoFormatCapabilities;
    /**
     * Interface to get capabilities about the features supported
     * by the decoder.
     *
     * @see DecoderFeaturesCapabilities for further information.
     */
    readonly decoderFeaturesCapabilities: DecoderFeaturesCapabilities;
}
/**
 * The VideoDecoderConfig defines all the attributes required for Video
 * decode use case.
 *
 * Applications should create this class to query the video decoders
 * supported on the device.
 */
declare class VideoDecoderConfig {
    private mMediaFormat?;
    private mFormatProfileLevel?;
    private mMediaCodecFeatures?;
    private mVideoFormat?;
    private mCodecFeatures?;
    /**
     * Sets the MediaFormat.
     *
     * This can be used to query on the format of the media supported by the device.
     *
     * @see MediaFormat for further details.
     */
    set mediaFormat(format: MediaFormat);
    /**
     * @returns {MediaFormat} set using the setter.
     */
    get mediaFormat(): MediaFormat;
    /**
     * Sets the MediaFormatProfileLevel.
     *
     * This can be used to query on the profile levels
     * supported.
     *
     * @see MediaFormatProfileLevel for further details
     */
    set formatProfileLevel(profileLevel: MediaFormatProfileLevel);
    /**
     * @returns {MediaFormatProfileLevel} set using the setter.
     */
    get formatProfileLevel(): MediaFormatProfileLevel;
    /**
     * Sets the MediaCodecFeatures.
     *
     * This can be used to query on media codec features supported
     * by the device.
     *
     * @see MediaCodecFeatures for more details.
     */
    set mediaCodecFeatures(features: MediaCodecFeatures);
    /**
     * @returns {MediaCodecFeatures} set using setter.
     */
    get mediaCodecFeatures(): MediaCodecFeatures;
    /**
     * Sets the VideoFormat.
     *
     * This can be used to query on different properties supported
     * by the video codecs on the device.
     *
     * @see VideoFormat for further details.
     */
    set videoFormat(format: VideoFormat);
    /**
     * @returns {VideoFormat} set using the setter.
     */
    get videoFormat(): VideoFormat;
    /**
     * Sets the DecoderFeatures.
     *
     * This can be used to query on decoder features like decryption.
     *
     * @see DecoderFeatures for further details.
     */
    set decoderFeatures(features: DecoderFeatures);
    /**
     * @returns {DecoderFeatures} set using the setter.
     */
    get decoderFeatures(): DecoderFeatures;
}
/**
 * The AudioDecoderConfig defines all the attributes required for audio
 * decode use case.
 *
 * Applications should create this class to query the audio decoders
 * supported on the device.
 */
declare class AudioDecoderConfig {
    private mMediaFormat?;
    private mFormatProfileLevel?;
    private mMediaCodecFeatures?;
    private mAudioFormat?;
    private mDecoderFeatures?;
    /**
     * Sets the MediaFormat.
     *
     * This can be used to query on the format of the media supported by the device.
     *
     * @see MediaFormat for further details.
     */
    set mediaFormat(format: MediaFormat);
    /**
     * @returns {MediaFormat} set using the setter.
     */
    get mediaFormat(): MediaFormat;
    /**
     * Sets the MediaFormatProfileLevel.
     *
     * This can be used to query on the profile levels
     * supported.
     *
     * @see MediaFormatProfileLevel for further details
     */
    set formatProfileLevel(profileLevel: MediaFormatProfileLevel);
    /**
     * @returns {MediaFormatProfileLevel} set using the setter.
     */
    get formatProfileLevel(): MediaFormatProfileLevel;
    /**
     * Sets the MediaCodecFeatures.
     *
     * This can be used to query on media codec features supported
     * by the device.
     *
     * @see MediaCodecFeatures for more details.
     */
    set mediaCodecFeatures(features: MediaCodecFeatures);
    /**
     * @returns {MediaCodecFeatures} set using setter.
     */
    get mediaCodecFeatures(): MediaCodecFeatures;
    /**
     * Sets the AudioFormat.
     *
     * This can be used to query on different properties supported
     * by the audio codecs on the device.
     *
     * @see AudioFormat for further details
     */
    set audioFormat(format: AudioFormat);
    /**
     * @returns {AudioFormat} set using the setter.
     */
    get audioFormat(): AudioFormat;
    /**
     * Sets the DecoderFeatures.
     *
     * This can be used to query on decoder features like decryption.
     *
     * @see DecoderFeatures for further details.
     */
    set codecFeatures(features: DecoderFeatures);
    /**
     * @returns {DecoderFeatures} set by the setter.
     */
    get codecFeatures(): DecoderFeatures;
}
/**
 * Represents the format of the media.
 */
declare class MediaFormat {
    private mMime;
    private mBitRate?;
    /**
     * constructs a MediaFormat object.
     *
     * Refer to
     * https://datatracker.ietf.org/doc/html/rfc6381
     *
     * MIME is the ability to identify the specific codec.
     *
     * @see {CodecMimeType} for Video/Audio codec mimetypes defined.
     *
     * @param mimeType @type {CodecMimeType} to be queried for.
     */
    constructor(mimeType: CodecMimeType);
    /**
     *
     * @returns {CodecMimeType} associated with this object.
     */
    get mimeType(): CodecMimeType;
    /**
     * Sets the target bitrate in kbps.
     *
     * This can also be used for dynamic configuration.
     */
    set bitrateKbps(bitrate: number);
    /**
     * @returns {number} the bitrate set by the setter.
     */
    get bitrateKbps(): number;
}
/**
 * Class to set the codec profile and level.
 */
declare class MediaFormatProfileLevel {
    private mCodecParams;
    private mProfileLevel?;
    /**
     * constructs a MediaFormatProfileLevel object.
     *
     * Refer to
     * https://datatracker.ietf.org/doc/html/rfc6381
     *
     * Codec Parameters represent the codec  major capabilities needed to decode
     * like codec/codec subtype and profiles/levels.
     *
     * For example string "avc1.640028" represents H264:-
     *     -- stream-format avc1
     *     -- profile 4.0 which is derived from 2 bytes bytes(base16) in the
     * sequence "640028"
     *     -- profile_idc identified by "64" which indicates "High Profile".
     *     -- level_idc which is "28" and 40 in decimal which means 4.0.
     *
     * @param params The codecs @type {string} for audio or video codec.
     */
    constructor(params: string);
    /**
     * @returns {string} set by the setter.
     */
    get codecParams(): string;
    /**
     * Sets the Profile and Level.
     *
     * For example codec parameters string
     * For video, "codecs=avc1.640028" has profile ID "0x64" which means high
     * profile for H264 and has level Id "0x28" which means level 4.0.
     *
     * For audio, "codecs=mp4a.40.02" has profile ID "0x02" which means low
     * complexity for AAC.
     *
     * This method can also be called for dynamic configuration.
     *
     * @param level @type {ProfileLevel} The desired profile and level to be used.
     *
     */
    set profileLevel(level: ProfileLevel);
    /**
     * @returns {ProfileLevel} set using the setter.
     */
    get profileLevel(): ProfileLevel;
}
/**
 * @name {AudioFormat} provides setters to set different properties
 * which can be used to query for a specific audio codec which satisfies all
 * the properties set.
 */
declare class AudioFormat {
    private mChannelCount?;
    private mSampleRate?;
    private mSampleFormat?;
    /**
     * The number of channels in the audio signal.
     *
     * Example: 1(mono), 2(stereo), 3(2.1), 5(4.1), 6(5.1), 8(7.1) etc.
     */
    set channelCount(count: number);
    /**
     * @returns Channel count as @type {number} set by the setter
     */
    get channelCount(): number;
    /**
     * The number of audio samples taken per second (in Hz).
     */
    set sampleRate(rate: number);
    /**
     * @returns Sample rate in Hz as
     * @type {number}.
     */
    get sampleRate(): number;
    /**
     * Sets the raw sample format, the supported values are
     * defined in @see AudioSampleFormat
     */
    set sampleFormat(format: AudioSampleFormat);
    /**
     * @returns {AudioSampleFormat} set by setter.
     */
    get sampleFormat(): AudioSampleFormat;
}
/**
 * @name VideoFormat provides setters to set different properties
 * which can be used to query for a specific video codec which satisfies all
 * the properties set.
 */
declare class VideoFormat {
    private mResolution?;
    private mColorFormat?;
    private mColorPrimaries?;
    private mColorTransfer?;
    private mColorMatrix?;
    private mFrameRate?;
    /**
     * Sets the resolution.
     *
     * Recomended to provide the max resolution during transform initialization
     * and required resolution for any dynamic resolution switching during
     * encoding in running state.
     *
     * This method can also be called for dynamic configuration.
     *
     * @param resolution: @type {Resolution} width and height in no of pixels
     */
    set resolution(resolution: Resolution);
    /**
     * @returns {Resolution} set by setter.
     */
    get resolution(): Resolution;
    /**
     * Sets the color format.
     *
     * This color format is associated with the raw buffers which is applicable
     * for decoders output or encoders input. Codec support standard and/or
     * proprietary color formats, where application has to choose based on the
     * usecase.
     *
     * For example, if the video decoder supports
     * "FLEX_YCbCr_420_888/FLEX_YCbCr_420_101010" which means proprietary
     * color format, is best choice for video decoding when
     * application will not read the buffer and its needed just for rendering on
     * display.
     *
     * @param format: @type {BufferPixelFormat} the color format value.
     */
    set colorFormat(format: BufferPixelFormat);
    /**
     * @returns {BufferPixelFormat} set by setter.
     */
    get colorFormat(): BufferPixelFormat;
    /**
     * Sets the color primaries.
     *
     * Color Primaries represent three points(RGB primaries) of the triangle on
     * the CIE 1931 chromaticity diagram, and the space inside the triangle is
     * the gamut.
     *
     * Applicable for decoders input or encoders output.
     *
     * @param primaries: @type {VideoColorPrimaries} The color primaries value.
     */
    set colorPrimaries(primaries: VideoColorPrimaries);
    /**
     * @returns {VideoColorPrimaries} set by setter.
     */
    get colorPrimaries(): VideoColorPrimaries;
    /**
     * Sets the color transfer.
     *
     * Color Transfer characteristics map the color gamut to the screen signal
     *
     * Applicable for decoders input or encoders output.
     *
     * @param transferFn: @type {VideoColorTransfer} the color transfer value.
     */
    set colorTransfer(transferFn: VideoColorTransfer);
    /**
     * @returns {VideoColorTransfer} set by the setter.
     */
    get colorTransfer(): VideoColorTransfer;
    /**
     * Sets the color matrix.
     *
     * Values are taken from Table 4 of ISO/IEC 23001-8:2016
     *
     * Applicable for decoders input or encoders output.
     *
     * @param matrix: @type {VideoColorMatrix} the color matrix value.
     */
    set colorMatrix(matrix: VideoColorMatrix);
    /**
     * @returns {VideoColorMatrix} set by the setter
     */
    get colorMatrix(): VideoColorMatrix;
    /**
     * Sets the frameRate.
     *
     * This can also be called for dynamic configuration.
     *
     * @param rate: @type {number} framerate value in no of frames/sec.
     */
    set frameRate(rate: number);
    /**
     * @returns {number}, the frame rate value set using setter.
     */
    get frameRate(): number;
}
/**
 * @name MediaCodecFeatures provides setters for different codec features.
 */
declare class MediaCodecFeatures {
    private mRequiresHardwareBacked?;
    /**
     * Set true to request the hardware backed codec.
     *
     * @param hardWareBacked: @type {boolean}, if true a hw backed codec will be queried.
     * If False or not set, this value is no-op and the returned codecs
     * may or may not have hardware backed feature.
     */
    set requiresHardwareBacked(hardWareBacked: boolean);
    /**
     * @returns {boolean} set by the setter.
     */
    get requiresHardwareBacked(): boolean;
}
/**
 * @name DecoderFeatures provides setters for different decoder features.
 */
declare class DecoderFeatures {
    private mRequiresDecryption?;
    /**
     * Request support for content decryption.
     *
     * AES-128 is the typical encryption standard used for DRM content.
     * The ISO/IEC 23001-7 standard has defined four Common Encryption schemes:
     * 1. CENC (AES CTR full-sample encryption)
     * 2. CENS(AES CTR patterned subsample encryption)
     * 3. CBC1 (AES CBC full-sample encryption)
     * 4. CBCS (AES CBC patterned subsample encryption)
     *
     * Refer to the DRM capabilities APIs to check which decrption scheme is
     * supported by the CDM
     *
     * @param decrypt: @type {boolean}, if true content decryption support is queried.
     * If false or not set, this value is no-op and the returned codecs
     * may or may not have decryption support.
     */
    set requiresDecryption(decrypt: boolean);
    /**
     * @returns {boolean}, the value set by setters.
     */
    get requiresDecryption(): boolean;
}
/**
 * Video Resolution in pixels
 */
interface Resolution {
    width: number;
    height: number;
}
/**
 * Profile and Level values for codecs.
 */
interface ProfileLevel {
    profile: number;
    level: number;
}
/**
 * Audio Raw Sample Format
 */
declare enum AudioSampleFormat {
    PCM_S8 = "PCM_S8",
    PCM_U8 = "PCM_U8",
    PCM_S16LE = "PCM_S16LE",
    PCM_S16BE = "PCM_S16BE",
    PCM_U16LE = "PCM_U16LE",
    PCM_U16BE = "PCM_U16BE",
    PCM_S24LE = "PCM_S24LE",
    PCM_S24BE = "PCM_S24BE",
    PCM_U24LE = "PCM_U24LE",
    PCM_U24BE = "PCM_U24BE",
    PCM_S32LE = "PCM_S32LE",
    PCM_S32BE = "PCM_S32BE",
    PCM_U32LE = "PCM_U32LE",
    PCM_U32BE = "PCM_U32BE",
    PCM_F32LE = "PCM_F32LE",
    PCM_F32BE = "PCM_F32BE"
}
/**
 * Codec Mime Types
 */
declare enum CodecMimeType {
    MIME_VIDEO_RAW = "video/raw",
    MIME_VP8 = "video/vp8",
    MIME_VP9 = "video/vp9",
    MIME_AV1 = "video/av01",
    MIME_HEVC = "video/hevc",
    MIME_AVC = "video/avc",
    MIME_H264 = "video/h264",
    MIME_H263 = "video/h263",
    MIME_3GPP = "video/3gpp",
    MIME_MPEG4 = "video/mpeg4",
    MIME_MP4VES = "video/mp4v-es",
    MIME_MPEG2 = "video/mpeg2",
    MIME_MPEG1 = "video/mpeg1",
    MIME_DOLBY_VISION = "video/dolby-vision",
    MIME_VIDEO_UNSPECIFIED = "video/*",
    MIME_AUDIO_RAW = "audio/raw",
    MIME_MP3 = "audio/mpeg",
    MIME_MPEG_LAYER_I = "audio/mpeg-L1",
    MIME_MPEG_LAYER_II = "audio/mpeg-L2",
    MIME_AAC_LATM = "audio/mp4a-latm",
    MIME_AAC = "audio/aac",
    MIME_AAC_RAW = "audio/aac-raw",
    MIME_AAC_ADTS = "audio/aac-adts",
    MIME_AAC_ADIF = "audio/aac-adif",
    MIME_AAC_LOAS = "audio/aac-loas",
    MIME_VORBIS = "audio/vorbis",
    MIME_OPUS = "audio/opus",
    MIME_FLAC = "audio/flac",
    MIME_WAV = "audio/wav",
    MIME_AMR_NB = "audio/amr",
    MIME_AMR_NB_3GPP = "audio/3gpp",
    MIME_AMR_WB = "audio/amr-wb",
    MIME_G711_ALAW = "audio/g711-alaw",
    MIME_G711_MLAW = "audio/g711-mlaw",
    MIME_AC3 = "audio/ac3",
    MIME_EAC3 = "audio/eac3",
    MIME_AUDIO_UNSPECIFIED = "audio/*"
}
/**
 * Video Color Primaries
 *
 * Color Primaries represent three points(RGB primaries) of the triangle on the
 * CIE 1931 chromaticity diagram, and the space inside the triangle is the
 * gamut.
 *
 * Color gamut describes a set of colors in which the content is intended to be
 * displayed.
 *
 * HDR content requires a wider color gamut than SDR content. Most of devices
 * support the sRGB color gamut but P3 or Rec. 2020 are color gamut that would
 * usually be expected for HDR content
 *
 * If the attached output device also supports the specified color, the device
 * needs to be able to cause the output device to render the appropriate color,
 * or something close enough. If the attached output device does not support the
 * specified color, the device needs to be capable of mapping the specified
 * color to a color supported by the output device.
 *
 * Values are taken from Table 2 â€” Interpretation of colour primaries
 * (ColourPrimaries) of ISO/IEC 23001-8:2016
 */
declare enum VideoColorPrimaries {
    BT709 = 1,
    BT2020 = 9,
    SMPTE_ST4321 = 12
}
/**
 * Video Color Transfer
 *
 * Color Transfer characteristics map the color gamut to the screen signal
 *
 * Transfer function describes the electro-optical algorithm supported by the
 * rendering capabilities of a device, independent of the display, to map
 * the source colors in the decoded media into the colors to be displayed.
 *
 * Values 1-15 are taken from Table 3 of ISO/IEC 23001-8:2016
 * Values 16-18 are proposed to extend the standard values
 * https://matroska.org/technical/elements.html
 */
declare enum VideoColorTransfer {
    BT_709 = 1,
    IEC_61966_2_1 = 13,
    SMPTE_BT2100_PQ = 16,
    HLG = 18
}
/**
 * Video Color Matrix
 * Values are taken from Table 4 of ISO/IEC 23001-8:2016
 */
declare enum VideoColorMatrix {
    IDENTITY = 0,
    BT709 = 1,
    UNSPECIFIED = 2,
    RESERVED_3 = 3,
    FCC_73682 = 4,
    ITU_R_BT470BG = 5,
    SMPTE_170M = 6,
    SMPTE_240M = 7,
    Y_CO_CG = 8,
    BT2020_NON_CONSTANT_LUMINANCE = 9,
    BT2020_CONSTANT_LUMINANCE = 10,
    SMPTE_ST_2085 = 11,
    CHROMA_DERIVED_NON_CONSTANT_LUMINANCE = 12,
    CHROMA_DERIVED_CONSTANT_LUMINANCE = 13,
    ITU_R_BT2100 = 14
}
export { AudioDecoderCapabilities, AudioDecoderConfig, AudioFormat, AudioSampleFormat, CodecMimeType, DecoderFeatures, DecoderFeaturesCapabilities, MediaCodecFeatures, MediaCodecFeaturesCapabilities, MediaFormat, MediaFormatProfileLevel, MediaFormatProfileLevelCapabilities, ProfileLevel, Resolution, VideoColorMatrix, VideoColorPrimaries, VideoColorTransfer, VideoDecoderCapabilities, VideoDecoderConfig, VideoFormat, VideoFormatCapabilities, };

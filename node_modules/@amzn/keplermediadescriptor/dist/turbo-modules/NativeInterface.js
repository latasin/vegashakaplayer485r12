"use strict";
/*
 * Copyright 2024 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.VideoFormat = exports.VideoDecoderConfig = exports.VideoColorTransfer = exports.VideoColorPrimaries = exports.VideoColorMatrix = exports.MediaFormatProfileLevel = exports.MediaFormat = exports.MediaCodecFeatures = exports.DecoderFeatures = exports.CodecMimeType = exports.AudioSampleFormat = exports.AudioFormat = exports.AudioDecoderConfig = void 0;
/**
 * The VideoDecoderConfig defines all the attributes required for Video
 * decode use case.
 *
 * Applications should create this class to query the video decoders
 * supported on the device.
 */
class VideoDecoderConfig {
    mMediaFormat;
    mFormatProfileLevel;
    mMediaCodecFeatures;
    mVideoFormat;
    mCodecFeatures;
    /**
     * Sets the MediaFormat.
     *
     * This can be used to query on the format of the media supported by the device.
     *
     * @see MediaFormat for further details.
     */
    set mediaFormat(format) {
        this.mMediaFormat = format;
    }
    /**
     * @returns {MediaFormat} set using the setter.
     */
    get mediaFormat() {
        return this.mMediaFormat;
    }
    /**
     * Sets the MediaFormatProfileLevel.
     *
     * This can be used to query on the profile levels
     * supported.
     *
     * @see MediaFormatProfileLevel for further details
     */
    set formatProfileLevel(profileLevel) {
        this.mFormatProfileLevel = profileLevel;
    }
    /**
     * @returns {MediaFormatProfileLevel} set using the setter.
     */
    get formatProfileLevel() {
        return this.mFormatProfileLevel;
    }
    /**
     * Sets the MediaCodecFeatures.
     *
     * This can be used to query on media codec features supported
     * by the device.
     *
     * @see MediaCodecFeatures for more details.
     */
    set mediaCodecFeatures(features) {
        this.mMediaCodecFeatures = features;
    }
    /**
     * @returns {MediaCodecFeatures} set using setter.
     */
    get mediaCodecFeatures() {
        return this.mMediaCodecFeatures;
    }
    /**
     * Sets the VideoFormat.
     *
     * This can be used to query on different properties supported
     * by the video codecs on the device.
     *
     * @see VideoFormat for further details.
     */
    set videoFormat(format) {
        this.mVideoFormat = format;
    }
    /**
     * @returns {VideoFormat} set using the setter.
     */
    get videoFormat() {
        return this.mVideoFormat;
    }
    /**
     * Sets the DecoderFeatures.
     *
     * This can be used to query on decoder features like decryption.
     *
     * @see DecoderFeatures for further details.
     */
    set decoderFeatures(features) {
        this.mCodecFeatures = features;
    }
    /**
     * @returns {DecoderFeatures} set using the setter.
     */
    get decoderFeatures() {
        return this.mCodecFeatures;
    }
}
exports.VideoDecoderConfig = VideoDecoderConfig;
/**
 * The AudioDecoderConfig defines all the attributes required for audio
 * decode use case.
 *
 * Applications should create this class to query the audio decoders
 * supported on the device.
 */
class AudioDecoderConfig {
    mMediaFormat;
    mFormatProfileLevel;
    mMediaCodecFeatures;
    mAudioFormat;
    mDecoderFeatures;
    /**
     * Sets the MediaFormat.
     *
     * This can be used to query on the format of the media supported by the device.
     *
     * @see MediaFormat for further details.
     */
    set mediaFormat(format) {
        this.mMediaFormat = format;
    }
    /**
     * @returns {MediaFormat} set using the setter.
     */
    get mediaFormat() {
        return this.mMediaFormat;
    }
    /**
     * Sets the MediaFormatProfileLevel.
     *
     * This can be used to query on the profile levels
     * supported.
     *
     * @see MediaFormatProfileLevel for further details
     */
    set formatProfileLevel(profileLevel) {
        this.mFormatProfileLevel = profileLevel;
    }
    /**
     * @returns {MediaFormatProfileLevel} set using the setter.
     */
    get formatProfileLevel() {
        return this.mFormatProfileLevel;
    }
    /**
     * Sets the MediaCodecFeatures.
     *
     * This can be used to query on media codec features supported
     * by the device.
     *
     * @see MediaCodecFeatures for more details.
     */
    set mediaCodecFeatures(features) {
        this.mMediaCodecFeatures = features;
    }
    /**
     * @returns {MediaCodecFeatures} set using setter.
     */
    get mediaCodecFeatures() {
        return this.mMediaCodecFeatures;
    }
    /**
     * Sets the AudioFormat.
     *
     * This can be used to query on different properties supported
     * by the audio codecs on the device.
     *
     * @see AudioFormat for further details
     */
    set audioFormat(format) {
        this.mAudioFormat = format;
    }
    /**
     * @returns {AudioFormat} set using the setter.
     */
    get audioFormat() {
        return this.mAudioFormat;
    }
    /**
     * Sets the DecoderFeatures.
     *
     * This can be used to query on decoder features like decryption.
     *
     * @see DecoderFeatures for further details.
     */
    set codecFeatures(features) {
        this.mDecoderFeatures = features;
    }
    /**
     * @returns {DecoderFeatures} set by the setter.
     */
    get codecFeatures() {
        return this.mDecoderFeatures;
    }
}
exports.AudioDecoderConfig = AudioDecoderConfig;
/**
 * Represents the format of the media.
 */
class MediaFormat {
    mMime;
    mBitRate;
    /**
     * constructs a MediaFormat object.
     *
     * Refer to
     * https://datatracker.ietf.org/doc/html/rfc6381
     *
     * MIME is the ability to identify the specific codec.
     *
     * @see {CodecMimeType} for Video/Audio codec mimetypes defined.
     *
     * @param mimeType @type {CodecMimeType} to be queried for.
     */
    constructor(mimeType) {
        this.mMime = mimeType;
    }
    /**
     *
     * @returns {CodecMimeType} associated with this object.
     */
    get mimeType() {
        return this.mMime;
    }
    /**
     * Sets the target bitrate in kbps.
     *
     * This can also be used for dynamic configuration.
     */
    set bitrateKbps(bitrate) {
        this.mBitRate = bitrate;
    }
    /**
     * @returns {number} the bitrate set by the setter.
     */
    get bitrateKbps() {
        return this.mBitRate;
    }
}
exports.MediaFormat = MediaFormat;
/**
 * Class to set the codec profile and level.
 */
class MediaFormatProfileLevel {
    mCodecParams;
    mProfileLevel;
    /**
     * constructs a MediaFormatProfileLevel object.
     *
     * Refer to
     * https://datatracker.ietf.org/doc/html/rfc6381
     *
     * Codec Parameters represent the codec  major capabilities needed to decode
     * like codec/codec subtype and profiles/levels.
     *
     * For example string "avc1.640028" represents H264:-
     *     -- stream-format avc1
     *     -- profile 4.0 which is derived from 2 bytes bytes(base16) in the
     * sequence "640028"
     *     -- profile_idc identified by "64" which indicates "High Profile".
     *     -- level_idc which is "28" and 40 in decimal which means 4.0.
     *
     * @param params The codecs @type {string} for audio or video codec.
     */
    constructor(params) {
        this.mCodecParams = params;
    }
    /**
     * @returns {string} set by the setter.
     */
    get codecParams() {
        return this.mCodecParams;
    }
    /**
     * Sets the Profile and Level.
     *
     * For example codec parameters string
     * For video, "codecs=avc1.640028" has profile ID "0x64" which means high
     * profile for H264 and has level Id "0x28" which means level 4.0.
     *
     * For audio, "codecs=mp4a.40.02" has profile ID "0x02" which means low
     * complexity for AAC.
     *
     * This method can also be called for dynamic configuration.
     *
     * @param level @type {ProfileLevel} The desired profile and level to be used.
     *
     */
    set profileLevel(level) {
        this.mProfileLevel = level;
    }
    /**
     * @returns {ProfileLevel} set using the setter.
     */
    get profileLevel() {
        return this.mProfileLevel;
    }
}
exports.MediaFormatProfileLevel = MediaFormatProfileLevel;
/**
 * @name {AudioFormat} provides setters to set different properties
 * which can be used to query for a specific audio codec which satisfies all
 * the properties set.
 */
class AudioFormat {
    mChannelCount;
    mSampleRate;
    mSampleFormat;
    /**
     * The number of channels in the audio signal.
     *
     * Example: 1(mono), 2(stereo), 3(2.1), 5(4.1), 6(5.1), 8(7.1) etc.
     */
    set channelCount(count) {
        this.mChannelCount = count;
    }
    /**
     * @returns Channel count as @type {number} set by the setter
     */
    get channelCount() {
        return this.mChannelCount;
    }
    /**
     * The number of audio samples taken per second (in Hz).
     */
    set sampleRate(rate) {
        this.mSampleRate = rate;
    }
    /**
     * @returns Sample rate in Hz as
     * @type {number}.
     */
    get sampleRate() {
        return this.mSampleRate;
    }
    /**
     * Sets the raw sample format, the supported values are
     * defined in @see AudioSampleFormat
     */
    set sampleFormat(format) {
        this.mSampleFormat = format;
    }
    /**
     * @returns {AudioSampleFormat} set by setter.
     */
    get sampleFormat() {
        return this.mSampleFormat;
    }
}
exports.AudioFormat = AudioFormat;
/**
 * @name VideoFormat provides setters to set different properties
 * which can be used to query for a specific video codec which satisfies all
 * the properties set.
 */
class VideoFormat {
    mResolution;
    mColorFormat;
    mColorPrimaries;
    mColorTransfer;
    mColorMatrix;
    mFrameRate;
    /**
     * Sets the resolution.
     *
     * Recomended to provide the max resolution during transform initialization
     * and required resolution for any dynamic resolution switching during
     * encoding in running state.
     *
     * This method can also be called for dynamic configuration.
     *
     * @param resolution: @type {Resolution} width and height in no of pixels
     */
    set resolution(resolution) {
        this.mResolution = resolution;
    }
    /**
     * @returns {Resolution} set by setter.
     */
    get resolution() {
        return this.mResolution;
    }
    /**
     * Sets the color format.
     *
     * This color format is associated with the raw buffers which is applicable
     * for decoders output or encoders input. Codec support standard and/or
     * proprietary color formats, where application has to choose based on the
     * usecase.
     *
     * For example, if the video decoder supports
     * "FLEX_YCbCr_420_888/FLEX_YCbCr_420_101010" which means proprietary
     * color format, is best choice for video decoding when
     * application will not read the buffer and its needed just for rendering on
     * display.
     *
     * @param format: @type {BufferPixelFormat} the color format value.
     */
    set colorFormat(format) {
        this.mColorFormat = format;
    }
    /**
     * @returns {BufferPixelFormat} set by setter.
     */
    get colorFormat() {
        return this.mColorFormat;
    }
    /**
     * Sets the color primaries.
     *
     * Color Primaries represent three points(RGB primaries) of the triangle on
     * the CIE 1931 chromaticity diagram, and the space inside the triangle is
     * the gamut.
     *
     * Applicable for decoders input or encoders output.
     *
     * @param primaries: @type {VideoColorPrimaries} The color primaries value.
     */
    set colorPrimaries(primaries) {
        this.mColorPrimaries = primaries;
    }
    /**
     * @returns {VideoColorPrimaries} set by setter.
     */
    get colorPrimaries() {
        return this.mColorPrimaries;
    }
    /**
     * Sets the color transfer.
     *
     * Color Transfer characteristics map the color gamut to the screen signal
     *
     * Applicable for decoders input or encoders output.
     *
     * @param transferFn: @type {VideoColorTransfer} the color transfer value.
     */
    set colorTransfer(transferFn) {
        this.mColorTransfer = transferFn;
    }
    /**
     * @returns {VideoColorTransfer} set by the setter.
     */
    get colorTransfer() {
        return this.mColorTransfer;
    }
    /**
     * Sets the color matrix.
     *
     * Values are taken from Table 4 of ISO/IEC 23001-8:2016
     *
     * Applicable for decoders input or encoders output.
     *
     * @param matrix: @type {VideoColorMatrix} the color matrix value.
     */
    set colorMatrix(matrix) {
        this.mColorMatrix = matrix;
    }
    /**
     * @returns {VideoColorMatrix} set by the setter
     */
    get colorMatrix() {
        return this.mColorMatrix;
    }
    /**
     * Sets the frameRate.
     *
     * This can also be called for dynamic configuration.
     *
     * @param rate: @type {number} framerate value in no of frames/sec.
     */
    set frameRate(rate) {
        this.mFrameRate = rate;
    }
    /**
     * @returns {number}, the frame rate value set using setter.
     */
    get frameRate() {
        return this.mFrameRate;
    }
}
exports.VideoFormat = VideoFormat;
/**
 * @name MediaCodecFeatures provides setters for different codec features.
 */
class MediaCodecFeatures {
    mRequiresHardwareBacked;
    /**
     * Set true to request the hardware backed codec.
     *
     * @param hardWareBacked: @type {boolean}, if true a hw backed codec will be queried.
     * If False or not set, this value is no-op and the returned codecs
     * may or may not have hardware backed feature.
     */
    set requiresHardwareBacked(hardWareBacked) {
        this.mRequiresHardwareBacked = hardWareBacked;
    }
    /**
     * @returns {boolean} set by the setter.
     */
    get requiresHardwareBacked() {
        return this.mRequiresHardwareBacked;
    }
}
exports.MediaCodecFeatures = MediaCodecFeatures;
/**
 * @name DecoderFeatures provides setters for different decoder features.
 */
class DecoderFeatures {
    mRequiresDecryption;
    /**
     * Request support for content decryption.
     *
     * AES-128 is the typical encryption standard used for DRM content.
     * The ISO/IEC 23001-7 standard has defined four Common Encryption schemes:
     * 1. CENC (AES CTR full-sample encryption)
     * 2. CENS(AES CTR patterned subsample encryption)
     * 3. CBC1 (AES CBC full-sample encryption)
     * 4. CBCS (AES CBC patterned subsample encryption)
     *
     * Refer to the DRM capabilities APIs to check which decrption scheme is
     * supported by the CDM
     *
     * @param decrypt: @type {boolean}, if true content decryption support is queried.
     * If false or not set, this value is no-op and the returned codecs
     * may or may not have decryption support.
     */
    set requiresDecryption(decrypt) {
        this.mRequiresDecryption = decrypt;
    }
    /**
     * @returns {boolean}, the value set by setters.
     */
    get requiresDecryption() {
        return this.mRequiresDecryption;
    }
}
exports.DecoderFeatures = DecoderFeatures;
/**
 * Audio Raw Sample Format
 */
var AudioSampleFormat;
(function (AudioSampleFormat) {
    // PCM signed 8-bit
    AudioSampleFormat["PCM_S8"] = "PCM_S8";
    // PCM unsigned 8-bit
    AudioSampleFormat["PCM_U8"] = "PCM_U8";
    // PCM signed 16-bit little-endian
    AudioSampleFormat["PCM_S16LE"] = "PCM_S16LE";
    // PCM signed 16-bit big-endian
    AudioSampleFormat["PCM_S16BE"] = "PCM_S16BE";
    // PCM unsigned 16-bit little-endian
    AudioSampleFormat["PCM_U16LE"] = "PCM_U16LE";
    // PCM unsigned 16-bit big-endian
    AudioSampleFormat["PCM_U16BE"] = "PCM_U16BE";
    // PCM signed 24-bit little-endian
    AudioSampleFormat["PCM_S24LE"] = "PCM_S24LE";
    // PCM signed 24-bit big-endian
    AudioSampleFormat["PCM_S24BE"] = "PCM_S24BE";
    // PCM unsigned 24-bit little-endian
    AudioSampleFormat["PCM_U24LE"] = "PCM_U24LE";
    // PCM unsigned 24-bit big-endian
    AudioSampleFormat["PCM_U24BE"] = "PCM_U24BE";
    // PCM signed 32-bit little-endian
    AudioSampleFormat["PCM_S32LE"] = "PCM_S32LE";
    // PCM signed 32-bit big-endian
    AudioSampleFormat["PCM_S32BE"] = "PCM_S32BE";
    // PCM unsigned 32-bit little-endian
    AudioSampleFormat["PCM_U32LE"] = "PCM_U32LE";
    // PCM unsigned 32-bit big-endian
    AudioSampleFormat["PCM_U32BE"] = "PCM_U32BE";
    // PCM 32-bit floating-point little-endian
    AudioSampleFormat["PCM_F32LE"] = "PCM_F32LE";
    // PCM 32-bit floating-point big-endian
    AudioSampleFormat["PCM_F32BE"] = "PCM_F32BE";
})(AudioSampleFormat || (AudioSampleFormat = {}));
exports.AudioSampleFormat = AudioSampleFormat;
/**
 * Codec Mime Types
 */
var CodecMimeType;
(function (CodecMimeType) {
    /* Video  Codec Mime Types*/
    // Raw format
    CodecMimeType["MIME_VIDEO_RAW"] = "video/raw";
    // Video Processor 8
    CodecMimeType["MIME_VP8"] = "video/vp8";
    // Video Processor 9
    CodecMimeType["MIME_VP9"] = "video/vp9";
    // AOMedia Video 1
    CodecMimeType["MIME_AV1"] = "video/av01";
    // High Efficiency Video Coding
    CodecMimeType["MIME_HEVC"] = "video/hevc";
    // Advanced Video Coding (alias video/h264)
    CodecMimeType["MIME_AVC"] = "video/avc";
    // Advanced Video Coding H264
    CodecMimeType["MIME_H264"] = "video/h264";
    // H.263 Video (alias video/3gpp)
    CodecMimeType["MIME_H263"] = "video/h263";
    // H.263 Video 3gpp
    CodecMimeType["MIME_3GPP"] = "video/3gpp";
    // MPEG-4 Video Elemental Stream (alias video/mp4v-es)
    CodecMimeType["MIME_MPEG4"] = "video/mpeg4";
    // MPEG-4 Video Elemental Stream mp4v-es
    CodecMimeType["MIME_MP4VES"] = "video/mp4v-es";
    // MPEG-2 Part 2 Visual
    CodecMimeType["MIME_MPEG2"] = "video/mpeg2";
    // MPEG-1 Part 2 Visual
    CodecMimeType["MIME_MPEG1"] = "video/mpeg1";
    // Dolby Vision
    CodecMimeType["MIME_DOLBY_VISION"] = "video/dolby-vision";
    // Video Unspecified
    CodecMimeType["MIME_VIDEO_UNSPECIFIED"] = "video/*";
    /* Audio  Codec Mime Types*/
    // Raw format
    CodecMimeType["MIME_AUDIO_RAW"] = "audio/raw";
    // MPEG-1 Audio Layer III
    CodecMimeType["MIME_MP3"] = "audio/mpeg";
    // MPEG-1 Audio Layer I
    CodecMimeType["MIME_MPEG_LAYER_I"] = "audio/mpeg-L1";
    // MPEG-1 Audio Layer II
    CodecMimeType["MIME_MPEG_LAYER_II"] = "audio/mpeg-L2";
    // Advanced Audio Coding (alias audio/aac)
    CodecMimeType["MIME_AAC_LATM"] = "audio/mp4a-latm";
    // Advanced Audio Coding - Mpeg Version II
    CodecMimeType["MIME_AAC"] = "audio/aac";
    // Advanced Audio Coding - Mpeg Version IV, RAW
    CodecMimeType["MIME_AAC_RAW"] = "audio/aac-raw";
    // Advanced Audio Coding - Mpeg Version IV, Audio Data Transport Stream
    CodecMimeType["MIME_AAC_ADTS"] = "audio/aac-adts";
    // Advanced Audio Coding - Mpeg Version IV, Audio Data Interchange Format
    CodecMimeType["MIME_AAC_ADIF"] = "audio/aac-adif";
    // Advanced Audio Coding - Mpeg Version IV, Low Overhead Audio Stream
    CodecMimeType["MIME_AAC_LOAS"] = "audio/aac-loas";
    // Vorbis
    CodecMimeType["MIME_VORBIS"] = "audio/vorbis";
    // Opus
    CodecMimeType["MIME_OPUS"] = "audio/opus";
    // Free Lossless Audio Codec
    CodecMimeType["MIME_FLAC"] = "audio/flac";
    // Waveform Audio File Format
    CodecMimeType["MIME_WAV"] = "audio/wav";
    // Adaptive Multi-Rate Narrow Band (alias audio/3gpp)
    CodecMimeType["MIME_AMR_NB"] = "audio/amr";
    // Adaptive Multi-Rate Narrow Band 3gpp
    CodecMimeType["MIME_AMR_NB_3GPP"] = "audio/3gpp";
    // Adaptive Multi-Rate Wide Band
    CodecMimeType["MIME_AMR_WB"] = "audio/amr-wb";
    // Pulse Code Modulation A-law
    CodecMimeType["MIME_G711_ALAW"] = "audio/g711-alaw";
    // Pulse Code Modulation µ-law
    CodecMimeType["MIME_G711_MLAW"] = "audio/g711-mlaw";
    // Dolby Digital
    CodecMimeType["MIME_AC3"] = "audio/ac3";
    // Dolby Digital Plus
    CodecMimeType["MIME_EAC3"] = "audio/eac3";
    // Audio Unspecified
    CodecMimeType["MIME_AUDIO_UNSPECIFIED"] = "audio/*";
})(CodecMimeType || (CodecMimeType = {}));
exports.CodecMimeType = CodecMimeType;
/**
 * Video Color Primaries
 *
 * Color Primaries represent three points(RGB primaries) of the triangle on the
 * CIE 1931 chromaticity diagram, and the space inside the triangle is the
 * gamut.
 *
 * Color gamut describes a set of colors in which the content is intended to be
 * displayed.
 *
 * HDR content requires a wider color gamut than SDR content. Most of devices
 * support the sRGB color gamut but P3 or Rec. 2020 are color gamut that would
 * usually be expected for HDR content
 *
 * If the attached output device also supports the specified color, the device
 * needs to be able to cause the output device to render the appropriate color,
 * or something close enough. If the attached output device does not support the
 * specified color, the device needs to be capable of mapping the specified
 * color to a color supported by the output device.
 *
 * Values are taken from Table 2 — Interpretation of colour primaries
 * (ColourPrimaries) of ISO/IEC 23001-8:2016
 */
var VideoColorPrimaries;
(function (VideoColorPrimaries) {
    /* Rec. ITU-R BT.709*/
    VideoColorPrimaries[VideoColorPrimaries["BT709"] = 1] = "BT709";
    /* Rec. ITU-R BT.2020*/
    VideoColorPrimaries[VideoColorPrimaries["BT2020"] = 9] = "BT2020";
    /* Society of Motion Picture and Television Engineers EG 432-1 (2010), P3*/
    VideoColorPrimaries[VideoColorPrimaries["SMPTE_ST4321"] = 12] = "SMPTE_ST4321";
})(VideoColorPrimaries || (VideoColorPrimaries = {}));
exports.VideoColorPrimaries = VideoColorPrimaries;
/**
 * Video Color Transfer
 *
 * Color Transfer characteristics map the color gamut to the screen signal
 *
 * Transfer function describes the electro-optical algorithm supported by the
 * rendering capabilities of a device, independent of the display, to map
 * the source colors in the decoded media into the colors to be displayed.
 *
 * Values 1-15 are taken from Table 3 of ISO/IEC 23001-8:2016
 * Values 16-18 are proposed to extend the standard values
 * https://matroska.org/technical/elements.html
 */
var VideoColorTransfer;
(function (VideoColorTransfer) {
    /* Rec. ITU-R BT.709*/
    VideoColorTransfer[VideoColorTransfer["BT_709"] = 1] = "BT_709";
    /* IEC 61966-2-1 sRGB*/
    VideoColorTransfer[VideoColorTransfer["IEC_61966_2_1"] = 13] = "IEC_61966_2_1";
    // This is used by HDR10, HDR10+ and Dolby Vision
    /* SMPTE ST 2084 (2014) for 10-, 12-,14- and 16-bit systems*/
    VideoColorTransfer[VideoColorTransfer["SMPTE_BT2100_PQ"] = 16] = "SMPTE_BT2100_PQ";
    /* Rec. ITU-R BT.2100-2 hybrid loggamma (HLG) system*/
    VideoColorTransfer[VideoColorTransfer["HLG"] = 18] = "HLG";
})(VideoColorTransfer || (VideoColorTransfer = {}));
exports.VideoColorTransfer = VideoColorTransfer;
/**
 * Video Color Matrix
 * Values are taken from Table 4 of ISO/IEC 23001-8:2016
 */
var VideoColorMatrix;
(function (VideoColorMatrix) {
    VideoColorMatrix[VideoColorMatrix["IDENTITY"] = 0] = "IDENTITY";
    VideoColorMatrix[VideoColorMatrix["BT709"] = 1] = "BT709";
    VideoColorMatrix[VideoColorMatrix["UNSPECIFIED"] = 2] = "UNSPECIFIED";
    VideoColorMatrix[VideoColorMatrix["RESERVED_3"] = 3] = "RESERVED_3";
    VideoColorMatrix[VideoColorMatrix["FCC_73682"] = 4] = "FCC_73682";
    VideoColorMatrix[VideoColorMatrix["ITU_R_BT470BG"] = 5] = "ITU_R_BT470BG";
    VideoColorMatrix[VideoColorMatrix["SMPTE_170M"] = 6] = "SMPTE_170M";
    VideoColorMatrix[VideoColorMatrix["SMPTE_240M"] = 7] = "SMPTE_240M";
    VideoColorMatrix[VideoColorMatrix["Y_CO_CG"] = 8] = "Y_CO_CG";
    VideoColorMatrix[VideoColorMatrix["BT2020_NON_CONSTANT_LUMINANCE"] = 9] = "BT2020_NON_CONSTANT_LUMINANCE";
    VideoColorMatrix[VideoColorMatrix["BT2020_CONSTANT_LUMINANCE"] = 10] = "BT2020_CONSTANT_LUMINANCE";
    VideoColorMatrix[VideoColorMatrix["SMPTE_ST_2085"] = 11] = "SMPTE_ST_2085";
    VideoColorMatrix[VideoColorMatrix["CHROMA_DERIVED_NON_CONSTANT_LUMINANCE"] = 12] = "CHROMA_DERIVED_NON_CONSTANT_LUMINANCE";
    VideoColorMatrix[VideoColorMatrix["CHROMA_DERIVED_CONSTANT_LUMINANCE"] = 13] = "CHROMA_DERIVED_CONSTANT_LUMINANCE";
    VideoColorMatrix[VideoColorMatrix["ITU_R_BT2100"] = 14] = "ITU_R_BT2100";
})(VideoColorMatrix || (VideoColorMatrix = {}));
exports.VideoColorMatrix = VideoColorMatrix;

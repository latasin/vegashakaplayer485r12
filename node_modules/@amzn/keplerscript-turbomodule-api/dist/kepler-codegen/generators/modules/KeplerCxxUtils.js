"use strict";
/**
 * Copyright (c) 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * PROPRIETARY/CONFIDENTIAL
 *
 * Use is subject to license terms.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.translatePrimitiveJSTypeToCpp = exports.checkReservedNames = exports.TMAPINamespace = void 0;
const RNCodegenUtils_1 = require("../../RNCodegenUtils");
exports.TMAPINamespace = "com::amazon::kepler::turbomodule";
// A non-comprehensive list of parameter names which may be valid in JS/TS, but will fail C++ compilation.
const ReservedNames = new Set([
    'void',
    'double',
    'int',
    'int32',
    'int32_t',
    'int64',
    'int64_t',
    'uint32',
    'uint32_t',
    'bool',
    'Callback',
    'Promise',
    'ArrayBuffer',
    'JSONContainer',
    'NativeObject',
    'BigInt',
    'char',
    'float',
    'string',
]);
// Checks parameter names for reserved keywords
const checkReservedNames = (name, createErrorMessage) => {
    if (ReservedNames.has(name)) {
        throw new Error(createErrorMessage(name));
    }
};
exports.checkReservedNames = checkReservedNames;
// C++ types for Kepler
var KeplerType;
(function (KeplerType) {
    KeplerType["VOID"] = "void";
    KeplerType["STRING"] = "std::string";
    KeplerType["DOUBLE"] = "double";
    KeplerType["FLOAT"] = "float";
    KeplerType["INT32"] = "int32_t";
    KeplerType["UINT32"] = "uint32_t";
    KeplerType["INT64"] = "int64_t";
    KeplerType["BIGINT"] = "com::amazon::kepler::turbomodule::BigInt";
    KeplerType["BOOLEAN"] = "bool";
    KeplerType["JS_ARRAY"] = "com::amazon::kepler::turbomodule::JSArray";
    KeplerType["OBJECT"] = "com::amazon::kepler::turbomodule::JSObject";
    KeplerType["NATIVE_OBJECT"] = "std::shared_ptr<com::amazon::kepler::turbomodule::NativeObject>";
    KeplerType["ARRAY_BUFFER"] = "com::amazon::kepler::turbomodule::ArrayBuffer";
    KeplerType["JSON_CONTAINER"] = "utils::json::JsonContainer";
    KeplerType["CALLBACK"] = "com::amazon::kepler::turbomodule::Callback";
    KeplerType["HOST_CALLBACK"] = "com::amazon::kepler::turbomodule::HostCallback";
    KeplerType["PROMISE"] = "com::amazon::kepler::turbomodule::Promise";
})(KeplerType || (KeplerType = {}));
// Adds Array wrapping function to KeplerType
(function (KeplerType) {
    function ARRAY(memberType) {
        return `std::vector<${memberType}>`;
    }
    KeplerType.ARRAY = ARRAY;
    function FUNCTION(isParam) {
        return isParam ? KeplerType.CALLBACK : KeplerType.HOST_CALLBACK;
    }
    KeplerType.FUNCTION = FUNCTION;
})(KeplerType || (KeplerType = {}));
// This holds the 1:1 type mappings which require no further logic
const BaseTypeMap = {
    [RNCodegenUtils_1.TypeAnnotation.VOID]: KeplerType.VOID,
    [RNCodegenUtils_1.TypeAnnotation.STRING]: KeplerType.STRING,
    [RNCodegenUtils_1.TypeAnnotation.NUMBER]: KeplerType.DOUBLE,
    [RNCodegenUtils_1.TypeAnnotation.DOUBLE]: KeplerType.DOUBLE,
    [RNCodegenUtils_1.TypeAnnotation.FLOAT]: KeplerType.FLOAT,
    [RNCodegenUtils_1.TypeAnnotation.INT32]: KeplerType.INT32,
    [RNCodegenUtils_1.TypeAnnotation.UINT32]: KeplerType.UINT32,
    [RNCodegenUtils_1.TypeAnnotation.INT64]: KeplerType.INT64,
    [RNCodegenUtils_1.TypeAnnotation.BIGINT]: KeplerType.BIGINT,
    [RNCodegenUtils_1.TypeAnnotation.BOOLEAN]: KeplerType.BOOLEAN,
    [RNCodegenUtils_1.TypeAnnotation.GENERIC_OBJECT]: KeplerType.OBJECT,
    [RNCodegenUtils_1.TypeAnnotation.OBJECT]: KeplerType.OBJECT,
    [RNCodegenUtils_1.TypeAnnotation.PROMISE]: KeplerType.PROMISE,
    [RNCodegenUtils_1.TypeAnnotation.ARRAY_BUFFER]: KeplerType.ARRAY_BUFFER,
    [RNCodegenUtils_1.TypeAnnotation.JSON_CONTAINER]: KeplerType.JSON_CONTAINER,
    [RNCodegenUtils_1.TypeAnnotation.MIXED]: KeplerType.OBJECT,
};
const UnionTypes = [RNCodegenUtils_1.TypeAnnotation.STRING, RNCodegenUtils_1.TypeAnnotation.NUMBER, RNCodegenUtils_1.TypeAnnotation.OBJECT];
const EnumTypes = [RNCodegenUtils_1.TypeAnnotation.STRING, RNCodegenUtils_1.TypeAnnotation.NUMBER];
const ArrayTypes = [
    RNCodegenUtils_1.TypeAnnotation.INT32,
    RNCodegenUtils_1.TypeAnnotation.UINT32,
    RNCodegenUtils_1.TypeAnnotation.INT64,
    RNCodegenUtils_1.TypeAnnotation.BIGINT,
    RNCodegenUtils_1.TypeAnnotation.FLOAT,
    RNCodegenUtils_1.TypeAnnotation.DOUBLE,
    RNCodegenUtils_1.TypeAnnotation.NUMBER,
    RNCodegenUtils_1.TypeAnnotation.BOOLEAN,
    RNCodegenUtils_1.TypeAnnotation.STRING,
    RNCodegenUtils_1.TypeAnnotation.ARRAY_BUFFER,
    RNCodegenUtils_1.TypeAnnotation.JSON_CONTAINER,
    RNCodegenUtils_1.TypeAnnotation.OBJECT,
    RNCodegenUtils_1.TypeAnnotation.GENERIC_OBJECT,
    RNCodegenUtils_1.TypeAnnotation.NATIVE_OBJECT,
    RNCodegenUtils_1.TypeAnnotation.FUNCTION
];
const translatePrimitiveJSTypeToCpp = (nullableTypeAnnotation, optional, isParam, createErrorMessage, resolveAlias) => {
    const [typeAnnotation, nullable] = (0, RNCodegenUtils_1.unwrapNullable)(nullableTypeAnnotation);
    const isRequired = !optional && !nullable;
    if (!isRequired) {
        throw new Error('Optionals are not supported by Kepler TurboModules.');
    }
    let realTypeAnnotation = typeAnnotation;
    if (typeAnnotation.type == 'TypeAliasTypeAnnotation') {
        const aliasName = typeAnnotation.name;
        // Allow custom objects to map JsonContainer via alias names
        if (aliasName.includes('JsonContainer')) {
            return KeplerType.JSON_CONTAINER;
        }
        realTypeAnnotation = resolveAlias(aliasName);
    }
    // Simple 1:1 type mappings
    if (realTypeAnnotation.type in BaseTypeMap) {
        return BaseTypeMap[realTypeAnnotation.type];
    }
    // Type mappings which require extra logic
    switch (realTypeAnnotation.type) {
        case RNCodegenUtils_1.TypeAnnotation.RESERVED:
            if (realTypeAnnotation.name === 'RootTag') {
                return KeplerType.DOUBLE;
            }
            // @ts-ignore
            throw new Error(createErrorMessage(realTypeAnnotation.name));
        case RNCodegenUtils_1.TypeAnnotation.FUNCTION:
            return KeplerType.FUNCTION(isParam);
        case RNCodegenUtils_1.TypeAnnotation.ENUM:
            if (EnumTypes.includes(realTypeAnnotation.memberType)) {
                return BaseTypeMap[realTypeAnnotation.memberType];
            }
            throw new Error(createErrorMessage(realTypeAnnotation.type));
        case RNCodegenUtils_1.TypeAnnotation.UNION:
            if (UnionTypes.includes(realTypeAnnotation.memberType)) {
                return BaseTypeMap[realTypeAnnotation.memberType];
            }
            throw new Error(createErrorMessage(realTypeAnnotation.type));
        case RNCodegenUtils_1.TypeAnnotation.ARRAY:
            if (!realTypeAnnotation.elementType) {
                return KeplerType.JS_ARRAY;
            }
            else if (ArrayTypes.includes(realTypeAnnotation.elementType.type)) {
                if (realTypeAnnotation.elementType.type === RNCodegenUtils_1.TypeAnnotation.FUNCTION) {
                    return KeplerType.ARRAY(KeplerType.FUNCTION(isParam));
                }
                return KeplerType.ARRAY(BaseTypeMap[realTypeAnnotation.elementType.type]);
            }
            else {
                return KeplerType.JS_ARRAY;
            }
        case RNCodegenUtils_1.TypeAnnotation.NATIVE_OBJECT:
            if (!isParam) {
                return KeplerType.NATIVE_OBJECT;
            }
            throw new Error(createErrorMessage(realTypeAnnotation.type));
        default:
            throw new Error(createErrorMessage(realTypeAnnotation.type));
    }
};
exports.translatePrimitiveJSTypeToCpp = translatePrimitiveJSTypeToCpp;

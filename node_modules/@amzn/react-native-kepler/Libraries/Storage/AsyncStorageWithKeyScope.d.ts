import { AsyncStorageStatic } from 'react-native';
export declare class AsyncStorageWithKeyScope implements AsyncStorageStatic {
    private readonly scopePrefix;
    private readonly scopePrefixLength;
    constructor(scopePrefix: string);
    getScopeTag(): string;
    prefixedKey(key: string): string;
    removePrefix(key: string): string;
    /**
     * Fetches key and passes the result to callback, along with an Error if there is any.
     */
    getItem(key: string, callback?: (error?: Error, result?: string) => void): Promise<string | null>;
    /**
     * Sets value for key and calls callback on completion, along with an Error if there is any.
     * Beware of using indeterminate keys, like including a timestamp or an id that may fluctuate
     * such that you are not able to determine the key later to get or remove it. This can lead
     * to an ever-increasing data store with no recovery options except to clear the store.
     */
    setItem(key: string, value: string, callback?: (error?: Error) => void): Promise<void>;
    removeItem(key: string, callback?: (error?: Error) => void): Promise<void>;
    /**
     * Merges existing value with input value, assuming they are stringified json. Returns a Promise object.
     * Not supported by all native implementation
     */
    mergeItem(key: string, value: string, callback?: (error?: Error) => void): Promise<void>;
    /**
     * Gets all keys known to the app, for all callers, libraries, etc
     */
    getAllKeys(callback?: (error?: Error, keys?: string[]) => void): Promise<string[]>;
    /**
     * multiGet invokes callback with an array of key-value pair arrays that matches the input format of multiSet
     */
    multiGet(keys: string[], callback?: (errors?: Error[], result?: [string, string][]) => void): Promise<[string, string][]>;
    /**
     * multiSet and multiMerge take arrays of key-value array pairs that match the output of multiGet,
     *
     * multiSet([['k1', 'val1'], ['k2', 'val2']], cb);
     *
     * Beware of using indeterminate keys, like including a timestamp or an id that may fluctuate
     * such that you are not able to determine the key later to get or remove it. This can lead
     * to an ever-increasing data store with no recovery options except to clear the store.
     */
    multiSet(keyValuePairs: string[][], callback?: (errors?: Error[]) => void): Promise<void>;
    /**
     * Delete all the keys in the keys array.
     */
    multiRemove(keys: string[], callback?: (errors?: Error[]) => void): Promise<void>;
    /**
     * Merges existing values with input values, assuming they are stringified json.
     * Returns a Promise object.
     *
     * Not supported by all native implementations.
     */
    multiMerge(keyValuePairs: string[][], callback?: (errors?: Error[]) => void): Promise<void>;
    /**
     * Erases all AsyncStorage for all clients. Not supported by AsyncStorageWithKeyScope.
     * Use clearScope instead. To clear all storage call AsyncStorage.clear() directly.
     */
    clear(callback?: (error?: Error) => void): Promise<void>;
    /**
     * Erases all values stored with keys prefixed with the scope prefix set for this instance.
     * This can potentially be a lengthy task to complete.
     */
    clearScope(callback?: (errors?: Error[]) => void): Promise<void>;
}

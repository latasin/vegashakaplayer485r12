"use strict";
/*
 * Copyright 2024 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncStorageWithKeyScope = void 0;
// Must import from react-native in this case to work at runtime
const react_native_1 = require("react-native");
/*
 * This class is an abstraction on top of AsyncStorage and
 * supports the same API methods.
 * Use this class to create an instance with a scope prefix string
 * that will be transparently prefixed to keys in the data store
 * with an underscore.
 *
 * This is useful for namespacing keys. The data store is shared globally
 * within an application process. so there can be many reasons for namespacing
 * contexts to avoid key name overlap.
 *
 * Example scopePrefix: "MyAppNetworking"
 *
 * All keys stored with the instance would be prefixed with "MyAppNetworking_".
 *
 * When keys are returned to the caller they are stripped of the prefix,
 * so the caller doesn't need to concern itself with that detail,
 * other than using an instance of this class created with a scopePrefix
 * that makes sense for its context.
 */
class AsyncStorageWithKeyScope {
    constructor(scopePrefix) {
        this.scopePrefix = scopePrefix;
        this.scopePrefixLength = scopePrefix.length;
    }
    getScopeTag() {
        return this.scopePrefix;
    }
    prefixedKey(key) {
        return this.scopePrefix + '_' + key;
    }
    removePrefix(key) {
        if (this.scopePrefixLength && key.startsWith(`${this.scopePrefix}_`)) {
            return key.slice(this.scopePrefixLength + 1);
        }
        return key;
    }
    /**
     * Fetches key and passes the result to callback, along with an Error if there is any.
     */
    getItem(key, callback) {
        return react_native_1.AsyncStorage.getItem(this.prefixedKey(key), callback);
    }
    /**
     * Sets value for key and calls callback on completion, along with an Error if there is any.
     * Beware of using indeterminate keys, like including a timestamp or an id that may fluctuate
     * such that you are not able to determine the key later to get or remove it. This can lead
     * to an ever-increasing data store with no recovery options except to clear the store.
     */
    setItem(key, value, callback) {
        return react_native_1.AsyncStorage.setItem(this.prefixedKey(key), value, callback);
    }
    removeItem(key, callback) {
        return react_native_1.AsyncStorage.removeItem(this.prefixedKey(key), callback);
    }
    /**
     * Merges existing value with input value, assuming they are stringified json. Returns a Promise object.
     * Not supported by all native implementation
     */
    mergeItem(key, value, callback) {
        return react_native_1.AsyncStorage.mergeItem(this.prefixedKey(key), value, callback);
    }
    /**
     * Gets all keys known to the app, for all callers, libraries, etc
     */
    getAllKeys(callback) {
        return new Promise(async (resolve, reject) => {
            react_native_1.AsyncStorage.getAllKeys()
                .then((keys) => {
                const descopedKeys = keys.map(key => {
                    return this.removePrefix(key);
                });
                if (callback) {
                    callback(null, descopedKeys);
                }
                resolve(descopedKeys);
            })
                .catch((error) => {
                if (callback) {
                    callback(error, null);
                }
                reject(error);
            });
        });
    }
    /**
     * multiGet invokes callback with an array of key-value pair arrays that matches the input format of multiSet
     */
    multiGet(keys, callback) {
        return new Promise(async (resolve, reject) => {
            const prefixedKeys = keys.map(key => {
                return this.prefixedKey(key);
            });
            react_native_1.AsyncStorage.multiGet(prefixedKeys)
                .then((values) => {
                const descopedValues = values.map(([key, value]) => [this.removePrefix(key), value]);
                if (callback) {
                    callback(null, descopedValues);
                }
                resolve(descopedValues);
            })
                .catch((error) => {
                if (callback) {
                    callback(error, null);
                }
                reject(error);
            });
        });
    }
    /**
     * multiSet and multiMerge take arrays of key-value array pairs that match the output of multiGet,
     *
     * multiSet([['k1', 'val1'], ['k2', 'val2']], cb);
     *
     * Beware of using indeterminate keys, like including a timestamp or an id that may fluctuate
     * such that you are not able to determine the key later to get or remove it. This can lead
     * to an ever-increasing data store with no recovery options except to clear the store.
     */
    multiSet(keyValuePairs, callback) {
        const prefixedKeyValuePairs = keyValuePairs.map(([key, value]) => [this.prefixedKey(key), value]);
        return react_native_1.AsyncStorage.multiSet(prefixedKeyValuePairs, callback);
    }
    /**
     * Delete all the keys in the keys array.
     */
    multiRemove(keys, callback) {
        const prefixedKeys = keys.map(key => {
            return this.prefixedKey(key);
        });
        return react_native_1.AsyncStorage.multiRemove(prefixedKeys, callback);
    }
    /**
     * Merges existing values with input values, assuming they are stringified json.
     * Returns a Promise object.
     *
     * Not supported by all native implementations.
     */
    multiMerge(keyValuePairs, callback) {
        const prefixedKeyValuePairs = keyValuePairs.map(([key, value]) => [this.prefixedKey(key), value]);
        return react_native_1.AsyncStorage.multiMerge(prefixedKeyValuePairs, callback);
    }
    /**
     * Erases all AsyncStorage for all clients. Not supported by AsyncStorageWithKeyScope.
     * Use clearScope instead. To clear all storage call AsyncStorage.clear() directly.
     */
    clear(callback) {
        return new Promise(async (resolve, reject) => {
            const unsupportedError = new Error("AsyncStorageWithKeyScope does not support clear(). Use clearScope() to clear values for keys using the scope prefix, or call AsyncStorage.clear() to clear all values from the data store.");
            if (callback) {
                callback(unsupportedError);
            }
            reject(unsupportedError);
        });
    }
    /**
     * Erases all values stored with keys prefixed with the scope prefix set for this instance.
     * This can potentially be a lengthy task to complete.
     */
    clearScope(callback) {
        if (react_native_1.AsyncStorage.removeValuesForKeysWithPrefix) {
            const prefix = this.scopePrefix + '_';
            return react_native_1.AsyncStorage.removeValuesForKeysWithPrefix(prefix, callback);
        }
        else {
            return new Promise(async (resolve, reject) => {
                const unsupportedError = new Error("Unable to clear scope because AsyncStorage.removeValuesForKeysWithPrefix is not implemented.");
                if (callback) {
                    callback([unsupportedError]);
                }
                reject(unsupportedError);
            });
        }
    }
}
exports.AsyncStorageWithKeyScope = AsyncStorageWithKeyScope;

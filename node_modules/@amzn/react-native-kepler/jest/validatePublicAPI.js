/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 * @format
 */

import type {TransformVisitor} from 'hermes-transform';

const translate = require('flow-api-translator');
const {promises: fs} = require('fs');
const {transform} = require('hermes-transform');
const os = require('os');
const path = require('path');
const normalize = require('normalize-path');

// Allows us to log regular console messages for untyped JS files as regular messages without jestconsole noise
const stdconsole = require('console');

// amznmod_react - factored implementation out from public-api-test.js
/**
 * @classdesc Options for validating Flow JavaScript/TypeScript API definition shapshots
 * @property {Boolean} flowOnly - Set true if your sourceFiles contain only Flow JS files.
 * @property {Boolean} typeScriptOnly - Set true if your source files contain only TypeScript files.
 * @property {Boolean} verifyTypeScriptDefGenerated - Set true if you pass .js files in source files.
 *  Set false if you pass .d.ts files in source files.
 * @property {Array<string>} excludedPlatforms - Matched against os.platform(), platforms you don't want the test to run on
 *  (e.g. 'win32').
 * @property {Boolean} logUntypedJavaScriptFiles - Set true to log warning messages for JavaScript files that Flow types
 *  could not be generated for.
 * @property {Boolean} failOnUntypedJavaScriptFiles - Set true to fail tests for JavaScript files when Flow types cannot be
 *  obtained from.
 */
class APIValidationOptions {
    flowOnly: boolean = false;
    typeScriptOnly: boolean = false;
    verifyTypeScriptDefGenerated: boolean = true;
    excludedPlatforms: Array<string> = [];
    logUntypedJavaScriptFiles: boolean = true;
    failOnUntypedJavaScriptFiles: boolean = false;
}

/**
 *  @function validate_public_api
 *  @description Validate Flow JavaScript/TypeScript API definition snapshots
 *  @param {string} packageRoot - Path to the package.json directory
 *  @param {Array<string>} sourceFiles - Array of paths to sources to validate (must be all .js or all .d.ts files)
 *  @param {APIValidationOptions} options - Options for validating sources
 *  @param {Set<string>} filesWithKnownErrors - Set of paths to files to skip validation
 */
function validate_public_api(
    packageRoot: string,
    sourceFiles: Array<string>,
    options: APIValidationOptions = new APIValidationOptions(),
    filesWithKnownErrors: Set<string> = new Set([])) {
    describe('public API', () => {
        if (options.excludedPlatforms.includes(os.platform())) {
            // eslint-disable-next-line jest/no-focused-tests
            test.only('skipping tests on ' + os.platform(), () => {
                console.log('skipping tests');
            });
        }

        describe('should not change unintentionally', () => {
            // amznmod_react - normalize the path string in the test name to unix
            test.each(sourceFiles)(normalize('%s'), async (file: string) => {
                let success = false;

                if (!options.flowOnly) {
                    // amznmod_react - Use generated .d.ts file for a .ts file as snapshot if possible
                    const typeScriptSource = await getTypeScriptExportedAPI(file, packageRoot,
                        options.verifyTypeScriptDefGenerated);

                    // amznmod_react - compare TypeScript def snapshot if not empty
                    if (typeScriptSource[0] !== '') {
                        try {
                            expect(typeScriptSource[0]).toMatchSnapshot(typeScriptSource[1]);
                            success = true;
                        } catch(e) {
                            if (!filesWithKnownErrors.has(file)) {
                                console.error('[API Validation] Unable to parse file:', file, '\n' + e);
                            }
                        } finally {
                            if (success && filesWithKnownErrors.has(file)) {
                                console.error(
                                    '[API Validation] Expected parse error, please remove file exclude from filesWithKnownErrors:',
                                    file,
                                );
                            }
                        }
                        return;
                    } else if (options.typeScriptOnly) {
                        // expected a valid file
                        if (!filesWithKnownErrors.has(file)) {
                            console.error('[API Validation] Empty typescript definition file:', file);
                            expect(typeScriptSource[0]).toBeDefined();
                            expect(typeScriptSource[0]).not.toEqual('');
                        }
                    }
                }

                if (!options.typeScriptOnly) {
                    const source = await fs.readFile(path.join(packageRoot, file), 'utf-8');

                    if (/@flow/.test(source)) {
                        if (source.includes('// $FlowFixMe[unsupported-syntax]')) {
                            if (options.failOnUntypedJavaScriptFiles && !filesWithKnownErrors.has(file)) {
                                console.error("[API Validation] Cannot get Flow JS types from file with Flow FIXME in', file");
                            } else {
                                if (options.logUntypedJavaScriptFiles) {
                                    stdconsole.warn('[API Validation] Cannot get Flow JS types from file with Flow FIXME in', file);
                                }
                                expect(
                                    'UNTYPED MODULE (unsupported-syntax suppression)',
                                ).toMatchSnapshot();
                                return;
                            }
                        }

                        try {
                            expect(await translateFlowToExportedAPI(source)).toMatchSnapshot();
                            success = true;
                        } catch (e) {
                            if (!filesWithKnownErrors.has(file)) {
                                console.error('[API Validation] Unable to parse file:', file, '\n' + e);
                            }
                        } finally {
                            if (success && filesWithKnownErrors.has(file)) {
                                console.error(
                                    '[API Validation] Expected parse error, please remove file exclude from filesWithKnownErrors:',
                                    file,
                                );
                            }
                        }
                    } else {
                        if (options.failOnUntypedJavaScriptFiles && !filesWithKnownErrors.has(file)) {
                            console.error('[API Validation] Unable to get Flow JS types from', file);
                        }
                        else {
                            if (options.logUntypedJavaScriptFiles) {
                                stdconsole.warn('[API Validation] Unable to get Flow JS types from', file);
                            }
                            expect('UNTYPED MODULE').toMatchSnapshot();
                        }
                    }
                }
            });
        });
    });
}

// amznmod_react - Add function to normalize line endings to unix
function normalizeLineEndings(str: string): string {
    return str.replace(/\r?\n/g, '\n');
}

async function translateFlowToExportedAPI(source: string): Promise<string> {
    // Convert to Flow typedefs
    const typeDefSource = await translate.translateFlowToFlowDef(source);

    // Remove comments and import declarations
    const visitors: TransformVisitor = context => ({
        Program(node) {
            // $FlowFixMe[cannot-write]
            delete node.docblock;

            for (const comment of node.comments) {
                context.removeComments(comment);
            }
        },
        ImportDeclaration(node) {
            context.removeNode(node);
        },
    });

    const result = await transform(typeDefSource, visitors);

    // Remove empty lines (saves space, consistency fix on Windows)
    // amznmod_react - normalize line endings to unix
    return normalizeLineEndings(result).replaceAll('\n\n', '\n');
}

// amznmod_react - function to identify existing ts file with same name as js file in path
async function getTypeScriptFileNameFromGeneratedJSFilePath(jsFilePath) {
    const typeScriptFileExtensions = ['.ts', '.tsx', '.cts', '.mts'];
    const parentDir = path.parse(jsFilePath).dir;
    const fileName = path.parse(jsFilePath).name;
    let typeScriptFileName = '';

    for (let i = 0; i <= typeScriptFileExtensions.length; i++) {
        typeScriptFileName = fileName + typeScriptFileExtensions[i];
        try {
            await fs.access(path.join(parentDir, typeScriptFileName));
            break;
        } catch(e) {
            typeScriptFileName = '';
        }
    }

    return typeScriptFileName;
}

// amznmod_react Add method to get .d.ts source generated for .ts
async function getTypeScriptExportedAPI(file: string,
                                        packageRoot: string,
                                        verifyTypeScriptDefGenerated: bool)
    : Promise<[string, string]> {
    let typeScriptFileName = '';

    if (verifyTypeScriptDefGenerated) {
        // We only want to take auto-generated .d.ts files
        // So we will check to see if there is a .typescript file with the same name.
        typeScriptFileName = await getTypeScriptFileNameFromGeneratedJSFilePath(path.join(packageRoot, file));
        if (typeScriptFileName === '') {
            return ['', typeScriptFileName];
        }
    } else {
        typeScriptFileName = path.parse(file).name + '.ts';
    }

    const parentDir = path.dirname(path.join(packageRoot, file));
    let typesFile = '';

    if (verifyTypeScriptDefGenerated) {
        typesFile = path.join(parentDir, path.parse(file).name + '.d.ts');
    } else {
        typesFile = path.join(parentDir, path.parse(file).name + '.ts');
    }

    const result = await fs.readFile(typesFile, 'utf-8');

    // Remove empty lines (saves space)
    return [normalizeLineEndings(result).replaceAll('\n\n', '\n'), typeScriptFileName];
}

module.exports = {
    APIValidationOptions,
    validate_public_api
}

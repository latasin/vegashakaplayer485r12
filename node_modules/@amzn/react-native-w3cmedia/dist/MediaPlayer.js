"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaPlayer = void 0;
/*
 * Copyright 2022-2025 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
const base64js = __importStar(require("base64-js"));
const LogLevelInitializer_1 = require("./LogLevelInitializer");
const AudioTrackListImpl_1 = require("./AudioTrackListImpl");
const EventTargetInterface_1 = require("./interface/EventTargetInterface");
const HTMLMediaElement_1 = require("./interface/HTMLMediaElement");
const MediaSource_1 = require("./interface/MediaSource");
// temporary till we import from audio turbo module
const MediaTypes_1 = require("./interface/MediaTypes");
const MediaElementEventRouter_1 = require("./MediaElementEventRouter");
const MediaErrorImpl_1 = require("./MediaErrorImpl");
const MediaEventEmitterImpl_1 = require("./MediaEventEmitterImpl");
const TextTrackImpl_1 = require("./TextTrackImpl");
const TextTrackListImpl_1 = require("./TextTrackListImpl");
const TimeRangesImpl_1 = require("./TimeRangesImpl");
const TrackListEventHandler_1 = require("./TrackListEventHandler");
const W3CMediaTurboModule_1 = __importDefault(require("./turbo-modules/W3CMediaTurboModule"));
const VideoTrackListImpl_1 = require("./VideoTrackListImpl");
const PlayerSessionClient_1 = require("./playersessionclient/PlayerSessionClient");
const PlayerSessionClientTypes_1 = require("./playersessionclient/PlayerSessionClientTypes");
const LogUtils_1 = require("./LogUtils");
const TimeMarchesOnAlgo_1 = require("./TimeMarchesOnAlgo");
const MediaControlStateUtil_1 = require("./mediacontrolhandler/MediaControlStateUtil");
const MediaControlSessionMapTab_1 = require("./mediacontrolhandler/MediaControlSessionMapTab");
const kepler_media_controls_1 = require("@amzn/kepler-media-controls");
const ComponentInstanceManager_1 = require("@amzn/react-native-kepler/Libraries/ComponentInstance/ComponentInstanceManager");
const KeplerMediaControlHandler_1 = require("./interface/KeplerMediaControlHandler");
const version_1 = require("./version");
const parseClientPackageManifest = async () => {
    if (MediaPlayer.isAppManifestParsed) {
        LogUtils_1.LogUtil.info(" MediaPlayer: Manifest was parsed.");
        return true;
    }
    try {
        const kmcResult = W3CMediaTurboModule_1.default.checkClientManifestForKMC();
        const componentId = kmcResult["component.id"] || "unknown";
        const hasKMC = kmcResult["hasKMC"] || false;
        MediaControlSessionMapTab_1.appClientKMCMapTable.set(componentId, hasKMC);
        MediaPlayer.isAppManifestParsed = true;
        return true;
    }
    catch (error) {
        LogUtils_1.LogUtil.warn(`MediaPlayer: checkClientManifestForKMC failed: ${error.message}`);
        return false;
    }
};
/**
 * @hidden
 * https://html.spec.whatwg.org/multipage/media.html#htmlmediaelement
 */
class MediaPlayer extends HTMLMediaElement_1.HTMLMediaElement {
    mediaElement;
    mediaElementEventRouter;
    eventEmitter;
    src_;
    volume_ = 1.0;
    muted_ = false;
    defaultMuted_ = false;
    playbackRate_ = 1.0;
    preload_ = "auto";
    autoplay_ = false;
    defaultPlaybackRate_ = 1.0;
    loop_ = false;
    audioTrackList;
    videoTrackList;
    // @TODO add a list of pending text tracks
    textTrackList;
    trackListEventHandler;
    surfaceHandle;
    captionViewHandle;
    static playerSessionClient = null;
    static isPlayerSessionEnabled = true;
    captioning_ = false;
    seekIntervalInSec_ = PlayerSessionClientTypes_1.DEFAULT_SEEK_SECONDS;
    mSessionId = { id: 0 };
    mediaControlHandler = null;
    mediaControlServer;
    mediaControlStateUtil = null;
    //static  isKMCEnabled: boolean = false;
    static isAppManifestParsed = false;
    static mediaSessionID_ = 0;
    /**
     * @TODO Create a TextTrackManager and TextTrackRenderer.
     */
    newlyIntroducedCues;
    tmoa = null;
    /**
     * https://www.w3.org/TR/encrypted-media/#htmlmediaelement-extensions
     */
    attachingMediaKeys_ = false;
    decryptionBlockedOnKey_ = false;
    playbackBlockedOnKey_ = false;
    nodeName_;
    MEDIA_EVENT_SOURCE_HTMLMEDIAELEMENT;
    MEDIA_EVENT_SOURCE_AUDIO_TRACKLIST;
    MEDIA_EVENT_SOURCE_VIDEO_TRACKLIST;
    MEDIA_EVENT_SOURCE_TEXT_TRACKLIST;
    mediaKeys;
    audioType_;
    audioUsage_;
    constructor(nodeName, audioType, audioUsage) {
        super();
        LogUtils_1.LogUtil.info(`MediaPlayer:+constructor: audioType = ${this.audioType_}, audioUsage = ${this.audioUsage_}, w3cmediaVersion = ${version_1.W3CMEDIA_VERSION}`);
        // Initialize logging system
        (0, LogLevelInitializer_1.initializeLogging)();
        // Refer : https://shepherd.a2z.com/issues/d1e58029-de66-4a87-986e-25b9fee68079
        if (audioType === undefined || (!(Object.values(MediaTypes_1.AudioContentType).includes(audioType)))) {
            // default
            this.audioType_ = (nodeName === "audio" ? MediaTypes_1.AudioContentType.CONTENT_TYPE_MUSIC : MediaTypes_1.AudioContentType.CONTENT_TYPE_MOVIE);
        }
        else {
            this.audioType_ = audioType;
        }
        if (audioUsage === undefined || (!(Object.values(MediaTypes_1.AudioUsageType).includes(audioUsage)))) {
            this.audioUsage_ = MediaTypes_1.AudioUsageType.USAGE_MEDIA; // default
        }
        else {
            this.audioUsage_ = audioUsage;
        }
        this.surfaceHandle = null;
        this.captionViewHandle = null;
        this.mediaElement = null;
        this.mediaElementEventRouter = null;
        this.eventEmitter = new MediaEventEmitterImpl_1.MediaEventEmitterImpl();
        this.nodeName_ = nodeName;
        this.src_ = "";
        this.audioTrackList = new AudioTrackListImpl_1.AudioTrackListImpl();
        this.videoTrackList = new VideoTrackListImpl_1.VideoTrackListImpl();
        this.textTrackList = new TextTrackListImpl_1.TextTrackListImpl();
        const mediaEventSource = W3CMediaTurboModule_1.default.getMediaEventSource();
        this.MEDIA_EVENT_SOURCE_AUDIO_TRACKLIST = mediaEventSource.AUDIO_TRACKLIST;
        this.MEDIA_EVENT_SOURCE_HTMLMEDIAELEMENT = mediaEventSource.HTMLMEDIAELEMENT;
        this.MEDIA_EVENT_SOURCE_VIDEO_TRACKLIST = mediaEventSource.VIDEO_TRACKLIST;
        this.MEDIA_EVENT_SOURCE_TEXT_TRACKLIST = mediaEventSource.TEXT_TRACKLIST;
        this.trackListEventHandler = new TrackListEventHandler_1.TrackListEventHandler();
        this.newlyIntroducedCues = new Set();
        // assign the session ID to mediaControlSessionID
        this.mSessionId.id = MediaPlayer.mediaSessionID_;
        // create MediaControlStateUtils by default
        this.mediaControlStateUtil = new MediaControlStateUtil_1.MediaControlStateUtil(this);
        //mediaControlSessionMapTable.set(this.mSessionId.id, mediaControlStateUtil);
        // increase the session ID associated with MP instance
        MediaPlayer.mediaSessionID_++;
        LogUtils_1.LogUtil.info(`MediaPlayer:-constructor`);
    }
    /**
     * @hidden
     * Configure the App client componentinstance which is using MediaPlayer.
     */
    async setMediaControlFocus(componentInstance, mediaControlHandler) {
        LogUtils_1.LogUtil.info(`MediaPlayer: componentInstance:  = ${componentInstance.name}, type = ${componentInstance.type} id = ${componentInstance.id}`);
        // check if manifest is parsed either by init() or need to parse
        let isPackageParsed = await parseClientPackageManifest();
        /*
         * Set the component instance to enable Kepler Media Controls by default to handle pause,
         * play and seek commands. If component instance is not set, app is expected to handle Kepler
         * Media Controls.
         * For further details please see
         * https://developer.amazon.com/docs/kepler-tv/media-controls-guide.html
        */
        /* validate the component instance configured by App client with parsed manifest components.
         *
         * 1. If KMC category not found during manifest parsing.
         *    i.  legacy mode i.e PlayerSession based media control will be enabled via W3cMedia.
         * 2. If componentInstance is configured by AppClient and KMC category found in parsing
         *   i.   default mode i.e KMC interface will be enabled via W3cMedia.
         *   ii.  Basic media controls (play/pause/seek/playbackspeed/startover) will provided by W3cMedia.
         *   iii. Server state / capabilities etc.. will be updated by W3cMedia.
         *   iii. W3cMedia will provide an option to override the mediacontrolhandler and let AppClient
         *        choose to implement override APIs (handleplay/handlepasue etc).
         *   iv.  App clients choose to override mediacontrolhandler are considered to be semi-advance mode :).
         * 3. If componentInstance is not configured and KMC category is present in manifest,
         *   i. This is considered as Advanced Mode of MediaControls where App Client has to handle
         *      all KMC features by itself. W3cMedia will have no role to handle any media control commands
        */
        // validate the componentinstance and type
        if (isPackageParsed && componentInstance.type === ComponentInstanceManager_1.ComponentType.INTERACTIVE) {
            if (MediaControlSessionMapTab_1.appClientKMCMapTable.get(componentInstance.name) === true) {
                // Check if Client has opt-in for media control or opt-out
                if (mediaControlHandler === undefined || mediaControlHandler === null) {
                    LogUtils_1.LogUtil.info("MediaPlayer:  App client opted for default mediacontrols.");
                    this.mediaControlHandler = new KeplerMediaControlHandler_1.KeplerMediaControlHandler();
                }
                else {
                    this.mediaControlHandler = mediaControlHandler;
                    LogUtils_1.LogUtil.info("MediaPlayer: App client may override mediacontrols.");
                }
                // get KMC server
                this.mediaControlServer = kepler_media_controls_1.MediaControlServerComponentAsync.getOrMakeServer();
                // configure the KMC event callback handler
                this.mediaControlServer.setHandlerForComponent(this.mediaControlHandler, componentInstance);
                // configure the controlserver.
                this.mediaControlStateUtil?.setMediaControlServer(this.mediaControlServer);
                // configure the mediaplayer to handler.
                this.mediaControlHandler?.setMediaPlayer(this);
                LogUtils_1.LogUtil.info("MediaPlayer: Initializing MediaControlHandler done.");
            }
            else {
                LogUtils_1.LogUtil.warn("MediaPlayer: KMC interface not build as component does not declared KMC category in manifest");
            }
        }
        else {
            LogUtils_1.LogUtil.warn("MediaPlayer: KMC interface not build as component is non-interactive");
        }
        Promise.resolve();
    }
    /**
     * @hidden
     */
    async initialize() {
        LogUtils_1.LogUtil.info(`MediaPlayer: initialize: audioType = ${this.audioType_}, audioUsage = ${this.audioUsage_}`);
        // check if manifest is parsed either by setupMediaControlComponentInstance() or need to parse
        let isPackageParsed = await parseClientPackageManifest();
        return new Promise((resolve, reject) => {
            if (this.mediaElement) {
                LogUtils_1.LogUtil.info("MediaPlayer: Media Element already created..skipping");
                resolve();
                return;
            }
            // check if KMC category is enabled in Manifest , if not create legacy mode (playersessionclient)
            if (isPackageParsed) {
                for (const clientKMCComponent of MediaControlSessionMapTab_1.appClientKMCMapTable.values()) {
                    if (clientKMCComponent === true) {
                        MediaPlayer.isPlayerSessionEnabled = false;
                        break;
                    }
                }
            }
            else {
                LogUtils_1.LogUtil.warn("MediaPlayer: Package parsing was not done");
            }
            // Init the playerSessionClient in case of legacy mediacontrols
            if (MediaPlayer.isPlayerSessionEnabled === true && MediaPlayer.playerSessionClient === null) {
                MediaPlayer.playerSessionClient = new PlayerSessionClient_1.PlayerSessionClient();
                MediaPlayer.playerSessionClient?.initialize();
                LogUtils_1.LogUtil.info("MediaPlayer: Initializing PlayerSessionClient done.");
            }
            const config = W3CMediaTurboModule_1.default.newMediaElementConfig();
            W3CMediaTurboModule_1.default.setWaitForAudioToCompleteSeek(config, false);
            W3CMediaTurboModule_1.default.setAudioConfig(config, this.audioType_, this.audioUsage_);
            W3CMediaTurboModule_1.default.newMediaElement(config, (nativeMediaElement) => {
                LogUtils_1.LogUtil.info("MediaPlayer: Native Media Element Created");
                const eventRouter_ = new MediaElementEventRouter_1.MediaElementEventRouter(nativeMediaElement);
                eventRouter_.registerHTMLMediaElement(this);
                this.mediaElement = nativeMediaElement;
                this.mediaElementEventRouter = eventRouter_;
                // see if legacy mode is enabled
                if (MediaPlayer.isPlayerSessionEnabled) {
                    MediaPlayer.playerSessionClient?.setMediaPlayer(this);
                    MediaPlayer.playerSessionClient?.setDefaultSeekIntervalInSec(this.seekIntervalInSec_);
                    // clear the KMC Map table as legacy mode is enabled
                    // @TODO Do we need to free MediaControlStateUtil? let garbage collector do the job.
                    // just settle with clearing the map table.
                    MediaControlSessionMapTab_1.mediaControlSessionMapTable.clear();
                    MediaControlSessionMapTab_1.appClientKMCMapTable.clear();
                }
                if (this.surfaceHandle !== undefined && this.surfaceHandle !== null) {
                    LogUtils_1.LogUtil.debug("MediaPlayer: setSurface.");
                    W3CMediaTurboModule_1.default.setSurface(this.mediaElement, this.surfaceHandle);
                }
                if (this.captionViewHandle !== undefined && this.captionViewHandle !== null) {
                    LogUtils_1.LogUtil.debug("MediaPlayer: setCaptionConsumer.");
                    W3CMediaTurboModule_1.default.setCaptionConsumer(this.mediaElement, this.captionViewHandle);
                }
                // set the audio stream mute/unmute
                if (this.defaultMuted_ || this.muted_) {
                    LogUtils_1.LogUtil.debug("MediaPlayer: muteAudio");
                    W3CMediaTurboModule_1.default.muteAudio(this.mediaElement);
                }
                // set the stream volume if not 1.0
                if (this.volume_ !== 1.0) {
                    LogUtils_1.LogUtil.debug("MediaPlayer: setVolumeLevel");
                    W3CMediaTurboModule_1.default.setVolumeLevel(this.mediaElement, this.volume_);
                }
                // set playback rate if not 1.0
                if (this.playbackRate_ !== 1.0) {
                    LogUtils_1.LogUtil.debug("MediaPlayer: playbackRate_:setPlaybackRate");
                    W3CMediaTurboModule_1.default.setPlaybackRate(this.mediaElement, this.playbackRate_);
                }
                else if (this.defaultPlaybackRate_ !== 1.0) {
                    LogUtils_1.LogUtil.debug("MediaPlayer: defaultPlaybackRate_:setPlaybackRate");
                    W3CMediaTurboModule_1.default.setPlaybackRate(this.mediaElement, this.defaultPlaybackRate_);
                }
                LogUtils_1.LogUtil.info("MediaPlayer: Native Media Element Resolve now..");
                resolve();
            });
        });
    }
    /**
     * @hidden
     */
    deinitialize() {
        LogUtils_1.LogUtil.info("MediaPlayer: deinitialize");
        this.mediaElementEventRouter?.deregisterMediaElement();
        if (MediaPlayer.isPlayerSessionEnabled) {
            MediaPlayer.playerSessionClient?.clearMediaPlayer(this);
        }
        else if (this.mediaControlHandler) {
            this.mediaControlStateUtil?.clearMediaPlayer(this);
        }
        return new Promise((resolve, reject) => {
            if (this.mediaElement) {
                LogUtils_1.LogUtil.info("MediaPlayer: destroying media element asynchronously");
                W3CMediaTurboModule_1.default.destroy(this.mediaElement, () => {
                    LogUtils_1.LogUtil.info("MediaPlayer: MediaElement destroyed");
                    this.mediaElement = null;
                    resolve();
                });
                return;
            }
            reject();
        });
    }
    /**
     * @hidden
     */
    deinitializeSync(timeoutInMs) {
        LogUtils_1.LogUtil.info("MediaPlayer: ++ deinitializeSync");
        this.mediaElementEventRouter?.deregisterMediaElement();
        if (MediaPlayer.isPlayerSessionEnabled) {
            MediaPlayer.playerSessionClient?.clearMediaPlayer(this);
        }
        else if (this.mediaControlHandler) {
            this.mediaControlStateUtil?.clearMediaPlayer(this);
        }
        if (this.mediaElement) {
            const status = W3CMediaTurboModule_1.default.destroySync(this.mediaElement, timeoutInMs);
            this.mediaElement = null;
            LogUtils_1.LogUtil.info("MediaPlayer: -- deinitializeSync");
            return status;
        }
        LogUtils_1.LogUtil.warn("MediaPlayer: not a valid MediaElement to deinit");
        return "invalid";
    }
    // EventTarget APIs
    /**
     * @hidden
     * Adds a event listener
     */
    addEventListener(type, listener, options) {
        LogUtils_1.LogUtil.info(`MediaPlayer:addEventListener: ${type}`);
        this.eventEmitter?.addEventListener(type, listener);
    }
    /**
     * @hidden
     * Removes event listener
     */
    removeEventListener(type, listener, options) {
        LogUtils_1.LogUtil.info(`MediaPlayer:removeEventListener: ${type}`);
        this.eventEmitter?.removeEventListener(type, listener);
    }
    /**
     * @hidden
     */
    get nodeName() {
        return this.nodeName_;
    }
    /**
     * @hidden
     */
    set src(url) {
        LogUtils_1.LogUtil.info(`Src URL`);
        const blobUrlPrefix = "blob:///";
        const isBlob = url.startsWith(blobUrlPrefix);
        if (isBlob) {
            // most likely mse
            // extract the index from url blob:///xxxx?offset=0&size=0
            const endIndex = url.indexOf('?');
            const mediaSourceId = url.slice(blobUrlPrefix.length, endIndex);
            LogUtils_1.LogUtil.debug(`MediaPlayer: mediaSourceId = ${mediaSourceId}`);
            const mediaSourceIdKey = parseInt(mediaSourceId, 10);
            const ms = MediaSource_1.GlobalMediaSources.get(mediaSourceIdKey);
            if (ms === null || ms === undefined) {
                LogUtils_1.LogUtil.error('invalid media source!!!');
                return;
            }
            // now trigger the setter on srcObject
            this.srcObject = ms;
            // Now we should remove the entry from the global map, oherwise,
            // the MediaSource instance will never get reclaimed by JS VM's Garbage Collector
            // when all other references are removed.
            MediaSource_1.GlobalMediaSources.delete(mediaSourceIdKey);
        }
        else {
            this.src_ = url;
            if (!this.mediaElement) {
                LogUtils_1.LogUtil.warn("MediaPlayer: media element not found...skipping set src");
                return;
            }
            // we assume that autoPlay is set before src
            W3CMediaTurboModule_1.default.setSrc(this.mediaElement, url, this.autoplay_);
        }
        this.decryptionBlockedOnKey_ = false;
        this.playbackBlockedOnKey_ = false;
    }
    /**
     * @hidden
     */
    set defaultSeekIntervalInSec(seekInterval) {
        LogUtils_1.LogUtil.debug(`MediaPlayer: defaultSeekIntervalInSec: ${seekInterval}`);
        if (seekInterval && Number.isInteger(seekInterval) && seekInterval > 0) {
            this.seekIntervalInSec_ = seekInterval;
            if (MediaPlayer.isPlayerSessionEnabled) {
                MediaPlayer.playerSessionClient?.setDefaultSeekIntervalInSec(this.seekIntervalInSec_);
            }
            else if (this.mediaControlHandler) {
                this.mediaControlStateUtil?.setDefaultSeekIntervalInSec(this.seekIntervalInSec_);
            }
        }
    }
    /**
     * @hidden
     */
    get defaultSeekIntervalInSec() {
        LogUtils_1.LogUtil.debug(`MediaPlayer: defaultSeekIntervalInSec: ${this.seekIntervalInSec_}`);
        return this.seekIntervalInSec_;
    }
    /**
     * @hidden
     */
    get src() {
        return this.src_;
    }
    /**
     * @hidden
     */
    set srcObject(srcObj) {
        LogUtils_1.LogUtil.info('MediaPlayer: setting srcObject');
        srcObj.setMediaEventRouter(this.mediaElementEventRouter);
        srcObj.setMediaElementHandle(this.mediaElement);
    }
    /**
     * @hidden
     */
    get error() {
        if (!this.mediaElement) {
            return null;
        }
        const err = W3CMediaTurboModule_1.default.getError(this.mediaElement);
        if (err.type === 0) {
            return null;
        }
        return new MediaErrorImpl_1.MediaErrorImpl(err.type, err.error_message);
    }
    /**
     * @hidden
     */
    get currentSrc() {
        return this.src_;
    }
    /**
     * @hidden
     */
    get networkState() {
        // TODO: Not supported by NFP
        return 0;
    }
    /**
     * @hidden
     */
    get buffered() {
        if (!this.mediaElement) {
            return new TimeRangesImpl_1.TimeRangesImpl(null);
        }
        return new TimeRangesImpl_1.TimeRangesImpl(W3CMediaTurboModule_1.default.getBuffered(this.mediaElement));
    }
    /**
     * @hidden
     */
    load() {
        LogUtils_1.LogUtil.info(`MediaPlayer: load`);
        if (!this.mediaElement || !this.src_) {
            LogUtils_1.LogUtil.warn("not loading as media element not ready or src_ is not set");
            return;
        }
        W3CMediaTurboModule_1.default.load(this.mediaElement);
        this.decryptionBlockedOnKey_ = false;
        this.playbackBlockedOnKey_ = false;
    }
    /**
     *@hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-navigator-canplaytype
     * @param type mime type
     */
    canPlayType(type) {
        return W3CMediaTurboModule_1.default.canPlayType(this.mediaElement, type);
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-readystate
     */
    get readyState() {
        if (!this.mediaElement) {
            return 0;
        }
        return W3CMediaTurboModule_1.default.getReadyState(this.mediaElement);
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-seeking
     */
    get seeking() {
        if (!this.mediaElement) {
            return false;
        }
        return W3CMediaTurboModule_1.default.getSeeking(this.mediaElement);
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-fastseek
     */
    fastSeek(time) {
        if (!this.mediaElement) {
            return;
        }
        W3CMediaTurboModule_1.default.seek(this.mediaElement, time);
        this.decryptionBlockedOnKey_ = false;
        this.playbackBlockedOnKey_ = false;
    }
    /**
     * @hidden
     *  https://html.spec.whatwg.org/multipage/media.html#dom-media-duration
     */
    get duration() {
        if (!this.mediaElement) {
            return NaN;
        }
        return W3CMediaTurboModule_1.default.getDuration(this.mediaElement);
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-getstartdate
     */
    getStartDate() {
        // TODO: NFP doesn't support this yet.
        return new Date();
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-paused
     */
    get paused() {
        if (!this.mediaElement) {
            return true;
        }
        return W3CMediaTurboModule_1.default.getPaused(this.mediaElement);
    }
    /**
     * @hidden
     *
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-played
     */
    get played() {
        // TODO: NFP doesn't support this
        return new TimeRangesImpl_1.TimeRangesImpl(null);
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-seekable
     */
    get seekable() {
        if (!this.mediaElement) {
            return new TimeRangesImpl_1.TimeRangesImpl(null);
        }
        return new TimeRangesImpl_1.TimeRangesImpl(W3CMediaTurboModule_1.default.getSeekable(this.mediaElement));
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-ended
     */
    get ended() {
        if (!this.mediaElement) {
            return false;
        }
        return W3CMediaTurboModule_1.default.getEnded(this.mediaElement);
    }
    /**
     * @hidden
     *  https://html.spec.whatwg.org/multipage/media.html#dom-media-play
     */
    play() {
        LogUtils_1.LogUtil.info("MediaPlayer: play");
        return new Promise((resolve, reject) => {
            if (this.mediaElement) {
                W3CMediaTurboModule_1.default.play(this.mediaElement);
                LogUtils_1.LogUtil.info("MediaPlayer:play resolved");
                resolve();
            }
            reject();
        });
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-pause
     */
    pause() {
        LogUtils_1.LogUtil.info("MediaPlayer: pause");
        if (this.mediaElement) {
            W3CMediaTurboModule_1.default.pause(this.mediaElement);
        }
    }
    /**
     * @hidden
    * https://html.spec.whatwg.org/multipage/media.html#dom-media-audiotracks
    */
    get audioTracks() {
        return this.audioTrackList;
    }
    /**
     * @hidden
    *  https://html.spec.whatwg.org/multipage/media.html#dom-media-videotracks
    */
    get videoTracks() {
        return this.videoTrackList;
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-texttracks
     */
    get textTracks() {
        return this.textTrackList;
    }
    /**
     * @hidden
     * @brief https://html.spec.whatwg.org/multipage/media.html#dom-media-addtexttrack
     * @param kind The kind attribute must return the text track kind of the text track that the TextTrack object represents.
     * @param label The label attribute must return the text track label of the text track that the TextTrack object represents.
     * @param language The language attribute must return the text track language of the text track that the TextTrack object represents.
     * @param uri The uri attribute must return the uri of the out of band subtitle of the text track that the TextTrack object represents.
     * This is a custom addition (not as per w3c spec). If uri is provided, this component will take care of parsing and rendering subtitles.
     * @param mimeType The mimeType attribute must return the mime type of the out of band subtitle of the text track that the TextTrack
     * object represents. This is a custom addition (not as per w3c spec).
     */
    addTextTrack(kind, label, language, uri, mimeType) {
        LogUtils_1.LogUtil.debug(`MediaPlayer:+addtexttrack ${kind} ${label} ${language} ${uri} ${mimeType}`);
        if (kind && (kind != 'subtitles') && (kind != 'captions') && (kind != 'metadata')) {
            LogUtils_1.LogUtil.warn('Only `subtitles` or `captions` or `metadata` kind of TextTracks are supported');
            return null;
        }
        const track = new TextTrackImpl_1.TextTrackImpl(this, this.mediaElement, null, kind, label ?? "", language ?? "", uri ?? "", mimeType ?? "");
        this.textTrackList.addTrack(track);
        if ((!this.tmoa) && (track.id.startsWith(TextTrackImpl_1.TextTrackImpl.JS_TRACK_ID_PREFIX))) {
            this.tmoa = new TimeMarchesOnAlgo_1.TimeMarchesOnAlgo();
        }
        LogUtils_1.LogUtil.debug(`MediaPlayer:-addtexttrack num of tracks ${this.textTrackList.length}`);
        return track;
    }
    /**
     * TextTrackManager Should take care of these
     * @param cue
     */
    addCue(cue) {
        this.newlyIntroducedCues.add(cue);
        LogUtils_1.LogUtil.debug(`MediaPlayer:addCue ${cue.id} and runTMOAAlgo`);
        this.triggerTMOAIfNeeded(cue);
    }
    removeCue(cue) {
        if (!this.newlyIntroducedCues.delete(cue)) {
            let wasCueActive = cue.isActive;
            this.tmoa?.removeCue(cue);
            if (wasCueActive) {
                // It is an actively rendered cue. Run TMO Algo immediately.
                this.runTMOAlgo();
            }
        }
        LogUtils_1.LogUtil.debug(`MediaPlayer:removeCue ${cue.id} and runTMOAAlgo`);
        this.triggerTMOAIfNeeded(cue);
    }
    triggerTMOAIfNeeded(cue) {
        let refPos = 0;
        refPos = this.tmoa?.getLastRunPosition();
        // @TODO query it dynamically from the MediaElement
        const margin = 0.25;
        if (((cue.startTime >= refPos) && (cue.startTime < (refPos + margin))) ||
            ((cue.endTime >= refPos) && (cue.endTime < (refPos + margin)))) {
            this.runTMOAlgo();
        }
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#attr-media-preload
     */
    get preload() {
        return this.preload_;
    }
    /**
     * @hidden
     */
    set preload(preload) {
        LogUtils_1.LogUtil.info(`MediaPlayer: setter preload ${preload}`);
        this.preload_ = preload;
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-currenttime
     */
    get currentTime() {
        if (this.mediaElement === null) {
            return NaN;
        }
        const pos = W3CMediaTurboModule_1.default.getCurrentTime(this.mediaElement);
        return pos;
    }
    /**
     * @hidden
     */
    set currentTime(time) {
        LogUtils_1.LogUtil.debug(`MediaPlayer: set currentTime ${time}`);
        W3CMediaTurboModule_1.default.seek(this.mediaElement, time);
        this.decryptionBlockedOnKey_ = false;
        this.playbackBlockedOnKey_ = false;
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-defaultplaybackrate
     */
    get defaultPlaybackRate() {
        return this.defaultPlaybackRate_;
    }
    /**
     * @hidden
     */
    set defaultPlaybackRate(rate) {
        LogUtils_1.LogUtil.debug(`MediaPlayer: set defaultPlaybackRate ${rate}`);
        this.defaultPlaybackRate_ = rate;
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-playbackrate
     */
    get playbackRate() {
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.warn("MediaPlayer: MediaElement is not available...default returns");
            return this.defaultPlaybackRate_;
        }
        this.playbackRate_ = W3CMediaTurboModule_1.default.getPlaybackRate(this.mediaElement);
        return this.playbackRate_;
    }
    /**
     * @hidden
     */
    set playbackRate(rate) {
        LogUtils_1.LogUtil.debug(`MediaPlayer: set playbackRate ${rate}`);
        this.playbackRate_ = rate;
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.warn("MediaPlayer: MediaElement is not available, cache the playbackrate value for now");
            return;
        }
        W3CMediaTurboModule_1.default.setPlaybackRate(this.mediaElement, rate);
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-preservespitch
     * @note Not implemented
     */
    preservesPitch;
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-autoplay
     */
    get autoplay() {
        return this.autoplay_;
    }
    /**
     * @hidden
     */
    set autoplay(autoplay) {
        LogUtils_1.LogUtil.info(`MediaPlayer: set autoplay ${autoplay}`);
        this.autoplay_ = autoplay;
        if (this.autoplay_) {
            this.play();
        }
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-loop
     */
    get loop() {
        return this.loop_;
    }
    /**
     * @hidden
     */
    set loop(loop) {
        LogUtils_1.LogUtil.info(`MediaPlayer: set loop ${loop}`);
        this.loop_ = loop;
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-volume
     */
    get volume() {
        LogUtils_1.LogUtil.info(`MediaPlayer: get volume`);
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.warn("MediaPlayer: MediaElement is not available...default returns");
            return this.volume_;
        }
        this.volume_ = W3CMediaTurboModule_1.default.getVolumeLevel(this.mediaElement);
        return this.volume_;
    }
    /**
     * @hidden
     */
    set volume(volume) {
        LogUtils_1.LogUtil.info(`MediaPlayer: set volume ${volume}`);
        this.volume_ = volume;
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.warn("MediaPlayer: MediaElement is not available, cache the volume value for now");
            return;
        }
        W3CMediaTurboModule_1.default.setVolumeLevel(this.mediaElement, volume);
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-muted
     */
    get muted() {
        LogUtils_1.LogUtil.info(`MediaPlayer: get muted`);
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.warn("MediaPlayer: media element not found...default returns");
            return this.defaultMuted_;
        }
        this.muted_ = W3CMediaTurboModule_1.default.isAudioMuted(this.mediaElement);
        return this.muted_;
    }
    /**
     * @hidden
     */
    set muted(muted) {
        LogUtils_1.LogUtil.info(`MediaPlayer: set muted ${muted}`);
        this.muted_ = muted;
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.warn("MediaPlayer: MediaElement is not available, cache the mute value for now");
            return;
        }
        if (muted) {
            W3CMediaTurboModule_1.default.muteAudio(this.mediaElement);
        }
        else {
            W3CMediaTurboModule_1.default.unMuteAudio(this.mediaElement);
        }
    }
    /**
     * @hidden
     * https://html.spec.whatwg.org/multipage/media.html#dom-media-defaultmuted
     */
    get defaultMuted() {
        return this.defaultMuted_;
    }
    /**
     * @hidden
     */
    set defaultMuted(defaultMuted) {
        LogUtils_1.LogUtil.info(`MediaPlayer: set defaultMuted ${defaultMuted}`);
        this.defaultMuted_ = defaultMuted;
    }
    /**
     * @hidden
     */
    setMediaKeys(mediaKeys) {
        LogUtils_1.LogUtil.info(`MediaPlayer: setMediaKeys`, mediaKeys ? mediaKeys : null);
        return new Promise((resolve, reject) => {
            if (!this.mediaElement) {
                LogUtils_1.LogUtil.error(`MediaPlayer: Invalid State. Media Element not inittialized`);
                reject();
            }
            if (mediaKeys) {
                this.mediaKeys = mediaKeys;
                const tmp = mediaKeys;
                const nmk = tmp.getnmk();
                if (nmk !== null) {
                    W3CMediaTurboModule_1.default.setMediaKeys(this.mediaElement, nmk);
                }
            }
            resolve();
        });
    }
    /**
     * @hidden
     * Handle all media element and audio/video track list events.
     */
    handleEvent(event) {
        // validate the event sent from native
        if (event) {
            LogUtils_1.LogUtil.debug(`MediaPlayer: handleEvent src = ${event.src}, event = ${event.name}`);
            switch (event.src) {
                case this.MEDIA_EVENT_SOURCE_AUDIO_TRACKLIST:
                    {
                        this.trackListEventHandler.handleAudioTrackListEvent(event, this.audioTrackList, this.mediaElement);
                    }
                    break;
                case this.MEDIA_EVENT_SOURCE_VIDEO_TRACKLIST:
                    {
                        this.trackListEventHandler.handleVideoTrackListEvent(event, this.videoTrackList, this.mediaElement);
                    }
                    break;
                case this.MEDIA_EVENT_SOURCE_TEXT_TRACKLIST:
                    {
                        this.trackListEventHandler.handleTextTrackListEvent(event, this.textTrackList, this.mediaElement);
                    }
                    break;
                default:
                    {
                        LogUtils_1.LogUtil.debug(`MediaPlayer:handleEvent: emit event ${event.name}`);
                        if ((event.name === 'play') || (event.name === 'timeupdate')) {
                            /**
                             * Relying on native side events, for hooking into the sequences being run on the native side.
                             * This is not the ideal place, as the algo should run before firing this event
                             * It is already late, so let us run TMOA first.
                             * Moreover, we should take the startTime of the next cue and then schedule it.
                             * */
                            this.runTMOAlgo();
                        }
                        if (event.name === 'encrypted') {
                            const typedInit = ArrayBuffer.isView(event.buffer)
                                ? new Uint8Array(event.buffer.buffer, event.buffer.byteOffset, event.buffer.byteLength)
                                : new Uint8Array(event.buffer);
                            const base64Init = base64js.fromByteArray(typedInit);
                            LogUtils_1.LogUtil.debug(`MediaPlayer:handleEvent: Player initType ${event.init_type} initData = ${base64Init}`);
                            this.eventEmitter.emit(event.name, new EventTargetInterface_1.MediaEncryptedEvent(event.name, this, event.init_type, event.buffer));
                        }
                        else if (event.name === 'ended' && this.loop_ === true) {
                            LogUtils_1.LogUtil.debug(`MediaPlayer:handleEvent: looping`);
                            this.play();
                        }
                        else {
                            this.eventEmitter.emit(event.name, new EventTargetInterface_1.Event(event.name, this));
                        }
                    }
                    break;
            }
        }
        else {
            LogUtils_1.LogUtil.error(`MediaPlayer: handleEvent invalid event passed to JS `);
        }
    }
    /**
     * @brief Sets the captions view handle to the player.
     * @param[in] captionViewHandle Handle to the captions view.
     */
    setCaptionViewHandle(captionViewHandle) {
        LogUtils_1.LogUtil.info(`MediaPlayer:setCaptionViewHandle ${captionViewHandle}`);
        if (captionViewHandle !== null && captionViewHandle.length > 0) {
            this.captionViewHandle = captionViewHandle;
            if (this.mediaElement) {
                W3CMediaTurboModule_1.default.setCaptionConsumer(this.mediaElement, captionViewHandle);
            }
            else {
                LogUtils_1.LogUtil.warn("MediaPlayer: media element not found...skipping set caption for now");
            }
        }
        else {
            LogUtils_1.LogUtil.error(`MediaPlayer: invalid caption surface passed to setCaptionViewHandle`);
        }
    }
    ;
    /**
     * @brief Clears the captions view handle to the player.
     * @param[in] captionViewHandle Handle to the captions view.
     */
    clearCaptionViewHandle(captionViewHandle) {
        LogUtils_1.LogUtil.info(`MediaPlayer:clearCaptionViewHandle ${captionViewHandle}`);
        if (this.captionViewHandle !== null && captionViewHandle === this.captionViewHandle) {
            if (this.mediaElement) {
                W3CMediaTurboModule_1.default.clearCaptionConsumer(this.mediaElement, captionViewHandle);
            }
            else {
                LogUtils_1.LogUtil.warn("MediaPlayer: media element not found...skipping reset caption");
            }
            // reset to null.
            this.captionViewHandle = null;
        }
    }
    ;
    /**
     * @hidden
     */
    get captioning() {
        return this.captioning_;
    }
    /**
     * @hidden
     */
    set captioning(captioning) {
        LogUtils_1.LogUtil.info(`MediaPlayer: set captioning ${captioning}`);
        this.captioning_ = captioning;
        this.eventEmitter.emit("captioningchange", new EventTargetInterface_1.Event("captioningchange", this));
    }
    runTMOAlgo() {
        if (!this.captionViewHandle) {
            LogUtils_1.LogUtil.debug(`runTMOAlgo: No captions consumer set, so skip this run`);
            return;
        }
        this.tmoa?.run(this.captionViewHandle, this.currentTime, this.newlyIntroducedCues);
    }
}
exports.MediaPlayer = MediaPlayer;

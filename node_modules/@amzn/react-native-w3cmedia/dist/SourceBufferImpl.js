"use strict";
/*
 * Copyright 2022-2023 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceBufferImpl = void 0;
const LogUtils_1 = require("./LogUtils");
const AudioTrackListImpl_1 = require("./AudioTrackListImpl");
const EventTargetInterface_1 = require("./interface/EventTargetInterface");
const MediaSourceInterface_1 = require("./interface/MediaSourceInterface");
const MediaEventEmitterImpl_1 = require("./MediaEventEmitterImpl");
const TextTrackListImpl_1 = require("./TextTrackListImpl");
const TimeRangesImpl_1 = require("./TimeRangesImpl");
const TrackListEventHandler_1 = require("./TrackListEventHandler");
const W3CMediaTurboModule_1 = __importDefault(require("./turbo-modules/W3CMediaTurboModule"));
const VideoTrackListImpl_1 = require("./VideoTrackListImpl");
const MediaErrorImpl_1 = require("./MediaErrorImpl");
const EventAttributes_1 = require("./EventAttributes");
const MimeTypeRegistry_1 = require("./constants/MimeTypeRegistry");
const MimeType_1 = require("./mimeparser/MimeType");
/**
 * This class implements SourceBuffer interface.
 * It uses EventEmitter to emit events
 */
class SourceBufferImpl extends EventAttributes_1.EventAttributes {
    eventEmitter;
    MEDIA_SEGMENTS;
    MEDIA_SEQUENCE;
    mediaElement;
    sourceBufferId;
    mimeType;
    audioTrackList;
    videoTrackList;
    textTrackList;
    mediaSource;
    _onupdatestart;
    _onupdate;
    _onupdateend;
    _onerror;
    _onabort;
    MEDIA_EVENT_SOURCE_AUDIO_TRACKLIST;
    MEDIA_EVENT_SOURCE_VIDEO_TRACKLIST;
    MEDIA_EVENT_SOURCE_TEXT_TRACKLIST;
    trackListEventHandler;
    constructor(mediaElement, mediaSource, sourceBufferId, type) {
        const _eventEmitter = new MediaEventEmitterImpl_1.MediaEventEmitterImpl();
        super(_eventEmitter);
        this.eventEmitter = _eventEmitter;
        this.mediaElement = mediaElement;
        if (mediaSource) {
            this.mediaSource = mediaSource;
        }
        this.sourceBufferId = sourceBufferId;
        this.mimeType = MimeType_1.MimeType.parseMimeString(type);
        this.audioTrackList = new AudioTrackListImpl_1.AudioTrackListImpl();
        this.videoTrackList = new VideoTrackListImpl_1.VideoTrackListImpl();
        this.textTrackList = new TextTrackListImpl_1.TextTrackListImpl();
        this.trackListEventHandler = new TrackListEventHandler_1.TrackListEventHandler();
        const frameProcessorAppendMode = W3CMediaTurboModule_1.default.getFrameProcessorAppendMode();
        this.MEDIA_SEGMENTS = frameProcessorAppendMode.SEGMENTS;
        this.MEDIA_SEQUENCE = frameProcessorAppendMode.SEQUENCE;
        const mediaEventSource = W3CMediaTurboModule_1.default.getMediaEventSource();
        this.MEDIA_EVENT_SOURCE_AUDIO_TRACKLIST = mediaEventSource.AUDIO_TRACKLIST;
        this.MEDIA_EVENT_SOURCE_VIDEO_TRACKLIST = mediaEventSource.VIDEO_TRACKLIST;
        this.MEDIA_EVENT_SOURCE_TEXT_TRACKLIST = mediaEventSource.TEXT_TRACKLIST;
        this.handleEvent = this.handleEvent.bind(this);
    }
    /**
     * @hidden
     * Checks whether sourcebuffer Exists or not.
     */
    sourceBufferExists() {
        for (let i = 0; i < this.mediaSource.sourceBuffers.length; i++) {
            if (this.getId() === this.mediaSource.sourceBuffers[i].getId()) {
                return true;
            }
        }
        return false;
    }
    /**
     * @hidden
     * Throw InvlaidStateError if 'updating' is true
     */
    isUpdating(errorMessage) {
        if (this.updating) {
            throw new MediaErrorImpl_1.InvalidStateError(errorMessage);
        }
    }
    // EventTarget APIs
    addEventListener(type, listener, options) {
        LogUtils_1.LogUtil.info(`SourceBuffer:addEventListener: ${type}`);
        this.eventEmitter.addListener(type, listener);
    }
    removeEventListener(type, listener, options) {
        LogUtils_1.LogUtil.info(`SourceBuffer:removeListener: ${type}`);
        this.eventEmitter.removeListener(type, listener);
    }
    // SourceBuffer APIs
    get mode() {
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: get mode - No Media Element`);
            return MediaSourceInterface_1.AppendMode.segments;
        }
        const mode_ = W3CMediaTurboModule_1.default.sourceBuffer_GetMode(this.mediaElement, this.sourceBufferId);
        return (mode_ === this.MEDIA_SEGMENTS ? MediaSourceInterface_1.AppendMode.segments : MediaSourceInterface_1.AppendMode.sequence);
    }
    set mode(mode) {
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: set mode -No Media Element`);
            return;
        }
        LogUtils_1.LogUtil.info(`SourceBuffer[${this.sourceBufferId}]:mode(${mode})`);
        W3CMediaTurboModule_1.default.sourceBuffer_SetMode(this.mediaElement, this.sourceBufferId, mode === MediaSourceInterface_1.AppendMode.segments ? this.MEDIA_SEGMENTS : this.MEDIA_SEQUENCE);
    }
    get updating() {
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: get updating - No Media Element`);
            return false;
        }
        return W3CMediaTurboModule_1.default.sourceBuffer_GetUpdating(this.mediaElement, this.sourceBufferId);
    }
    get buffered() {
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: get buffered - No Media Element`);
            return new TimeRangesImpl_1.TimeRangesImpl(null);
        }
        return new TimeRangesImpl_1.TimeRangesImpl(W3CMediaTurboModule_1.default.sourceBuffer_GetBuffered(this.mediaElement, this.sourceBufferId));
    }
    get timestampOffset() {
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: get timestampOffset - No Media Element`);
            return NaN;
        }
        return W3CMediaTurboModule_1.default.sourceBuffer_GetTimestampOffset(this.mediaElement, this.sourceBufferId);
    }
    set timestampOffset(offset) {
        var finalOffset;
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: set timestampOffset - No Media Element`);
            return;
        }
        this.isUpdating("set timestampOffset throws an exception when updating attribute is true.");
        LogUtils_1.LogUtil.debug(`SourceBuffer[${this.sourceBufferId}]:timestampOffset = ${this.timestampOffset})`);
        if (Number.isNaN(offset) || offset === undefined || offset === Number.POSITIVE_INFINITY ||
            offset === Number.NEGATIVE_INFINITY) {
            LogUtils_1.LogUtil.warn("SourceBuffer timestampOffset set to invalid value, throwing exception");
            throw new TypeError("timestampOffset");
        }
        if (offset === null) {
            LogUtils_1.LogUtil.warn("param offset is null");
            finalOffset = 0;
        }
        else if (typeof offset === "boolean") {
            LogUtils_1.LogUtil.info("param offset is boolean");
            finalOffset = (offset) ? 1 : 0;
        }
        else if (typeof offset === "string") {
            if (offset === "") {
                LogUtils_1.LogUtil.warn("param offset is empty string");
                finalOffset = 0;
            }
            else {
                finalOffset = Number(offset);
                if (Number.isNaN(finalOffset)) {
                    LogUtils_1.LogUtil.warn("param offset is invalid string");
                    throw new TypeError("timestampOffset");
                }
                LogUtils_1.LogUtil.info("param offset is valid string");
            }
        }
        else if (typeof offset === "number") {
            LogUtils_1.LogUtil.info("set finalOffset to offset");
            finalOffset = offset;
        }
        else {
            LogUtils_1.LogUtil.info("Unknown param type");
        }
        if (!this.sourceBufferExists()) {
            throw new MediaErrorImpl_1.InvalidStateError("sorucebuffer doesn't exist while setting timestampOffSet value");
        }
        LogUtils_1.LogUtil.info(`SourceBuffer[${this.sourceBufferId}]:timestampOffset(${finalOffset})`);
        W3CMediaTurboModule_1.default.sourceBuffer_SetTimestampOffset(this.mediaElement, this.sourceBufferId, finalOffset);
        if (this.mediaSource.readyState === MediaSourceInterface_1.ReadyState.ended) {
            this.mediaSource.handleEvent("sourceopen");
        }
    }
    get audioTracks() {
        return this.audioTrackList;
    }
    get videoTracks() {
        return this.videoTrackList;
    }
    get textTracks() {
        return this.textTrackList;
    }
    get appendWindowStart() {
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: get appendWindowStart - No Media Element`);
            return NaN;
        }
        return W3CMediaTurboModule_1.default.sourceBuffer_GetAppendWindowStart(this.mediaElement, this.sourceBufferId);
    }
    set appendWindowStart(wndStart) {
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: set appendWindowStart - No Media Element`);
            return;
        }
        LogUtils_1.LogUtil.info(`SourceBuffer[${this.sourceBufferId}]:appendWindowStart(${wndStart})`);
        W3CMediaTurboModule_1.default.sourceBuffer_SetAppendWindowStart(this.mediaElement, this.sourceBufferId, wndStart);
    }
    get appendWindowEnd() {
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: get appendWindowEnd - No Media Element`);
            return NaN;
        }
        return W3CMediaTurboModule_1.default.sourceBuffer_GetAppendWindowEnd(this.mediaElement, this.sourceBufferId);
    }
    set appendWindowEnd(wndEnd) {
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: set appendWindowEnd - No Media Element`);
            return;
        }
        LogUtils_1.LogUtil.info(`SourceBuffer[${this.sourceBufferId}]:appendWindowEnd(${wndEnd})`);
        W3CMediaTurboModule_1.default.sourceBuffer_SetAppendWindowEnd(this.mediaElement, this.sourceBufferId, wndEnd);
    }
    /**
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-sourcebuffer-onupdatestart
     */
    set onupdatestart(listener) {
        this.addEvent(this._onupdatestart, "updatestart", listener);
    }
    /**
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-sourcebuffer-onupdate
     */
    set onupdate(listener) {
        this.addEvent(this._onupdate, "update", listener);
    }
    /**
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-sourcebuffer-onupdateend
     */
    set onupdateend(listener) {
        this.addEvent(this._onupdateend, "updateend", listener);
    }
    /**
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-sourcebuffer-onerror
     */
    set onerror(listener) {
        this.addEvent(this._onerror, "error", listener);
    }
    /**
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-sourcebuffer-onabort
     */
    set onabort(listener) {
        this.addEvent(this._onabort, "abort", listener);
    }
    appendBuffer(data) {
        let inputBuf;
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: appendBuffer - No Media Element`);
            return;
        }
        if (data instanceof ArrayBuffer) {
            inputBuf = data;
        }
        else if (data instanceof Uint8Array) {
            inputBuf = data.buffer;
        }
        LogUtils_1.LogUtil.info(`SourceBuffer[${this.sourceBufferId}]:appendBuffer(${inputBuf.byteLength})`);
        this.isUpdating("appendBuffer() throws an exception there is a pending append.");
        if (!this.sourceBufferExists()) {
            throw new MediaErrorImpl_1.InvalidStateError("appendBuffer() throws an exception when called after removeSourceBuffer().");
        }
        const sourceBufferResultCodes = W3CMediaTurboModule_1.default.getDemuxerAddSourceBufferResult();
        const ret = W3CMediaTurboModule_1.default.sourceBuffer_Append(this.mediaElement, this.sourceBufferId, inputBuf);
        if (ret === sourceBufferResultCodes.QUOTA_EXCEEDED) {
            LogUtils_1.LogUtil.error(`SourceBuffer[${this.sourceBufferId}]:appendBuffer error(${ret})`);
            throw new MediaErrorImpl_1.QuotaExceededError("The quota has been exceeded.");
        }
        else if (ret === sourceBufferResultCodes.NOT_SUPPORTED) {
            LogUtils_1.LogUtil.error(`SourceBuffer[${this.sourceBufferId}]:appendBuffer error(${ret})`);
            throw new MediaErrorImpl_1.NotSupportedError("The operation is not supported.");
        }
        else if (sourceBufferResultCodes.OK && ret !== sourceBufferResultCodes.OK) {
            LogUtils_1.LogUtil.error(`SourceBuffer[${this.sourceBufferId}]:appendBuffer error(${ret})`);
            throw new MediaErrorImpl_1.InvalidStateError("The object is in an invalid state.");
        }
        this.mediaSource.handleEvent("sourceopen");
    }
    abort() {
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: abort - No Media Element`);
            return;
        }
        LogUtils_1.LogUtil.info(`SourceBuffer[${this.sourceBufferId}]:abort`);
        /**
         * If the readyState attribute of the parent media source is not in the "open" state
         * then throw an InvalidStateError exception and abort these steps.
         * https://www.w3.org/TR/2016/REC-media-source-20161117/#dom-sourcebuffer-abort
         */
        if (this.mediaSource.readyState !== MediaSourceInterface_1.ReadyState.open) {
            throw new MediaErrorImpl_1.InvalidStateError("SourceBuffer:abort readyState is not open");
        }
        if (!this.sourceBufferExists()) {
            throw new MediaErrorImpl_1.InvalidStateError("SourceBuffer:abort SourceBuffer doesn't exist");
        }
        W3CMediaTurboModule_1.default.sourceBuffer_Abort(this.mediaElement, this.sourceBufferId);
    }
    changeType(type) {
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: changeType - No Media Element`);
            return;
        }
        LogUtils_1.LogUtil.info(`SourceBuffer[${this.sourceBufferId}]:changeType`);
        //https://www.w3.org/TR/media-source-2/#dom-sourcebuffer-changetype
        // 1. If type is an empty string then throw a TypeError exception and abort these steps.
        if (type === null) {
            LogUtils_1.LogUtil.error(`SourceBuffer::changeType: type is null`);
            throw new MediaErrorImpl_1.NotSupportedError("changeType: 'type' is null");
        }
        if (typeof type !== "string") {
            LogUtils_1.LogUtil.error(`SourceBuffer::changeType: type is not string`);
            throw new TypeError("changeType: 'type' is not string");
        }
        if (type === "") {
            LogUtils_1.LogUtil.error(`SourceBuffer::changeType: empty type`);
            throw new TypeError("changeType: empty type");
        }
        // 2. If this object has been removed from the sourceBuffers attribute of the parent media
        //    source, then throw an InvalidStateError exception and abort these steps.
        if (!this.sourceBufferExists()) {
            throw new MediaErrorImpl_1.InvalidStateError("SourceBuffer:changeType SourceBuffer doesn't exist");
        }
        // 3. If the updating attribute equals true, then throw an InvalidStateError exception and
        //    abort these steps.
        this.isUpdating("SourceBuffer::changeType: pending append.");
        // 4. If type contains a MIME type that is not supported or contains a MIME type that is not
        //    supported with the types specified (currently or previously) of SourceBuffer objects in
        //    the sourceBuffers attribute of the parent media source, then throw a NotSupportedError
        //    exception and abort these steps.
        // check for the negative cases like changing main type from audio to video or vice versa
        // video main type can have both audio and video tracks but may need negative case handling
        let mimeType = MimeType_1.MimeType.parseMimeString(type);
        if (mimeType === null) {
            LogUtils_1.LogUtil.error("invalid mime ", type);
            throw new TypeError("changeType: 'type' is invalid");
        }
        if (mimeType.type !== "video" && mimeType.type !== "audio") {
            LogUtils_1.LogUtil.error("invalid mime ", type);
            throw new TypeError("changeType: 'type' is invalid");
        }
        if (!MimeTypeRegistry_1.MimeTypeRegistry.checkSupportedType(mimeType)) {
            LogUtils_1.LogUtil.error(`SourceBuffer::changeType: type is not supported`);
            throw new MediaErrorImpl_1.NotSupportedError("changeType: 'type' is not supported");
        }
        if (this.mimeType.type != mimeType.type) {
            LogUtils_1.LogUtil.error(`SourceBuffer::changeType: type is different from initial, video -> audio or vice versa. this.mimeType is `, this.mimeType.type, ` mimeType is `, mimeType);
            throw new TypeError("changeType: 'type' is invalid");
        }
        // if the above checks passes, don't expect any error or exception from the Native expect
        // from tryQueryInterface.
        const result = W3CMediaTurboModule_1.default.sourceBuffer_ChangeType(this.mediaElement, this.sourceBufferId, type);
        if (isNaN(result)) {
            LogUtils_1.LogUtil.error(`SourceBuffer::changeType: not supported`);
            throw new MediaErrorImpl_1.NotSupportedError("changeType: not supported");
        }
    }
    checkforValidNumber(value) {
        return !Number.isNaN(value) && typeof value === 'number';
    }
    remove(start, end) {
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: remove - No Media Element`);
            return;
        }
        if (!this.checkforValidNumber(start) || !Number.isFinite(start) ||
            !this.checkforValidNumber(end) || start >= end || start < 0 ||
            end === Number.NEGATIVE_INFINITY) {
            throw new TypeError(`'start' or 'end' is not a valid number`);
        }
        if (Number.isNaN(this.mediaSource.duration)) {
            throw new TypeError(`'duration is NAN'`);
        }
        if (start > this.mediaSource.duration) {
            throw new TypeError(`'start' is beyond the duration`);
        }
        if (!this.sourceBufferExists()) {
            throw new MediaErrorImpl_1.InvalidStateError("appendBuffer() throws an exception when called after removeSourceBuffer().");
        }
        this.isUpdating("Updating is true");
        W3CMediaTurboModule_1.default.sourceBuffer_Remove(this.mediaElement, this.sourceBufferId, start, end);
        if (this.mediaSource.readyState === MediaSourceInterface_1.ReadyState.ended) {
            this.mediaSource.handleEvent("sourceopen");
        }
    }
    // public APIs
    getId() {
        if (!this.mediaElement) {
            LogUtils_1.LogUtil.error(`SourceBuffer[${this.sourceBufferId}]: getId - No Media Element`);
            return "";
        }
        return W3CMediaTurboModule_1.default.sourceBuffer_GetId(this.mediaElement, this.sourceBufferId);
    }
    handleEvent(event) {
        // handle only valid events to avoid exception
        if (event) {
            LogUtils_1.LogUtil.info(`SourceBuffer[${this.sourceBufferId}]:handleEvent: with event: ${event.src}`);
            if (event.src === this.MEDIA_EVENT_SOURCE_VIDEO_TRACKLIST) {
                this.trackListEventHandler.handleVideoTrackListEvent(event, this.videoTrackList, this.mediaElement);
            }
            else if (event.src === this.MEDIA_EVENT_SOURCE_AUDIO_TRACKLIST) {
                this.trackListEventHandler.handleAudioTrackListEvent(event, this.audioTrackList, this.mediaElement);
            }
            else if (event.src === this.MEDIA_EVENT_SOURCE_TEXT_TRACKLIST) {
                this.trackListEventHandler.handleTextTrackListEvent(event, this.textTrackList, this.mediaElement);
            }
            else { // source buffer update** events
                this.eventEmitter.emit(event.name, new EventTargetInterface_1.Event(event.name, this));
            }
        }
        else {
            LogUtils_1.LogUtil.error(`SourceBuffer[${this.sourceBufferId}]:handleEvent: invalid event received`);
        }
    }
}
exports.SourceBufferImpl = SourceBufferImpl;

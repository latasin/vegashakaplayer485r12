"use strict";
/*
 * Copyright 2022 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceBufferListImpl = void 0;
const LogUtils_1 = require("./LogUtils");
const MediaEventEmitterImpl_1 = require("./MediaEventEmitterImpl");
const EventTargetInterface_1 = require("./interface/EventTargetInterface");
const EventAttributes_1 = require("./EventAttributes");
/**
 * Proxies to support [ ] operator on VideoTrackList
 */
const proxyHandlers = {
    get(target, key) {
        if (!(key in target)) {
            return target.sourceBuffers[key];
        }
        else {
            return Reflect.get(target, key);
        }
    }
};
/**
 * This class implements SourceBufferList and uses Proxy
 * to implement [ ] operator to access underlying soucebuffes
 * at the specified index.
 */
class SourceBufferListImpl extends EventAttributes_1.EventAttributes {
    sourceBuffers;
    eventEmitter;
    _onaddsourcebuffer;
    _onremovesourcebuffer;
    constructor() {
        const _eventEmitter = new MediaEventEmitterImpl_1.MediaEventEmitterImpl();
        super(_eventEmitter);
        this.eventEmitter = _eventEmitter;
        this.sourceBuffers = new Array();
        return new Proxy(this, proxyHandlers);
    }
    addEventListener(type, listener, options) {
        LogUtils_1.LogUtil.info(`SourceBufferListImpl:addEventListener: ${type}`);
        this.eventEmitter.addListener(type, listener);
    }
    removeEventListener(type, listener, options) {
        LogUtils_1.LogUtil.info(`SourceBufferListImpl:removeEventListener: ${type}`);
        this.eventEmitter.removeListener(type, listener);
    }
    /** SourceBufferList implemetation */
    get length() {
        if (!this.sourceBuffers) {
            return 0;
        }
        return this.sourceBuffers.length;
    }
    /**
     * @hidden
     * Handle events from native turbo module
     */
    handleEvent(eventName) {
        LogUtils_1.LogUtil.debug(`SourceBufferListImpl:handleEvent: event name ${eventName}`);
        if (eventName === "addsourcebuffer" || eventName === "removesourcebuffer") {
            this.eventEmitter.emit(eventName, new EventTargetInterface_1.Event(eventName, this));
        }
    }
    /**
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-sourcebufferlist-onaddsourcebuffer
     */
    set onaddsourcebuffer(listener) {
        this.addEvent(this._onaddsourcebuffer, "addsourcebuffer", listener);
    }
    /**
     * For additional information, see
     * https://www.w3.org/TR/media-source-2/#dom-sourcebufferlist-onremovesourcebuffer
     */
    set onremovesourcebuffer(listener) {
        this.addEvent(this._onremovesourcebuffer, "removesourcebuffer", listener);
    }
    /** public apis */
    /**
     * Gets Source buffer at index. THis needs to be called after checking
     * for array lenght by the callee
     */
    getSourceBuffer(index) {
        return this.sourceBuffers[index];
    }
    /**
     * Adds a source buffer to the list
     * @param sourceBuffer: SourceBufferImpl object that will be added to the list
     */
    addSourceBuffer(sourceBuffer) {
        LogUtils_1.LogUtil.info(`SourceBufferListImpl: addSourceBuffer id ${sourceBuffer.getId()}`);
        this.sourceBuffers.push(sourceBuffer);
        this.handleEvent("addsourcebuffer");
    }
    /**
     * Removes a source buffer from the list
     * @param id Unique id of the source buffer that needs to be removed
     */
    removeSourceBuffer(id) {
        LogUtils_1.LogUtil.info(`SourceBufferListImpl: removeTrack id ${id}`);
        // find the track
        let sourceBufferIndex = undefined;
        this.sourceBuffers.forEach((souceBuffer, index) => {
            if (souceBuffer.getId() === id) {
                sourceBufferIndex = index;
            }
        });
        // remove track if found
        if (sourceBufferIndex !== undefined) {
            this.sourceBuffers.splice(sourceBufferIndex, 1);
            this.handleEvent("removesourcebuffer");
        }
        else {
            LogUtils_1.LogUtil.warn(`source buffer id ${id} not found`);
        }
    }
    /**
     * Removes all source buffers from the list
     */
    clear() {
        LogUtils_1.LogUtil.info(`SourceBufferListImpl: clear `);
        this.sourceBuffers.splice(0, this.sourceBuffers.length);
        this.handleEvent("removesourcebuffer");
    }
}
exports.SourceBufferListImpl = SourceBufferListImpl;

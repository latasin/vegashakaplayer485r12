"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextTrackImpl = void 0;
const LogUtils_1 = require("./LogUtils");
const TextTrackCueListImpl_1 = require("./TextTrackCueListImpl");
const W3CMediaTurboModule_1 = __importDefault(require("./turbo-modules/W3CMediaTurboModule"));
const EventTargetInterface_1 = require("./interface/EventTargetInterface");
const MediaEventEmitterImpl_1 = require("./MediaEventEmitterImpl");
const VTTCue_1 = require("./VTTCue");
/**
 * @TODO We need to have separate implementations for
 * JS and native TextTracks, if we want to support both.
 * This looks messed up right now.
 */
class TextTrackImpl {
    /**
     * We support multiple instances of MediaElement.
     * Let JS TextTrack ids be unique across MediaElements as well.
     */
    static orderId = 0;
    static NATIVE_TRACK_ID_PREFIX = "NATIVE_";
    static JS_TRACK_ID_PREFIX = "JS_";
    /**
     * @TODO : Get rid of native TextTracks.
     * Try using JS implementation itself.
     * */
    textTrack;
    mediaElement;
    textTrackCueList;
    activeCueList;
    _id;
    /**
     * This is the creation order and
     * not the TrackList insertion order
     */
    _orderId;
    _kind;
    _label;
    _language;
    //@TODO implement
    _inBandMetadataTrackDispatchType;
    _mode;
    _readinessState;
    eventEmitter;
    _mediaPlayer;
    /**
     * extra added args
     */
    _uri;
    _mimeType;
    constructor(mediaPlayer, mediaElement, textTrack, kind, label, language, uri, mimeType) {
        this._mediaPlayer = mediaPlayer;
        this._inBandMetadataTrackDispatchType = "";
        this._mode = "hidden";
        this._readinessState = "loaded";
        this.mediaElement = mediaElement;
        this.textTrack = null;
        this.textTrackCueList = null;
        this.activeCueList = null;
        LogUtils_1.LogUtil.info(`TextTrackImpl::+constructor textTrack: ${textTrack} uri: ${uri} ME: ${mediaElement}`);
        if (textTrack || (uri && this.mediaElement)) {
            if (!textTrack) {
                this.textTrack = W3CMediaTurboModule_1.default.addTextTrack(this.mediaElement, kind, label ?? "", language ?? "", uri ?? "", mimeType ?? "");
            }
            else {
                this.textTrack = textTrack;
            }
            this._id = TextTrackImpl.NATIVE_TRACK_ID_PREFIX + this.textTrack?.id;
        }
        else {
            this._kind = kind;
            this._label = label;
            this._language = language || "";
            this.textTrackCueList = new TextTrackCueListImpl_1.TextTrackCueListImpl();
            this.activeCueList = new TextTrackCueListImpl_1.TextTrackCueListImpl();
            this._id = TextTrackImpl.JS_TRACK_ID_PREFIX + TextTrackImpl.orderId.toString();
        }
        this.eventEmitter = new MediaEventEmitterImpl_1.MediaEventEmitterImpl();
        this._orderId = TextTrackImpl.orderId;
        TextTrackImpl.orderId++;
        LogUtils_1.LogUtil.info(`TextTrackImpl: constructed TextTrack ${this._id}`);
    }
    get cues() {
        return this.textTrackCueList;
    }
    get activeCues() {
        this.activeCueList.removeAllCues();
        /**
         * @TODO optimize by listening to cue's enter/exit events
         * But this looks more safe, as user may be the first listener.
         */
        for (let i = 0; i < this.textTrackCueList.length; i++) {
            let cue = this.textTrackCueList[i];
            if (cue.isActive) {
                this.activeCueList.addCue(cue);
            }
        }
        return this.activeCueList;
    }
    /**
     * @param {TextTrackCue} cue
     */
    addCue(cue) {
        if (this.textTrack) {
            LogUtils_1.LogUtil.warn(`TextTrackImpl(${this._id}):addCue Supported only for Tracks added by the user`);
            return;
        }
        if (cue instanceof VTTCue_1.VTTCue) {
            cue.setTrack(this);
        }
        this.textTrackCueList.addCue(cue);
        if (this._mediaPlayer && (this._mode !== "disabled")) {
            this._mediaPlayer.addCue(cue);
        }
    }
    removeCue(cue) {
        LogUtils_1.LogUtil.debug(`TextTrackImpl: remove Cue: ${cue.id} ${cue.startTime} - ${cue.endTime} from ${this._id}`);
        this.textTrackCueList.removeCue(cue);
        this._mediaPlayer?.removeCue(cue);
    }
    get id() {
        return this._id;
    }
    get orderId() {
        return this._orderId;
    }
    // @CHECK : Do we really need to fetch these properties from the native track?
    get kind() {
        if (this.textTrack === null) {
            return this._kind;
        }
        return this.textTrack.kind;
    }
    get label() {
        if (this.textTrack === null) {
            return this._label;
        }
        return this.textTrack.label;
    }
    get language() {
        if (this.textTrack === null) {
            return this._language;
        }
        return this.textTrack.language;
    }
    /**
     * @TODO implement
     */
    get inBandMetadataTrackDispatchType() {
        LogUtils_1.LogUtil.warn(`TextTrackImpl(${this._id}): inBandMetadataTrackDispatchType not supported`);
        return this._inBandMetadataTrackDispatchType;
    }
    get mode() {
        if (this.textTrack === null) {
            return this._mode;
        }
        const textTrack = W3CMediaTurboModule_1.default.getTextTrackById(this.mediaElement, (this.id.replace(TextTrackImpl.NATIVE_TRACK_ID_PREFIX, '')));
        return textTrack?.mode;
    }
    set mode(aMode) {
        LogUtils_1.LogUtil.info(`TextTrackImpl(${this._id}): set mode ${aMode}`);
        if (this.textTrack) {
            this.textTrack.mode = aMode;
            if (this.textTrack.mode === "showing") {
                LogUtils_1.LogUtil.debug(`enable text track id ${this.textTrack.id}`);
                W3CMediaTurboModule_1.default.enableTextTrack(this.mediaElement, this.textTrack.id);
            }
            else if (this.textTrack.mode === "hidden") {
                LogUtils_1.LogUtil.debug(`hide text track id ${this.textTrack.id}`);
                /**
                 * @Check This seems wrong
                 * "Hidden : Indicates that the text track is active, but that the
                 * user agent is not actively displaying the cues. If no
                 * attempt has yet been made to obtain the track's cues,
                 * the user agent will perform such an attempt momentarily.
                 * The user agent is maintaining a list of which cues are
                 * active, and events are being fired accordingly."
                 */
                W3CMediaTurboModule_1.default.disableTextTrack(this.mediaElement, this.textTrack.id);
            }
            else {
                LogUtils_1.LogUtil.info(`disable text track id ${this.textTrack.id}`);
            }
        }
        else {
            /**
             * @TODO handle mode switching of the JS text tracks.
             * This is inefficient.
             */
            if (this._mode !== "disabled" && aMode === "disabled") {
                for (let i = 0; i < this.textTrackCueList.length; i++) {
                    this._mediaPlayer?.removeCue(this.textTrackCueList[i]);
                }
                LogUtils_1.LogUtil.debug(`Track ${this._id} Disabled on user request`);
            }
            else if (this._mode === "disabled" && aMode !== "disabled") {
                for (let i = 0; i < this.textTrackCueList.length; i++) {
                    this._mediaPlayer?.addCue(this.textTrackCueList[i]);
                }
                LogUtils_1.LogUtil.debug(`Track ${this._id} Enabled on user request`);
            }
            this._mode = aMode;
            this._mediaPlayer?.runTMOAlgo();
        }
    }
    oncuechange = (e) => {
        LogUtils_1.LogUtil.debug(`TextTrackImpl: ${this._id} Default Handler event : ` + e?.type);
    };
    // EventTarget API implementation
    addEventListener(type, listener, options) {
        LogUtils_1.LogUtil.debug(`TextTrackImpl:addEventListener ${type}`);
        this.eventEmitter.addEventListener(type, listener);
    }
    removeEventListener(type, listener, options) {
        LogUtils_1.LogUtil.debug(`TextTrackImpl:removeEventListener ${type}`);
        this.eventEmitter.removeEventListener(type, listener);
    }
    /**
     * @TODO Handle cuechange event
     * @param event
     * @returns
     */
    dispatchEvent(event) {
        LogUtils_1.LogUtil.debug(`TextTrackImpl: ${this._id} dispatchEvent ${event.type}`);
        if (event.type === "cuechange") {
            // If we register this as listener with the emitter, we need not do this
            this.oncuechange(event);
        }
        return this.eventEmitter.emit(event.type, new EventTargetInterface_1.Event(event.type, this));
    }
    refresh() {
        if (!this.textTrack && this._mode !== "disabled") {
            this._mediaPlayer?.runTMOAlgo();
        }
    }
}
exports.TextTrackImpl = TextTrackImpl;

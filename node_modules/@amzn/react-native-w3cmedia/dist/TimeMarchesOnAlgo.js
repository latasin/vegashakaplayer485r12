"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeMarchesOnAlgo = void 0;
const LogUtils_1 = require("./LogUtils");
const EventTargetInterface_1 = require("./interface/EventTargetInterface");
const VTTCue_1 = require("./VTTCue");
const W3CMediaTurboModule_1 = __importDefault(require("./turbo-modules/W3CMediaTurboModule"));
class TMOATask {
    time;
    e;
    constructor(aTime, aEvent) {
        this.time = aTime;
        this.e = aEvent;
    }
}
class TimeMarchesOnAlgo {
    /**
     * New ques
     * current position
     * earliest position
     **/
    _lastCurrentPosition = 0;
    _allCues;
    constructor() {
        this._allCues = new Array();
    }
    getLastRunPosition() {
        return this._lastCurrentPosition;
    }
    /**
     * @CHECK Player will explicitly trim the TextTracks or
     * it needs to be done implicitly??
     * @param cue
     */
    removeCue(cue) {
        // @TODO optimise search
        let cueIndex = this._allCues.findIndex(vttcue => vttcue === cue || vttcue.id === cue.id);
        if (cueIndex >= 0) {
            this._allCues.splice(cueIndex, 1); //remove element from array
        }
        if (cue.isActive) {
            cue.isActive = false;
            /**
             * @TODO erase it from the display or cancel it if it is
             * scheduled to be renderred
             **/
        }
    }
    /**
     * @TODO Rework on this using TextTrackCueManager
     * https://html.spec.whatwg.org/multipage/media.html#time-marches-on
     * @param currentTime : Current playback Position
     */
    run(captionViewHandle, currentTime, newlyIntroducedCues) {
        LogUtils_1.LogUtil.debug(`TMOA:+run time = ${currentTime} new cues ${newlyIntroducedCues?.size}` +
            ` lastTime = ${this._lastCurrentPosition}`);
        if (Number.isNaN(currentTime) || currentTime < 0) {
            LogUtils_1.LogUtil.debug(`TMOA:-run OUT}`);
            return;
        }
        /**
         * Step 1 to 7
         * Step 6: that is, firing the 'timeupdate' event is skipped here.
         *'timeupdate' event is fired from the native side from a dedicated,
         * playback progress minitor thread. Ideally, that should be fired from here.
         */
        let currentCues = [];
        let otherCues = [];
        let missedCues = [];
        if (this.updateCuesLists(currentTime, currentCues, otherCues, missedCues, newlyIntroducedCues)) {
            LogUtils_1.LogUtil.debug(`TMOA:-run There is nothing to update !!`);
            this._lastCurrentPosition = currentTime;
            return;
        }
        /**
         * Step 8 : @TODO Support pause-on-exit flag ??
         */
        /**
         * Step 9, 10, 11, 12
         */
        let affectedTracks = new Array();
        let taskList = new Array();
        this.prepareTaskList(currentCues, otherCues, missedCues, taskList, affectedTracks);
        /**
         * Step 13
         */
        this.sortTaskList(taskList);
        /**
         * Step 14 : Dispatch events to their targets
         */
        this.processTaskList(taskList);
        /**
         * Step 15, 16 : Inform the affected tracks
         */
        this.informAffectedTracks(affectedTracks);
        /**
         * Step 17:
         * Update Cue Active Track
         * @CHECK do we need to submit all the active cues
         * for rendering, including from the last run?
         * Ideally, those need not be rendered again
         */
        let toBeRenderedCues = [];
        this.updateActiveCues(currentCues, otherCues, toBeRenderedCues);
        /**
         * Step 18: Render active cues from the "Showing" Tracks
         */
        this.renderActiveCues(captionViewHandle, toBeRenderedCues);
        this._lastCurrentPosition = currentTime;
        LogUtils_1.LogUtil.debug(`TMOA:-run}`);
        return;
    }
    updateCuesLists(currentTime, currentCues, otherCues, missedCues, newlyIntroducedCues) {
        // @TODO get rid of _allCues or optimise merging
        if (newlyIntroducedCues && newlyIntroducedCues.size > 0) {
            this._allCues = this._allCues.concat(Array.from(newlyIntroducedCues));
            this.sortList();
        }
        let nothingToDo = true;
        this._allCues.forEach(cue => {
            if (cue.startTime <= currentTime && currentTime < cue.endTime) {
                currentCues.push(cue);
                if (!cue.isActive) {
                    nothingToDo = false;
                }
            }
            else {
                otherCues.push(cue);
                if (cue.isActive) {
                    nothingToDo = false;
                }
                if (cue.startTime >= this._lastCurrentPosition &&
                    cue.endTime <= currentTime) {
                    if (!newlyIntroducedCues?.has(cue)) {
                        missedCues.push(cue);
                        nothingToDo = false;
                    }
                }
            }
        });
        /**
         * Step 5:
         */
        if (newlyIntroducedCues) {
            newlyIntroducedCues.clear();
        }
        return nothingToDo;
    }
    prepareTaskList(currentCues, otherCues, missedCues, aTaskList, affectedTracks) {
        /**
         * Step 10 : Prepare 'enter' event for missed cues
         */
        missedCues.forEach(cue => {
            aTaskList.push(new TMOATask(cue.startTime, new EventTargetInterface_1.Event('enter', cue)));
            /**
             * Either we can blindly push and remove duplicates later
             * OR
             * avoid pushing duplicates, in th efirst place
             * For now implement as per the specs and optimize late
             */
            /*if (affectedTracks.findIndex(
                            track => (track === cue.track || track.id === cue.track.id)
                            ) < 0) {
                            affectedTracks.push(cue.track);
                        }*/
            affectedTracks.push(cue.track);
        });
        /**
         * Step 11 : "For each text track cue in other cues that either has its
         * text track cue active flag set or is in missed cues, prepare an event
         * named exit for the TextTrackCue object with the later of the text track
         * cue end time and the text track cue start time."
         *
         * This is confusing, can cue endTime be > startTime??
         *
         * Prepare exit event for eligible-other cues and missed cues
         */
        otherCues.forEach(cue => {
            if (cue.isActive) {
                let time = cue.endTime > cue.startTime ? cue.endTime : cue.startTime;
                aTaskList.push(new TMOATask(time, new EventTargetInterface_1.Event('exit', cue)));
                affectedTracks.push(cue.track);
            }
        });
        // This can be clubbed with step 10. Should we?
        missedCues.forEach(cue => {
            let time = cue.endTime > cue.startTime ? cue.endTime : cue.startTime;
            aTaskList.push(new TMOATask(time, new EventTargetInterface_1.Event('exit', cue)));
            affectedTracks.push(cue.track);
        });
        /**
         * Step 12: Prepare enter event for current cues which are going to be active in this loop
         */
        currentCues.forEach(cue => {
            if (!cue.isActive) {
                aTaskList.push(new TMOATask(cue.startTime, new EventTargetInterface_1.Event('enter', cue)));
                affectedTracks.push(cue.track);
            }
        });
    }
    sortTaskList(aTaskList) {
        aTaskList.sort((t1, t2) => {
            let result = 0;
            let c1 = t1.e.target;
            let c2 = t2.e.target;
            if (t1.time !== t2.time) {
                result = t1.time - t2.time;
            }
            else if (c1.track.orderId !==
                c2.track.orderId) {
                result =
                    c1.track.orderId -
                        c2.track.orderId;
            }
            else if (c1.endTime !== c2.endTime) {
                result = c1.endTime - c2.endTime;
            }
            else if (t1.e.type === 'enter') {
                result = -1;
            }
            return result;
        });
    }
    processTaskList(aTaskList) {
        aTaskList.forEach(task => {
            // Need to fire them asynchronously, as Target('s emitter) emits then synchronously.
            // FIXME : bad practice??
            setTimeout(() => task.e.target.dispatchEvent(task.e), 0);
        });
    }
    informAffectedTracks(affectedTracks) {
        // Step 15: Sort affected track list
        affectedTracks.sort((t1, t2) => {
            return t1.orderId - t2.orderId;
        });
        // Step 16 : Inform the affected tracks
        affectedTracks.forEach(t => {
            // Need to fire them asynchronously, as Target('s emitter) emits then synchronously.
            // FIXME : bad practice??
            setTimeout(() => t.dispatchEvent(new EventTargetInterface_1.TrackEvent('cuechange', t, t)));
        });
    }
    updateActiveCues(currentCues, otherCues, toBeRenderedCues) {
        currentCues.forEach(cue => {
            if (!cue.isActive) {
                cue.isActive = true;
            }
            if (cue.track?.mode === "showing" &&
                cue.track?.kind !== "metadata") {
                toBeRenderedCues.push(cue);
            }
        });
        otherCues.forEach(cue => (cue.isActive = false));
    }
    renderActiveCues(captionViewHandle, toBeRenderedCues) {
        /**
         * @TODO MediaPlayer needs to create and provide a TextTrackRenderer
         * For now just log these.
         */
        let nativeVTTCueArray = [];
        toBeRenderedCues.forEach(cue => {
            LogUtils_1.LogUtil.debug(`TMOA: renderActiveCues: ${cue.id} ${cue.startTime} - ${cue.endTime} ${cue.text}`);
            nativeVTTCueArray.push({
                startTime: cue.startTime,
                endTime: (Number.isFinite(cue.endTime) ? cue.endTime : cue.startTime),
                region: cue.region,
                vertical: cue.vertical,
                snapToLines: cue.snapToLines,
                line: cue.line,
                lineAlign: cue.lineAlign,
                position: cue.position,
                positionAlign: cue.positionAlign,
                size: cue.size,
                align: cue.align,
                text: cue.text
            });
        });
        if (nativeVTTCueArray.length > 0) {
            LogUtils_1.LogUtil.warn('TMOA: renderActiveCues: Cues: ' + JSON.stringify(nativeVTTCueArray));
            W3CMediaTurboModule_1.default.renderCaptionsV2(captionViewHandle, nativeVTTCueArray);
        }
    }
    /**
     * In-order cues are not guaranteed, so sort the cues
     * https://html.spec.whatwg.org/multipage/media.html#text-track-cue-order
     * @TODO fix this is not in the required order.
     */
    sortList() {
        const sortedList = this._allCues.slice().sort((c1, c2) => {
            let result = 0;
            if (c1.startTime != c2.startTime) {
                result = c1.startTime - c2.startTime;
            }
            else if (c1.endTime != c2.endTime) {
                result = c1.endTime - c2.endTime;
            }
            else {
                if ('line' in VTTCue_1.VTTCue.prototype) {
                    // Native VTTCue
                    result = this._allCues.indexOf(c2) - this._allCues.indexOf(c1);
                }
                else {
                    // Polyfilled VTTCue
                    result = this._allCues.indexOf(c1) - this._allCues.indexOf(c2);
                }
            }
            return result;
        });
        this._allCues = sortedList;
    }
}
exports.TimeMarchesOnAlgo = TimeMarchesOnAlgo;

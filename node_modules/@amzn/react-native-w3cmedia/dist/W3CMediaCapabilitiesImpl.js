"use strict";
/*
 * Copyright 2024-2025 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaCapabilitiesImpl = exports.decodingInfo = void 0;
const keplermediadescriptor_1 = require("@amzn/keplermediadescriptor");
const LogUtils_1 = require("./LogUtils");
const MediaCapabilitiesDecodingInfoImpl_1 = require("./MediaCapabilitiesDecodingInfoImpl");
const EncryptedMediaCapabilitiesImpl_1 = require("./EncryptedMediaCapabilitiesImpl");
const MimeType_1 = require("./mimeparser/MimeType");
const MimeUtils_1 = require("./mimeparser/MimeUtils");
const CodecProfileLevelParser_1 = require("./mimeparser/CodecProfileLevelParser");
const MimeTypeRegistry_1 = require("./constants/MimeTypeRegistry");
function decodingInfo(config) {
    LogUtils_1.LogUtil.debug("decodingInfo++");
    let impl = new MediaCapabilitiesImpl();
    LogUtils_1.LogUtil.debug("calling into w3c decodingInfo with ", config);
    let res = new Promise((_, reject) => {
        reject(new TypeError('default reject'));
    });
    try {
        res = impl.decodingInfo(config);
    }
    catch (error) {
        LogUtils_1.LogUtil.debug("caught error ", error);
    }
    LogUtils_1.LogUtil.debug("decodingInfo--");
    return res;
}
exports.decodingInfo = decodingInfo;
class MediaCapabilitiesImpl {
    mAudioMimeType;
    mAudioContainerString;
    mVideoMimeType;
    mVideoContainerString;
    async decodingInfo(configuration) {
        LogUtils_1.LogUtil.debug("decodingInfoImpl++");
        // allow the unknown mime types from shaka
        if (configuration?.video?.contentType?.localeCompare(MimeTypeRegistry_1.UNKNOWN_SHAKA_MIME) === 0) {
            let result = new MediaCapabilitiesDecodingInfoImpl_1.MediaCapabilitiesDecodingInfoImpl(configuration);
            return new Promise((resolve, _) => {
                resolve(result);
            });
        }
        // 1.  If configuration is not a valid MediaDecodingConfiguration, return a Promise rejected with a newly
        //     created TypeError.
        if (!this.isValidDecodingConfiguration(configuration)) {
            LogUtils_1.LogUtil.error("decodingInfoImpl invalid config");
            return new Promise((_, reject) => {
                reject(new TypeError('configuration is not a valid MediaDecodingConfiguration'));
            });
        }
        // Note: Skipping the global object checks in 2.1 and 2.2
        // 3. Let p be a new promise.
        let result = await this.createMediaCapabilitiesDecodingInfo(configuration);
        let p = new Promise((resolve, reject) => {
            // 4. In parallel, run the Create a MediaCapabilitiesDecodingInfo algorithm with configuration and resolve
            //    p with its result.
            resolve(result);
        });
        LogUtils_1.LogUtil.debug("decodingInfoImpl--");
        // 5. Return p.
        return p;
    }
    isValidDecodingConfiguration(configuration) {
        LogUtils_1.LogUtil.debug("isValidDecodingConfiguration++");
        // 1. It MUST be a valid MediaConfiguration.
        if (configuration === undefined) {
            LogUtils_1.LogUtil.error("configuration is undefined");
            return false;
        }
        if (!this.isValidMediaConfigurationForDecoding(configuration, configuration.type)) {
            LogUtils_1.LogUtil.error("isValidMediaConfigurationForDecoding failed");
            return false;
        }
        if (configuration.keySystemConfiguration !== undefined) {
            // 2.  If keySystemConfiguration exists:
            // 2.1  The type MUST be media-source or file.
            if (!(configuration.type === "file") && !(configuration.type === "media-source")) {
                LogUtils_1.LogUtil.error("config type is not valid when keySystemConfiguration exists");
                return false;
            }
            // 2.2  If keySystemConfiguration.audio exists, audio MUST also exist.
            if (configuration.keySystemConfiguration.audio !== undefined && configuration.audio === undefined) {
                LogUtils_1.LogUtil.error("If keySystemConfiguration.audio exists, audio MUST also exist.");
                return false;
            }
            // 2.3  If keySystemConfiguration.video exists, video MUST also exist.
            if (configuration.keySystemConfiguration.video !== undefined && configuration.video === undefined) {
                LogUtils_1.LogUtil.error("If keySystemConfiguration.video exists, video MUST also exist.");
                return false;
            }
        }
        LogUtils_1.LogUtil.debug("isValidDecodingConfiguration--");
        return true;
    }
    ;
    isValidMediaConfigurationForDecoding(configuration, type) {
        if (!configuration.video && !configuration.audio) {
            // 1. audio and/or video MUST exist.
            LogUtils_1.LogUtil.error("audio and/or video MUST exist.");
            return false;
        }
        if (configuration.video) {
            // 1. If configuration’s contentType is not a valid video MIME type, return false and abort these steps.
            if (!this.isValidMimeType(configuration.video.contentType, true)) {
                LogUtils_1.LogUtil.error("Mime type should be valid: ", configuration.video.contentType);
                return false;
            }
            // 2. If framerate is not finite or is not greater than 0, return false and abort these steps.
            if (!Number.isFinite(configuration.video.framerate) || configuration.video.framerate <= 0) {
                LogUtils_1.LogUtil.error("framerate should be finite");
                return false;
            }
            // 3. If an optional member is specified for a MediaDecodingType or MediaEncodingType to which it’s not
            //    applicable, return false and abort these steps.
            if (configuration.video.hdrMetadataType !== undefined) {
                if (!(configuration.video.hdrMetadataType === "smpteSt2086") &&
                    !(configuration.video.hdrMetadataType === "smpteSt2094-10") &&
                    !(configuration.video.hdrMetadataType === "smpteSt2094-40")) {
                    LogUtils_1.LogUtil.error("Invalid hdrMetadataType passed ", configuration.video.hdrMetadataType);
                    return false;
                }
                // hdrMetadataType is only applicable to MediaDecodingConfiguration for types media-source and file.
                if (!(type === "file") && !(type === "media-source")) {
                    LogUtils_1.LogUtil.error("hdrMetadataType is only applicable to MediaDecodingConfiguration for types media-source and file");
                    return false;
                }
            }
            if (configuration.video.colorGamut !== undefined) {
                if (!(configuration.video.colorGamut === "srgb") &&
                    !(configuration.video.colorGamut === "p3") &&
                    !(configuration.video.colorGamut === "rec2020")) {
                    LogUtils_1.LogUtil.error("Invalid colorGamut passed ", configuration.video.colorGamut);
                    return false;
                }
                // colorGamut is only applicable to MediaDecodingConfiguration for types media-source and file.
                if (!(type === "file") && !(type === "media-source")) {
                    LogUtils_1.LogUtil.error("colorGamut is only applicable to MediaDecodingConfiguration for types media-source and file");
                    return false;
                }
            }
            if (configuration.video.transferFunction !== undefined) {
                if (!(configuration.video.transferFunction === "srgb") &&
                    !(configuration.video.transferFunction === "pq") &&
                    !(configuration.video.transferFunction === "hlg")) {
                    LogUtils_1.LogUtil.error("Invalid transferFunction passed ", configuration.video.transferFunction);
                    return false;
                }
                // transferFunction is only applicable to MediaDecodingConfiguration for types media-source and file.
                if (!(type === "file") && !(type === "media-source")) {
                    LogUtils_1.LogUtil.error("transferFunction is only applicable to MediaDecodingConfiguration for types media-source and file");
                    return false;
                }
            }
            if (configuration.video.scalabilityMode !== undefined) {
                // scalabilityMode is only applicable to MediaEncodingConfiguration for type webrtc.
                LogUtils_1.LogUtil.error("scalabilityMode is only applicable to MediaDecodingConfiguration for types webrtc");
                return false;
            }
            if (configuration.video.spatialScalability !== undefined) {
                // spatialScalability is only applicable to MediaDecodingConfiguration for types media-source, file and webrtc.
                if (!(type === "file") && !(type === "media-source") && !(type === "webrtc")) {
                    LogUtils_1.LogUtil.error("spatialScalability is only applicable to MediaDecodingConfiguration for types media-source, file and webrtc");
                    return false;
                }
            }
        }
        if (configuration.audio) {
            //  If configuration’s contentType is not a valid audio MIME type, return false and abort these steps.
            if (!this.isValidMimeType(configuration.audio.contentType, false)) {
                LogUtils_1.LogUtil.error("invalid audio mime type ", configuration.audio.contentType);
                return false;
            }
        }
        return true;
    }
    isValidMimeType(mime, isVideo) {
        // mime type examples:
        // 'video/mp4;codecs=avc1.640028'
        // 'video/VP8'
        // 'video/H264;level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f'
        // 'video/VP9'
        // 'video/webm;codecs=vp8'
        let mimeType = MimeType_1.MimeType.parseMimeString(mime);
        if (mimeType === null) {
            return false;
        }
        // A valid video MIME type is a string that is a valid media MIME type and for which the type per [RFC9110] is either video or application.
        if (isVideo && !(mimeType.type === "application" || mimeType.type === "video")) {
            return false;
        }
        //  A valid audio MIME type is a string that is a valid media MIME type and for which the type per [RFC9110] is either audio or application.
        if (!isVideo && !(mimeType.type === "application" || mimeType.type === "audio")) {
            return false;
        }
        let container = "";
        if (isVideo && (0, MimeUtils_1.checkSupportedVideoContainers)(mimeType.essence)) {
            container = mimeType.essence;
        }
        if (!isVideo && (0, MimeUtils_1.checkSupportedAudioContainers)(mimeType.essence)) {
            container = mimeType.essence;
        }
        // 2.1.4.1 If the MIME type does not imply a codec, the string MUST also have one and only one parameter that is named codecs
        //         with a value describing a single media codec. Otherwise, it MUST contain no parameters.
        let codecInfo = this.parseMimeForCodecType(mimeType, container);
        if (container !== "" || mimeType.type === "application") {
            let paramLength = mimeType.getParameterCount();
            if (paramLength > 1) {
                return false;
            }
            if (paramLength === 1 && codecInfo === undefined) {
                return false;
            }
            if (isVideo && codecInfo.codec.startsWith("audio")) {
                return false;
            }
            if (!isVideo && codecInfo.codec.startsWith("video")) {
                return false;
            }
        }
        if (isVideo) {
            this.mVideoMimeType = mimeType;
            this.mVideoContainerString = container;
        }
        else {
            this.mAudioMimeType = mimeType;
            this.mAudioContainerString = container;
        }
        return true;
    }
    parseMimeForCodecType(mimeType, container, hdrMetadataType = undefined) {
        let codecStr = mimeType.getParameter("codecs");
        if (codecStr === undefined) {
            // we dont have the codecs parameter in the mime,
            // all we can do is to get the subtype and see if its a codec.
            if (container.length > 0) {
                // this is a container type, this doesnt help us.
                LogUtils_1.LogUtil.error("we dont have a \"codecs\" parameter in the mime and the type is container");
                return undefined;
            }
            // TODO: now we have a "video/h264" type use case. At least for h264,
            // profile-level-id should be used for profile/level info. Add this support.
        }
        // TODO: do we want to match the container and codec combo using MimeTypeRegistry?
        codecStr = (0, MimeUtils_1.removeLeadingAndTrailingHTTPWhitespace)(codecStr);
        let info = (0, CodecProfileLevelParser_1.parseCodecMime)(codecStr, hdrMetadataType);
        return info;
    }
    parseChannelCountStr(channelCountStr) {
        LogUtils_1.LogUtil.debug("parseChannelCountStr++ ", channelCountStr, " type: ", typeof channelCountStr);
        // 5.1.1 should be 7
        let channelArr = channelCountStr.toString().split('.');
        let totalChannels = 0;
        for (let index = 0; index < channelArr.length; index++) {
            let num = Number(channelArr[index]);
            if (Number.isNaN(num)) {
                return undefined;
            }
            totalChannels += num;
        }
        LogUtils_1.LogUtil.debug("parseChannelCountStr-- ", totalChannels);
        return totalChannels;
    }
    async createMediaCapabilitiesDecodingInfo(configuration) {
        //  1. Let info be a new MediaCapabilitiesDecodingInfo instance. Unless stated otherwise,
        //     reading and writing apply to info for the next steps.
        // 2.  Set configuration to be a new MediaDecodingConfiguration. For every property in configuration create a new property with the same name and value in configuration.
        let info = new MediaCapabilitiesDecodingInfoImpl_1.MediaCapabilitiesDecodingInfoImpl(configuration);
        // 3.  If configuration.keySystemConfiguration exists:
        if (configuration.keySystemConfiguration !== undefined) {
            // 3.1  Set keySystemAccess to the result of running the Check Encrypted Decoding Support algorithm with configuration.
            info.keySystemAccess = await (0, EncryptedMediaCapabilitiesImpl_1.checkEncryptedDecodingsupport)(configuration);
            // 3.2  If keySystemAccess is not null set supported to true. Otherwise set it to false.
            info.supported = info.keySystemAccess !== null;
        }
        else {
            // 4.1 Set keySystemAccess to null.
            info.keySystemAccess = null;
        }
        // 4.2  If the user agent is able to decode the media represented by configuration, set supported to true.
        // if we dont have audio config itself then default to true.
        let audioSupported = configuration.audio ? false : true;
        if (configuration.audio) {
            audioSupported = await this.checkAudioDecodingSuport(configuration);
        }
        // if we dont have video config itself then default to true.
        let videoSupported = configuration.video ? false : true;
        // we have already set the fps before querying the TM, so all the caps returned
        // support the provided fps.
        info.smooth = videoSupported;
        if (configuration.video) {
            let caps = await this.checkVideoDecodingSuport(configuration);
            videoSupported = caps.length > 0;
            for (let cap of caps) {
                if (cap.mediaCodecFeaturesCapabilities.hardwareBacked) {
                    info.powerEfficient = true;
                    break;
                }
            }
        }
        if (configuration.keySystemConfiguration === undefined) {
            // 4.3 Otherwise, set it to false.
            info.supported = audioSupported && videoSupported;
        }
        return info;
    }
    async checkAudioDecodingSuport(config) {
        const decoderConfig = new keplermediadescriptor_1.AudioDecoderConfig();
        let codecInfo = this.parseMimeForCodecType(this.mAudioMimeType, this.mAudioContainerString);
        if (codecInfo !== undefined) {
            // TODO: check the compatibility with the container?
            let mediaFormat = new keplermediadescriptor_1.MediaFormat(codecInfo.codec);
            decoderConfig.mediaFormat = mediaFormat;
        }
        let audioFormat = new keplermediadescriptor_1.AudioFormat();
        audioFormat.channelCount = this.parseChannelCountStr(config.audio.channels);
        audioFormat.sampleRate = config.audio.samplerate;
        decoderConfig.audioFormat = audioFormat;
        if (config.audio.spatialRendering) {
            // TODO: check the mime type and call into audio system for support.
            // We only have eac3-joc support for now. So the mime passed should
            // match this and audio TM should say this is supported.
        }
        LogUtils_1.LogUtil.debug("audio decoder config before query is ", decoderConfig);
        let caps = await keplermediadescriptor_1.KeplerMediaDescriptor.queryMediaCapabilities(decoderConfig);
        return caps.length > 0;
    }
    async checkVideoDecodingSuport(config) {
        const decoderConfig = new keplermediadescriptor_1.VideoDecoderConfig();
        let codecStr = this.mVideoMimeType.getParameter("codecs");
        codecStr = (0, MimeUtils_1.removeLeadingAndTrailingHTTPWhitespace)(codecStr);
        let profileLevel = new keplermediadescriptor_1.MediaFormatProfileLevel(codecStr);
        let codecInfo = this.parseMimeForCodecType(this.mVideoMimeType, this.mVideoContainerString, config.video.hdrMetadataType ? "" : config.video.hdrMetadataType);
        if (codecInfo !== undefined) {
            // TODO: check the compatibility with the container
            let mediaFormat = new keplermediadescriptor_1.MediaFormat(codecInfo.codec);
            mediaFormat.bitrateKbps = config.video.bitrate / 1024; // decoding info bitrate is in bps.
            decoderConfig.mediaFormat = mediaFormat;
            if (codecInfo.profile !== undefined && codecInfo.level !== undefined) {
                profileLevel.profileLevel = {
                    profile: codecInfo.profile,
                    level: codecInfo.level
                };
            }
        }
        let videoFormat = new keplermediadescriptor_1.VideoFormat();
        videoFormat.resolution = {
            width: config.video.width,
            height: config.video.height
        };
        videoFormat.colorPrimaries = codecInfo?.color_space?.primaries;
        videoFormat.colorTransfer = codecInfo?.color_space?.transfer;
        videoFormat.colorMatrix = codecInfo?.color_space?.matrix;
        videoFormat.frameRate = config.video.framerate;
        if (config.video.colorGamut !== undefined) {
            if (config.video.colorGamut === "srgb") {
                // nothing to do, since all codecs and displays support this by default.
                // TODO: confirm this behavior. Also IDL doesnt have BT601, it only has 709.
            }
            else if (config.video.colorGamut === "p3") {
                videoFormat.colorPrimaries = keplermediadescriptor_1.VideoColorPrimaries.SMPTE_ST4321;
            }
            else if (config.video.colorGamut === "rec2020") {
                videoFormat.colorPrimaries = keplermediadescriptor_1.VideoColorPrimaries.BT2020;
            }
        }
        if (config.video.transferFunction !== undefined) {
            if (config.video.transferFunction === "srgb") {
                // nothing to do, since all codecs and displays support this by default.
                // TODO: confirm this behavior. If we need to do something we need to use IEC_61966_2_1 instead of 709.
            }
            else if (config.video.transferFunction === "hlg") {
                videoFormat.colorTransfer = keplermediadescriptor_1.VideoColorTransfer.HLG;
            }
            else if (config.video.transferFunction === "pq") {
                videoFormat.colorTransfer = keplermediadescriptor_1.VideoColorTransfer.SMPTE_BT2100_PQ;
            }
        }
        decoderConfig.videoFormat = videoFormat;
        decoderConfig.formatProfileLevel = profileLevel;
        LogUtils_1.LogUtil.debug("video decoder config before query is ", decoderConfig);
        let caps = await keplermediadescriptor_1.KeplerMediaDescriptor.queryMediaCapabilities(decoderConfig);
        return caps;
    }
}
exports.MediaCapabilitiesImpl = MediaCapabilitiesImpl;

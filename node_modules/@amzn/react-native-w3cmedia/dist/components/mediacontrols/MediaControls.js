"use strict";
/*
 * Copyright 2022-2024 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// rs_out
// @ts-nocheck
const react_1 = require("react");
const LogUtils_1 = require("../../LogUtils");
const react_native_1 = require("react-native");
const PlayBackConstants_1 = require("../../constants/PlayBackConstants");
const CaptionButton_1 = __importDefault(require("./CaptionButton"));
const FloatingButton_1 = __importStar(require("./FloatingButton"));
const FloatingList_1 = __importDefault(require("./FloatingList"));
const Slider_1 = __importDefault(require("./SeekBarUI/Slider/Slider"));
const SliderMetaData_1 = __importDefault(require("./SliderMetaData"));
const styles = react_native_1.StyleSheet.create({
    container: {
        width: '100%',
        height: '100%',
        top: 0,
        left: 0,
        position: 'absolute',
        backgroundColor: 'transparent',
        flexDirection: 'column',
        alignItems: 'center',
    },
    buttonsContainer: {
        width: '100%',
        height: '100%',
        top: 0,
        left: 0,
        position: 'absolute',
        flexDirection: 'row',
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: 'rgba(0, 0, 0, 0.5)'
    },
    otherOptionsContainer: {
        bottom: 0,
        right: 0,
        padding: 5,
        position: 'absolute',
        flexDirection: 'row',
        justifyContent: 'flex-end',
        alignItems: 'flex-end'
    },
    captionList: {
        position: 'absolute',
        right: 10,
        bottom: 90,
    },
    playbackSpeedList: {
        position: 'absolute',
        right: 10,
        bottom: 90,
    },
    imageContainer: {
        width: 80,
        height: 80,
    },
    playPauseImageContainer: {
        width: 170,
        height: 170,
    },
    imageContainerForPlaybackButton: {
        minWidth: 160,
        width: 'auto',
        height: 80
    },
    slider: {
        width: '100%',
        position: 'absolute',
        bottom: 125,
    },
    seekBox: {
        width: '100%',
        position: 'absolute',
        bottom: 50,
        flexDirection: 'row',
        justifyContent: 'space-between'
    },
    timeShifter: {
        backgroundColor: '#FF474D'
    }
});
// This is the initial speed of seekbar thumb
// while starting the seek 
const DEFAULT_STEP = 150;
const PROGRESS_UPDATE_INTERVAL = 500; // milliseconds
const ONE_SECOND = 1000; // milliseconds
const CAPTION_OFF = 'Off';
const DEFAULT_CAPTION = CAPTION_OFF;
const DEFAULT_PLAYBACK_SPEED = '1';
const MediaControls = (props) => {
    let stepInterval = (0, react_1.useRef)(0);
    const previousPlaybackState = (0, react_1.useRef)(false);
    const refPlay = (0, react_1.useRef)(null);
    const refMute = (0, react_1.useRef)(null);
    const refLoop = (0, react_1.useRef)(null);
    const refCaption = (0, react_1.useRef)(null);
    const refCaptionList = (0, react_1.useRef)(null);
    const refPlaybackSpeed = (0, react_1.useRef)(null);
    const refPlaybackSpeedList = (0, react_1.useRef)(null);
    const [isPlaying, setIsPlaying] = (0, react_1.useState)(!props.mediaPlayer?.paused);
    const [isMute, setIsMute] = (0, react_1.useState)(props.mediaPlayer?.muted);
    const [isLoopEnabled, setEnableLoop] = (0, react_1.useState)(props.mediaPlayer?.loop);
    const [isCaptionListVisible, setIsCaptionListVisible] = (0, react_1.useState)(false);
    const [isPlaybackListVisible, setIsPlaybackListVisible] = (0, react_1.useState)(false);
    const captionValue = (0, react_1.useRef)(DEFAULT_CAPTION);
    const playbackSpeedValue = (0, react_1.useRef)(DEFAULT_PLAYBACK_SPEED);
    const captionData = (0, react_1.useRef)(null);
    const [currentTrackTime, setCurrentTrackTime] = (0, react_1.useState)(0);
    const [stepValue, setStepValue] = (0, react_1.useState)(DEFAULT_STEP);
    const [thumbValue, setThumbValue] = (0, react_1.useState)(0);
    (0, react_1.useEffect)(() => {
        const currentinterval = setInterval(() => {
            setCurrentTrackTime(props.mediaPlayer.currentTime * ONE_SECOND);
        }, PROGRESS_UPDATE_INTERVAL);
        return () => clearInterval(currentinterval);
    }, [props.mediaPlayer]);
    (0, react_1.useEffect)(() => {
        setUpEventListener();
        return () => {
            removeEventListeners();
            if (props.mediaPlayer === null || props.mediaPlayer?.textTracks === null) {
                captionData.length = 0;
            }
        };
    }, [props.mediaPlayer]);
    const handleOnSlidingStart = () => {
        if (props.mediaPlayer) {
            previousPlaybackState.current = !props.mediaPlayer.paused;
            props.mediaPlayer.pause();
        }
        stepInterval.current = setInterval(() => {
            setStepValue((prev) => prev * 3);
        }, 3000);
    };
    const handleOnSlidingEnd = () => {
        clearInterval(stepInterval.current);
        setStepValue(DEFAULT_STEP);
        props.mediaPlayer.currentTime = thumbValue / ONE_SECOND;
        if (previousPlaybackState.current) {
            props.mediaPlayer.play();
        }
    };
    const onChangeValueHandler = (value) => {
        setThumbValue(value);
    };
    const closeFloatingList = () => {
        if (isPlaybackListVisible) {
            setIsPlaybackListVisible(false);
        }
        if (isCaptionListVisible) {
            setIsCaptionListVisible(false);
        }
    };
    const onPausePlayToggle = (mediaPlayer) => {
        LogUtils_1.LogUtil.info(`MediaControls:onPausePlayToggle: isPlaying is ${isPlaying}`);
        closeFloatingList();
        if (mediaPlayer?.paused) {
            mediaPlayer?.play();
        }
        else {
            mediaPlayer?.pause();
        }
        if (props.onPressHandler) {
            props.onPressHandler();
        }
    };
    const onMuteUnmuteToggle = (mediaPlayer) => {
        LogUtils_1.LogUtil.info(`MediaControls:onMuteUnmuteToggle: isMute is ${isMute}`);
        closeFloatingList();
        if (mediaPlayer === undefined) {
            return;
        }
        mediaPlayer.muted = !mediaPlayer.muted;
        setIsMute(mediaPlayer.muted);
    };
    const onLoopToggle = (mediaPlayer) => {
        LogUtils_1.LogUtil.info(`MediaControls:onEnableDisableLoopToggle: isLoop is ${isLoopEnabled}`);
        closeFloatingList();
        if (mediaPlayer === undefined) {
            return;
        }
        mediaPlayer.loop = !mediaPlayer.loop;
        setEnableLoop(mediaPlayer.loop);
    };
    const onCaptionToggle = () => {
        LogUtils_1.LogUtil.info(`MediaControls:onEnableDisableCaptionToggle: isCaptionListVisible is ${!isCaptionListVisible}`);
        if (isPlaybackListVisible) {
            setIsPlaybackListVisible(false);
        }
        if (captionData.current !== null) {
            setIsCaptionListVisible(!isCaptionListVisible);
        }
    };
    const onPlaybackSpeedToggle = () => {
        LogUtils_1.LogUtil.info(`MediaControls:onPlaybackSpeedToggle: isPlaybackListVisible is ${!isPlaybackListVisible}`);
        if (isCaptionListVisible) {
            setIsCaptionListVisible(false);
        }
        setIsPlaybackListVisible(!isPlaybackListVisible);
    };
    const onCaptionValueToggle = (mediaPlayer, newLanguage) => {
        LogUtils_1.LogUtil.info(`MediaControls:onCaptionValueToggle: previous id ${captionValue.current}`);
        const track = mediaPlayer.textTracks.getTrackById(captionValue.current);
        if (track) {
            track.mode = "hidden";
        }
        captionValue.current = newLanguage;
        LogUtils_1.LogUtil.info(`MediaControls:onCaptionValueToggle: new id ${captionValue.current}`);
        setIsCaptionListVisible(false);
        if (mediaPlayer === undefined) {
            return;
        }
        const newTrack = mediaPlayer.textTracks.getTrackById(captionValue.current);
        if (newTrack) {
            mediaPlayer.captioning = true;
            newTrack.mode = "showing";
        }
        else {
            mediaPlayer.captioning = false;
        }
    };
    const onPlaybackSpeedValueToggle = (mediaPlayer, newSpeed) => {
        LogUtils_1.LogUtil.info(`MediaControls:onPlaybackSpeedValueToggle: previous playbackSpeedValue
         is ${playbackSpeedValue.current}`);
        playbackSpeedValue.current = newSpeed;
        setIsPlaybackListVisible(false);
        if (mediaPlayer === undefined) {
            return;
        }
        mediaPlayer.playbackRate = Number(playbackSpeedValue.current);
        LogUtils_1.LogUtil.info(`MediaControls:onPlaybackSpeedValueToggle: current playbackSpeedValue
         is ${playbackSpeedValue.current}`);
    };
    const button = <react_native_1.View style={styles.playPauseImageContainer} accessibilityLabel={"MediaControls PLAY/PAUSE"}>
            <FloatingButton_1.default ref={refPlay} hasTVPreferredFocus={true} onPressHandler={() => {
            onPausePlayToggle(props.mediaPlayer);
        }} buttonType={isPlaying ? FloatingButton_1.ButtonType.PAUSE : FloatingButton_1.ButtonType.PLAY}/>
        </react_native_1.View>;
    const muteUnmuteButton = <react_native_1.View style={styles.imageContainer} accessibilityLabel={"MediaControls MUTE/UNMUTE"}>
            <FloatingButton_1.default ref={refMute} onPressHandler={() => {
            onMuteUnmuteToggle(props.mediaPlayer);
        }} buttonType={isMute ? FloatingButton_1.ButtonType.MUTE : FloatingButton_1.ButtonType.UNMUTE}/>
        </react_native_1.View>;
    const toggleLoop = <react_native_1.View style={styles.imageContainer} accessibilityLabel={"MediaControls Enable/Disable Loop"}>
            <FloatingButton_1.default ref={refLoop} onPressHandler={() => {
            onLoopToggle(props.mediaPlayer);
        }} buttonType={isLoopEnabled ? FloatingButton_1.ButtonType.ENABLE_LOOP : FloatingButton_1.ButtonType.DISABLE_LOOP}/>
        </react_native_1.View>;
    const toggleCaptionButton = <CaptionButton_1.default ref={refCaption} onPressHandler={() => {
            if (!isCaptionListVisible) {
                refCaptionList.current?.focus();
            }
            onCaptionToggle();
        }} captionDataAvailable={captionData.current !== null} captionOff={captionValue.current === CAPTION_OFF}/>;
    const SliderMetaDataView = <SliderMetaData_1.default currentTime={currentTrackTime} totalTime={props.mediaPlayer.duration * ONE_SECOND}/>;
    const SeekBar = <Slider_1.default currentValue={currentTrackTime} totalValue={props.mediaPlayer.duration === Infinity ? currentTrackTime : props.mediaPlayer.duration * ONE_SECOND} onFocus={() => {
            closeFloatingList();
        }} step={stepValue} onValueChange={onChangeValueHandler} onSlidingStart={handleOnSlidingStart} onSlidingEnd={handleOnSlidingEnd} longPressIntervalDuration={10} barTrackColor={'rgba(113, 31, 34,0.3)'} currentValueIndicatorColor={"red"} disableThumbnail={true} timeShiftIndicatorStyle={styles.timeShifter}/>;
    const playbackButton = <react_native_1.View style={styles.imageContainerForPlaybackButton} accessibilityLabel={"MediaControls Playback Speed"}>
            <FloatingButton_1.default ref={refPlaybackSpeed} onPressHandler={() => {
            if (!isPlaybackListVisible) {
                refPlaybackSpeedList.current?.focus();
            }
            onPlaybackSpeedToggle();
        }} value={playbackSpeedValue.current} buttonType={FloatingButton_1.ButtonType.PLAYBACK_SPEED}/>
        </react_native_1.View>;
    const onPlayingUpdate = () => {
        setIsPlaying(true);
    };
    const onPausedUpdate = () => {
        setIsPlaying(false);
    };
    const onEndedUpdate = () => {
        // Playback has ENDED.
        // Go to the earliest possible position.
        // and change icon to play.
        if (props.mediaPlayer !== undefined && props.mediaPlayer !== null) {
            props.mediaPlayer.currentTime = 0;
            setIsPlaying(false);
        }
    };
    const onSeekCompleted = () => {
        if (props.mediaPlayer !== undefined && props.mediaPlayer !== null) {
            LogUtils_1.LogUtil.info("MediaControls:onSeekCompleted: seeked event triggered");
        }
    };
    const onMuteUpdated = () => {
        if (props.mediaPlayer !== undefined && props.mediaPlayer !== null) {
            LogUtils_1.LogUtil.info("MediaControls:onMuteUpdated: volume change event triggered");
            if (props.mediaPlayer.muted) {
                setIsMute(true);
            }
            else {
                setIsMute(false);
            }
        }
    };
    const onTextTrackAdded = () => {
        LogUtils_1.LogUtil.info("MediaControls:onTextTrackAdded: addTrack change event triggered");
        captionDataFetch(props.mediaPlayer?.textTracks);
    };
    const captionDataFetch = (textTrackList) => {
        if (textTrackList === undefined || textTrackList === null) {
            return;
        }
        const tempTrackInfo = [{
                id: 'Off',
                value: 'Off',
            }];
        for (let i = 0; i < textTrackList.length; i++) {
            // @ts-ignore
            const textTrack = textTrackList[i];
            LogUtils_1.LogUtil.info(`MediaControls: text track id = ${textTrack.id} \
                kind = ${textTrack.kind} \
                language = ${textTrack.language} \
                label = ${textTrack.label} \
                mode = ${textTrack.mode} `);
            tempTrackInfo.push({
                id: textTrack.id,
                value: textTrack.language,
            });
            if (textTrack.mode === 'showing') {
                captionValue.current = textTrack.id;
            }
        }
        if (tempTrackInfo.length > 1) {
            captionData.current = tempTrackInfo;
        }
    };
    const setUpEventListener = () => {
        props.mediaPlayer?.addEventListener("play", onPlayingUpdate);
        props.mediaPlayer?.addEventListener("pause", onPausedUpdate);
        props.mediaPlayer?.addEventListener("ended", onEndedUpdate);
        props.mediaPlayer?.addEventListener("seeked", onSeekCompleted);
        props.mediaPlayer?.addEventListener("volumechange", onMuteUpdated);
        props.mediaPlayer?.textTracks?.addEventListener("addtrack", onTextTrackAdded);
    };
    const removeEventListeners = () => {
        props.mediaPlayer?.removeEventListener("play", onPlayingUpdate);
        props.mediaPlayer?.removeEventListener("pause", onPausedUpdate);
        props.mediaPlayer?.removeEventListener("ended", onEndedUpdate);
        props.mediaPlayer?.removeEventListener("seeked", onSeekCompleted);
        props.mediaPlayer?.removeEventListener("volumechange", onMuteUpdated);
        props.mediaPlayer?.textTracks?.removeEventListener("addtrack", onTextTrackAdded);
    };
    const onPressHandler = () => {
        closeFloatingList();
        refPlay.current?.focus();
    };
    return (<react_native_1.TouchableOpacity style={styles.container} onPress={onPressHandler} activeOpacity={1}>
                <react_native_1.View style={styles.buttonsContainer}>
                    {button}
                    <react_native_1.View style={styles.seekBox}>
	                    {SliderMetaDataView}
	                 </react_native_1.View>
	                 <react_native_1.View style={styles.slider}>
	                    {SeekBar}
	                 </react_native_1.View>
                    <react_native_1.View style={styles.otherOptionsContainer}>
                      {muteUnmuteButton}
                      {toggleLoop}
                      {toggleCaptionButton}
                      {playbackButton}
                      {captionData.current !== null && isCaptionListVisible ?
            <FloatingList_1.default defaultValue={captionValue.current} listContainerPositioning={styles.captionList} data={captionData.current} onPressHandler={(arg) => {
                    onCaptionValueToggle(props.mediaPlayer, arg);
                    refPlay.current?.focus();
                }} ref={refCaptionList}/> : null}
                      {isPlaybackListVisible ?
            <FloatingList_1.default defaultValue={playbackSpeedValue.current} listContainerPositioning={styles.playbackSpeedList} data={PlayBackConstants_1.PLAYBACK_SPEED_DATA} onPressHandler={(arg) => {
                    onPlaybackSpeedValueToggle(props.mediaPlayer, arg);
                    refPlay.current?.focus();
                }} ref={refPlaybackSpeedList}/> : null}
                    </react_native_1.View>
                </react_native_1.View>
        </react_native_1.TouchableOpacity>);
};
exports.default = MediaControls;

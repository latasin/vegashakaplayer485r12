"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VideoPlayer = exports.VideoPlaybackQualityImpl = void 0;
/*
 * Copyright 2022-2025 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
const MediaPlayer_1 = require("../MediaPlayer");
const LogUtils_1 = require("../LogUtils");
const W3CMediaTurboModule_1 = __importDefault(require("../turbo-modules/W3CMediaTurboModule"));
const MediaTypes_1 = require("./MediaTypes");
class VideoPlaybackQualityImpl {
    creationTime_ = 0;
    droppedVideoFrames_ = 0;
    totalVideoFrames_ = 0;
    /**
     * @brief Constructor to create a video playback quality instance
     */
    constructor(creationTime, droppedVideoFrames, totalVideoFrames) {
        this.creationTime_ = creationTime;
        this.droppedVideoFrames_ = droppedVideoFrames;
        this.totalVideoFrames_ = totalVideoFrames;
    }
    get creationTime() {
        return this.creationTime_;
    }
    get droppedVideoFrames() {
        return this.droppedVideoFrames_;
    }
    get totalVideoFrames() {
        return this.totalVideoFrames_;
    }
    get corruptedVideoFrames() {
        return NaN;
    }
}
exports.VideoPlaybackQualityImpl = VideoPlaybackQualityImpl;
/** *
 * @brief VideoPlayer is a component that implements the `HTMLVideoElement` interface
 * that extends `HTMLMediaElement` interface.
 * @remarks This is a typescript class and not a react native component. Apps need
 * to create an instance of `VideoPlayer` and use it to start buffering the content
 * without rendering video on screen. It doesn't render video to the screen by
 *  default, nor does it render the media controls GUI. Apps are expected to build
 * their own media controls UI and control the playback experience. When the app
 * wants to show the video on screen, it must add `KeplerVideoSurfaceView` React
 * Native component to the render tree, receive `onSurfaceViewCreated` event and
 * pass the surface handle obtained in the event callback to `VideoPlayer` through
 * the `setSurfaceHandle` API.
 */
class VideoPlayer extends MediaPlayer_1.MediaPlayer {
    videoWidth_ = 0;
    videoHeight_ = 0;
    width_ = undefined;
    height_ = undefined;
    poster_ = "";
    playsInline_ = false;
    /**
     * @brief Constructor to create a video player instance
     */
    constructor() {
        super("video", MediaTypes_1.AudioContentType.CONTENT_TYPE_MOVIE, MediaTypes_1.AudioUsageType.USAGE_MEDIA);
    }
    /**
     * @brief Initiailzes the player.
     * Wait for the promise to be fulfilled before calling any other fucntion.
     * @returns Promise that is resolved when player is initialized..
     */
    initialize() {
        return super.initialize();
    }
    /**
     * @brief DeInitiailzes the player.
     *
     * @returns Promise that is resolved when player is deInitialized.
     */
    deinitialize() {
        return super.deinitialize();
    }
    /**
     * @brief DeInitiailzes the player synchronously
     * @param timeoutInMs time out threshold set by client to return the deinit control.
     * @returns MediaPlayerDeInitStatus
     */
    deinitializeSync(timeoutInMs) {
        return super.deinitializeSync(timeoutInMs);
    }
    /**
     * @hidden
     */
    get videoWidth() {
        return this.videoWidth_;
    }
    /**
     * @hidden
     */
    get videoHeight() {
        return this.videoHeight_;
    }
    /**
     * @hidden
     */
    set width(w) {
        this.width_ = w;
    }
    /**
     * @hidden
     */
    get width() {
        if (this.width_ !== undefined) {
            return this.width_;
        }
        else {
            return 0;
        }
    }
    /**
     * @hidden
     */
    set height(h) {
        this.height_ = h;
    }
    /**
    * @hidden
    */
    get height() {
        if (this.height_ !== undefined) {
            return this.height_;
        }
        else {
            return 0;
        }
    }
    /**
     * @hidden
     */
    get poster() {
        return this.poster_;
    }
    /**
     * @hidden
     */
    set poster(img) {
        this.poster_ = img;
    }
    /**
     * @hidden
     */
    get playsInline() {
        return this.playsInline_;
    }
    /**
     * @hidden
     */
    set playsInline(b) {
        // Video element is not expected to handle playsInline.
        // Main document element should handle this.
        this.playsInline_ = b;
    }
    /**
     * @brief setup the component instance with current mediaplayer being used and pass mediaControlHandler
     *        in case client wants to opt handling of mediacontrol commands.
     */
    setMediaControlFocus(componentInstance, mediaControlHandler) {
        return super.setMediaControlFocus(componentInstance, mediaControlHandler);
    }
    /**
     * @brief Sets the surface handle to which video is rendered.
     * @param[in] `surfaceHandle` The surface handle returned by the `onSurfaceViewCreated` event emitted
     * by `KeplerVideoSurfaceView` component.
     */
    setSurfaceHandle(surfaceHandle) {
        LogUtils_1.LogUtil.info(`VideoPlayer: setSurfaceHandle: ${surfaceHandle}`);
        if (surfaceHandle !== null && surfaceHandle.length > 0) {
            this.surfaceHandle = surfaceHandle;
            if (this.mediaElement !== null) {
                W3CMediaTurboModule_1.default.setSurface(this.mediaElement, surfaceHandle);
            }
            else {
                LogUtils_1.LogUtil.warn(`VideoPlayer: mediaElement not available, hence only cached the surface`);
            }
        }
        else {
            LogUtils_1.LogUtil.error(`VideoPlayer: invalid surface passed to setSurfaceHandle`);
        }
    }
    /**
    * @brief Sets the surface handle to which video is rendered.
    * @param[in] `surfaceHandle` The surface handle returned by `onSurfaceViewCreated` event emitted
    * by `KeplerVideoSurfaceView` component.
    */
    clearSurfaceHandle(surfaceHandle) {
        LogUtils_1.LogUtil.info(`VideoPlayer: clearSurfaceHandle: ${surfaceHandle}`);
        if (this.surfaceHandle !== null && surfaceHandle === this.surfaceHandle) {
            if (this.mediaElement !== null) {
                W3CMediaTurboModule_1.default.clearSurface(this.mediaElement, this.surfaceHandle);
            }
            else {
                LogUtils_1.LogUtil.warn("MediaPlayer: media element not found...skipping reset surface");
            }
            this.surfaceHandle = null;
        }
    }
    /**
     * @hidden
     */
    handleEvent(event) {
        switch (event.src) {
            case this.MEDIA_EVENT_SOURCE_HTMLMEDIAELEMENT:
                {
                    // Check for resolution change.
                    if ("resize" === event.name) {
                        this.videoWidth_ = event.width;
                        this.videoHeight_ = event.height;
                    }
                }
                break;
            default:
                break;
        }
        super.handleEvent(event);
    }
    /**
     * @brief Fetches video playback quality attributes.
     */
    getVideoPlaybackQuality() {
        let creationTime = NaN;
        let droppedVideoFrames = 0;
        let totalVideoFrames = 0;
        if (this.mediaElement !== null) {
            const result = W3CMediaTurboModule_1.default.getVideoPlaybackQuality(this.mediaElement);
            creationTime = Date.now();
            droppedVideoFrames = result.droppedVideoFrames;
            totalVideoFrames = result.totalVideoFrames;
        }
        return new VideoPlaybackQualityImpl(creationTime, droppedVideoFrames, totalVideoFrames);
    }
}
exports.VideoPlayer = VideoPlayer;
;

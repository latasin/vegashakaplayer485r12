"use strict";
/*
 * Copyright 2025 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseVp9CodecID = exports.parseAV1CodecId = exports.parseHEVCCodecId = exports.parseAVCCodecId = exports.parseCodecMime = exports.CodecInfo = void 0;
const keplermediadescriptor_1 = require("@amzn/keplermediadescriptor");
const LogUtils_1 = require("../LogUtils");
;
const stringToCodecTypeMap = new Map([
    // We only allow this for WAV so it isn't ambiguous.
    ["1", keplermediadescriptor_1.CodecMimeType.MIME_WAV],
    ["mp3", keplermediadescriptor_1.CodecMimeType.MIME_MP3],
    // Following is the list of RFC 6381 compliant audio codec
    // strings:
    //   mp4a.66     - MPEG-2 AAC MAIN
    //   mp4a.67     - MPEG-2 AAC LC
    //   mp4a.68     - MPEG-2 AAC SSR
    //   mp4a.69     - MPEG-2 extension to MPEG-1 (MP3)
    //   mp4a.6B     - MPEG-1 audio (MP3)
    //   mp4a.40.2   - MPEG-4 AAC LC
    //   mp4a.40.02  - MPEG-4 AAC LC (leading 0 in aud-oti for
    //                 compatibility)
    //   mp4a.40.5   - MPEG-4 HE-AAC v1 (AAC LC + SBR)
    //   mp4a.40.05  - MPEG-4 HE-AAC v1 (AAC LC + SBR) (leading 0
    //                 in aud-oti for compatibility)
    //   mp4a.40.29  - MPEG-4 HE-AAC v2 (AAC LC + SBR + PS)
    ["mp4a.66", keplermediadescriptor_1.CodecMimeType.MIME_AAC],
    ["mp4a.67", keplermediadescriptor_1.CodecMimeType.MIME_AAC],
    ["mp4a.68", keplermediadescriptor_1.CodecMimeType.MIME_AAC],
    ["mp4a.69", keplermediadescriptor_1.CodecMimeType.MIME_MP3],
    ["mp4a.6B", keplermediadescriptor_1.CodecMimeType.MIME_MP3],
    ["mp4a.40.2", keplermediadescriptor_1.CodecMimeType.MIME_AAC],
    ["mp4a.40.02", keplermediadescriptor_1.CodecMimeType.MIME_AAC],
    // PROJXXX-197156 use the right mappings once they are available.
    ["mp4a.40.5", keplermediadescriptor_1.CodecMimeType.MIME_AAC],
    ["mp4a.40.05", keplermediadescriptor_1.CodecMimeType.MIME_AAC],
    ["mp4a.40.29", keplermediadescriptor_1.CodecMimeType.MIME_AAC],
    // MPEG Surround is based on a down-mix coded with AAC-LC and HE-AAC
    // PROJXXX-197156 use the right mappings once they are available.
    ["mp4a.40.30", keplermediadescriptor_1.CodecMimeType.MIME_AAC],
    ["mp4a.40.42", keplermediadescriptor_1.CodecMimeType.MIME_AUDIO_UNSPECIFIED],
    // Note: Strictly speaking only mp4a.A5 and mp4a.A6
    // codec ids are valid according to RFC 6381 section 3.3, 3.4.
    // Lower-case oti (mp4a.a5 and mp4a.a6) should be rejected. But
    // Chromium used to allow those in older versions of Chromecast
    // firmware and some apps (notably MPL) depend on those codec
    // types being supported, so they should be allowed for now
    // (crbug.com/564960).
    ["ac-3", keplermediadescriptor_1.CodecMimeType.MIME_AC3],
    ["mp4a.a5", keplermediadescriptor_1.CodecMimeType.MIME_AC3],
    ["mp4a.A5", keplermediadescriptor_1.CodecMimeType.MIME_AC3],
    ["ec-3", keplermediadescriptor_1.CodecMimeType.MIME_EAC3],
    ["mp4a.a6", keplermediadescriptor_1.CodecMimeType.MIME_EAC3],
    ["mp4a.A6", keplermediadescriptor_1.CodecMimeType.MIME_EAC3],
    ["vorbis", keplermediadescriptor_1.CodecMimeType.MIME_VORBIS],
    ["opus", keplermediadescriptor_1.CodecMimeType.MIME_OPUS],
    ["Opus", keplermediadescriptor_1.CodecMimeType.MIME_OPUS],
    ["flac", keplermediadescriptor_1.CodecMimeType.MIME_FLAC],
    ["fLaC", keplermediadescriptor_1.CodecMimeType.MIME_FLAC],
    ["vp8", keplermediadescriptor_1.CodecMimeType.MIME_VP8],
    ["vp8.0", keplermediadescriptor_1.CodecMimeType.MIME_VP8],
    ["theora", keplermediadescriptor_1.CodecMimeType.MIME_AUDIO_UNSPECIFIED],
    ["dtsc", keplermediadescriptor_1.CodecMimeType.MIME_AUDIO_UNSPECIFIED],
    ["mp4a.a9", keplermediadescriptor_1.CodecMimeType.MIME_AUDIO_UNSPECIFIED],
    ["mp4a.A9", keplermediadescriptor_1.CodecMimeType.MIME_AUDIO_UNSPECIFIED],
    // PROJXXX-197156 use the right mappings once they are available.
    ["dtse", keplermediadescriptor_1.CodecMimeType.MIME_AUDIO_UNSPECIFIED],
    ["mp4a.ac", keplermediadescriptor_1.CodecMimeType.MIME_AUDIO_UNSPECIFIED],
    ["mp4a.AC", keplermediadescriptor_1.CodecMimeType.MIME_AUDIO_UNSPECIFIED],
    ["dtsx", keplermediadescriptor_1.CodecMimeType.MIME_AUDIO_UNSPECIFIED],
    ["mp4a.b2", keplermediadescriptor_1.CodecMimeType.MIME_AUDIO_UNSPECIFIED],
    ["mp4a.B2", keplermediadescriptor_1.CodecMimeType.MIME_AUDIO_UNSPECIFIED],
    // PROJXXX-197156 use the right mappings once they are available.
    ["ac-4", keplermediadescriptor_1.CodecMimeType.MIME_AUDIO_UNSPECIFIED],
    ["mp4a.ae", keplermediadescriptor_1.CodecMimeType.MIME_AUDIO_UNSPECIFIED],
    ["mp4a.AE", keplermediadescriptor_1.CodecMimeType.MIME_AUDIO_UNSPECIFIED],
]);
// TODO: get the actual values once the IDL is finalised.
const AVCProfileUnknown = 0;
const AVCProfileBaseline = 1;
const AVCProfileMain = 2;
const AVCProfileExtended = 3;
const AVCProfileHigh = 4;
const AVCProfileHigh10 = 5;
const AVCProfileHigh422 = 6;
const AVCProfileHigh444 = 7;
const AVCProfileConstrainedBaseline = 8;
const AVCProfileConstrainedHigh = 9;
const AVCLevelUnknown = 0;
const HEVCProfileUnknown = 100;
const HEVCProfileMain = 101;
const HEVCProfileMain10HDR10 = 104;
const HEVCProfileMain10HDR10Plus = 105;
const HEVCLevelUnknown = 100;
const VP9ProfileUnknown = 300;
const VP9Profile0 = 301;
const VP9Profile1 = 302;
const VP9Profile2 = 303;
const VP9Profile3 = 304;
const VP9Profile2HDR = 305;
const VP9Profile3HDR = 306;
const VP9Profile2HDR10Plus = 307;
const VP9Profile3HDR10Plus = 308;
const VP9LevelUnknown = 300;
const VP9Level1 = 301;
const VP9Level11 = 302;
const VP9Level2 = 303;
const VP9Level21 = 304;
const VP9Level3 = 305;
const VP9Level31 = 306;
const VP9Level4 = 307;
const VP9Level41 = 308;
const VP9Level5 = 309;
const VP9Level51 = 310;
const VP9Level52 = 311;
const VP9Level6 = 312;
const VP9Level61 = 313;
const VP9Level62 = 314;
// TODO: figure this mapping with the actual profile numbers from mime type.
const DolbyVisionProfileUnknown = 800;
const DolbyVisionProfileDvavPer = 801;
const DolbyVisionProfileDvavPen = 802;
const DolbyVisionProfileDvheDer = 803;
const DolbyVisionProfileDvheDen = 804;
const DolbyVisionProfileDvheDtr = 805;
const DolbyVisionProfileDvheStn = 806;
const DolbyVisionProfileDvheDth = 807;
const DolbyVisionProfileDvheDtb = 808;
const DolbyVisionProfileDvheSt = 809;
const DolbyVisionProfileDvavSe = 810;
const DolbyVisionLevelUnknown = 800;
// TODO: figure the correct mappings for these values
const H264PROFILE_SCALABLEBASELINE = 7;
const H264PROFILE_SCALABLEHIGH = 8;
const H264PROFILE_STEREOHIGH = 9;
const H264PROFILE_MULTIVIEWHIGH = 10;
const HEVCPROFILE_HIGH_THROUGHPUT_SCREEN_EXTENDED = 36;
const HEVCPROFILE_SCALABLE_REXT = 35;
const HEVCPROFILE_SCREEN_EXTENDED = 34;
const HEVCPROFILE_SCALABLE_MAIN = 32;
const HEVCPROFILE_MULTIVIEW_MAIN = 31;
const HEVCPROFILE_HIGH_THROUGHPUT = 30;
const HEVCPROFILE_REXT = 29;
class ColorSpace {
    primaries;
    transfer;
    matrix;
    range; // TODO: this should be VideoColorRange but its not defined in JS yet.
}
;
class CodecInfo {
    codec;
    bit_depth;
    color_space;
    subsampling;
    profile;
    level;
}
exports.CodecInfo = CodecInfo;
function getPrimaryID(primary) {
    if (primary < 1 || primary > 22 || primary == 3) {
        return 0;
    }
    if (primary > 12 && primary < 22) {
        return 0;
    }
    return primary;
}
function getTransferID(transfer) {
    if (transfer < 1 || transfer > 18 || transfer == 3) {
        return 0;
    }
    return transfer;
}
function getMatrixID(matrix) {
    if (matrix < 0 || matrix > 11 || matrix == 3) {
        return -1;
    }
    return matrix;
}
function isDolbyVisionAVCCodecId(codec_id) {
    return codec_id.startsWith("dva1.") || codec_id.startsWith("dvav.");
}
function isDolbyVisionHEVCCodecId(codec_id) {
    return codec_id.startsWith("dvh1.") || codec_id.startsWith("dvhe.");
}
function getVP9HDRProfileId(hdrmetadatatype, mimeProfile) {
    if (hdrmetadatatype === "smpteSt2086") {
        // HDR10
        switch (mimeProfile) {
            case VP9Profile2:
                return VP9Profile2HDR;
            case VP9Profile3:
                return VP9Profile3HDR;
            default:
                return VP9ProfileUnknown;
        }
    }
    if (hdrmetadatatype === "smpteSt2094-40") {
        // HDR10+
        switch (mimeProfile) {
            case VP9Profile2:
                return VP9Profile2HDR10Plus;
            case VP9Profile3:
                return VP9Profile3HDR10Plus;
            default:
                return VP9ProfileUnknown;
        }
    }
    return mimeProfile;
}
function parseCodecMime(codec_id, hdrMetadataType = "") {
    LogUtils_1.LogUtil.debug("parseCodecMime++: ", codec_id, " ", hdrMetadataType);
    let mimeType = stringToCodecTypeMap.get(codec_id);
    if (mimeType != undefined) {
        let codecInfo = new CodecInfo();
        codecInfo.codec = mimeType;
        return codecInfo;
    }
    let profileLevel = parseAVCCodecId(codec_id);
    if (profileLevel != undefined) {
        let codecInfo = new CodecInfo();
        codecInfo.codec = keplermediadescriptor_1.CodecMimeType.MIME_AVC;
        codecInfo.profile = profileLevel.profile;
        codecInfo.level = profileLevel.level;
        return codecInfo;
    }
    profileLevel = parseHEVCCodecId(codec_id, hdrMetadataType);
    if (profileLevel != undefined) {
        let codecInfo = new CodecInfo();
        codecInfo.codec = keplermediadescriptor_1.CodecMimeType.MIME_HEVC;
        codecInfo.profile = profileLevel.profile;
        codecInfo.level = profileLevel.level;
        return codecInfo;
    }
    let codecInfo = parseVp9CodecID(codec_id, hdrMetadataType);
    if (codecInfo != undefined) {
        codecInfo.codec = keplermediadescriptor_1.CodecMimeType.MIME_VP9;
        return codecInfo;
    }
    profileLevel = parseDolbyVisionCodecId(codec_id);
    if (profileLevel != undefined) {
        let codecInfo = new CodecInfo();
        codecInfo.codec = keplermediadescriptor_1.CodecMimeType.MIME_DOLBY_VISION;
        codecInfo.profile = profileLevel.profile;
        codecInfo.level = profileLevel.level;
        return codecInfo;
    }
    profileLevel = parseAV1CodecId(codec_id, hdrMetadataType);
    if (profileLevel != undefined) {
        let codecInfo = new CodecInfo();
        codecInfo.codec = keplermediadescriptor_1.CodecMimeType.MIME_AV1;
        codecInfo.profile = profileLevel.profile;
        codecInfo.level = profileLevel.level;
        return codecInfo;
    }
    // unknown codec
    return undefined;
}
exports.parseCodecMime = parseCodecMime;
/**
 * Parses strings in the format
 * <avc1/avc3>.<profile byte><constraint byte><level byte> [avc1.xxxxxx, avc3.xxxxxx]
 * Ex:
 *  avc1.4d002a is Main Profile, Level 4.2
 *
 *
 * Refers ParseAVCCodecId in
 * https://source.chromium.org/chromium/chromium/src/+/main:media/base/video_codec_string_parsers.cc
 *
 * @param codec_id @type {string} which represents avc profile level.
 * @returns @type {ProfileLevel} corresponding to the string passed.
 */
function parseAVCCodecId(codec_id) {
    let result = {
        profile: undefined,
        level: undefined,
    };
    // Make sure we have avc1.xxxxxx or avc3.xxxxxx , where xxxxxx are hex digits
    if (!codec_id.startsWith("avc1.") && !codec_id.startsWith("avc3.")) {
        return undefined;
    }
    return result;
}
exports.parseAVCCodecId = parseAVCCodecId;
function parseHEVCCodecId(codec_id, hdrMetadataType) {
    let result = {
        profile: HEVCProfileUnknown,
        level: HEVCLevelUnknown,
    };
    if (!codec_id.startsWith("hev1.") && !codec_id.startsWith("hvc1.")) {
        return undefined;
    }
    if (hdrMetadataType != "smpteSt2086" && hdrMetadataType != "smpteSt2094-40") {
        // parse only if the hdr meta is what we need.
        return result;
    }
    // HEVC codec id consists of:
    const kMaxHevcCodecIdLength = 5 + // 'hev1.' or 'hvc1.' prefix (5 chars)
        4 + // profile, e.g. '.A12' (max 4 chars)
        9 + // profile_compatibility, dot + 32-bit hex number (max 9 chars)
        5 + // tier and level, e.g. '.H120' (max 5 chars)
        18; // up to 6 constraint bytes, bytes are dot-separated and hex-encoded.
    if (codec_id.length > kMaxHevcCodecIdLength) {
        // Codec id is too long
        return undefined;
    }
    let elem = codec_id.split(".");
    if (!(elem[0] === "hev1") && !(elem[0] === "hvc1")) {
        return undefined;
    }
    if (elem.length < 4) {
        // invalid HEVC codec id
        return undefined;
    }
    let general_profile_space = 0;
    if (elem[1].length > 0 &&
        (elem[1][0].toUpperCase() === 'A' ||
            elem[1][0].toUpperCase() === 'B' ||
            elem[1][0].toUpperCase() === 'C')) {
        switch (elem[1][0]) {
            case 'A':
                general_profile_space = 1;
                break;
            case 'B':
                general_profile_space = 2;
                break;
            case 'C':
                general_profile_space = 3;
            default:
                break;
        }
        elem[1] = elem[1].substring(1);
    }
    let general_profile_idc = 0;
    general_profile_idc = Number(elem[1]);
    if (Number.isNaN(general_profile_idc) || general_profile_idc > 0x1f) {
        // invalid general_profile_idc
        return undefined;
    }
    let general_profile_compatibility_flags = Number("0x" + elem[2]);
    if (Number.isNaN(general_profile_compatibility_flags)) {
        return undefined;
    }
    let out_profile = HEVCProfileUnknown;
    // Spec A.3.3
    // NOTICE: Do not change the order of below sections
    if (general_profile_idc === 2 || (general_profile_compatibility_flags & 4)) {
        if (hdrMetadataType === "smpteSt2086") {
            out_profile = HEVCProfileMain10HDR10;
        }
        if (hdrMetadataType === "smpteSt2094-40") {
            out_profile = HEVCProfileMain10HDR10Plus;
        }
    }
    if (out_profile === HEVCProfileUnknown) {
        // non-hdr case, depend on the native impl to figure out profile.
        return undefined;
    }
    let general_tier_flag;
    if (elem[3].length > 0 && (elem[3][0] === 'L' || elem[3][0] === 'H')) {
        general_tier_flag = (elem[3][0] === 'L') ? 0 : 1;
        elem[3] = elem[3].substring(1);
    }
    else {
        // invalid general_tier_flag, elem[3]
        return undefined;
    }
    let general_level_idc = Number(elem[3]);
    if (Number.isNaN(general_level_idc) ||
        general_level_idc > 0xff) {
        // invalid general_level_idc elem[3]
        return undefined;
    }
    let constraint_flags = Array(6).fill(0);
    if (elem.length > 10) {
        // unexpected number of trailing bytes in HEVC codec_id
        return undefined;
    }
    for (let i = 4; i < elem.length; ++i) {
        let constr_byte = Number("0x" + elem[i]);
        if (Number.isNaN(constr_byte) || constr_byte > 0xFF) {
            // invalid constraint byte elem[i]
            return undefined;
        }
        constraint_flags[i - 4] = constr_byte;
    }
    // todo: map this level value to our value in IDL
    result.level = HEVCLevelUnknown;
    result.profile = out_profile;
    return result;
}
exports.parseHEVCCodecId = parseHEVCCodecId;
function parseAV1CodecId(codec_id, hdrMetadataType) {
    LogUtils_1.LogUtil.debug("parseAV1CodecId++ ", codec_id);
    let result = {
        profile: undefined,
        level: undefined,
    };
    if ((codec_id === "av1" || codec_id === "av01") && !hdrMetadataType) {
        return result;
    }
    // The codecs parameter string for the AOM AV1 codec is as follows:
    // See https://aomediacodec.github.io/av1-isobmff/#codecsparam.
    //
    // <sample entry4CC>.<profile>.<level><tier>.<bitDepth>.<monochrome>.
    // <chromaSubsampling>.<colorPrimaries>.<transferCharacteristics>.
    // <matrixCoefficients>.<videoFullRangeFlag>
    let fields = codec_id.split(".");
    // The parameters sample entry 4CC, profile, level, tier, and bitDepth are all
    // mandatory fields. If any of these fields are empty, or not within their
    // allowed range, the processing device SHOULD treat it as an error.
    if (fields.length < 4 || fields.length > 10) {
        // " Invalid number of fields
        LogUtils_1.LogUtil.error("parseAV1CodecId: Invalid number of fields ", fields.length);
        return undefined;
    }
    // All the other fields (including their leading '.') are optional, mutually
    // inclusive (all or none) fields. If not specified then the values listed in
    // the table below are assumed.
    //
    // mono_chrome              0
    // chromaSubsampling        112 (4:2:0 colocated with luma (0,0))
    // colorPrimaries           1 (ITU-R BT.709)
    // transferCharacteristics  1 (ITU-R BT.709)
    // matrixCoefficients       1 (ITU-R BT.709)
    // videoFullRangeFlag       0 (studio swing representation)
    // Initialize optional fields to their defaults.
    if (fields[0] != "av01") {
        // Invalid AV1 4CC
        return undefined;
    }
    // TODO: add logic to parse HDR and other info
    LogUtils_1.LogUtil.debug("parseAV1CodecId-- ", codec_id);
    return result;
}
exports.parseAV1CodecId = parseAV1CodecId;
;
function parseVp9CodecID(codec_id, hdrmetadatatype) {
    // Initialize optional fields to their defaults.
    let cs = {
        primaries: undefined,
        transfer: undefined,
        matrix: undefined,
        range: undefined,
    };
    let result = {
        bit_depth: undefined,
        color_space: cs,
        subsampling: undefined,
        profile: undefined,
        level: undefined,
        codec: undefined
    };
    if (codec_id.startsWith("vp9") || codec_id.startsWith("vp9.0")) {
        // this is legacy vp9 mime type
        result.profile = VP9ProfileUnknown;
        result.level = VP9LevelUnknown;
        return result;
    }
    let fields = codec_id.split('.');
    // First four fields are mandatory. No more than 9 fields are expected.
    if (fields.length < 4 || fields.length > 9) {
        // " Invalid number of fields
        return undefined;
    }
    if (fields[0] != "vp09") {
        // Invalid 4CC
        return undefined;
    }
    if (hdrmetadatatype === "smpteSt2094-10") {
        // vp9 dolby is not valid combo
        return undefined;
    }
    let values = [];
    for (let i = 1; i < fields.length; ++i) {
        // Missing value is not allowed.
        if (fields[i] == "") {
            // " Invalid missing field i
            return undefined;
        }
        let value = Number(fields[i]);
        if (Number.isNaN(value) || value < 0) {
            // " Invalid field value
            return undefined;
        }
        values.push(value);
    }
    let profile_idc = values[0];
    switch (profile_idc) {
        case 0:
            result.profile = VP9Profile0;
            break;
        case 1:
            result.profile = VP9Profile1;
            break;
        case 2:
            result.profile = VP9Profile2;
            break;
        case 3:
            result.profile = VP9Profile3;
            break;
        default:
            // Invalid profile
            return undefined;
    }
    result.level = values[1];
    switch (result.level) {
        case 10:
            result.level = VP9Level1;
            break;
        case 11:
            result.level = VP9Level11;
            break;
        case 20:
            result.level = VP9Level2;
            break;
        case 21:
            result.level = VP9Level21;
            break;
        case 30:
            result.level = VP9Level3;
            break;
        case 31:
            result.level = VP9Level31;
            break;
        case 40:
            result.level = VP9Level4;
            break;
        case 41:
            result.level = VP9Level41;
            break;
        case 50:
            result.level = VP9Level5;
            break;
        case 51:
            result.level = VP9Level51;
            break;
        case 52:
            result.level = VP9Level52;
            break;
        case 60:
            result.level = VP9Level6;
            break;
        case 61:
            result.level = VP9Level61;
            break;
        case 62:
            result.level = VP9Level62;
            break;
        default:
            // " Invalid level
            return undefined;
    }
    result.bit_depth = values[2];
    if (result.bit_depth != 8 && result.bit_depth != 10 &&
        result.bit_depth != 12) {
        // Invalid bit-depth
        return undefined;
    }
    // 4:2:0 isn't supported in profiles 1, 3.
    if (profile_idc == 1 || profile_idc == 3) {
        result.subsampling = 2 /* VideoChromaSampling.k422 */;
    }
    if (values.length < 4) {
        // we only have profile, level and bitDepth
        let hdrProfile = getVP9HDRProfileId(hdrmetadatatype, result.profile);
        if (hdrProfile == VP9ProfileUnknown) {
            // the hdr meta requested and profile didnt match
            return undefined;
        }
        result.profile = hdrProfile;
        return result;
    }
    let chroma_subsampling = values[3];
    switch (chroma_subsampling) {
        case 0:
        case 1:
            result.subsampling = 1 /* VideoChromaSampling.k420 */;
            break;
        case 2:
            result.subsampling = 2 /* VideoChromaSampling.k422 */;
            break;
        case 3:
            result.subsampling = 3 /* VideoChromaSampling.k444 */;
            break;
        default:
            // Invalid chroma subsampling
            return undefined;
    }
    if (result.subsampling != 1 /* VideoChromaSampling.k420 */ &&
        profile_idc != 1 &&
        profile_idc != 3) {
        // 4:2:2 and 4:4:4 are only supported in profile 1, 3
        // Ideally this would be an error, but even Netflix broke when we tried...
        result.subsampling = 1 /* VideoChromaSampling.k420 */;
    }
    if (values.length < 5) {
        return undefined;
    }
    result.color_space.primaries = getPrimaryID(values[4]);
    // TODO: this 0 value is not defined in our js apis.
    if (result.color_space.primaries == 0) {
        // Invalid color primaries: values[4]
        return undefined;
    }
    if (result.color_space.primaries === keplermediadescriptor_1.VideoColorPrimaries.BT2020) {
        if (hdrmetadatatype === "smpteSt2086") {
            // HDR10
            switch (result.profile) {
                case VP9Profile2:
                    result.profile = VP9Profile2HDR;
                    break;
                case VP9Profile3:
                    result.profile = VP9Profile3HDR;
                    break;
                default:
                    return undefined;
            }
        }
        if (hdrmetadatatype === "smpteSt2094-40") {
            // HDR10+
            switch (result.profile) {
                case VP9Profile2:
                    result.profile = VP9Profile2HDR10Plus;
                    break;
                case VP9Profile3:
                    result.profile = VP9Profile3HDR10Plus;
                    break;
                default:
                    return undefined;
            }
        }
    }
    if (values.length < 6) {
        return undefined;
    }
    result.color_space.transfer = getTransferID(values[5]);
    if (result.color_space.transfer == 0) {
        // Invalid transfer function: values[5]
        return undefined;
    }
    if (values.length < 7) {
        return undefined;
    }
    result.color_space.matrix = getMatrixID(values[6]);
    if (result.color_space.matrix == -1) {
        // Invalid matrix coefficients: values[6]
        return undefined;
    }
    if (result.color_space.matrix === keplermediadescriptor_1.VideoColorMatrix.IDENTITY &&
        chroma_subsampling != 3) {
        // Invalid combination of chroma_subsampling  and matrix coefficients
    }
    if (values.length < 8) {
        return undefined;
    }
    let video_full_range_flag = values[7];
    if (video_full_range_flag > 1) {
        // Invalid full range flag
        return undefined;
    }
    result.color_space.range = video_full_range_flag == 1
        ? "FULL"
        : "LIMITED";
    return result;
}
exports.parseVp9CodecID = parseVp9CodecID;
// The specification for Dolby Vision codec id strings can be found in Dolby
// Vision streams within the MPEG-DASH format:
// https://professional.dolby.com/siteassets/content-creation/dolby-vision-for-content-creators/dolbyvisioninmpegdashspecification_v2_0_public_20190107.pdf
function parseDolbyVisionCodecId(codec_id) {
    if (!isDolbyVisionAVCCodecId(codec_id) &&
        !isDolbyVisionHEVCCodecId(codec_id)) {
        return undefined;
    }
    let kMaxDvCodecIdLength = 5 // FOURCC string
        + 1 // delimiting period
        + 2 // profile id as 2 digit string
        + 1 // delimiting period
        + 2; // level id as 2 digit string.
    if (codec_id.length > kMaxDvCodecIdLength) {
        // Codec id is too long (" << codec_id << ")";
        return undefined;
    }
    let elem = codec_id.split(".");
    if (elem.length != 3) {
        // invalid dolby vision codec id " << codec_id;
        return undefined;
    }
    // Profile string should be two digits.
    let profile_id = Number(elem[1]);
    if (elem[1].length != 2 || Number.isNaN(profile_id) || profile_id > 9) {
        // invalid format or profile_id
        return undefined;
    }
    let result = {
        profile: DolbyVisionProfileUnknown,
        level: DolbyVisionLevelUnknown
    };
    // Only profiles 0, 4, 5, 7, 8 and 9 are valid. Profile 0 and 9 are encoded
    // based on AVC while profile 4, 5, 7 and 8 are based on HEVC.
    switch (profile_id) {
        case 0:
        case 9:
            if (!isDolbyVisionAVCCodecId(codec_id)) {
                // codec id is mismatched with profile_id
                return undefined;
            }
            if (profile_id == 0) {
                result.profile = DolbyVisionProfileDvavPer;
            }
            else if (profile_id == 9) {
                result.profile = DolbyVisionProfileDvavSe;
            }
            break;
        case 5:
        case 7:
        case 8:
            if (!isDolbyVisionHEVCCodecId(codec_id)) {
                // codec id is mismatched with profile_id=" << profile_id;
                return undefined;
            }
            if (profile_id == 5) {
                result.profile = DolbyVisionProfileDvheStn;
            }
            else if (profile_id == 7) {
                result.profile = DolbyVisionProfileDvheDtb;
            }
            else if (profile_id == 8) {
                result.profile = DolbyVisionProfileDvheSt;
            }
            break;
        default:
            // depecrated and not supported profile_id=" << profile_id;
            return undefined;
    }
    // Level string should be two digits.
    let level_id = Number(elem[2]);
    if (elem[2].length != 2 || Number.isNaN(level_id) ||
        level_id > 13 || level_id < 1) {
        // invalid format level_id=" << elem[2];
        return undefined;
    }
    // TODO: map this level to ours
    result.level = level_id;
    return result;
}

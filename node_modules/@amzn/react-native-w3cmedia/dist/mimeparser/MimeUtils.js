"use strict";
/*
 * Copyright 2024 Amazon.com, Inc. or its affiliates. All rights reserved.
 *
 * AMAZON PROPRIETARY/CONFIDENTIAL
 *
 * You may not use this file except in compliance with the terms and
 * conditions set forth in the accompanying LICENSE.TXT file.
 *
 * THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectHTTPQuotedString = exports.soleyContainsHTTPQuotedStringTokenCodePoints = exports.isHTTPWhitespaceChar = exports.removeTrailingHTTPWhitespace = exports.solelyContainsHTTPTokenCodePoints = exports.removeLeadingAndTrailingHTTPWhitespace = exports.checkSupportedAudioContainers = exports.checkSupportedVideoContainers = void 0;
const supportedVideoContainers = ["video/mp4", "video/webm", "video/ogg", "video/mpeg", "video/avi", "video/quicktime", "video/3gpp"];
const supportedAudioContainers = ["audio/mp4", "audio/webm", "audio/ogg", "audio/mpeg", "audio/aac",
    "audio/ac3", "audio/x-ac3", "audio/flac", "audio/x-flac"];
function checkSupportedVideoContainers(mimeType) {
    return supportedVideoContainers.includes(mimeType);
}
exports.checkSupportedVideoContainers = checkSupportedVideoContainers;
function checkSupportedAudioContainers(mimeType) {
    return supportedAudioContainers.includes(mimeType);
}
exports.checkSupportedAudioContainers = checkSupportedAudioContainers;
function removeLeadingAndTrailingHTTPWhitespace(str) {
    return str.replace(/^[ \t\n\r]+/u, "").replace(/[ \t\n\r]+$/u, "");
}
exports.removeLeadingAndTrailingHTTPWhitespace = removeLeadingAndTrailingHTTPWhitespace;
;
function solelyContainsHTTPTokenCodePoints(str) {
    return /^[-!#$%&'*+.^_`|~A-Za-z0-9]*$/u.test(str);
}
exports.solelyContainsHTTPTokenCodePoints = solelyContainsHTTPTokenCodePoints;
function removeTrailingHTTPWhitespace(str) {
    return str.replace(/[ \t\n\r]+$/u, "");
}
exports.removeTrailingHTTPWhitespace = removeTrailingHTTPWhitespace;
function isHTTPWhitespaceChar(char) {
    return char === " " || char === "\t" || char === "\n" || char === "\r";
}
exports.isHTTPWhitespaceChar = isHTTPWhitespaceChar;
function soleyContainsHTTPQuotedStringTokenCodePoints(str) {
    return /^[\t\u0020-\u007E\u0080-\u00FF]*$/u.test(str);
}
exports.soleyContainsHTTPQuotedStringTokenCodePoints = soleyContainsHTTPQuotedStringTokenCodePoints;
/**
 * To collect an HTTP quoted string from a string input, given a position variable
 * position and an optional boolean extract-value (default false):
 * Note: we dont use extract-value explicitly since we need it to be true always.
 *
 * https://fetch.spec.whatwg.org/#collect-an-http-quoted-string
 *
 * @param input @type {string} from which output needs to be extracted.
 * @param position @type {number} current position during parsing the mime string.
 *                 (should be at the location of " in parameter map)
 * @returns @type {string} which is within the quotes and @type {number} which is the position of the end quote
 */
function collectHTTPQuotedString(input, position) {
    // 1. Let positionStart be position.
    // not required.
    // 2. Let value be the empty string.
    let value = "";
    // 3. Assert: the code point at position within input is U+0022 (").
    if (input[position] != "\"") {
        // TODO: assert?
        return [input, -1];
    }
    // 4. Advance position by 1.
    position++;
    // 5. while true
    while (true) {
        // 5.1 Append the result of collecting a sequence of code points that are not U+0022 (")
        //     or U+005C (\) from input, given position, to value.
        while (position < input.length && input[position] !== "\"" && input[position] !== "\\") {
            value += input[position];
            position++;
        }
        // 5.2 If position is past the end of input, then break.
        if (position >= input.length) {
            break;
        }
        // 5.3 Let quoteOrBackslash be the code point at position within input.
        const quoteOrBackslash = input[position];
        // 5.4 Advance position by 1.
        position++;
        // 5.5 If quoteOrBackslash is U+005C (\), then:
        if (quoteOrBackslash === "\\") {
            // 5.5.1 If position is past the end of input, then append U+005C (\) to value and break.
            if (position >= input.length) {
                value += "\\";
                break;
            }
            // 5.5.2 Append the code point at position within input to value.
            value += input[position];
            // 5.5.3 Advance position by 1.
            ++position;
        }
        else {
            // 5.6. Otherwise:
            // 5.6.1 Assert: quoteOrBackslash is U+0022 (").
            if (quoteOrBackslash != "\"") {
                // todo: assert?
                return [input, -1];
            }
            // 5.6.2 Break.
            break;
        }
    }
    // 6. If extract-value is true, then return value.
    // note: we didnt take this and its true by default for us.
    // 7. Return the code points from positionStart to position, inclusive, within input.
    // note: this would've returned the output in "value" format, which we dont want. So return value only.
    return [value, position];
}
exports.collectHTTPQuotedString = collectHTTPQuotedString;

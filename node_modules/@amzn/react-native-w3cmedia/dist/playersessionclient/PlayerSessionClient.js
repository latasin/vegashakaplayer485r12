"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlayerSessionClient = void 0;
const PlayerSession_1 = require("@amzn/react-native-kepler/Libraries/PlayerSession/PlayerSession");
const LogUtils_1 = require("../LogUtils");
const PlayerSessionTypes_1 = require("@amzn/react-native-kepler/Libraries/PlayerSession/api/PlayerSessionTypes");
const PlayerSessionClientTypes_1 = require("./PlayerSessionClientTypes");
const PlaybackStateUtils_1 = require("./PlaybackStateUtils");
class PlayerSessionClient {
    currentPlayerMediaOp = null;
    seekIntervalInSec_ = PlayerSessionClientTypes_1.DEFAULT_SEEK_SECONDS;
    error = {
        code: PlayerSessionClientTypes_1.DEFAULT_ERROR_CODE,
        codeString: PlayerSessionClientTypes_1.DEFAULT_ERROR_CODE_STRING
    };
    callbacks = {
        onPause: () => {
            if ((0, PlaybackStateUtils_1.isPauseEnabled)(this.playerState)) {
                LogUtils_1.LogUtil.info('Player Session is performing pause operation on Media Player');
                this.mediaPlayer?.pause();
                this.currentPlayerMediaOp = PlayerSessionTypes_1.PlayerMediaOps.PLAYER_MEDIA_OP_PAUSE;
            }
            else {
                LogUtils_1.LogUtil.debug('Pause operation by Player Session could not be performed because it is currently disabled');
            }
        },
        onPlay: () => {
            if ((0, PlaybackStateUtils_1.isPlayEnabled)(this.playerState)) {
                LogUtils_1.LogUtil.info('Player Session is performing play operation on Media Player');
                this.mediaPlayer?.play();
                this.currentPlayerMediaOp = PlayerSessionTypes_1.PlayerMediaOps.PLAYER_MEDIA_OP_PLAY;
            }
            else {
                LogUtils_1.LogUtil.debug('Play operation by Player Session could not be performed because it is currently disabled');
            }
        },
        onStop: () => {
            if ((0, PlaybackStateUtils_1.isPauseEnabled)(this.playerState)) {
                LogUtils_1.LogUtil.debug('Player Session is performing stop operation on Media Player');
                this.mediaPlayer?.pause();
                this.currentPlayerMediaOp = PlayerSessionTypes_1.PlayerMediaOps.PLAYER_MEDIA_OP_STOP;
            }
            else {
                LogUtils_1.LogUtil.debug('Stop operation by Player Session could not be performed because it is currently disabled');
            }
        },
        onRewind: (seconds, steps) => {
            if ((0, PlaybackStateUtils_1.isSeekEnabled)(this.playerState)) {
                LogUtils_1.LogUtil.debug('Player Session is performing rewind operation on Media Player');
                const SECONDS = seconds !== -1 ? seconds : this.seekIntervalInSec_;
                const STEPS = steps !== -1 ? steps : PlayerSessionClientTypes_1.DEFAULT_SEEK_STEPS;
                LogUtils_1.LogUtil.info(`Rewinding ${SECONDS} seconds with ${STEPS} steps`);
                this.mediaPlayer?.fastSeek(this.mediaPlayer?.currentTime - SECONDS * STEPS);
                this.currentPlayerMediaOp = PlayerSessionTypes_1.PlayerMediaOps.PLAYER_MEDIA_OP_REWIND;
            }
            else {
                LogUtils_1.LogUtil.debug('Rewind operation by Player Session could not be performed because seek is currently disabled');
            }
        },
        onFastForward: (seconds, steps) => {
            if ((0, PlaybackStateUtils_1.isSeekEnabled)(this.playerState)) {
                LogUtils_1.LogUtil.debug('Player Session is performing forward operation on Media Player');
                const SECONDS = seconds !== -1 ? seconds : this.seekIntervalInSec_;
                const STEPS = steps !== -1 ? steps : PlayerSessionClientTypes_1.DEFAULT_SEEK_STEPS;
                LogUtils_1.LogUtil.info(`FastForwarding ${SECONDS} seconds with ${STEPS} steps`);
                this.mediaPlayer?.fastSeek(this.mediaPlayer?.currentTime + SECONDS * STEPS);
                this.currentPlayerMediaOp = PlayerSessionTypes_1.PlayerMediaOps.PLAYER_MEDIA_OP_FF;
            }
            else {
                LogUtils_1.LogUtil.debug('Forward operation by Player Session could not be performed because seek is currently disabled');
            }
        },
        onUnsupportedOperation: (operation) => {
            LogUtils_1.LogUtil.debug(`Player Session received an unsupported operation: ${PlayerSessionTypes_1.PlayerMediaOps[operation]}`);
        },
        onSeekTo: (deltaPositionMilliseconds, isRelative) => {
            if ((0, PlaybackStateUtils_1.isSeekEnabled)(this.playerState)) {
                LogUtils_1.LogUtil.info(`Player Session is performing seek operation on Media Player of ${deltaPositionMilliseconds} ms`);
                if (this.mediaPlayer === null) {
                    LogUtils_1.LogUtil.info(' session is null hence returning');
                    return;
                }
                const DELTA_POSITION_SECONDS = deltaPositionMilliseconds / 1000;
                if (!isRelative) {
                    this.mediaPlayer.currentTime = DELTA_POSITION_SECONDS;
                }
                else {
                    this.mediaPlayer.currentTime += DELTA_POSITION_SECONDS;
                }
                this.currentPlayerMediaOp = PlayerSessionTypes_1.PlayerMediaOps.PLAYER_MEDIA_OP_SEEK_TO;
            }
            else {
                LogUtils_1.LogUtil.debug('Seek operation by Player Session could not be performed because it is currently disabled');
            }
        },
        onStartOver: () => {
            LogUtils_1.LogUtil.info('Player Session is performing start over operation on Media Player');
            this.mediaPlayer.currentTime = 0;
            this.currentPlayerMediaOp = PlayerSessionTypes_1.PlayerMediaOps.PLAYER_MEDIA_OP_START_OVER;
        },
        onSetPlaybackSpeed: () => { },
        onRequestPlayerPlaybackStateInfo: () => {
            LogUtils_1.LogUtil.info('Player Session is performing to send playback state of MediaPlayer');
            this.setPlaybackState();
        }
    };
    eventListeners = {
        loadstart: () => {
            LogUtils_1.LogUtil.info('PlayerSessionClient: loadstart event');
            this.playerState = PlayerSessionTypes_1.PlayerState.PLAYER_STATE_CONNECTING;
            this.setPlaybackState();
        },
        waiting: () => {
            LogUtils_1.LogUtil.info('PlayerSessionClient: waiting event');
            this.playerState = PlayerSessionTypes_1.PlayerState.PLAYER_STATE_BUFFERING;
            this.setPlaybackState();
        },
        playing: () => {
            LogUtils_1.LogUtil.info('PlayerSessionClient: player event');
            this.playerState = PlayerSessionTypes_1.PlayerState.PLAYER_STATE_PLAYING;
            this.setPlaybackState();
        },
        pause: () => {
            LogUtils_1.LogUtil.info('PlayerSessionClient: pause event');
            this.playerState = PlayerSessionTypes_1.PlayerState.PLAYER_STATE_PAUSED;
            this.setPlaybackState();
        },
        seeking: () => {
            LogUtils_1.LogUtil.info('PlayerSessionClient: seeking event');
        },
        ended: () => {
            LogUtils_1.LogUtil.info('PlayerSessionClient: ended event');
            this.playerState = PlayerSessionTypes_1.PlayerState.PLAYER_STATE_STOPPED;
            this.setPlaybackState();
        },
        error: () => {
            LogUtils_1.LogUtil.info('PlayerSessionClient: error event');
            if (this.mediaPlayer !== null) {
                this.playerState = PlayerSessionTypes_1.PlayerState.PLAYER_STATE_ERROR;
                this.setPlayerError(this.mediaPlayer?.error);
            }
        },
        ratechange: () => {
            LogUtils_1.LogUtil.info('PlayerSessionClient: ratechange');
            if (this.mediaPlayer === null) {
                LogUtils_1.LogUtil.info('PlayerSessionClient: mediaplayer null');
                return;
            }
            const { playbackRate, defaultPlaybackRate } = this.mediaPlayer;
            if (playbackRate === defaultPlaybackRate) {
                return;
            }
            else if (playbackRate > defaultPlaybackRate) {
                this.playerState = PlayerSessionTypes_1.PlayerState.PLAYER_STATE_FAST_FORWARDING;
            }
            else if (playbackRate < -1 * defaultPlaybackRate) {
                this.playerState = PlayerSessionTypes_1.PlayerState.PLAYER_STATE_REWINDING;
            }
            this.setPlaybackState();
        }
    };
    playerSessionCreated = false;
    playerState = PlayerSessionTypes_1.PlayerState.PLAYER_STATE_NONE;
    mediaPlayer; // Media<VideoProps, VideoState> | Media<AudioProps, AudioState>;
    constructor() {
    }
    initialize = () => {
        try {
            LogUtils_1.LogUtil.info('Creating Player session for Media Player');
            PlayerSession_1.PlayerSession.setPlayerSessionCallback(this.callbacks);
            this.playerSessionCreated = PlayerSession_1.PlayerSession.create();
            if (this.playerSessionCreated) {
                LogUtils_1.LogUtil.info('Succesfully created Player session');
            }
            else {
                LogUtils_1.LogUtil.warn('PlayerSession creation failed!!');
            }
        }
        catch (error) {
            this.playerState = PlayerSessionTypes_1.PlayerState.PLAYER_STATE_INVALID;
            const errorMessage = `Failed to create Player session for Media Player:\n${error}`;
            this.setPlayerSessionError({
                code: PlayerSessionTypes_1.ErrorCode.ERROR_APP_NONE,
                codeString: errorMessage
            });
            return;
        }
    };
    setMediaPlayer = (mediaPlayer) => {
        LogUtils_1.LogUtil.info(`setMediaPlayer `);
        if (mediaPlayer === null || mediaPlayer === undefined) {
            return;
        }
        this.mediaPlayer = mediaPlayer;
        if (this.playerSessionCreated && this.mediaPlayer !== null) {
            LogUtils_1.LogUtil.info('Succesfully attached MediaPlayer to PlayerSession');
            this.setEventListeners();
        }
    };
    setDefaultSeekIntervalInSec = (seekInterval) => {
        LogUtils_1.LogUtil.info(`setDefaultSeekIntervalInSec seekInterval ` + seekInterval);
        if (this.mediaPlayer === null || this.mediaPlayer === undefined) {
            return;
        }
        this.seekIntervalInSec_ = seekInterval;
    };
    clearMediaPlayer = (mediaPlayer) => {
        LogUtils_1.LogUtil.info(`clearMediaPlayer `);
        if (mediaPlayer === null || mediaPlayer === undefined) {
            return;
        }
        this.removeEventListeners(mediaPlayer);
        // check if previously set media player is the one
        // that is cleared
        if (this.mediaPlayer === mediaPlayer) {
            this.mediaPlayer = null;
        }
        else {
            // maybe another media player was set before
            // clearing this one. Do nothing.
        }
    };
    setEventListeners() {
        for (const listener in this.eventListeners) {
            if (this.eventListeners.hasOwnProperty(listener))
                this.mediaPlayer?.addEventListener(listener, this.eventListeners[listener]);
        }
    }
    removeEventListeners(mediaPlayer) {
        if (mediaPlayer === null) {
            return;
        }
        for (const listener in this.eventListeners) {
            if (this.eventListeners.hasOwnProperty(listener))
                mediaPlayer.removeEventListener(listener, this.eventListeners[listener]);
        }
    }
    setPlaybackState = () => {
        if (!this.playerSessionCreated) {
            LogUtils_1.LogUtil.error('Attempted to set playbackState before player session created');
            return;
        }
        try {
            const playbackState = this.getPlaybackState();
            LogUtils_1.LogUtil.info('Setting playbackState to session client \n');
            const playbackStateSent = PlayerSession_1.PlayerSession.setPlaybackState(playbackState);
            if (playbackStateSent)
                LogUtils_1.LogUtil.info('Setting playbackState state to session client is successful\n');
            else
                LogUtils_1.LogUtil.error('Failed to set playbackState as:\n');
        }
        catch (error) {
            LogUtils_1.LogUtil.error('Unable to set playbackState.\n', error);
        }
    };
    getPlaybackState = () => {
        LogUtils_1.LogUtil.info('enumarate the session playback state');
        return {
            state: this.playerState,
            supportedMediaOps: (0, PlaybackStateUtils_1.getSupportedMediaOps)(this.playerState),
            errorCode: this.error.code,
            errorCodeString: this.error.codeString,
            timeRangeData: {
                minSeekMs: 0,
                maxSeekMs: (this.mediaPlayer === null || this.mediaPlayer === undefined) ? -1 : this.mediaPlayer?.duration,
                trackPositionMs: (this.mediaPlayer === null || this.mediaPlayer === undefined) ? -1 : this.mediaPlayer?.currentTime
            },
            audioFocus: PlayerSessionTypes_1.AudioFocusMode.AUDIO_FOCUS_NONE,
            currentPlaybackSpeed: 1,
            repeatMode: PlayerSessionTypes_1.PlayerRepeatMode.PLAYER_REPEAT_MODE_NONE,
            shuffleMode: PlayerSessionTypes_1.PlayerShuffleMode.PLAYER_SHUFFLE_MODE_NONE,
            trackRating: PlayerSessionTypes_1.PlayerTrackRating.PLAYER_RATING_NONE,
            audioTrackAvailableLanguages: ['English'],
            captionTrackInfo: [{ captionLanguage: 'English', captionMimeType: '' }]
        };
    };
    setPlayerError = (mediaError) => {
        this.error = {
            code: this.getErrorCode((mediaError?.code) ?? -1),
            codeString: (mediaError?.message) ?? 'Error But No Message'
        };
        LogUtils_1.LogUtil.info('setPlayerError: setPlaybackState call');
        this.setPlaybackState();
    };
    getErrorCode = (errorCode) => {
        LogUtils_1.LogUtil.info('getErrorCode :\n');
        switch (errorCode) {
            case 1: // MediaError.MEDIA_ERR_ABORTED
            case 2: // MediaError.MEDIA_ERR_DECODE
            case 3: // MediaError.MEDIA_ERR_NETWORK
            case 4: // MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED
            default:
                return PlayerSessionTypes_1.ErrorCode.ERROR_APP_ERROR;
        }
    };
    setPlayerSessionError = (playerSessionError) => {
        this.error = {
            code: playerSessionError.code,
            codeString: playerSessionError.codeString
        };
        LogUtils_1.LogUtil.info('setPlayerSessionError: setPlaybackState call');
        this.setPlaybackState();
    };
    resetError = () => {
        this.error = {
            code: PlayerSessionClientTypes_1.DEFAULT_ERROR_CODE,
            codeString: PlayerSessionClientTypes_1.DEFAULT_ERROR_CODE_STRING
        };
    };
    destroy = () => {
        try {
            this.playerState = PlayerSessionTypes_1.PlayerState.PLAYER_STATE_SESSION_RELEASE;
            this.setPlaybackState();
            this.removeEventListeners(this.mediaPlayer);
            PlayerSession_1.PlayerSession.destroy();
        }
        catch (error) {
            LogUtils_1.LogUtil.error('An exception occurred while destroying PlayerSession:\n', error);
        }
    };
}
exports.PlayerSessionClient = PlayerSessionClient;

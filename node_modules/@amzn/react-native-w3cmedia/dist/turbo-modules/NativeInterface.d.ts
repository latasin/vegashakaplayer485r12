/** This file is copied from ATVKeplerNFPBindingsInterface vmpf-dev branch */
declare type MediaPlayerDeInitStatus = "success" | "timedout" | "invalid";
interface NativeMediaError {
    type: number;
    error_code: number;
    error_message: string;
    component_name: string;
    severity: number;
}
interface NativeTimeRange {
    start: number;
    end: number;
}
interface NativeTimeRanges {
    length: number;
    [index: number]: NativeTimeRange;
}
interface NativeAudioTrack {
    id: string;
    kind: string;
    label: string;
    language: string;
    enabled: boolean;
    sourceBufferId: string;
}
interface NativeVideoTrack {
    id: string;
    kind: string;
    label: string;
    language: string;
    selected: boolean;
    sourceBufferId: string;
}
interface NativeTextTrack {
    id: string;
    kind: string;
    label: string;
    language: string;
    mode: string;
}
interface NativeVTTRegion {
    id: string;
    width: number;
    lines: number;
    regionAnchorX: number;
    regionAnchorY: number;
    viewportAnchorX: number;
    viewportAnchorY: number;
    scroll: string;
}
interface NativeVTTCue {
    startTime: number;
    endTime: number;
    region?: NativeVTTRegion;
    vertical: string;
    snapToLines: boolean;
    line: string;
    lineAlign: string;
    position: string;
    positionAlign: string;
    size: number;
    align: string;
    text: string;
}
interface NativeMPBDiagnosticInfo {
    readonly num_dropped_frames: number;
    readonly error_code: number;
}
interface NativeAddSourceBufferResult {
    status: number;
    sourceBufferId: string;
}
interface NativeMediaElementConfig {
    readonly _tag: "MediaElementConfig";
    readonly id: number;
}
interface NativeMediaElement {
    readonly _tag: "NativeMediaElement";
    readonly id: number;
}
interface MediaEventSource {
    HTMLMEDIAELEMENT: number;
    MEDIASOURCE: number;
    SOURCEBUFFER: number;
    ACTIVESOURCEBUFFERS: number;
    AUDIO_TRACKLIST: number;
    VIDEO_TRACKLIST: number;
    TEXT_TRACKLIST: number;
}
interface TrackListChangeType {
    ADD_TRACK: number;
    ENABLED_CHANGE: number;
    REMOVE_TRACK: number;
}
interface MediaErrorType {
    ABORTED: number;
    DECODE: number;
    DEMUXER_APPEND_ERROR: number;
    DEMUXER_INVALID_PARAMS: number;
    DEMUXER_INVALID_STATE: number;
    MPB_ERROR: number;
    MPB_FUNCTION_FAILURE: number;
    NETWORK: number;
    OK: number;
    PIPELINE_ERROR: number;
    SAMPLE_CONSUMER_ERROR: number;
    SAMPLE_CONSUMER_INVALID_STATE: number;
    SRC_NOT_SUPPORTED: number;
    TRACK_BUFFER_READER_INVALID_STATE: number;
}
interface MediaElementReadyState {
    HAVE_CURRENT_DATA: number;
    HAVE_ENOUGH_DATA: number;
    HAVE_FUTURE_DATA: number;
    HAVE_METADATA: number;
    HAVE_NOTHING: number;
}
interface MSEErrorCode {
    INTERNAL_ERROR: number;
    INVALID_STATE: number;
    MPB_ERROR: number;
    NOT_FOUND: number;
    NOT_SUPPORTED: number;
    OK: number;
    QUOTA_EXCEEDED: number;
    TYPE_ERROR: number;
}
interface DemuxerAddSourceBufferResult {
    INVALID_STATE: number;
    NOT_SUPPORTED: number;
    OK: number;
    QUOTA_EXCEEDED: number;
}
interface DRMEventType {
    CALLBACK: number;
    SESSION_CLOSE: number;
    SESSION_MESSAGE: number;
    SESSION_KEY_STATUS_CHANGED: number;
}
interface CDMiMessageType {
    INDIVIDUALIZATION_REQUEST: number;
    LICENSE_RELEASE: number;
    LICENSE_RENEWAL: number;
    LICENSE_REQUEST: number;
}
interface MpbPictureMode {
    FILMMAKER: number;
    NONE: number;
}
interface FrameProcessorAppendMode {
    SEGMENTS: number;
    SEQUENCE: number;
}
interface CdmSessionType {
    TEMPORARY: number;
    PERSISTENT: number;
}
interface CdmInitDataType {
    CENC: number;
    KEYIDS: number;
    WEBM: number;
}
interface CdmMediaKeyRequirement {
    REQUIRED: number;
    OPTIONAL: number;
    NOT_ALLOWED: number;
}
interface CdmMediaRobustness {
    SECURE: number;
    NOT_SECURE: number;
}
interface CdmMediaKeyStatus {
    USABLE: number;
    EXPIRED: number;
    RELEASED: number;
    OUTPUT_RESTRICTED: number;
    OUTPUT_DOWNSCALED: number;
    USABLE_IN_FUTURE: number;
    PENDING: number;
    INTERNAL: number;
}
interface CdmMediaCapability {
    mime: string;
    robustness: CdmMediaRobustness;
    encryptionScheme: string;
}
interface NativeCdmConfiguration {
    label: string;
    init_data_types: Array<CdmInitDataType>;
    audio_capabilities: Array<CdmMediaCapability>;
    video_capabilities: Array<CdmMediaCapability>;
    distinctive_identifier: CdmMediaKeyRequirement;
    persistent_state: CdmMediaKeyRequirement;
    session_types: Array<CdmSessionType>;
}
interface NativeCDMiAccess {
    readonly _tag: "NativeCDMiAccess";
}
interface NativeCDMiMediaKeys {
    readonly _tag: "NativeCDMiMediaKeys";
}
interface NativeCDMiSession {
    readonly _tag: "NativeCDMiSession";
}
interface NativeCDMiMediaKeysPolicy {
    minHdcpVersion: string;
}
interface NativeDRMEvent {
    id: number;
    result: {
        error_code: number;
        mpb_error: number;
    };
    integer: number;
    event: number;
    access: NativeCDMiAccess;
    media_keys: NativeCDMiMediaKeys;
    session: NativeCDMiSession;
    configuration: NativeCdmConfiguration;
}
interface NativeMediaElementEvent {
    src: number;
    name: string;
    track_id: string;
    sourcebuffer_id: string;
    init_type: string;
    width: number;
    height: number;
    buffer: ArrayBuffer;
}
interface NativeVideoPlaybackQualityInfo {
    readonly droppedVideoFrames: number;
    readonly totalVideoFrames: number;
}
interface NativeKMCResult {
    readonly "component.id": string;
    readonly "hasKMC": boolean;
}
interface AlgorithmIdentifier {
    name: string;
    iv: ArrayBuffer | Uint8Array | DataView;
    counter?: ArrayBuffer | Uint8Array | DataView;
}
declare type KeyFormat = "raw" | "pkcs8" | "spki" | "jwk";
declare type KeyType = "secret" | "public" | "private";
declare type KeyUsage = "encrypt" | "decrypt" | "sign" | "verify" | "deriveKey" | "deriveBits" | "wrapKey" | "unwrapKey";
declare type BufferSource = ArrayBuffer;
declare type AlgorithmObject = AlgorithmIdentifier;
interface CryptoKeyObject {
    type: KeyType;
    extractable: boolean;
    algorithm: AlgorithmObject;
    keyId?: number;
    key?: ArrayBuffer;
    usages: Array<KeyUsage>;
}
declare type CryptoKey = Readonly<CryptoKeyObject>;
export { NativeAddSourceBufferResult, NativeAudioTrack, NativeMPBDiagnosticInfo, NativeMediaElement, NativeMediaElementConfig, NativeMediaError, NativeTimeRange, NativeTimeRanges, NativeVideoTrack, NativeMediaElementEvent, NativeTextTrack, NativeVTTRegion, NativeVTTCue, NativeVideoPlaybackQualityInfo, NativeKMCResult, CDMiMessageType, DemuxerAddSourceBufferResult, DRMEventType, FrameProcessorAppendMode, MediaErrorType, MediaEventSource, MediaElementReadyState, MpbPictureMode, MSEErrorCode, TrackListChangeType, NativeCDMiAccess, NativeCDMiMediaKeys, NativeCDMiSession, CdmSessionType, CdmInitDataType, CdmMediaKeyRequirement, CdmMediaRobustness, CdmMediaKeyStatus, CdmMediaCapability, NativeCdmConfiguration, NativeCDMiMediaKeysPolicy, NativeDRMEvent, AlgorithmIdentifier, AlgorithmObject, BufferSource, CryptoKey, CryptoKeyObject, KeyFormat, KeyType, KeyUsage, MediaPlayerDeInitStatus, };

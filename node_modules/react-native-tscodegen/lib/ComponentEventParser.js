"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseEvent = exports.checkEventType = void 0;
var ts = require("typescript");
var TypeChecker_1 = require("./TypeChecker");
function checkEventType(eventType, info, propDecl) {
    if (ts.isParenthesizedTypeNode(eventType)) {
        return checkEventType(eventType.type, info, propDecl);
    }
    else if (ts.isUnionTypeNode(eventType)) {
        var result = void 0;
        for (var _i = 0, _a = eventType.types; _i < _a.length; _i++) {
            var elementType = _a[_i];
            var elementResult = checkEventType(elementType, info, propDecl);
            if (elementResult !== undefined) {
                if (result === undefined) {
                    result = elementResult;
                }
                else {
                    throw new Error("Event " + propDecl.name.getText() + " in type " + info.typeNode.getText() + " should have a correct event type.");
                }
            }
        }
        if (result !== undefined) {
            result.optional = true;
        }
        return result;
    }
    else if (ts.isTypeReferenceNode(eventType)) {
        var typeName = eventType.typeName.getText();
        if (typeName !== 'DirectEventHandler' && typeName !== 'BubblingEventHandler') {
            return undefined;
        }
        var typeArguments = eventType.typeArguments;
        if (typeArguments === undefined || typeArguments.length < 1 || typeArguments.length > 2) {
            throw new Error("Event " + propDecl.name.getText() + " in type " + info.typeNode.getText() + " should have one or two type parameters for " + typeName + ".");
        }
        if (typeArguments.length === 2) {
            var nameArgument = typeArguments[1];
            if (ts.isLiteralTypeNode(nameArgument) && ts.isStringLiteral(nameArgument.literal)) {
                return {
                    optional: false,
                    eventType: typeArguments[0],
                    eventTypeName: typeName,
                    paperTopLevelNameDeprecated: nameArgument.literal.text
                };
            }
        }
        return {
            optional: false,
            eventType: typeArguments[0],
            eventTypeName: typeName
        };
    }
    else {
        return undefined;
    }
}
exports.checkEventType = checkEventType;
function rnRawTypeToObjectPropertyType(typeNode, rawType) {
    var namePlaceholder = undefined;
    switch (rawType.kind) {
        case 'Boolean': return { type: 'BooleanTypeAnnotation', name: namePlaceholder, optional: rawType.isNullable };
        case 'String': return { type: 'StringTypeAnnotation', name: namePlaceholder, optional: rawType.isNullable };
        case 'Float': return { type: 'FloatTypeAnnotation', name: namePlaceholder, optional: rawType.isNullable };
        case 'Double': return { type: 'DoubleTypeAnnotation', name: namePlaceholder, optional: rawType.isNullable };
        case 'Int32': return { type: 'Int32TypeAnnotation', name: namePlaceholder, optional: rawType.isNullable };
        case 'StringLiterals': return {
            type: 'StringEnumTypeAnnotation',
            name: namePlaceholder,
            optional: rawType.isNullable,
            options: rawType.values.map(function (name) { return { name: name }; })
        };
        case 'Object': return {
            type: 'ObjectTypeAnnotation',
            name: namePlaceholder,
            optional: rawType.isNullable,
            properties: rawType.properties.map(function (rawProp) {
                var prop = rnRawTypeToObjectPropertyType(typeNode, rawProp.propertyType);
                prop.name = rawProp.name;
                if (rawProp.optional) {
                    prop.optional = true;
                }
                return prop;
            })
        };
        case 'Null': return {
            type: 'ObjectTypeAnnotation',
            name: namePlaceholder,
            optional: rawType.isNullable,
            properties: []
        };
        default:
    }
    throw new Error("Component event type does not support " + typeNode.getText() + ": " + JSON.stringify(rawType, undefined, 2) + ".");
}
function parseEvent(info, propDecl, eventInfo) {
    var propType = propDecl.type;
    var rawType = TypeChecker_1.typeToRNRawType(eventInfo.eventType, info.sourceFile, { allowObject: true });
    var eventProperties = [];
    if (rawType.kind !== 'Null') {
        var objectType = rnRawTypeToObjectPropertyType(propType, rawType);
        if (objectType.type === 'ObjectTypeAnnotation') {
            eventProperties = objectType.properties;
        }
        else {
            throw new Error("Component event type does not support " + propType.getText() + ": " + JSON.stringify(rawType, undefined, 2) + ".");
        }
    }
    var result = {
        name: propDecl.name.getText(),
        bubblingType: eventInfo.eventTypeName === 'DirectEventHandler' ? 'direct' : 'bubble',
        optional: (propDecl.questionToken !== undefined) || eventInfo.optional,
        typeAnnotation: {
            type: 'EventTypeAnnotation',
            argument: {
                type: 'ObjectTypeAnnotation',
                properties: eventProperties
            }
        }
    };
    if (eventInfo.paperTopLevelNameDeprecated !== undefined) {
        result.paperTopLevelNameDeprecated = eventInfo.paperTopLevelNameDeprecated;
    }
    return result;
}
exports.parseEvent = parseEvent;
//# sourceMappingURL=ComponentEventParser.js.map
"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseProperty = void 0;
var TypeChecker_1 = require("./TypeChecker");
function rnRawTypeToObjectTypeAnnotation(rawType, typeNode) {
    return {
        type: 'ObjectTypeAnnotation',
        properties: rawType.properties.map(function (value) {
            var _a = rnRawTypeToPropTypeTypeAnnotation(value.propertyType, typeNode), optional = _a[0], typeAnnotation = _a[1];
            return {
                name: value.name,
                optional: value.optional || optional,
                typeAnnotation: typeAnnotation
            };
        })
    };
}
function rnRawTypeToPropTypeTypeAnnotation(rawType, typeNode) {
    switch (rawType.kind) {
        case 'Boolean': return [rawType.isNullable, {
                type: 'BooleanTypeAnnotation',
                default: (rawType.defaultValue === undefined ? (rawType.isNullable ? null : false) : rawType.defaultValue === true)
            }];
        case 'String': return [rawType.isNullable, {
                type: 'StringTypeAnnotation',
                default: (rawType.defaultValue === undefined ? null : "" + rawType.defaultValue)
            }];
        case 'Float': return [rawType.isNullable, {
                type: 'FloatTypeAnnotation',
                default: (rawType.defaultValue === undefined ? (rawType.isNullable ? null : 0) : +rawType.defaultValue)
            }];
        case 'Double': return [rawType.isNullable, {
                type: 'DoubleTypeAnnotation',
                default: (rawType.defaultValue === undefined ? 0 : +rawType.defaultValue)
            }];
        case 'Int32': return [rawType.isNullable, {
                type: 'Int32TypeAnnotation',
                default: (rawType.defaultValue === undefined ? 0 : +rawType.defaultValue)
            }];
        case 'StringLiterals': return [rawType.isNullable, {
                type: 'StringEnumTypeAnnotation',
                options: rawType.values.map(function (name) { return { name: name }; }),
                default: (rawType.defaultValue === undefined ? rawType.values[0] : "" + rawType.defaultValue)
            }];
        case 'NumberLiterals': return [rawType.isNullable, {
                type: 'Int32EnumTypeAnnotation',
                options: rawType.values.map(function (value) { return { value: value }; }),
                default: (rawType.defaultValue === undefined ? rawType.values[0] : +rawType.defaultValue)
            }];
        case 'rn:ColorPrimitive': return [rawType.isNullable, {
                type: 'ReservedPropTypeAnnotation',
                name: 'ColorPrimitive'
            }];
        case 'rn:ImageSourcePrimitive': return [rawType.isNullable, {
                type: 'ReservedPropTypeAnnotation',
                name: 'ImageSourcePrimitive'
            }];
        case 'rn:PointPrimitive': return [rawType.isNullable, {
                type: 'ReservedPropTypeAnnotation',
                name: 'PointPrimitive'
            }];
        case 'rn:EdgeInsetsPrimitive': return [rawType.isNullable, {
                type: 'ReservedPropTypeAnnotation',
                name: 'EdgeInsetsPrimitive'
            }];
        case 'Object': return [rawType.isNullable, rnRawTypeToObjectTypeAnnotation(rawType, typeNode)];
        case 'Array':
            switch (rawType.elementType.kind) {
                case 'Boolean': return [rawType.isNullable, {
                        type: 'ArrayTypeAnnotation',
                        elementType: { type: 'BooleanTypeAnnotation' }
                    }];
                case 'String': return [rawType.isNullable, {
                        type: 'ArrayTypeAnnotation',
                        elementType: { type: 'StringTypeAnnotation' }
                    }];
                case 'Float': return [rawType.isNullable, {
                        type: 'ArrayTypeAnnotation',
                        elementType: { type: 'FloatTypeAnnotation' }
                    }];
                case 'Double': return [rawType.isNullable, {
                        type: 'ArrayTypeAnnotation',
                        elementType: { type: 'DoubleTypeAnnotation' }
                    }];
                case 'Int32': return [rawType.isNullable, {
                        type: 'ArrayTypeAnnotation',
                        elementType: { type: 'Int32TypeAnnotation' }
                    }];
                case 'StringLiterals': return [rawType.isNullable, {
                        type: 'ArrayTypeAnnotation',
                        elementType: {
                            type: 'StringEnumTypeAnnotation',
                            options: rawType.elementType.values.map(function (name) { return { name: name }; }),
                            default: (rawType.defaultValue === undefined ? rawType.elementType.defaultValue === undefined ? null : "" + rawType.elementType.defaultValue : "" + rawType.defaultValue)
                        }
                    }];
                case 'rn:ColorPrimitive': return [rawType.isNullable, {
                        type: 'ArrayTypeAnnotation',
                        elementType: {
                            type: 'ReservedPropTypeAnnotation',
                            name: 'ColorPrimitive'
                        }
                    }];
                case 'rn:ImageSourcePrimitive': return [rawType.isNullable, {
                        type: 'ArrayTypeAnnotation',
                        elementType: {
                            type: 'ReservedPropTypeAnnotation',
                            name: 'ImageSourcePrimitive'
                        }
                    }];
                case 'rn:PointPrimitive': return [rawType.isNullable, {
                        type: 'ArrayTypeAnnotation',
                        elementType: {
                            type: 'ReservedPropTypeAnnotation',
                            name: 'PointPrimitive'
                        }
                    }];
                case 'rn:EdgeInsetsPrimitive': return [rawType.isNullable, {
                        type: 'ArrayTypeAnnotation',
                        elementType: {
                            type: 'ReservedPropTypeAnnotation',
                            name: 'EdgeInsetsPrimitive'
                        }
                    }];
                case 'Object': return [rawType.isNullable, {
                        type: 'ArrayTypeAnnotation',
                        elementType: rnRawTypeToObjectTypeAnnotation(rawType.elementType, typeNode)
                    }];
                case 'Array': {
                    switch (rawType.elementType.elementType.kind) {
                        case 'Object': return [rawType.isNullable, {
                                type: 'ArrayTypeAnnotation',
                                elementType: {
                                    type: 'ArrayTypeAnnotation',
                                    elementType: rnRawTypeToObjectTypeAnnotation(rawType.elementType.elementType, typeNode)
                                }
                            }];
                        default:
                    }
                }
                default:
            }
            break;
        default:
    }
    throw new Error("Component property argument type does not support " + typeNode.getText() + ": " + JSON.stringify(rawType, undefined, 2) + ".");
}
function parseProperty(info, propDecl) {
    var propType = propDecl.type;
    var rawType = TypeChecker_1.typeToRNRawType(propType, info.sourceFile, { allowObject: true });
    var _a = rnRawTypeToPropTypeTypeAnnotation(rawType, propType), optional = _a[0], typeAnnotation = _a[1];
    return {
        name: propDecl.name.getText(),
        optional: propDecl.questionToken !== undefined || optional,
        typeAnnotation: typeAnnotation
    };
}
exports.parseProperty = parseProperty;
//# sourceMappingURL=ComponentPropertyParser.js.map